// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for SDL
class DartSdl {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DartSdl(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DartSdl.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform() {
    return _SDL_GetPlatform();
  }

  late final _SDL_GetPlatformPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform =
      _SDL_GetPlatformPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  late final ffi.Pointer<uintptr_t> ___security_cookie =
      _lookup<uintptr_t>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  ffi.Pointer<ffi.Void> SDL_malloc(
    int size,
  ) {
    return _SDL_malloc(
      size,
    );
  }

  late final _SDL_mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc =
      _SDL_mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc(
      nmemb,
      size,
    );
  }

  late final _SDL_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc =
      _SDL_callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc(
      mem,
      size,
    );
  }

  late final _SDL_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc = _SDL_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free(
      mem,
    );
  }

  late final _SDL_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free =
      _SDL_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions = _SDL_GetMemoryFunctionsPtr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions = _SDL_SetMemoryFunctionsPtr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations() {
    return _SDL_GetNumAllocations();
  }

  late final _SDL_GetNumAllocationsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations =
      _SDL_GetNumAllocationsPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv(
      name,
    );
  }

  late final _SDL_getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv = _SDL_getenvPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv = _SDL_setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort = _SDL_qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs(
    int x,
  ) {
    return _SDL_abs(
      x,
    );
  }

  late final _SDL_absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs = _SDL_absPtr.asFunction<int Function(int)>();

  int SDL_isalpha(
    int x,
  ) {
    return _SDL_isalpha(
      x,
    );
  }

  late final _SDL_isalphaPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha = _SDL_isalphaPtr.asFunction<int Function(int)>();

  int SDL_isalnum(
    int x,
  ) {
    return _SDL_isalnum(
      x,
    );
  }

  late final _SDL_isalnumPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum = _SDL_isalnumPtr.asFunction<int Function(int)>();

  int SDL_isblank(
    int x,
  ) {
    return _SDL_isblank(
      x,
    );
  }

  late final _SDL_isblankPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank = _SDL_isblankPtr.asFunction<int Function(int)>();

  int SDL_iscntrl(
    int x,
  ) {
    return _SDL_iscntrl(
      x,
    );
  }

  late final _SDL_iscntrlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl = _SDL_iscntrlPtr.asFunction<int Function(int)>();

  int SDL_isdigit(
    int x,
  ) {
    return _SDL_isdigit(
      x,
    );
  }

  late final _SDL_isdigitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit = _SDL_isdigitPtr.asFunction<int Function(int)>();

  int SDL_isxdigit(
    int x,
  ) {
    return _SDL_isxdigit(
      x,
    );
  }

  late final _SDL_isxdigitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit = _SDL_isxdigitPtr.asFunction<int Function(int)>();

  int SDL_ispunct(
    int x,
  ) {
    return _SDL_ispunct(
      x,
    );
  }

  late final _SDL_ispunctPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct = _SDL_ispunctPtr.asFunction<int Function(int)>();

  int SDL_isspace(
    int x,
  ) {
    return _SDL_isspace(
      x,
    );
  }

  late final _SDL_isspacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace = _SDL_isspacePtr.asFunction<int Function(int)>();

  int SDL_isupper(
    int x,
  ) {
    return _SDL_isupper(
      x,
    );
  }

  late final _SDL_isupperPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper = _SDL_isupperPtr.asFunction<int Function(int)>();

  int SDL_islower(
    int x,
  ) {
    return _SDL_islower(
      x,
    );
  }

  late final _SDL_islowerPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower = _SDL_islowerPtr.asFunction<int Function(int)>();

  int SDL_isprint(
    int x,
  ) {
    return _SDL_isprint(
      x,
    );
  }

  late final _SDL_isprintPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint = _SDL_isprintPtr.asFunction<int Function(int)>();

  int SDL_isgraph(
    int x,
  ) {
    return _SDL_isgraph(
      x,
    );
  }

  late final _SDL_isgraphPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph = _SDL_isgraphPtr.asFunction<int Function(int)>();

  int SDL_toupper(
    int x,
  ) {
    return _SDL_toupper(
      x,
    );
  }

  late final _SDL_toupperPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper = _SDL_toupperPtr.asFunction<int Function(int)>();

  int SDL_tolower(
    int x,
  ) {
    return _SDL_tolower(
      x,
    );
  }

  late final _SDL_tolowerPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower = _SDL_tolowerPtr.asFunction<int Function(int)>();

  int SDL_crc32(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc32(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc32Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc32 =
      _SDL_crc32Ptr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset = _SDL_memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy = _SDL_memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove = _SDL_memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp = _SDL_memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen(
      wstr,
    );
  }

  late final _SDL_wcslenPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen =
      _SDL_wcslenPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy = _SDL_wcslcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat = _SDL_wcslcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup(
      wstr,
    );
  }

  late final _SDL_wcsdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup = _SDL_wcsdupPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr = _SDL_wcsstrPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp = _SDL_wcscmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp = _SDL_wcsncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp = _SDL_wcscasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp = _SDL_wcsncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen(
      str,
    );
  }

  late final _SDL_strlenPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen =
      _SDL_strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy = _SDL_strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy = _SDL_utf8strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat = _SDL_strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup(
      str,
    );
  }

  late final _SDL_strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup = _SDL_strdupPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev(
      str,
    );
  }

  late final _SDL_strrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev = _SDL_strrevPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr(
      str,
    );
  }

  late final _SDL_struprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr = _SDL_struprPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr(
      str,
    );
  }

  late final _SDL_strlwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr = _SDL_strlwrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr(
      str,
      c,
    );
  }

  late final _SDL_strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr = _SDL_strchrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr(
      str,
      c,
    );
  }

  late final _SDL_strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr = _SDL_strrchrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr(
      haystack,
      needle,
    );
  }

  late final _SDL_strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr = _SDL_strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr = _SDL_strtokrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen(
      str,
    );
  }

  late final _SDL_utf8strlenPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen =
      _SDL_utf8strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa = _SDL_itoaPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa = _SDL_uitoaPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa = _SDL_ltoaPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa = _SDL_ultoaPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa = _SDL_lltoaPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa = _SDL_ulltoaPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi(
      str,
    );
  }

  late final _SDL_atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi =
      _SDL_atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof(
      str,
    );
  }

  late final _SDL_atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof =
      _SDL_atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol = _SDL_strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul = _SDL_strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtollPtr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll = _SDL_strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoullPtr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull = _SDL_strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod(
      str,
      endp,
    );
  }

  late final _SDL_strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod = _SDL_strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp(
      str1,
      str2,
    );
  }

  late final _SDL_strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp = _SDL_strcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp = _SDL_strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp = _SDL_strcasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp = _SDL_strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf(
      text,
      fmt,
    );
  }

  late final _SDL_sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf = _SDL_sscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf = _SDL_vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf = _SDL_snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf = _SDL_vsnprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf = _SDL_asprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf = _SDL_vasprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos(
    double x,
  ) {
    return _SDL_acos(
      x,
    );
  }

  late final _SDL_acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos = _SDL_acosPtr.asFunction<double Function(double)>();

  double SDL_acosf(
    double x,
  ) {
    return _SDL_acosf(
      x,
    );
  }

  late final _SDL_acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf = _SDL_acosfPtr.asFunction<double Function(double)>();

  double SDL_asin(
    double x,
  ) {
    return _SDL_asin(
      x,
    );
  }

  late final _SDL_asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin = _SDL_asinPtr.asFunction<double Function(double)>();

  double SDL_asinf(
    double x,
  ) {
    return _SDL_asinf(
      x,
    );
  }

  late final _SDL_asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf = _SDL_asinfPtr.asFunction<double Function(double)>();

  double SDL_atan(
    double x,
  ) {
    return _SDL_atan(
      x,
    );
  }

  late final _SDL_atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan = _SDL_atanPtr.asFunction<double Function(double)>();

  double SDL_atanf(
    double x,
  ) {
    return _SDL_atanf(
      x,
    );
  }

  late final _SDL_atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf = _SDL_atanfPtr.asFunction<double Function(double)>();

  double SDL_atan2(
    double y,
    double x,
  ) {
    return _SDL_atan2(
      y,
      x,
    );
  }

  late final _SDL_atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan2 =
      _SDL_atan2Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f(
    double y,
    double x,
  ) {
    return _SDL_atan2f(
      y,
      x,
    );
  }

  late final _SDL_atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f =
      _SDL_atan2fPtr.asFunction<double Function(double, double)>();

  double SDL_ceil(
    double x,
  ) {
    return _SDL_ceil(
      x,
    );
  }

  late final _SDL_ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil = _SDL_ceilPtr.asFunction<double Function(double)>();

  double SDL_ceilf(
    double x,
  ) {
    return _SDL_ceilf(
      x,
    );
  }

  late final _SDL_ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf = _SDL_ceilfPtr.asFunction<double Function(double)>();

  double SDL_copysign(
    double x,
    double y,
  ) {
    return _SDL_copysign(
      x,
      y,
    );
  }

  late final _SDL_copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign =
      _SDL_copysignPtr.asFunction<double Function(double, double)>();

  double SDL_copysignf(
    double x,
    double y,
  ) {
    return _SDL_copysignf(
      x,
      y,
    );
  }

  late final _SDL_copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf =
      _SDL_copysignfPtr.asFunction<double Function(double, double)>();

  double SDL_cos(
    double x,
  ) {
    return _SDL_cos(
      x,
    );
  }

  late final _SDL_cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos = _SDL_cosPtr.asFunction<double Function(double)>();

  double SDL_cosf(
    double x,
  ) {
    return _SDL_cosf(
      x,
    );
  }

  late final _SDL_cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf = _SDL_cosfPtr.asFunction<double Function(double)>();

  double SDL_exp(
    double x,
  ) {
    return _SDL_exp(
      x,
    );
  }

  late final _SDL_expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp = _SDL_expPtr.asFunction<double Function(double)>();

  double SDL_expf(
    double x,
  ) {
    return _SDL_expf(
      x,
    );
  }

  late final _SDL_expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf = _SDL_expfPtr.asFunction<double Function(double)>();

  double SDL_fabs(
    double x,
  ) {
    return _SDL_fabs(
      x,
    );
  }

  late final _SDL_fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs = _SDL_fabsPtr.asFunction<double Function(double)>();

  double SDL_fabsf(
    double x,
  ) {
    return _SDL_fabsf(
      x,
    );
  }

  late final _SDL_fabsfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf = _SDL_fabsfPtr.asFunction<double Function(double)>();

  double SDL_floor(
    double x,
  ) {
    return _SDL_floor(
      x,
    );
  }

  late final _SDL_floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor = _SDL_floorPtr.asFunction<double Function(double)>();

  double SDL_floorf(
    double x,
  ) {
    return _SDL_floorf(
      x,
    );
  }

  late final _SDL_floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf = _SDL_floorfPtr.asFunction<double Function(double)>();

  double SDL_trunc(
    double x,
  ) {
    return _SDL_trunc(
      x,
    );
  }

  late final _SDL_truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc = _SDL_truncPtr.asFunction<double Function(double)>();

  double SDL_truncf(
    double x,
  ) {
    return _SDL_truncf(
      x,
    );
  }

  late final _SDL_truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf = _SDL_truncfPtr.asFunction<double Function(double)>();

  double SDL_fmod(
    double x,
    double y,
  ) {
    return _SDL_fmod(
      x,
      y,
    );
  }

  late final _SDL_fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod =
      _SDL_fmodPtr.asFunction<double Function(double, double)>();

  double SDL_fmodf(
    double x,
    double y,
  ) {
    return _SDL_fmodf(
      x,
      y,
    );
  }

  late final _SDL_fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf =
      _SDL_fmodfPtr.asFunction<double Function(double, double)>();

  double SDL_log(
    double x,
  ) {
    return _SDL_log(
      x,
    );
  }

  late final _SDL_logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log = _SDL_logPtr.asFunction<double Function(double)>();

  double SDL_logf(
    double x,
  ) {
    return _SDL_logf(
      x,
    );
  }

  late final _SDL_logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf = _SDL_logfPtr.asFunction<double Function(double)>();

  double SDL_log10(
    double x,
  ) {
    return _SDL_log10(
      x,
    );
  }

  late final _SDL_log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log10 = _SDL_log10Ptr.asFunction<double Function(double)>();

  double SDL_log10f(
    double x,
  ) {
    return _SDL_log10f(
      x,
    );
  }

  late final _SDL_log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f = _SDL_log10fPtr.asFunction<double Function(double)>();

  double SDL_pow(
    double x,
    double y,
  ) {
    return _SDL_pow(
      x,
      y,
    );
  }

  late final _SDL_powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow =
      _SDL_powPtr.asFunction<double Function(double, double)>();

  double SDL_powf(
    double x,
    double y,
  ) {
    return _SDL_powf(
      x,
      y,
    );
  }

  late final _SDL_powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf =
      _SDL_powfPtr.asFunction<double Function(double, double)>();

  double SDL_round(
    double x,
  ) {
    return _SDL_round(
      x,
    );
  }

  late final _SDL_roundPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round = _SDL_roundPtr.asFunction<double Function(double)>();

  double SDL_roundf(
    double x,
  ) {
    return _SDL_roundf(
      x,
    );
  }

  late final _SDL_roundfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf = _SDL_roundfPtr.asFunction<double Function(double)>();

  int SDL_lround(
    double x,
  ) {
    return _SDL_lround(
      x,
    );
  }

  late final _SDL_lroundPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround = _SDL_lroundPtr.asFunction<int Function(double)>();

  int SDL_lroundf(
    double x,
  ) {
    return _SDL_lroundf(
      x,
    );
  }

  late final _SDL_lroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf = _SDL_lroundfPtr.asFunction<int Function(double)>();

  double SDL_scalbn(
    double x,
    int n,
  ) {
    return _SDL_scalbn(
      x,
      n,
    );
  }

  late final _SDL_scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn =
      _SDL_scalbnPtr.asFunction<double Function(double, int)>();

  double SDL_scalbnf(
    double x,
    int n,
  ) {
    return _SDL_scalbnf(
      x,
      n,
    );
  }

  late final _SDL_scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf =
      _SDL_scalbnfPtr.asFunction<double Function(double, int)>();

  double SDL_sin(
    double x,
  ) {
    return _SDL_sin(
      x,
    );
  }

  late final _SDL_sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin = _SDL_sinPtr.asFunction<double Function(double)>();

  double SDL_sinf(
    double x,
  ) {
    return _SDL_sinf(
      x,
    );
  }

  late final _SDL_sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf = _SDL_sinfPtr.asFunction<double Function(double)>();

  double SDL_sqrt(
    double x,
  ) {
    return _SDL_sqrt(
      x,
    );
  }

  late final _SDL_sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt = _SDL_sqrtPtr.asFunction<double Function(double)>();

  double SDL_sqrtf(
    double x,
  ) {
    return _SDL_sqrtf(
      x,
    );
  }

  late final _SDL_sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf = _SDL_sqrtfPtr.asFunction<double Function(double)>();

  double SDL_tan(
    double x,
  ) {
    return _SDL_tan(
      x,
    );
  }

  late final _SDL_tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan = _SDL_tanPtr.asFunction<double Function(double)>();

  double SDL_tanf(
    double x,
  ) {
    return _SDL_tanf(
      x,
    );
  }

  late final _SDL_tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf = _SDL_tanfPtr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_openPtr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open = _SDL_iconv_openPtr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close(
      cd,
    );
  }

  late final _SDL_iconv_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close =
      _SDL_iconv_closePtr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv = _SDL_iconvPtr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string = _SDL_iconv_stringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_main(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _SDL_main(
      argc,
      argv,
    );
  }

  late final _SDL_mainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_main');
  late final _SDL_main = _SDL_mainPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Circumvent failure of SDL_Init() when not using SDL_main() as an entry
  /// point.
  ///
  /// This function is defined in SDL_main.h, along with the preprocessor rule to
  /// redefine main() as SDL_main(). Thus to ensure that your main() function
  /// will not be changed it is necessary to define SDL_MAIN_HANDLED before
  /// including SDL.h.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  void SDL_SetMainReady() {
    return _SDL_SetMainReady();
  }

  late final _SDL_SetMainReadyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_SetMainReady');
  late final _SDL_SetMainReady =
      _SDL_SetMainReadyPtr.asFunction<void Function()>();

  /// Register a win32 window class for SDL's use.
  ///
  /// This can be called to set the application window class at startup. It is
  /// safe to call this multiple times, as long as every call is eventually
  /// paired with a call to SDL_UnregisterApp, but a second registration attempt
  /// while a previous registration is still active will be ignored, other than
  /// to increment a counter.
  ///
  /// Most applications do not need to, and should not, call this directly; SDL
  /// will call it when initializing the video subsystem.
  ///
  /// \param name the window class name, in UTF-8 encoding. If NULL, SDL
  /// currently uses "SDL_app" but this isn't guaranteed.
  /// \param style the value to use in WNDCLASSEX::style. If `name` is NULL, SDL
  /// currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` regardless of
  /// what is specified here.
  /// \param hInst the HINSTANCE to use in WNDCLASSEX::hInstance. If zero, SDL
  /// will use `GetModuleHandle(NULL)` instead.
  /// \returns 0 on success, -1 on error. SDL_GetError() may have details.
  ///
  /// \since This function is available since SDL 2.0.2.
  int SDL_RegisterApp(
    ffi.Pointer<ffi.Char> name,
    int style,
    ffi.Pointer<ffi.Void> hInst,
  ) {
    return _SDL_RegisterApp(
      name,
      style,
      hInst,
    );
  }

  late final _SDL_RegisterAppPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, Uint32,
              ffi.Pointer<ffi.Void>)>>('SDL_RegisterApp');
  late final _SDL_RegisterApp = _SDL_RegisterAppPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Void>)>();

  /// Deregister the win32 window class from an SDL_RegisterApp call.
  ///
  /// This can be called to undo the effects of SDL_RegisterApp.
  ///
  /// Most applications do not need to, and should not, call this directly; SDL
  /// will call it when deinitializing the video subsystem.
  ///
  /// It is safe to call this multiple times, as long as every call is eventually
  /// paired with a prior call to SDL_RegisterApp. The window class will only be
  /// deregistered when the registration counter in SDL_RegisterApp decrements to
  /// zero through calls to this function.
  ///
  /// \since This function is available since SDL 2.0.2.
  void SDL_UnregisterApp() {
    return _SDL_UnregisterApp();
  }

  late final _SDL_UnregisterAppPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnregisterApp');
  late final _SDL_UnregisterApp =
      _SDL_UnregisterAppPtr.asFunction<void Function()>();

  int SDL_ReportAssertion(
    ffi.Pointer<SDL_AssertData> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _SDL_ReportAssertion(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _SDL_ReportAssertionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ReportAssertion');
  late final _SDL_ReportAssertion = _SDL_ReportAssertionPtr.asFunction<
      int Function(ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Set an application-defined assertion handler.
  ///
  /// This function allows an application to show its own assertion UI and/or
  /// force the response to an assertion failure. If the application doesn't
  /// provide this, SDL will try to do the right thing, popping up a
  /// system-specific GUI dialog, and probably minimizing any fullscreen windows.
  ///
  /// This callback may fire from any thread, but it runs wrapped in a mutex, so
  /// it will only fire from one thread at a time.
  ///
  /// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
  ///
  /// \param handler the SDL_AssertionHandler function to call when an assertion
  /// fails or NULL for the default handler
  /// \param userdata a pointer that is passed to `handler`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAssertionHandler
  void SDL_SetAssertionHandler(
    SDL_AssertionHandler handler,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetAssertionHandler(
      handler,
      userdata,
    );
  }

  late final _SDL_SetAssertionHandlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_AssertionHandler,
              ffi.Pointer<ffi.Void>)>>('SDL_SetAssertionHandler');
  late final _SDL_SetAssertionHandler = _SDL_SetAssertionHandlerPtr.asFunction<
      void Function(SDL_AssertionHandler, ffi.Pointer<ffi.Void>)>();

  /// Get the default assertion handler.
  ///
  /// This returns the function pointer that is called by default when an
  /// assertion is triggered. This is an internal function provided by SDL, that
  /// is used for assertions when SDL_SetAssertionHandler() hasn't been used to
  /// provide a different function.
  ///
  /// \returns the default SDL_AssertionHandler that is called when an assert
  /// triggers.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GetAssertionHandler
  SDL_AssertionHandler SDL_GetDefaultAssertionHandler() {
    return _SDL_GetDefaultAssertionHandler();
  }

  late final _SDL_GetDefaultAssertionHandlerPtr =
      _lookup<ffi.NativeFunction<SDL_AssertionHandler Function()>>(
          'SDL_GetDefaultAssertionHandler');
  late final _SDL_GetDefaultAssertionHandler =
      _SDL_GetDefaultAssertionHandlerPtr.asFunction<
          SDL_AssertionHandler Function()>();

  /// Get the current assertion handler.
  ///
  /// This returns the function pointer that is called when an assertion is
  /// triggered. This is either the value last passed to
  /// SDL_SetAssertionHandler(), or if no application-specified function is set,
  /// is equivalent to calling SDL_GetDefaultAssertionHandler().
  ///
  /// The parameter `puserdata` is a pointer to a void*, which will store the
  /// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value
  /// will always be NULL for the default handler. If you don't care about this
  /// data, it is safe to pass a NULL pointer to this function to ignore it.
  ///
  /// \param puserdata pointer which is filled with the "userdata" pointer that
  /// was passed to SDL_SetAssertionHandler()
  /// \returns the SDL_AssertionHandler that is called when an assert triggers.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_SetAssertionHandler
  SDL_AssertionHandler SDL_GetAssertionHandler(
    ffi.Pointer<ffi.Pointer<ffi.Void>> puserdata,
  ) {
    return _SDL_GetAssertionHandler(
      puserdata,
    );
  }

  late final _SDL_GetAssertionHandlerPtr = _lookup<
      ffi.NativeFunction<
          SDL_AssertionHandler Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetAssertionHandler');
  late final _SDL_GetAssertionHandler = _SDL_GetAssertionHandlerPtr.asFunction<
      SDL_AssertionHandler Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Get a list of all assertion failures.
  ///
  /// This function gets all assertions triggered since the last call to
  /// SDL_ResetAssertionReport(), or the start of the program.
  ///
  /// The proper way to examine this data looks something like this:
  ///
  /// ```c
  /// const SDL_AssertData *item = SDL_GetAssertionReport();
  /// while (item) {
  /// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
  /// item->condition, item->function, item->filename,
  /// item->linenum, item->trigger_count,
  /// item->always_ignore ? "yes" : "no");
  /// item = item->next;
  /// }
  /// ```
  ///
  /// \returns a list of all failed assertions or NULL if the list is empty. This
  /// memory should not be modified or freed by the application.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ResetAssertionReport
  ffi.Pointer<SDL_AssertData> SDL_GetAssertionReport() {
    return _SDL_GetAssertionReport();
  }

  late final _SDL_GetAssertionReportPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_AssertData> Function()>>(
          'SDL_GetAssertionReport');
  late final _SDL_GetAssertionReport = _SDL_GetAssertionReportPtr.asFunction<
      ffi.Pointer<SDL_AssertData> Function()>();

  /// Clear the list of all assertion failures.
  ///
  /// This function will clear the list of all assertions triggered up to that
  /// point. Immediately following this call, SDL_GetAssertionReport will return
  /// no items. In addition, any previously-triggered assertions will be reset to
  /// a trigger_count of zero, and their always_ignore state will be false.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAssertionReport
  void SDL_ResetAssertionReport() {
    return _SDL_ResetAssertionReport();
  }

  late final _SDL_ResetAssertionReportPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_ResetAssertionReport');
  late final _SDL_ResetAssertionReport =
      _SDL_ResetAssertionReportPtr.asFunction<void Function()>();

  /// Try to lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  /// \returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already
  /// held.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicUnlock
  int SDL_AtomicTryLock(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicTryLock(
      lock,
    );
  }

  late final _SDL_AtomicTryLockPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_SpinLock>)>>(
      'SDL_AtomicTryLock');
  late final _SDL_AtomicTryLock = _SDL_AtomicTryLockPtr.asFunction<
      int Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicTryLock
  /// \sa SDL_AtomicUnlock
  void SDL_AtomicLock(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicLock(
      lock,
    );
  }

  late final _SDL_AtomicLockPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicLock');
  late final _SDL_AtomicLock =
      _SDL_AtomicLockPtr.asFunction<void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Unlock a spin lock by setting it to 0.
  ///
  /// Always returns immediately.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicTryLock
  void SDL_AtomicUnlock(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicUnlock(
      lock,
    );
  }

  late final _SDL_AtomicUnlockPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicUnlock');
  late final _SDL_AtomicUnlock = _SDL_AtomicUnlockPtr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Memory barriers are designed to prevent reads and writes from being
  /// reordered by the compiler and being seen out of order on multi-core CPUs.
  ///
  /// A typical pattern would be for thread A to write some data and a flag, and
  /// for thread B to read the flag and get the data. In this case you would
  /// insert a release barrier between writing the data and the flag,
  /// guaranteeing that the data write completes no later than the flag is
  /// written, and you would insert an acquire barrier between reading the flag
  /// and reading the data, to ensure that all the reads associated with the flag
  /// have completed.
  ///
  /// In this pattern you should always see a release barrier paired with an
  /// acquire barrier and you should gate the data reads/writes with a single
  /// flag variable.
  ///
  /// For more information on these semantics, take a look at the blog post:
  /// http://preshing.com/20120913/acquire-and-release-semantics
  ///
  /// \since This function is available since SDL 2.0.6.
  void SDL_MemoryBarrierReleaseFunction() {
    return _SDL_MemoryBarrierReleaseFunction();
  }

  late final _SDL_MemoryBarrierReleaseFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierReleaseFunction');
  late final _SDL_MemoryBarrierReleaseFunction =
      _SDL_MemoryBarrierReleaseFunctionPtr.asFunction<void Function()>();

  void SDL_MemoryBarrierAcquireFunction() {
    return _SDL_MemoryBarrierAcquireFunction();
  }

  late final _SDL_MemoryBarrierAcquireFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierAcquireFunction');
  late final _SDL_MemoryBarrierAcquireFunction =
      _SDL_MemoryBarrierAcquireFunctionPtr.asFunction<void Function()>();

  /// Set an atomic variable to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param oldval the old value
  /// \param newval the new value
  /// \returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGet
  /// \sa SDL_AtomicSet
  int SDL_AtomicCAS(
    ffi.Pointer<SDL_atomic_t> a,
    int oldval,
    int newval,
  ) {
    return _SDL_AtomicCAS(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int, ffi.Int)>>('SDL_AtomicCAS');
  late final _SDL_AtomicCAS = _SDL_AtomicCASPtr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int, int)>();

  /// Set an atomic variable to a value.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicGet
  int SDL_AtomicSet(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicSet(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicSet');
  late final _SDL_AtomicSet = _SDL_AtomicSetPtr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Get the value of an atomic variable.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable
  /// \returns the current value of an atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicSet
  int SDL_AtomicGet(
    ffi.Pointer<SDL_atomic_t> a,
  ) {
    return _SDL_AtomicGet(
      a,
    );
  }

  late final _SDL_AtomicGetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_atomic_t>)>>(
          'SDL_AtomicGet');
  late final _SDL_AtomicGet =
      _SDL_AtomicGetPtr.asFunction<int Function(ffi.Pointer<SDL_atomic_t>)>();

  /// Add to an atomic variable.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value to add
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicDecRef
  /// \sa SDL_AtomicIncRef
  int SDL_AtomicAdd(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicAdd(
      a,
      v,
    );
  }

  late final _SDL_AtomicAddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicAdd');
  late final _SDL_AtomicAdd = _SDL_AtomicAddPtr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Set a pointer to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param oldval the old pointer value
  /// \param newval the new pointer value
  /// \returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCAS
  /// \sa SDL_AtomicGetPtr
  /// \sa SDL_AtomicSetPtr
  int SDL_AtomicCASPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> oldval,
    ffi.Pointer<ffi.Void> newval,
  ) {
    return _SDL_AtomicCASPtr1(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicCASPtr');
  late final _SDL_AtomicCASPtr1 = _SDL_AtomicCASPtrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// Set a pointer to a value atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param v the desired pointer value
  /// \returns the previous value of the pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicSetPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> v,
  ) {
    return _SDL_AtomicSetPtr1(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicSetPtr');
  late final _SDL_AtomicSetPtr1 = _SDL_AtomicSetPtrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>)>();

  /// Get the value of a pointer atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \returns the current value of a pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicSetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicGetPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ) {
    return _SDL_AtomicGetPtr1(
      a,
    );
  }

  late final _SDL_AtomicGetPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_AtomicGetPtr');
  late final _SDL_AtomicGetPtr1 = _SDL_AtomicGetPtrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError(
      fmt,
    );
  }

  late final _SDL_SetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError =
      _SDL_SetErrorPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError() {
    return _SDL_GetError();
  }

  late final _SDL_GetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError =
      _SDL_GetErrorPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg = _SDL_GetErrorMsgPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError() {
    return _SDL_ClearError();
  }

  late final _SDL_ClearErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError = _SDL_ClearErrorPtr.asFunction<void Function()>();

  int SDL_Error(
    int code,
  ) {
    return _SDL_Error(
      code,
    );
  }

  late final _SDL_ErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error = _SDL_ErrorPtr.asFunction<int Function(int)>();

  /// Create a new mutex.
  ///
  /// All newly-created mutexes begin in the _unlocked_ state.
  ///
  /// Calls to SDL_LockMutex() will not return while the mutex is locked by
  /// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
  ///
  /// SDL mutexes are reentrant.
  ///
  /// \returns the initialized and unlocked mutex or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  ffi.Pointer<SDL_mutex> SDL_CreateMutex() {
    return _SDL_CreateMutex();
  }

  late final _SDL_CreateMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_mutex> Function()>>(
          'SDL_CreateMutex');
  late final _SDL_CreateMutex =
      _SDL_CreateMutexPtr.asFunction<ffi.Pointer<SDL_mutex> Function()>();

  /// Lock the mutex.
  ///
  /// This will block until the mutex is available, which is to say it is in the
  /// unlocked state and the OS has chosen the caller as the next thread to lock
  /// it. Of all threads waiting to lock the mutex, only one may do so at a time.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// \param mutex the mutex to lock
  /// \return 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_LockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_LockMutex(
      mutex,
    );
  }

  late final _SDL_LockMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_LockMutex');
  late final _SDL_LockMutex =
      _SDL_LockMutexPtr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Try to lock a mutex without blocking.
  ///
  /// This works just like SDL_LockMutex(), but if the mutex is not available,
  /// this function returns `SDL_MUTEX_TIMEOUT` immediately.
  ///
  /// This technique is useful if you need exclusive access to a resource but
  /// don't want to wait for it, and will return to it to try again later.
  ///
  /// \param mutex the mutex to try to lock
  /// \returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_UnlockMutex
  int SDL_TryLockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_TryLockMutex(
      mutex,
    );
  }

  late final _SDL_TryLockMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_TryLockMutex');
  late final _SDL_TryLockMutex =
      _SDL_TryLockMutexPtr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Unlock the mutex.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// It is an error to unlock a mutex that has not been locked by the current
  /// thread, and doing so results in undefined behavior.
  ///
  /// It is also an error to unlock a mutex that isn't locked at all.
  ///
  /// \param mutex the mutex to unlock.
  /// \returns 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_UnlockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_UnlockMutex(
      mutex,
    );
  }

  late final _SDL_UnlockMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_UnlockMutex');
  late final _SDL_UnlockMutex =
      _SDL_UnlockMutexPtr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Destroy a mutex created with SDL_CreateMutex().
  ///
  /// This function must be called on any mutex that is no longer needed. Failure
  /// to destroy a mutex will result in a system memory or resource leak. While
  /// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
  /// to destroy a locked mutex, and may result in undefined behavior depending
  /// on the platform.
  ///
  /// \param mutex the mutex to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  void SDL_DestroyMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_DestroyMutex(
      mutex,
    );
  }

  late final _SDL_DestroyMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_DestroyMutex');
  late final _SDL_DestroyMutex =
      _SDL_DestroyMutexPtr.asFunction<void Function(ffi.Pointer<SDL_mutex>)>();

  /// Create a semaphore.
  ///
  /// This function creates a new semaphore and initializes it with the value
  /// `initial_value`. Each wait operation on the semaphore will atomically
  /// decrement the semaphore value and potentially block if the semaphore value
  /// is 0. Each post operation will atomically increment the semaphore value and
  /// wake waiting threads and allow them to retry the wait operation.
  ///
  /// \param initial_value the starting value of the semaphore
  /// \returns a new semaphore or NULL on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  ffi.Pointer<SDL_sem> SDL_CreateSemaphore(
    int initial_value,
  ) {
    return _SDL_CreateSemaphore(
      initial_value,
    );
  }

  late final _SDL_CreateSemaphorePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_sem> Function(Uint32)>>(
          'SDL_CreateSemaphore');
  late final _SDL_CreateSemaphore =
      _SDL_CreateSemaphorePtr.asFunction<ffi.Pointer<SDL_sem> Function(int)>();

  /// Destroy a semaphore.
  ///
  /// It is not safe to destroy a semaphore if there are threads currently
  /// waiting on it.
  ///
  /// \param sem the semaphore to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  void SDL_DestroySemaphore(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_DestroySemaphore(
      sem,
    );
  }

  late final _SDL_DestroySemaphorePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_DestroySemaphore');
  late final _SDL_DestroySemaphore = _SDL_DestroySemaphorePtr.asFunction<
      void Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value or the call is interrupted by a
  /// signal or error. If the call is successful it will atomically decrement the
  /// semaphore value.
  ///
  /// This function is the equivalent of calling SDL_SemWaitTimeout() with a time
  /// length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param sem the semaphore wait on
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemWait(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemWait(
      sem,
    );
  }

  late final _SDL_SemWaitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemWait');
  late final _SDL_SemWait =
      _SDL_SemWaitPtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// See if a semaphore has a positive value and decrement it if it does.
  ///
  /// This function checks to see if the semaphore pointed to by `sem` has a
  /// positive value and atomically decrements the semaphore value if it does. If
  /// the semaphore doesn't have a positive value, the function immediately
  /// returns SDL_MUTEX_TIMEDOUT.
  ///
  /// \param sem the semaphore to wait on
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would
  /// block, or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemTryWait(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemTryWait(
      sem,
    );
  }

  late final _SDL_SemTryWaitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemTryWait');
  late final _SDL_SemTryWait =
      _SDL_SemTryWaitPtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value, the call is interrupted by a
  /// signal or error, or the specified time has elapsed. If the call is
  /// successful it will atomically decrement the semaphore value.
  ///
  /// \param sem the semaphore to wait on
  /// \param ms the length of the timeout, in milliseconds
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not
  /// succeed in the allotted time, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  int SDL_SemWaitTimeout(
    ffi.Pointer<SDL_sem> sem,
    int ms,
  ) {
    return _SDL_SemWaitTimeout(
      sem,
      ms,
    );
  }

  late final _SDL_SemWaitTimeoutPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>, Uint32)>>(
      'SDL_SemWaitTimeout');
  late final _SDL_SemWaitTimeout = _SDL_SemWaitTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_sem>, int)>();

  /// Atomically increment a semaphore's value and wake waiting threads.
  ///
  /// \param sem the semaphore to increment
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemPost(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemPost(
      sem,
    );
  }

  late final _SDL_SemPostPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemPost');
  late final _SDL_SemPost =
      _SDL_SemPostPtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Get the current value of a semaphore.
  ///
  /// \param sem the semaphore to query
  /// \returns the current value of the semaphore.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  int SDL_SemValue(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemValue(
      sem,
    );
  }

  late final _SDL_SemValuePtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemValue');
  late final _SDL_SemValue =
      _SDL_SemValuePtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Create a condition variable.
  ///
  /// \returns a new condition variable or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_DestroyCond
  ffi.Pointer<SDL_cond> SDL_CreateCond() {
    return _SDL_CreateCond();
  }

  late final _SDL_CreateCondPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_cond> Function()>>(
          'SDL_CreateCond');
  late final _SDL_CreateCond =
      _SDL_CreateCondPtr.asFunction<ffi.Pointer<SDL_cond> Function()>();

  /// Destroy a condition variable.
  ///
  /// \param cond the condition variable to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  void SDL_DestroyCond(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_DestroyCond(
      cond,
    );
  }

  late final _SDL_DestroyCondPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_DestroyCond');
  late final _SDL_DestroyCond =
      _SDL_DestroyCondPtr.asFunction<void Function(ffi.Pointer<SDL_cond>)>();

  /// Restart one of the threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondSignal(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondSignal(
      cond,
    );
  }

  late final _SDL_CondSignalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondSignal');
  late final _SDL_CondSignal =
      _SDL_CondSignalPtr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Restart all threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondBroadcast(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondBroadcast(
      cond,
    );
  }

  late final _SDL_CondBroadcastPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondBroadcast');
  late final _SDL_CondBroadcast =
      _SDL_CondBroadcastPtr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Wait until a condition variable is signaled.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`. Once the condition variable is signaled, the mutex is re-locked and
  /// the function returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// This function is the equivalent of calling SDL_CondWaitTimeout() with a
  /// time length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \returns 0 when it is signaled or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWait(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_CondWait(
      cond,
      mutex,
    );
  }

  late final _SDL_CondWaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>>('SDL_CondWait');
  late final _SDL_CondWait = _SDL_CondWaitPtr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>();

  /// Wait until a condition variable is signaled or a certain time has passed.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`, or for the specified time to elapse. Once the condition variable is
  /// signaled or the time elapsed, the mutex is re-locked and the function
  /// returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \param ms the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`
  /// to wait indefinitely
  /// \returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if
  /// the condition is not signaled in the allotted time, or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWaitTimeout(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
    int ms,
  ) {
    return _SDL_CondWaitTimeout(
      cond,
      mutex,
      ms,
    );
  }

  late final _SDL_CondWaitTimeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>,
              Uint32)>>('SDL_CondWaitTimeout');
  late final _SDL_CondWaitTimeout = _SDL_CondWaitTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>, int)>();

  late final ffi.Pointer<ffi.Double> __HUGE = _lookup<ffi.Double>('_HUGE');

  double get _HUGE => __HUGE.value;

  set _HUGE(double value) => __HUGE.value = value;

  late final ffi.Pointer<_float_const> __Denorm_C =
      _lookup<_float_const>('_Denorm_C');

  ffi.Pointer<_float_const> get _Denorm_C => __Denorm_C;

  late final ffi.Pointer<_float_const> __Inf_C =
      _lookup<_float_const>('_Inf_C');

  ffi.Pointer<_float_const> get _Inf_C => __Inf_C;

  late final ffi.Pointer<_float_const> __Nan_C =
      _lookup<_float_const>('_Nan_C');

  ffi.Pointer<_float_const> get _Nan_C => __Nan_C;

  late final ffi.Pointer<_float_const> __Snan_C =
      _lookup<_float_const>('_Snan_C');

  ffi.Pointer<_float_const> get _Snan_C => __Snan_C;

  late final ffi.Pointer<_float_const> __Hugeval_C =
      _lookup<_float_const>('_Hugeval_C');

  ffi.Pointer<_float_const> get _Hugeval_C => __Hugeval_C;

  late final ffi.Pointer<_float_const> __FDenorm_C =
      _lookup<_float_const>('_FDenorm_C');

  ffi.Pointer<_float_const> get _FDenorm_C => __FDenorm_C;

  late final ffi.Pointer<_float_const> __FInf_C =
      _lookup<_float_const>('_FInf_C');

  ffi.Pointer<_float_const> get _FInf_C => __FInf_C;

  late final ffi.Pointer<_float_const> __FNan_C =
      _lookup<_float_const>('_FNan_C');

  ffi.Pointer<_float_const> get _FNan_C => __FNan_C;

  late final ffi.Pointer<_float_const> __FSnan_C =
      _lookup<_float_const>('_FSnan_C');

  ffi.Pointer<_float_const> get _FSnan_C => __FSnan_C;

  late final ffi.Pointer<_float_const> __LDenorm_C =
      _lookup<_float_const>('_LDenorm_C');

  ffi.Pointer<_float_const> get _LDenorm_C => __LDenorm_C;

  late final ffi.Pointer<_float_const> __LInf_C =
      _lookup<_float_const>('_LInf_C');

  ffi.Pointer<_float_const> get _LInf_C => __LInf_C;

  late final ffi.Pointer<_float_const> __LNan_C =
      _lookup<_float_const>('_LNan_C');

  ffi.Pointer<_float_const> get _LNan_C => __LNan_C;

  late final ffi.Pointer<_float_const> __LSnan_C =
      _lookup<_float_const>('_LSnan_C');

  ffi.Pointer<_float_const> get _LSnan_C => __LSnan_C;

  late final ffi.Pointer<_float_const> __Eps_C =
      _lookup<_float_const>('_Eps_C');

  ffi.Pointer<_float_const> get _Eps_C => __Eps_C;

  late final ffi.Pointer<_float_const> __Rteps_C =
      _lookup<_float_const>('_Rteps_C');

  ffi.Pointer<_float_const> get _Rteps_C => __Rteps_C;

  late final ffi.Pointer<_float_const> __FEps_C =
      _lookup<_float_const>('_FEps_C');

  ffi.Pointer<_float_const> get _FEps_C => __FEps_C;

  late final ffi.Pointer<_float_const> __FRteps_C =
      _lookup<_float_const>('_FRteps_C');

  ffi.Pointer<_float_const> get _FRteps_C => __FRteps_C;

  late final ffi.Pointer<_float_const> __LEps_C =
      _lookup<_float_const>('_LEps_C');

  ffi.Pointer<_float_const> get _LEps_C => __LEps_C;

  late final ffi.Pointer<_float_const> __LRteps_C =
      _lookup<_float_const>('_LRteps_C');

  ffi.Pointer<_float_const> get _LRteps_C => __LRteps_C;

  late final ffi.Pointer<ffi.Double> __Zero_C = _lookup<ffi.Double>('_Zero_C');

  double get _Zero_C => __Zero_C.value;

  set _Zero_C(double value) => __Zero_C.value = value;

  late final ffi.Pointer<ffi.Double> __Xbig_C = _lookup<ffi.Double>('_Xbig_C');

  double get _Xbig_C => __Xbig_C.value;

  set _Xbig_C(double value) => __Xbig_C.value = value;

  late final ffi.Pointer<ffi.Float> __FZero_C = _lookup<ffi.Float>('_FZero_C');

  double get _FZero_C => __FZero_C.value;

  set _FZero_C(double value) => __FZero_C.value = value;

  late final ffi.Pointer<ffi.Float> __FXbig_C = _lookup<ffi.Float>('_FXbig_C');

  double get _FXbig_C => __FXbig_C.value;

  set _FXbig_C(double value) => __FXbig_C.value = value;

  late final ffi.Pointer<ffi.Double> _HUGE1 = _lookup<ffi.Double>('HUGE');

  double get HUGE => _HUGE1.value;

  set HUGE(double value) => _HUGE1.value = value;

  late final ffi.Pointer<ffi.Int32> ___current_exit_return_mode =
      _lookup<ffi.Int32>('__current_exit_return_mode');

  int get __current_exit_return_mode => ___current_exit_return_mode.value;

  set __current_exit_return_mode(int value) =>
      ___current_exit_return_mode.value = value;

  ffi.Pointer<SDL_Thread> SDL_CreateThread(
    SDL_ThreadFunction fn,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThread(
      fn,
      name,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              SDL_ThreadFunction,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThread');
  late final _SDL_CreateThread = _SDL_CreateThreadPtr.asFunction<
      ffi.Pointer<SDL_Thread> Function(
          SDL_ThreadFunction,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          pfnSDL_CurrentBeginThread,
          pfnSDL_CurrentEndThread)>();

  ffi.Pointer<SDL_Thread> SDL_CreateThreadWithStackSize(
    ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>> fn,
    ffi.Pointer<ffi.Char> name,
    int stacksize,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThreadWithStackSize(
      fn,
      name,
      stacksize,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadWithStackSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThreadWithStackSize');
  late final _SDL_CreateThreadWithStackSize =
      _SDL_CreateThreadWithStackSizePtr.asFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>();

  /// Get the thread name as it was specified in SDL_CreateThread().
  ///
  /// This is internal memory, not to be freed by the caller, and remains valid
  /// until the specified thread is cleaned up by SDL_WaitThread().
  ///
  /// \param thread the thread to query
  /// \returns a pointer to a UTF-8 string that names the specified thread, or
  /// NULL if it doesn't have a name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateThread
  ffi.Pointer<ffi.Char> SDL_GetThreadName(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadName(
      thread,
    );
  }

  late final _SDL_GetThreadNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Thread>)>>('SDL_GetThreadName');
  late final _SDL_GetThreadName = _SDL_GetThreadNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Thread>)>();

  /// Get the thread identifier for the current thread.
  ///
  /// This thread identifier is as reported by the underlying operating system.
  /// If SDL is running on a platform that does not support threads the return
  /// value will always be zero.
  ///
  /// This function also returns a valid thread ID when called from the main
  /// thread.
  ///
  /// \returns the ID of the current thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetThreadID
  int SDL_ThreadID() {
    return _SDL_ThreadID();
  }

  late final _SDL_ThreadIDPtr =
      _lookup<ffi.NativeFunction<SDL_threadID Function()>>('SDL_ThreadID');
  late final _SDL_ThreadID = _SDL_ThreadIDPtr.asFunction<int Function()>();

  /// Get the thread identifier for the specified thread.
  ///
  /// This thread identifier is as reported by the underlying operating system.
  /// If SDL is running on a platform that does not support threads the return
  /// value will always be zero.
  ///
  /// \param thread the thread to query
  /// \returns the ID of the specified thread, or the ID of the current thread if
  /// `thread` is NULL.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ThreadID
  int SDL_GetThreadID(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadID(
      thread,
    );
  }

  late final _SDL_GetThreadIDPtr = _lookup<
          ffi.NativeFunction<SDL_threadID Function(ffi.Pointer<SDL_Thread>)>>(
      'SDL_GetThreadID');
  late final _SDL_GetThreadID =
      _SDL_GetThreadIDPtr.asFunction<int Function(ffi.Pointer<SDL_Thread>)>();

  /// Set the priority for the current thread.
  ///
  /// Note that some platforms will not let you alter the priority (or at least,
  /// promote the thread to a higher priority) at all, and some require you to be
  /// an administrator account. Be prepared for this to fail.
  ///
  /// \param priority the SDL_ThreadPriority to set
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetThreadPriority(
    int priority,
  ) {
    return _SDL_SetThreadPriority(
      priority,
    );
  }

  late final _SDL_SetThreadPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_SetThreadPriority');
  late final _SDL_SetThreadPriority =
      _SDL_SetThreadPriorityPtr.asFunction<int Function(int)>();

  /// Wait for a thread to finish.
  ///
  /// Threads that haven't been detached will remain (as a "zombie") until this
  /// function cleans them up. Not doing so is a resource leak.
  ///
  /// Once a thread has been cleaned up through this function, the SDL_Thread
  /// that references it becomes invalid and should not be referenced again. As
  /// such, only one thread may call SDL_WaitThread() on another.
  ///
  /// The return code for the thread function is placed in the area pointed to by
  /// `status`, if `status` is not NULL.
  ///
  /// You may not wait on a thread that has been used in a call to
  /// SDL_DetachThread(). Use either that function or this one, but not both, or
  /// behavior is undefined.
  ///
  /// It is safe to pass a NULL thread to this function; it is a no-op.
  ///
  /// Note that the thread pointer is freed by this function and is not valid
  /// afterward.
  ///
  /// \param thread the SDL_Thread pointer that was returned from the
  /// SDL_CreateThread() call that started this thread
  /// \param status pointer to an integer that will receive the value returned
  /// from the thread function by its 'return', or NULL to not
  /// receive such value back.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateThread
  /// \sa SDL_DetachThread
  void SDL_WaitThread(
    ffi.Pointer<SDL_Thread> thread,
    ffi.Pointer<ffi.Int> status,
  ) {
    return _SDL_WaitThread(
      thread,
      status,
    );
  }

  late final _SDL_WaitThreadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Thread>,
              ffi.Pointer<ffi.Int>)>>('SDL_WaitThread');
  late final _SDL_WaitThread = _SDL_WaitThreadPtr.asFunction<
      void Function(ffi.Pointer<SDL_Thread>, ffi.Pointer<ffi.Int>)>();

  /// Let a thread clean up on exit without intervention.
  ///
  /// A thread may be "detached" to signify that it should not remain until
  /// another thread has called SDL_WaitThread() on it. Detaching a thread is
  /// useful for long-running threads that nothing needs to synchronize with or
  /// further manage. When a detached thread is done, it simply goes away.
  ///
  /// There is no way to recover the return code of a detached thread. If you
  /// need this, don't detach the thread and instead use SDL_WaitThread().
  ///
  /// Once a thread is detached, you should usually assume the SDL_Thread isn't
  /// safe to reference again, as it will become invalid immediately upon the
  /// detached thread's exit, instead of remaining until someone has called
  /// SDL_WaitThread() to finally clean it up. As such, don't detach the same
  /// thread more than once.
  ///
  /// If a thread has already exited when passed to SDL_DetachThread(), it will
  /// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
  /// not safe to detach a thread that might be used with SDL_WaitThread().
  ///
  /// You may not call SDL_WaitThread() on a thread that has been detached. Use
  /// either that function or this one, but not both, or behavior is undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  ///
  /// \param thread the SDL_Thread pointer that was returned from the
  /// SDL_CreateThread() call that started this thread
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_CreateThread
  /// \sa SDL_WaitThread
  void SDL_DetachThread(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_DetachThread(
      thread,
    );
  }

  late final _SDL_DetachThreadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Thread>)>>(
          'SDL_DetachThread');
  late final _SDL_DetachThread =
      _SDL_DetachThreadPtr.asFunction<void Function(ffi.Pointer<SDL_Thread>)>();

  /// Create a piece of thread-local storage.
  ///
  /// This creates an identifier that is globally visible to all threads but
  /// refers to data that is thread-specific.
  ///
  /// \returns the newly created thread local storage identifier or 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSGet
  /// \sa SDL_TLSSet
  int SDL_TLSCreate() {
    return _SDL_TLSCreate();
  }

  late final _SDL_TLSCreatePtr =
      _lookup<ffi.NativeFunction<SDL_TLSID Function()>>('SDL_TLSCreate');
  late final _SDL_TLSCreate = _SDL_TLSCreatePtr.asFunction<int Function()>();

  /// Get the current thread's value associated with a thread local storage ID.
  ///
  /// \param id the thread local storage ID
  /// \returns the value associated with the ID for the current thread or NULL if
  /// no value has been set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSCreate
  /// \sa SDL_TLSSet
  ffi.Pointer<ffi.Void> SDL_TLSGet(
    int id,
  ) {
    return _SDL_TLSGet(
      id,
    );
  }

  late final _SDL_TLSGetPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(SDL_TLSID)>>(
          'SDL_TLSGet');
  late final _SDL_TLSGet =
      _SDL_TLSGetPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Set the current thread's value associated with a thread local storage ID.
  ///
  /// The function prototype for `destructor` is:
  ///
  /// ```c
  /// void destructor(void *value)
  /// ```
  ///
  /// where its parameter `value` is what was passed as `value` to SDL_TLSSet().
  ///
  /// \param id the thread local storage ID
  /// \param value the value to associate with the ID for the current thread
  /// \param destructor a function called when the thread exits, to free the
  /// value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSCreate
  /// \sa SDL_TLSGet
  int SDL_TLSSet(
    int id,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        destructor,
  ) {
    return _SDL_TLSSet(
      id,
      value,
      destructor,
    );
  }

  late final _SDL_TLSSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              SDL_TLSID,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_TLSSet');
  late final _SDL_TLSSet = _SDL_TLSSetPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// Cleanup all TLS data for this thread.
  ///
  /// \since This function is available since SDL 2.0.16.
  void SDL_TLSCleanup() {
    return _SDL_TLSCleanup();
  }

  late final _SDL_TLSCleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_TLSCleanup');
  late final _SDL_TLSCleanup = _SDL_TLSCleanupPtr.asFunction<void Function()>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile = _SDL_RWFromFilePtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFPPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP = _SDL_RWFromFPPtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem = _SDL_RWFromMemPtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem = _SDL_RWFromConstMemPtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW() {
    return _SDL_AllocRW();
  }

  late final _SDL_AllocRWPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW =
      _SDL_AllocRWPtr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW(
      area,
    );
  }

  late final _SDL_FreeRWPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW =
      _SDL_FreeRWPtr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize(
      context,
    );
  }

  late final _SDL_RWsizePtr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize =
      _SDL_RWsizePtr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseekPtr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek = _SDL_RWseekPtr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell(
      context,
    );
  }

  late final _SDL_RWtellPtr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell =
      _SDL_RWtellPtr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWreadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread = _SDL_RWreadPtr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite = _SDL_RWwritePtr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose(
      context,
    );
  }

  late final _SDL_RWclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose =
      _SDL_RWclosePtr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW = _SDL_LoadFile_RWPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile = _SDL_LoadFilePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU8(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU8(
      src,
    );
  }

  late final _SDL_ReadU8Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU8 =
      _SDL_ReadU8Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE16(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE16(
      src,
    );
  }

  late final _SDL_ReadLE16Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE16 =
      _SDL_ReadLE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE16(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE16(
      src,
    );
  }

  late final _SDL_ReadBE16Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE16 =
      _SDL_ReadBE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE32(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE32(
      src,
    );
  }

  late final _SDL_ReadLE32Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE32 =
      _SDL_ReadLE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE32(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE32(
      src,
    );
  }

  late final _SDL_ReadBE32Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE32 =
      _SDL_ReadBE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE64(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE64(
      src,
    );
  }

  late final _SDL_ReadLE64Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE64 =
      _SDL_ReadLE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE64(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE64(
      src,
    );
  }

  late final _SDL_ReadBE64Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE64 =
      _SDL_ReadBE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU8(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU8(
      dst,
      value,
    );
  }

  late final _SDL_WriteU8Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU8 =
      _SDL_WriteU8Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE16(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE16(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE16 =
      _SDL_WriteLE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE16(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE16(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE16 =
      _SDL_WriteBE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE32(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE32(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE32 =
      _SDL_WriteLE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE32(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE32(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE32 =
      _SDL_WriteBE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE64(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE64(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE64 =
      _SDL_WriteLE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE64(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE64(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE64 =
      _SDL_WriteBE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to get the number of built-in audio drivers.
  ///
  /// This function returns a hardcoded number. This never returns a negative
  /// value; if there are no drivers compiled into this build of SDL, this
  /// function returns zero. The presence of a driver in this list does not mean
  /// it will function, it just means SDL is capable of interacting with that
  /// interface. For example, a build of SDL might have esound support, but if
  /// there's no esound server available, SDL's esound driver would fail if used.
  ///
  /// By default, SDL tries all drivers, in its preferred order, until one is
  /// found to be usable.
  ///
  /// \returns the number of built-in audio drivers.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioDriver
  int SDL_GetNumAudioDrivers() {
    return _SDL_GetNumAudioDrivers();
  }

  late final _SDL_GetNumAudioDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAudioDrivers');
  late final _SDL_GetNumAudioDrivers =
      _SDL_GetNumAudioDriversPtr.asFunction<int Function()>();

  /// Use this function to get the name of a built in audio driver.
  ///
  /// The list of audio drivers is given in the order that they are normally
  /// initialized by default; the drivers that seem more reasonable to choose
  /// first (as far as the SDL developers believe) are earlier in the list.
  ///
  /// The names of drivers are all simple, low-ASCII identifiers, like "alsa",
  /// "coreaudio" or "xaudio2". These never have Unicode characters, and are not
  /// meant to be proper names.
  ///
  /// \param index the index of the audio driver; the value ranges from 0 to
  /// SDL_GetNumAudioDrivers() - 1
  /// \returns the name of the audio driver at the requested index, or NULL if an
  /// invalid index was specified.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumAudioDrivers
  ffi.Pointer<ffi.Char> SDL_GetAudioDriver(
    int index,
  ) {
    return _SDL_GetAudioDriver(
      index,
    );
  }

  late final _SDL_GetAudioDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetAudioDriver');
  late final _SDL_GetAudioDriver =
      _SDL_GetAudioDriverPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Use this function to initialize a particular audio driver.
  ///
  /// This function is used internally, and should not be used unless you have a
  /// specific need to designate the audio driver you want to use. You should
  /// normally use SDL_Init() or SDL_InitSubSystem().
  ///
  /// \param driver_name the name of the desired audio driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AudioQuit
  int SDL_AudioInit(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_AudioInit(
      driver_name,
    );
  }

  late final _SDL_AudioInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_AudioInit');
  late final _SDL_AudioInit =
      _SDL_AudioInitPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Use this function to shut down audio if you initialized it with
  /// SDL_AudioInit().
  ///
  /// This function is used internally, and should not be used unless you have a
  /// specific need to specify the audio driver you want to use. You should
  /// normally use SDL_Quit() or SDL_QuitSubSystem().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AudioInit
  void SDL_AudioQuit() {
    return _SDL_AudioQuit();
  }

  late final _SDL_AudioQuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_AudioQuit');
  late final _SDL_AudioQuit = _SDL_AudioQuitPtr.asFunction<void Function()>();

  /// Get the name of the current audio driver.
  ///
  /// The returned string points to internal static memory and thus never becomes
  /// invalid, even if you quit the audio subsystem and initialize a new driver
  /// (although such a case would return a different static string from another
  /// call to this function, of course). As such, you should not modify or free
  /// the returned string.
  ///
  /// \returns the name of the current audio driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AudioInit
  ffi.Pointer<ffi.Char> SDL_GetCurrentAudioDriver() {
    return _SDL_GetCurrentAudioDriver();
  }

  late final _SDL_GetCurrentAudioDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentAudioDriver');
  late final _SDL_GetCurrentAudioDriver = _SDL_GetCurrentAudioDriverPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// This function is a legacy means of opening the audio device.
  ///
  /// This function remains for compatibility with SDL 1.2, but also because it's
  /// slightly easier to use than the new functions in SDL 2.0. The new, more
  /// powerful, and preferred way to do this is SDL_OpenAudioDevice().
  ///
  /// This function is roughly equivalent to:
  ///
  /// ```c
  /// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);
  /// ```
  ///
  /// With two notable exceptions:
  ///
  /// - If `obtained` is NULL, we use `desired` (and allow no changes), which
  /// means desired will be modified to have the correct values for silence,
  /// etc, and SDL will convert any differences between your app's specific
  /// request and the hardware behind the scenes.
  /// - The return value is always success or failure, and not a device ID, which
  /// means you can only have one device open at a time with this function.
  ///
  /// \param desired an SDL_AudioSpec structure representing the desired output
  /// format. Please refer to the SDL_OpenAudioDevice
  /// documentation for details on how to prepare this structure.
  /// \param obtained an SDL_AudioSpec structure filled in with the actual
  /// parameters, or NULL.
  /// \returns 0 if successful, placing the actual hardware parameters in the
  /// structure pointed to by `obtained`.
  ///
  /// If `obtained` is NULL, the audio data passed to the callback
  /// function will be guaranteed to be in the requested format, and
  /// will be automatically converted to the actual hardware audio
  /// format if necessary. If `obtained` is NULL, `desired` will have
  /// fields modified.
  ///
  /// This function returns a negative error code on failure to open the
  /// audio device or failure to set up the audio thread; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CloseAudio
  /// \sa SDL_LockAudio
  /// \sa SDL_PauseAudio
  /// \sa SDL_UnlockAudio
  int SDL_OpenAudio(
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
  ) {
    return _SDL_OpenAudio(
      desired,
      obtained,
    );
  }

  late final _SDL_OpenAudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<SDL_AudioSpec>)>>('SDL_OpenAudio');
  late final _SDL_OpenAudio = _SDL_OpenAudioPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioSpec>, ffi.Pointer<SDL_AudioSpec>)>();

  /// Get the number of built-in audio devices.
  ///
  /// This function is only valid after successfully initializing the audio
  /// subsystem.
  ///
  /// Note that audio capture support is not implemented as of SDL 2.0.4, so the
  /// `iscapture` parameter is for future expansion and should always be zero for
  /// now.
  ///
  /// This function will return -1 if an explicit list of devices can't be
  /// determined. Returning -1 is not an error. For example, if SDL is set up to
  /// talk to a remote audio server, it can't list every one available on the
  /// Internet, but it will still allow a specific host to be specified in
  /// SDL_OpenAudioDevice().
  ///
  /// In many common cases, when this function returns a value <= 0, it can still
  /// successfully open the default device (NULL for first argument of
  /// SDL_OpenAudioDevice()).
  ///
  /// This function may trigger a complete redetect of available hardware. It
  /// should not be called for each iteration of a loop, but rather once at the
  /// start of a loop:
  ///
  /// ```c
  /// // Don't do this:
  /// for (int i = 0; i < SDL_GetNumAudioDevices(0); i++)
  ///
  /// // do this instead:
  /// const int count = SDL_GetNumAudioDevices(0);
  /// for (int i = 0; i < count; ++i) { do_something_here(); }
  /// ```
  ///
  /// \param iscapture zero to request playback devices, non-zero to request
  /// recording devices
  /// \returns the number of available devices exposed by the current driver or
  /// -1 if an explicit list of devices can't be determined. A return
  /// value of -1 does not necessarily mean an error condition.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioDeviceName
  /// \sa SDL_OpenAudioDevice
  int SDL_GetNumAudioDevices(
    int iscapture,
  ) {
    return _SDL_GetNumAudioDevices(
      iscapture,
    );
  }

  late final _SDL_GetNumAudioDevicesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumAudioDevices');
  late final _SDL_GetNumAudioDevices =
      _SDL_GetNumAudioDevicesPtr.asFunction<int Function(int)>();

  /// Get the human-readable name of a specific audio device.
  ///
  /// This function is only valid after successfully initializing the audio
  /// subsystem. The values returned by this function reflect the latest call to
  /// SDL_GetNumAudioDevices(); re-call that function to redetect available
  /// hardware.
  ///
  /// The string returned by this function is UTF-8 encoded, read-only, and
  /// managed internally. You are not to free it. If you need to keep the string
  /// for any length of time, you should make your own copy of it, as it will be
  /// invalid next time any of several other SDL functions are called.
  ///
  /// \param index the index of the audio device; valid values range from 0 to
  /// SDL_GetNumAudioDevices() - 1
  /// \param iscapture non-zero to query the list of recording devices, zero to
  /// query the list of output devices.
  /// \returns the name of the audio device at the requested index, or NULL on
  /// error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumAudioDevices
  ffi.Pointer<ffi.Char> SDL_GetAudioDeviceName(
    int index,
    int iscapture,
  ) {
    return _SDL_GetAudioDeviceName(
      index,
      iscapture,
    );
  }

  late final _SDL_GetAudioDeviceNamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int, ffi.Int)>>(
      'SDL_GetAudioDeviceName');
  late final _SDL_GetAudioDeviceName = _SDL_GetAudioDeviceNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int)>();

  /// Get the preferred audio format of a specific audio device.
  ///
  /// This function is only valid after a successfully initializing the audio
  /// subsystem. The values returned by this function reflect the latest call to
  /// SDL_GetNumAudioDevices(); re-call that function to redetect available
  /// hardware.
  ///
  /// `spec` will be filled with the sample rate, sample format, and channel
  /// count. All other values in the structure are filled with 0. When the
  /// supported struct members are 0, SDL was unable to get the property from the
  /// backend.
  ///
  /// \param index the index of the audio device; valid values range from 0 to
  /// SDL_GetNumAudioDevices() - 1
  /// \param iscapture non-zero to query the list of recording devices, zero to
  /// query the list of output devices.
  /// \param spec The SDL_AudioSpec to be initialized by this function.
  /// \returns 0 on success, nonzero on error
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetNumAudioDevices
  int SDL_GetAudioDeviceSpec(
    int index,
    int iscapture,
    ffi.Pointer<SDL_AudioSpec> spec,
  ) {
    return _SDL_GetAudioDeviceSpec(
      index,
      iscapture,
      spec,
    );
  }

  late final _SDL_GetAudioDeviceSpecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_AudioSpec>)>>('SDL_GetAudioDeviceSpec');
  late final _SDL_GetAudioDeviceSpec = _SDL_GetAudioDeviceSpecPtr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_AudioSpec>)>();

  /// Open a specific audio device.
  ///
  /// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,
  /// this function will never return a 1 so as not to conflict with the legacy
  /// function.
  ///
  /// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,
  /// this function would fail if `iscapture` was not zero. Starting with SDL
  /// 2.0.5, recording is implemented and this value can be non-zero.
  ///
  /// Passing in a `device` name of NULL requests the most reasonable default
  /// (and is equivalent to what SDL_OpenAudio() does to choose a device). The
  /// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
  /// some drivers allow arbitrary and driver-specific strings, such as a
  /// hostname/IP address for a remote audio server, or a filename in the
  /// diskaudio driver.
  ///
  /// An opened audio device starts out paused, and should be enabled for playing
  /// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio
  /// callback function to be called. Since the audio driver may modify the
  /// requested size of the audio buffer, you should allocate any local mixing
  /// buffers after you open the audio device.
  ///
  /// The audio callback runs in a separate thread in most cases; you can prevent
  /// race conditions between your callback and other threads without fully
  /// pausing playback with SDL_LockAudioDevice(). For more information about the
  /// callback, see SDL_AudioSpec.
  ///
  /// Managing the audio spec via 'desired' and 'obtained':
  ///
  /// When filling in the desired audio spec structure:
  ///
  /// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).
  /// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).
  /// - `desired->samples` is the desired size of the audio buffer, in _sample
  /// frames_ (with stereo output, two samples--left and right--would make a
  /// single sample frame). This number should be a power of two, and may be
  /// adjusted by the audio driver to a value more suitable for the hardware.
  /// Good values seem to range between 512 and 8096 inclusive, depending on
  /// the application and CPU speed. Smaller values reduce latency, but can
  /// lead to underflow if the application is doing heavy processing and cannot
  /// fill the audio buffer in time. Note that the number of sample frames is
  /// directly related to time by the following formula: `ms =
  /// (sampleframes*1000)/freq`
  /// - `desired->size` is the size in _bytes_ of the audio buffer, and is
  /// calculated by SDL_OpenAudioDevice(). You don't initialize this.
  /// - `desired->silence` is the value used to set the buffer to silence, and is
  /// calculated by SDL_OpenAudioDevice(). You don't initialize this.
  /// - `desired->callback` should be set to a function that will be called when
  /// the audio device is ready for more data. It is passed a pointer to the
  /// audio buffer, and the length in bytes of the audio buffer. This function
  /// usually runs in a separate thread, and so you should protect data
  /// structures that it accesses by calling SDL_LockAudioDevice() and
  /// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL
  /// pointer here, and call SDL_QueueAudio() with some frequency, to queue
  /// more audio samples to be played (or for capture devices, call
  /// SDL_DequeueAudio() with some frequency, to obtain audio samples).
  /// - `desired->userdata` is passed as the first parameter to your callback
  /// function. If you passed a NULL callback, this value is ignored.
  ///
  /// `allowed_changes` can have the following flags OR'd together:
  ///
  /// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`
  /// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`
  /// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`
  /// - `SDL_AUDIO_ALLOW_ANY_CHANGE`
  ///
  /// These flags specify how SDL should behave when a device cannot offer a
  /// specific feature. If the application requests a feature that the hardware
  /// doesn't offer, SDL will always try to get the closest equivalent.
  ///
  /// For example, if you ask for float32 audio format, but the sound card only
  /// supports int16, SDL will set the hardware to int16. If you had set
  /// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`
  /// structure. If that flag was *not* set, SDL will prepare to convert your
  /// callback's float32 audio to int16 before feeding it to the hardware and
  /// will keep the originally requested format in the `obtained` structure.
  ///
  /// The resulting audio specs, varying depending on hardware and on what
  /// changes were allowed, will then be written back to `obtained`.
  ///
  /// If your application can only handle one specific data format, pass a zero
  /// for `allowed_changes` and let SDL transparently handle any differences.
  ///
  /// \param device a UTF-8 string reported by SDL_GetAudioDeviceName() or a
  /// driver-specific name as appropriate. NULL requests the most
  /// reasonable default device.
  /// \param iscapture non-zero to specify a device should be opened for
  /// recording, not playback
  /// \param desired an SDL_AudioSpec structure representing the desired output
  /// format; see SDL_OpenAudio() for more information
  /// \param obtained an SDL_AudioSpec structure filled in with the actual output
  /// format; see SDL_OpenAudio() for more information
  /// \param allowed_changes 0, or one or more flags OR'd together
  /// \returns a valid device ID that is > 0 on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// For compatibility with SDL 1.2, this will never return 1, since
  /// SDL reserves that ID for the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CloseAudioDevice
  /// \sa SDL_GetAudioDeviceName
  /// \sa SDL_LockAudioDevice
  /// \sa SDL_OpenAudio
  /// \sa SDL_PauseAudioDevice
  /// \sa SDL_UnlockAudioDevice
  int SDL_OpenAudioDevice(
    ffi.Pointer<ffi.Char> device,
    int iscapture,
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
    int allowed_changes,
  ) {
    return _SDL_OpenAudioDevice(
      device,
      iscapture,
      desired,
      obtained,
      allowed_changes,
    );
  }

  late final _SDL_OpenAudioDevicePtr = _lookup<
      ffi.NativeFunction<
          SDL_AudioDeviceID Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Int)>>('SDL_OpenAudioDevice');
  late final _SDL_OpenAudioDevice = _SDL_OpenAudioDevicePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<SDL_AudioSpec>,
          ffi.Pointer<SDL_AudioSpec>, int)>();

  /// This function is a legacy means of querying the audio device.
  ///
  /// New programs might want to use SDL_GetAudioDeviceStatus() instead. This
  /// function is equivalent to calling...
  ///
  /// ```c
  /// SDL_GetAudioDeviceStatus(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \returns the SDL_AudioStatus of the audio device opened by SDL_OpenAudio().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioDeviceStatus
  int SDL_GetAudioStatus() {
    return _SDL_GetAudioStatus();
  }

  late final _SDL_GetAudioStatusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetAudioStatus');
  late final _SDL_GetAudioStatus =
      _SDL_GetAudioStatusPtr.asFunction<int Function()>();

  /// Use this function to get the current audio state of an audio device.
  ///
  /// \param dev the ID of an audio device previously opened with
  /// SDL_OpenAudioDevice()
  /// \returns the SDL_AudioStatus of the specified audio device.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PauseAudioDevice
  int SDL_GetAudioDeviceStatus(
    int dev,
  ) {
    return _SDL_GetAudioDeviceStatus(
      dev,
    );
  }

  late final _SDL_GetAudioDeviceStatusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_AudioDeviceID)>>(
          'SDL_GetAudioDeviceStatus');
  late final _SDL_GetAudioDeviceStatus =
      _SDL_GetAudioDeviceStatusPtr.asFunction<int Function(int)>();

  /// This function is a legacy means of pausing the audio device.
  ///
  /// New programs might want to use SDL_PauseAudioDevice() instead. This
  /// function is equivalent to calling...
  ///
  /// ```c
  /// SDL_PauseAudioDevice(1, pause_on);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \param pause_on non-zero to pause, 0 to unpause
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioStatus
  /// \sa SDL_PauseAudioDevice
  void SDL_PauseAudio(
    int pause_on,
  ) {
    return _SDL_PauseAudio(
      pause_on,
    );
  }

  late final _SDL_PauseAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('SDL_PauseAudio');
  late final _SDL_PauseAudio =
      _SDL_PauseAudioPtr.asFunction<void Function(int)>();

  /// Use this function to pause and unpause audio playback on a specified
  /// device.
  ///
  /// This function pauses and unpauses the audio callback processing for a given
  /// device. Newly-opened audio devices start in the paused state, so you must
  /// call this function with **pause_on**=0 after opening the specified audio
  /// device to start playing sound. This allows you to safely initialize data
  /// for your callback function after opening the audio device. Silence will be
  /// written to the audio device while paused, and the audio callback is
  /// guaranteed to not be called. Pausing one device does not prevent other
  /// unpaused devices from running their callbacks.
  ///
  /// Pausing state does not stack; even if you pause a device several times, a
  /// single unpause will start the device playing again, and vice versa. This is
  /// different from how SDL_LockAudioDevice() works.
  ///
  /// If you just need to protect a few variables from race conditions vs your
  /// callback, you shouldn't pause the audio device, as it will lead to dropouts
  /// in the audio playback. Instead, you should use SDL_LockAudioDevice().
  ///
  /// \param dev a device opened by SDL_OpenAudioDevice()
  /// \param pause_on non-zero to pause, 0 to unpause
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudioDevice
  void SDL_PauseAudioDevice(
    int dev,
    int pause_on,
  ) {
    return _SDL_PauseAudioDevice(
      dev,
      pause_on,
    );
  }

  late final _SDL_PauseAudioDevicePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID, ffi.Int)>>(
      'SDL_PauseAudioDevice');
  late final _SDL_PauseAudioDevice =
      _SDL_PauseAudioDevicePtr.asFunction<void Function(int, int)>();

  /// Load the audio data of a WAVE file into memory.
  ///
  /// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
  /// be valid pointers. The entire data portion of the file is then loaded into
  /// memory and decoded if necessary.
  ///
  /// If `freesrc` is non-zero, the data source gets automatically closed and
  /// freed before the function returns.
  ///
  /// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
  /// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
  /// A-law and mu-law (8 bits). Other formats are currently unsupported and
  /// cause an error.
  ///
  /// If this function succeeds, the pointer returned by it is equal to `spec`
  /// and the pointer to the audio data allocated by the function is written to
  /// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec
  /// members `freq`, `channels`, and `format` are set to the values of the audio
  /// data in the buffer. The `samples` member is set to a sane default and all
  /// others are set to zero.
  ///
  /// It's necessary to use SDL_FreeWAV() to free the audio data returned in
  /// `audio_buf` when it is no longer used.
  ///
  /// Because of the underspecification of the .WAV format, there are many
  /// problematic files in the wild that cause issues with strict decoders. To
  /// provide compatibility with these files, this decoder is lenient in regards
  /// to the truncation of the file, the fact chunk, and the size of the RIFF
  /// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
  /// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
  /// tune the behavior of the loading process.
  ///
  /// Any file that is invalid (due to truncation, corruption, or wrong values in
  /// the headers), too big, or unsupported causes an error. Additionally, any
  /// critical I/O error from the data source will terminate the loading process
  /// with an error. The function returns NULL on error and in all cases (with
  /// the exception of `src` being NULL), an appropriate error message will be
  /// set.
  ///
  /// It is required that the data source supports seeking.
  ///
  /// Example:
  ///
  /// ```c
  /// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, &spec, &buf, &len);
  /// ```
  ///
  /// Note that the SDL_LoadWAV macro does this same thing for you, but in a less
  /// messy way:
  ///
  /// ```c
  /// SDL_LoadWAV("sample.wav", &spec, &buf, &len);
  /// ```
  ///
  /// \param src The data source for the WAVE data
  /// \param freesrc If non-zero, SDL will _always_ free the data source
  /// \param spec An SDL_AudioSpec that will be filled in with the wave file's
  /// format details
  /// \param audio_buf A pointer filled with the audio data, allocated by the
  /// function.
  /// \param audio_len A pointer filled with the length of the audio data buffer
  /// in bytes
  /// \returns This function, if successfully called, returns `spec`, which will
  /// be filled with the audio data format of the wave source data.
  /// `audio_buf` will be filled with a pointer to an allocated buffer
  /// containing the audio data, and `audio_len` is filled with the
  /// length of that audio buffer in bytes.
  ///
  /// This function returns NULL if the .WAV file cannot be opened, uses
  /// an unknown data format, or is corrupt; call SDL_GetError() for
  /// more information.
  ///
  /// When the application is done with the data returned in
  /// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeWAV
  /// \sa SDL_LoadWAV
  ffi.Pointer<SDL_AudioSpec> SDL_LoadWAV_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
    ffi.Pointer<SDL_AudioSpec> spec,
    ffi.Pointer<ffi.Pointer<Uint8>> audio_buf,
    ffi.Pointer<Uint32> audio_len,
  ) {
    return _SDL_LoadWAV_RW(
      src,
      freesrc,
      spec,
      audio_buf,
      audio_len,
    );
  }

  late final _SDL_LoadWAV_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_AudioSpec> Function(
              ffi.Pointer<SDL_RWops>,
              ffi.Int,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<ffi.Pointer<Uint8>>,
              ffi.Pointer<Uint32>)>>('SDL_LoadWAV_RW');
  late final _SDL_LoadWAV_RW = _SDL_LoadWAV_RWPtr.asFunction<
      ffi.Pointer<SDL_AudioSpec> Function(
          ffi.Pointer<SDL_RWops>,
          int,
          ffi.Pointer<SDL_AudioSpec>,
          ffi.Pointer<ffi.Pointer<Uint8>>,
          ffi.Pointer<Uint32>)>();

  /// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().
  ///
  /// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()
  /// its data can eventually be freed with SDL_FreeWAV(). It is safe to call
  /// this function with a NULL pointer.
  ///
  /// \param audio_buf a pointer to the buffer created by SDL_LoadWAV() or
  /// SDL_LoadWAV_RW()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadWAV
  /// \sa SDL_LoadWAV_RW
  void SDL_FreeWAV(
    ffi.Pointer<Uint8> audio_buf,
  ) {
    return _SDL_FreeWAV(
      audio_buf,
    );
  }

  late final _SDL_FreeWAVPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Uint8>)>>(
          'SDL_FreeWAV');
  late final _SDL_FreeWAV =
      _SDL_FreeWAVPtr.asFunction<void Function(ffi.Pointer<Uint8>)>();

  /// Initialize an SDL_AudioCVT structure for conversion.
  ///
  /// Before an SDL_AudioCVT structure can be used to convert audio data it must
  /// be initialized with source and destination information.
  ///
  /// This function will zero out every field of the SDL_AudioCVT, so it must be
  /// called before the application fills in the final buffer information.
  ///
  /// Once this function has returned successfully, and reported that a
  /// conversion is necessary, the application fills in the rest of the fields in
  /// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,
  /// and then can call SDL_ConvertAudio() to complete the conversion.
  ///
  /// \param cvt an SDL_AudioCVT structure filled in with audio conversion
  /// information
  /// \param src_format the source format of the audio data; for more info see
  /// SDL_AudioFormat
  /// \param src_channels the number of channels in the source
  /// \param src_rate the frequency (sample-frames-per-second) of the source
  /// \param dst_format the destination format of the audio data; for more info
  /// see SDL_AudioFormat
  /// \param dst_channels the number of channels in the destination
  /// \param dst_rate the frequency (sample-frames-per-second) of the destination
  /// \returns 1 if the audio filter is prepared, 0 if no conversion is needed,
  /// or a negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ConvertAudio
  int SDL_BuildAudioCVT(
    ffi.Pointer<SDL_AudioCVT> cvt,
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_BuildAudioCVT(
      cvt,
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_BuildAudioCVTPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioCVT>, SDL_AudioFormat, Uint8,
              ffi.Int, SDL_AudioFormat, Uint8, ffi.Int)>>('SDL_BuildAudioCVT');
  late final _SDL_BuildAudioCVT = _SDL_BuildAudioCVTPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioCVT>, int, int, int, int, int, int)>();

  /// Convert audio data to a desired audio format.
  ///
  /// This function does the actual audio data conversion, after the application
  /// has called SDL_BuildAudioCVT() to prepare the conversion information and
  /// then filled in the buffer details.
  ///
  /// Once the application has initialized the `cvt` structure using
  /// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio
  /// data in the source format, this function will convert the buffer, in-place,
  /// to the desired format.
  ///
  /// The data conversion may go through several passes; any given pass may
  /// possibly temporarily increase the size of the data. For example, SDL might
  /// expand 16-bit data to 32 bits before resampling to a lower frequency,
  /// shrinking the data size after having grown it briefly. Since the supplied
  /// buffer will be both the source and destination, converting as necessary
  /// in-place, the application must allocate a buffer that will fully contain
  /// the data during its largest conversion pass. After SDL_BuildAudioCVT()
  /// returns, the application should set the `cvt->len` field to the size, in
  /// bytes, of the source data, and allocate a buffer that is `cvt->len *
  /// cvt->len_mult` bytes long for the `buf` field.
  ///
  /// The source data should be copied into this buffer before the call to
  /// SDL_ConvertAudio(). Upon successful return, this buffer will contain the
  /// converted audio, and `cvt->len_cvt` will be the size of the converted data,
  /// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once
  /// this function returns.
  ///
  /// \param cvt an SDL_AudioCVT structure that was previously set up by
  /// SDL_BuildAudioCVT().
  /// \returns 0 if the conversion was completed successfully or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BuildAudioCVT
  int SDL_ConvertAudio(
    ffi.Pointer<SDL_AudioCVT> cvt,
  ) {
    return _SDL_ConvertAudio(
      cvt,
    );
  }

  late final _SDL_ConvertAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_AudioCVT>)>>(
          'SDL_ConvertAudio');
  late final _SDL_ConvertAudio = _SDL_ConvertAudioPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioCVT>)>();

  /// Create a new audio stream.
  ///
  /// \param src_format The format of the source audio
  /// \param src_channels The number of channels of the source audio
  /// \param src_rate The sampling rate of the source audio
  /// \param dst_format The format of the desired audio output
  /// \param dst_channels The number of channels of the desired audio output
  /// \param dst_rate The sampling rate of the desired audio output
  /// \returns 0 on success, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  ffi.Pointer<SDL_AudioStream> SDL_NewAudioStream(
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_NewAudioStream(
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_NewAudioStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_AudioStream> Function(SDL_AudioFormat, Uint8, ffi.Int,
              SDL_AudioFormat, Uint8, ffi.Int)>>('SDL_NewAudioStream');
  late final _SDL_NewAudioStream = _SDL_NewAudioStreamPtr.asFunction<
      ffi.Pointer<SDL_AudioStream> Function(int, int, int, int, int, int)>();

  /// Add data to be converted/resampled to the stream.
  ///
  /// \param stream The stream the audio data is being added to
  /// \param buf A pointer to the audio data to add
  /// \param len The number of bytes to write to the stream
  /// \returns 0 on success, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamPut(
    ffi.Pointer<SDL_AudioStream> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamPut(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamPutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_AudioStreamPut');
  late final _SDL_AudioStreamPut = _SDL_AudioStreamPutPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>, int)>();

  /// Get converted/resampled data from the stream
  ///
  /// \param stream The stream the audio is being requested from
  /// \param buf A buffer to fill with audio data
  /// \param len The maximum number of bytes to fill
  /// \returns the number of bytes read from the stream, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamGet(
    ffi.Pointer<SDL_AudioStream> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamGet(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_AudioStreamGet');
  late final _SDL_AudioStreamGet = _SDL_AudioStreamGetPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of converted/resampled bytes available.
  ///
  /// The stream may be buffering data behind the scenes until it has enough to
  /// resample correctly, so this number might be lower than what you expect, or
  /// even be zero. Add more data or flush the stream if you need the data now.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamAvailable(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamAvailable(
      stream,
    );
  }

  late final _SDL_AudioStreamAvailablePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_AudioStreamAvailable');
  late final _SDL_AudioStreamAvailable = _SDL_AudioStreamAvailablePtr
      .asFunction<int Function(ffi.Pointer<SDL_AudioStream>)>();

  /// Tell the stream that you're done sending data, and anything being buffered
  /// should be converted/resampled and made available immediately.
  ///
  /// It is legal to add more data to a stream after flushing, but there will be
  /// audio gaps in the output. Generally this is intended to signal the end of
  /// input, so the complete output becomes available.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamFlush(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamFlush(
      stream,
    );
  }

  late final _SDL_AudioStreamFlushPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_AudioStreamFlush');
  late final _SDL_AudioStreamFlush = _SDL_AudioStreamFlushPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream>)>();

  /// Clear any pending data in the stream without converting it
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_FreeAudioStream
  void SDL_AudioStreamClear(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamClear(
      stream,
    );
  }

  late final _SDL_AudioStreamClearPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_AudioStreamClear');
  late final _SDL_AudioStreamClear = _SDL_AudioStreamClearPtr.asFunction<
      void Function(ffi.Pointer<SDL_AudioStream>)>();

  /// Free an audio stream
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  void SDL_FreeAudioStream(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_FreeAudioStream(
      stream,
    );
  }

  late final _SDL_FreeAudioStreamPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_FreeAudioStream');
  late final _SDL_FreeAudioStream = _SDL_FreeAudioStreamPtr.asFunction<
      void Function(ffi.Pointer<SDL_AudioStream>)>();

  /// This function is a legacy means of mixing audio.
  ///
  /// This function is equivalent to calling...
  ///
  /// ```c
  /// SDL_MixAudioFormat(dst, src, format, len, volume);
  /// ```
  ///
  /// ...where `format` is the obtained format of the audio device from the
  /// legacy SDL_OpenAudio() function.
  ///
  /// \param dst the destination for the mixed audio
  /// \param src the source audio buffer to be mixed
  /// \param len the length of the audio buffer in bytes
  /// \param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
  /// for full audio volume
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MixAudioFormat
  void SDL_MixAudio(
    ffi.Pointer<Uint8> dst,
    ffi.Pointer<Uint8> src,
    int len,
    int volume,
  ) {
    return _SDL_MixAudio(
      dst,
      src,
      len,
      volume,
    );
  }

  late final _SDL_MixAudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, Uint32,
              ffi.Int)>>('SDL_MixAudio');
  late final _SDL_MixAudio = _SDL_MixAudioPtr.asFunction<
      void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int)>();

  /// Mix audio data in a specified format.
  ///
  /// This takes an audio buffer `src` of `len` bytes of `format` data and mixes
  /// it into `dst`, performing addition, volume adjustment, and overflow
  /// clipping. The buffer pointed to by `dst` must also be `len` bytes of
  /// `format` data.
  ///
  /// This is provided for convenience -- you can mix your own audio data.
  ///
  /// Do not use this function for mixing together more than two streams of
  /// sample data. The output from repeated application of this function may be
  /// distorted by clipping, because there is no accumulator with greater range
  /// than the input (not to mention this being an inefficient way of doing it).
  ///
  /// It is a common misconception that this function is required to write audio
  /// data to an output stream in an audio callback. While you can do that,
  /// SDL_MixAudioFormat() is really only needed when you're mixing a single
  /// audio stream with a volume adjustment.
  ///
  /// \param dst the destination for the mixed audio
  /// \param src the source audio buffer to be mixed
  /// \param format the SDL_AudioFormat structure representing the desired audio
  /// format
  /// \param len the length of the audio buffer in bytes
  /// \param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
  /// for full audio volume
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_MixAudioFormat(
    ffi.Pointer<Uint8> dst,
    ffi.Pointer<Uint8> src,
    int format,
    int len,
    int volume,
  ) {
    return _SDL_MixAudioFormat(
      dst,
      src,
      format,
      len,
      volume,
    );
  }

  late final _SDL_MixAudioFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>,
              SDL_AudioFormat, Uint32, ffi.Int)>>('SDL_MixAudioFormat');
  late final _SDL_MixAudioFormat = _SDL_MixAudioFormatPtr.asFunction<
      void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int)>();

  /// Queue more audio on non-callback devices.
  ///
  /// If you are looking to retrieve queued audio from a non-callback capture
  /// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return
  /// -1 to signify an error if you use it with capture devices.
  ///
  /// SDL offers two ways to feed audio to the device: you can either supply a
  /// callback that SDL triggers with some frequency to obtain more audio (pull
  /// method), or you can supply no callback, and then SDL will expect you to
  /// supply data at regular intervals (push method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Queued data will drain to the device as
  /// necessary without further intervention from you. If the device needs audio
  /// but there is not enough queued, it will play silence to make up the
  /// difference. This means you will have skips in your audio playback if you
  /// aren't routinely queueing sufficient data.
  ///
  /// This function copies the supplied data, so you are safe to free it when the
  /// function returns. This function is thread-safe, but queueing to the same
  /// device from two threads at once does not promise which buffer will be
  /// queued first.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; doing so returns an error. You have to use the audio callback or
  /// queue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before queueing; SDL
  /// handles locking internally for this function.
  ///
  /// Note that SDL2 does not support planar audio. You will need to resample
  /// from planar audio formats into a non-planar one (see SDL_AudioFormat)
  /// before queuing audio.
  ///
  /// \param dev the device ID to which we will queue audio
  /// \param data the data to queue to the device for later playback
  /// \param len the number of bytes (not samples!) to which `data` points
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_ClearQueuedAudio
  /// \sa SDL_GetQueuedAudioSize
  int SDL_QueueAudio(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_QueueAudio(
      dev,
      data,
      len,
    );
  }

  late final _SDL_QueueAudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_AudioDeviceID, ffi.Pointer<ffi.Void>,
              Uint32)>>('SDL_QueueAudio');
  late final _SDL_QueueAudio = _SDL_QueueAudioPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Dequeue more audio on non-callback devices.
  ///
  /// If you are looking to queue audio for output on a non-callback playback
  /// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always
  /// return 0 if you use it with playback devices.
  ///
  /// SDL offers two ways to retrieve audio from a capture device: you can either
  /// supply a callback that SDL triggers with some frequency as the device
  /// records more audio data, (push method), or you can supply no callback, and
  /// then SDL will expect you to retrieve data at regular intervals (pull
  /// method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Data from the device will keep queuing as
  /// necessary without further intervention from you. This means you will
  /// eventually run out of memory if you aren't routinely dequeueing data.
  ///
  /// Capture devices will not queue data when paused; if you are expecting to
  /// not need captured audio for some length of time, use SDL_PauseAudioDevice()
  /// to stop the capture device from queueing more data. This can be useful
  /// during, say, level loading times. When unpaused, capture devices will start
  /// queueing data from that point, having flushed any capturable data available
  /// while paused.
  ///
  /// This function is thread-safe, but dequeueing from the same device from two
  /// threads at once does not promise which thread will dequeue data first.
  ///
  /// You may not dequeue audio from a device that is using an
  /// application-supplied callback; doing so returns an error. You have to use
  /// the audio callback, or dequeue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before dequeueing; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev the device ID from which we will dequeue audio
  /// \param data a pointer into where audio data should be copied
  /// \param len the number of bytes (not samples!) to which (data) points
  /// \returns the number of bytes dequeued, which could be less than requested;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_ClearQueuedAudio
  /// \sa SDL_GetQueuedAudioSize
  int SDL_DequeueAudio(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_DequeueAudio(
      dev,
      data,
      len,
    );
  }

  late final _SDL_DequeueAudioPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(SDL_AudioDeviceID, ffi.Pointer<ffi.Void>,
              Uint32)>>('SDL_DequeueAudio');
  late final _SDL_DequeueAudio = _SDL_DequeueAudioPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of bytes of still-queued audio.
  ///
  /// For playback devices: this is the number of bytes that have been queued for
  /// playback with SDL_QueueAudio(), but have not yet been sent to the hardware.
  ///
  /// Once we've sent it to the hardware, this function can not decide the exact
  /// byte boundary of what has been played. It's possible that we just gave the
  /// hardware several kilobytes right before you called this function, but it
  /// hasn't played any of it yet, or maybe half of it, etc.
  ///
  /// For capture devices, this is the number of bytes that have been captured by
  /// the device and are waiting for you to dequeue. This number may grow at any
  /// time, so this only informs of the lower-bound of available data.
  ///
  /// You may not queue or dequeue audio on a device that is using an
  /// application-supplied callback; calling this function on such a device
  /// always returns 0. You have to use the audio callback or queue audio, but
  /// not both.
  ///
  /// You should not call SDL_LockAudio() on the device before querying; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev the device ID of which we will query queued audio size
  /// \returns the number of bytes (not samples!) of queued audio.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_ClearQueuedAudio
  /// \sa SDL_QueueAudio
  /// \sa SDL_DequeueAudio
  int SDL_GetQueuedAudioSize(
    int dev,
  ) {
    return _SDL_GetQueuedAudioSize(
      dev,
    );
  }

  late final _SDL_GetQueuedAudioSizePtr =
      _lookup<ffi.NativeFunction<Uint32 Function(SDL_AudioDeviceID)>>(
          'SDL_GetQueuedAudioSize');
  late final _SDL_GetQueuedAudioSize =
      _SDL_GetQueuedAudioSizePtr.asFunction<int Function(int)>();

  /// Drop any queued audio data waiting to be sent to the hardware.
  ///
  /// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
  /// output devices, the hardware will start playing silence if more audio isn't
  /// queued. For capture devices, the hardware will start filling the empty
  /// queue with new data if the capture device isn't paused.
  ///
  /// This will not prevent playback of queued audio that's already been sent to
  /// the hardware, as we can not undo that, so expect there to be some fraction
  /// of a second of audio that might still be heard. This can be useful if you
  /// want to, say, drop any pending music or any unprocessed microphone input
  /// during a level change in your game.
  ///
  /// You may not queue or dequeue audio on a device that is using an
  /// application-supplied callback; calling this function on such a device
  /// always returns 0. You have to use the audio callback or queue audio, but
  /// not both.
  ///
  /// You should not call SDL_LockAudio() on the device before clearing the
  /// queue; SDL handles locking internally for this function.
  ///
  /// This function always succeeds and thus returns void.
  ///
  /// \param dev the device ID of which to clear the audio queue
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetQueuedAudioSize
  /// \sa SDL_QueueAudio
  /// \sa SDL_DequeueAudio
  void SDL_ClearQueuedAudio(
    int dev,
  ) {
    return _SDL_ClearQueuedAudio(
      dev,
    );
  }

  late final _SDL_ClearQueuedAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_ClearQueuedAudio');
  late final _SDL_ClearQueuedAudio =
      _SDL_ClearQueuedAudioPtr.asFunction<void Function(int)>();

  /// This function is a legacy means of locking the audio device.
  ///
  /// New programs might want to use SDL_LockAudioDevice() instead. This function
  /// is equivalent to calling...
  ///
  /// ```c
  /// SDL_LockAudioDevice(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudioDevice
  /// \sa SDL_UnlockAudio
  /// \sa SDL_UnlockAudioDevice
  void SDL_LockAudio() {
    return _SDL_LockAudio();
  }

  late final _SDL_LockAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockAudio');
  late final _SDL_LockAudio = _SDL_LockAudioPtr.asFunction<void Function()>();

  /// Use this function to lock out the audio callback function for a specified
  /// device.
  ///
  /// The lock manipulated by these functions protects the audio callback
  /// function specified in SDL_OpenAudioDevice(). During a
  /// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed
  /// that the callback function for that device is not running, even if the
  /// device is not paused. While a device is locked, any other unpaused,
  /// unlocked devices may still run their callbacks.
  ///
  /// Calling this function from inside your audio callback is unnecessary. SDL
  /// obtains this lock before calling your function, and releases it when the
  /// function returns.
  ///
  /// You should not hold the lock longer than absolutely necessary. If you hold
  /// it too long, you'll experience dropouts in your audio playback. Ideally,
  /// your application locks the device, sets a few variables and unlocks again.
  /// Do not do heavy work while holding the lock for a device.
  ///
  /// It is safe to lock the audio device multiple times, as long as you unlock
  /// it an equivalent number of times. The callback will not run until the
  /// device has been unlocked completely in this way. If your application fails
  /// to unlock the device appropriately, your callback will never run, you might
  /// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably
  /// deadlock.
  ///
  /// Internally, the audio device lock is a mutex; if you lock from two threads
  /// at once, not only will you block the audio callback, you'll block the other
  /// thread.
  ///
  /// \param dev the ID of the device to be locked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UnlockAudioDevice
  void SDL_LockAudioDevice(
    int dev,
  ) {
    return _SDL_LockAudioDevice(
      dev,
    );
  }

  late final _SDL_LockAudioDevicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_LockAudioDevice');
  late final _SDL_LockAudioDevice =
      _SDL_LockAudioDevicePtr.asFunction<void Function(int)>();

  /// This function is a legacy means of unlocking the audio device.
  ///
  /// New programs might want to use SDL_UnlockAudioDevice() instead. This
  /// function is equivalent to calling...
  ///
  /// ```c
  /// SDL_UnlockAudioDevice(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudio
  /// \sa SDL_UnlockAudioDevice
  void SDL_UnlockAudio() {
    return _SDL_UnlockAudio();
  }

  late final _SDL_UnlockAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockAudio');
  late final _SDL_UnlockAudio =
      _SDL_UnlockAudioPtr.asFunction<void Function()>();

  /// Use this function to unlock the audio callback function for a specified
  /// device.
  ///
  /// This function should be paired with a previous SDL_LockAudioDevice() call.
  ///
  /// \param dev the ID of the device to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudioDevice
  void SDL_UnlockAudioDevice(
    int dev,
  ) {
    return _SDL_UnlockAudioDevice(
      dev,
    );
  }

  late final _SDL_UnlockAudioDevicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_UnlockAudioDevice');
  late final _SDL_UnlockAudioDevice =
      _SDL_UnlockAudioDevicePtr.asFunction<void Function(int)>();

  /// This function is a legacy means of closing the audio device.
  ///
  /// This function is equivalent to calling...
  ///
  /// ```c
  /// SDL_CloseAudioDevice(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_OpenAudio
  void SDL_CloseAudio() {
    return _SDL_CloseAudio();
  }

  late final _SDL_CloseAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_CloseAudio');
  late final _SDL_CloseAudio = _SDL_CloseAudioPtr.asFunction<void Function()>();

  /// Use this function to shut down audio processing and close the audio device.
  ///
  /// The application should close open audio devices once they are no longer
  /// needed. Calling this function will wait until the device's audio callback
  /// is not running, release the audio hardware and then clean up internal
  /// state. No further audio will play from this device once this function
  /// returns.
  ///
  /// This function may block briefly while pending audio data is played by the
  /// hardware, so that applications don't drop the last buffer of data they
  /// supplied.
  ///
  /// The device ID is invalid as soon as the device is closed, and is eligible
  /// for reuse in a new SDL_OpenAudioDevice() call immediately.
  ///
  /// \param dev an audio device previously opened with SDL_OpenAudioDevice()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_OpenAudioDevice
  void SDL_CloseAudioDevice(
    int dev,
  ) {
    return _SDL_CloseAudioDevice(
      dev,
    );
  }

  late final _SDL_CloseAudioDevicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_CloseAudioDevice');
  late final _SDL_CloseAudioDevice =
      _SDL_CloseAudioDevicePtr.asFunction<void Function(int)>();

  /// Put UTF-8 text into the clipboard.
  ///
  /// \param text the text to store in the clipboard
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetClipboardText
  /// \sa SDL_HasClipboardText
  int SDL_SetClipboardText(
    ffi.Pointer<ffi.Char> text,
  ) {
    return _SDL_SetClipboardText(
      text,
    );
  }

  late final _SDL_SetClipboardTextPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetClipboardText');
  late final _SDL_SetClipboardText = _SDL_SetClipboardTextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>)>();

  /// Get UTF-8 text from the clipboard, which must be freed with SDL_free().
  ///
  /// This functions returns empty string if there was not enough memory left for
  /// a copy of the clipboard's content.
  ///
  /// \returns the clipboard text on success or an empty string on failure; call
  /// SDL_GetError() for more information. Caller must call SDL_free()
  /// on the returned pointer when done with it (even if there was an
  /// error).
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasClipboardText
  /// \sa SDL_SetClipboardText
  ffi.Pointer<ffi.Char> SDL_GetClipboardText() {
    return _SDL_GetClipboardText();
  }

  late final _SDL_GetClipboardTextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetClipboardText');
  late final _SDL_GetClipboardText =
      _SDL_GetClipboardTextPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Query whether the clipboard exists and contains a non-empty text string.
  ///
  /// \returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetClipboardText
  /// \sa SDL_SetClipboardText
  int SDL_HasClipboardText() {
    return _SDL_HasClipboardText();
  }

  late final _SDL_HasClipboardTextPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasClipboardText');
  late final _SDL_HasClipboardText =
      _SDL_HasClipboardTextPtr.asFunction<int Function()>();

  /// Get the number of CPU cores available.
  ///
  /// \returns the total number of logical CPU cores. On CPUs that include
  /// technologies such as hyperthreading, the number of logical cores
  /// may be more than the number of physical cores.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetCPUCount() {
    return _SDL_GetCPUCount();
  }

  late final _SDL_GetCPUCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetCPUCount');
  late final _SDL_GetCPUCount =
      _SDL_GetCPUCountPtr.asFunction<int Function()>();

  /// Determine the L1 cache line size of the CPU.
  ///
  /// This is useful for determining multi-threaded structure padding or SIMD
  /// prefetch sizes.
  ///
  /// \returns the L1 cache line size of the CPU, in bytes.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetCPUCacheLineSize() {
    return _SDL_GetCPUCacheLineSize();
  }

  late final _SDL_GetCPUCacheLineSizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetCPUCacheLineSize');
  late final _SDL_GetCPUCacheLineSize =
      _SDL_GetCPUCacheLineSizePtr.asFunction<int Function()>();

  /// Determine whether the CPU has the RDTSC instruction.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasRDTSC() {
    return _SDL_HasRDTSC();
  }

  late final _SDL_HasRDTSCPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasRDTSC');
  late final _SDL_HasRDTSC = _SDL_HasRDTSCPtr.asFunction<int Function()>();

  /// Determine whether the CPU has AltiVec features.
  ///
  /// This always returns false on CPUs that aren't using PowerPC instruction
  /// sets.
  ///
  /// \returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasAltiVec() {
    return _SDL_HasAltiVec();
  }

  late final _SDL_HasAltiVecPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAltiVec');
  late final _SDL_HasAltiVec = _SDL_HasAltiVecPtr.asFunction<int Function()>();

  /// Determine whether the CPU has MMX features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasMMX() {
    return _SDL_HasMMX();
  }

  late final _SDL_HasMMXPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasMMX');
  late final _SDL_HasMMX = _SDL_HasMMXPtr.asFunction<int Function()>();

  /// Determine whether the CPU has 3DNow! features.
  ///
  /// This always returns false on CPUs that aren't using AMD instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has 3DNow! features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_Has3DNow() {
    return _SDL_Has3DNow();
  }

  late final _SDL_Has3DNowPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_Has3DNow');
  late final _SDL_Has3DNow = _SDL_Has3DNowPtr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasSSE() {
    return _SDL_HasSSE();
  }

  late final _SDL_HasSSEPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE');
  late final _SDL_HasSSE = _SDL_HasSSEPtr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE2 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasSSE2() {
    return _SDL_HasSSE2();
  }

  late final _SDL_HasSSE2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE2');
  late final _SDL_HasSSE2 = _SDL_HasSSE2Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE3 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasSSE3() {
    return _SDL_HasSSE3();
  }

  late final _SDL_HasSSE3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE3');
  late final _SDL_HasSSE3 = _SDL_HasSSE3Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE4.1 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE4.1 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE42
  int SDL_HasSSE41() {
    return _SDL_HasSSE41();
  }

  late final _SDL_HasSSE41Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE41');
  late final _SDL_HasSSE41 = _SDL_HasSSE41Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE4.2 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE4.2 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  int SDL_HasSSE42() {
    return _SDL_HasSSE42();
  }

  late final _SDL_HasSSE42Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE42');
  late final _SDL_HasSSE42 = _SDL_HasSSE42Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has AVX features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasAVX() {
    return _SDL_HasAVX();
  }

  late final _SDL_HasAVXPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX');
  late final _SDL_HasAVX = _SDL_HasAVXPtr.asFunction<int Function()>();

  /// Determine whether the CPU has AVX2 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasAVX2() {
    return _SDL_HasAVX2();
  }

  late final _SDL_HasAVX2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX2');
  late final _SDL_HasAVX2 = _SDL_HasAVX2Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has AVX-512F (foundation) features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_HasAVX
  int SDL_HasAVX512F() {
    return _SDL_HasAVX512F();
  }

  late final _SDL_HasAVX512FPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX512F');
  late final _SDL_HasAVX512F = _SDL_HasAVX512FPtr.asFunction<int Function()>();

  /// Determine whether the CPU has ARM SIMD (ARMv6) features.
  ///
  /// This is different from ARM NEON, which is a different instruction set.
  ///
  /// This always returns false on CPUs that aren't using ARM instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_HasNEON
  int SDL_HasARMSIMD() {
    return _SDL_HasARMSIMD();
  }

  late final _SDL_HasARMSIMDPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasARMSIMD');
  late final _SDL_HasARMSIMD = _SDL_HasARMSIMDPtr.asFunction<int Function()>();

  /// Determine whether the CPU has NEON (ARM SIMD) features.
  ///
  /// This always returns false on CPUs that aren't using ARM instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_HasNEON() {
    return _SDL_HasNEON();
  }

  late final _SDL_HasNEONPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasNEON');
  late final _SDL_HasNEON = _SDL_HasNEONPtr.asFunction<int Function()>();

  /// Get the amount of RAM configured in the system.
  ///
  /// \returns the amount of RAM configured in the system in MB.
  ///
  /// \since This function is available since SDL 2.0.1.
  int SDL_GetSystemRAM() {
    return _SDL_GetSystemRAM();
  }

  late final _SDL_GetSystemRAMPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetSystemRAM');
  late final _SDL_GetSystemRAM =
      _SDL_GetSystemRAMPtr.asFunction<int Function()>();

  /// Report the alignment this system needs for SIMD allocations.
  ///
  /// This will return the minimum number of bytes to which a pointer must be
  /// aligned to be compatible with SIMD instructions on the current machine. For
  /// example, if the machine supports SSE only, it will return 16, but if it
  /// supports AVX-512F, it'll return 64 (etc). This only reports values for
  /// instruction sets SDL knows about, so if your SDL build doesn't have
  /// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
  /// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
  /// Plan accordingly.
  ///
  /// \returns the alignment in bytes needed for available, known SIMD
  /// instructions.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_SIMDGetAlignment() {
    return _SDL_SIMDGetAlignment();
  }

  late final _SDL_SIMDGetAlignmentPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('SDL_SIMDGetAlignment');
  late final _SDL_SIMDGetAlignment =
      _SDL_SIMDGetAlignmentPtr.asFunction<int Function()>();

  /// Allocate memory in a SIMD-friendly way.
  ///
  /// This will allocate a block of memory that is suitable for use with SIMD
  /// instructions. Specifically, it will be properly aligned and padded for the
  /// system's supported vector instructions.
  ///
  /// The memory returned will be padded such that it is safe to read or write an
  /// incomplete vector at the end of the memory block. This can be useful so you
  /// don't have to drop back to a scalar fallback at the end of your SIMD
  /// processing loop to deal with the final elements without overflowing the
  /// allocated buffer.
  ///
  /// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or
  /// delete[], etc.
  ///
  /// Note that SDL will only deal with SIMD instruction sets it is aware of; for
  /// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and
  /// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants
  /// 64. To be clear: if you can't decide to use an instruction set with an
  /// SDL_Has*() function, don't use that instruction set with memory allocated
  /// through here.
  ///
  /// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't
  /// out of memory, but you are not allowed to dereference it (because you only
  /// own zero bytes of that buffer).
  ///
  /// \param len The length, in bytes, of the block to allocate. The actual
  /// allocated block might be larger due to padding, etc.
  /// \returns a pointer to the newly-allocated block, NULL if out of memory.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDRealloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDAlloc(
    int len,
  ) {
    return _SDL_SIMDAlloc(
      len,
    );
  }

  late final _SDL_SIMDAllocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_SIMDAlloc');
  late final _SDL_SIMDAlloc =
      _SDL_SIMDAllocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Reallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
  /// SDL_malloc, memalign, new[], etc.
  ///
  /// \param mem The pointer obtained from SDL_SIMDAlloc. This function also
  /// accepts NULL, at which point this function is the same as
  /// calling SDL_SIMDAlloc with a NULL pointer.
  /// \param len The length, in bytes, of the block to allocated. The actual
  /// allocated block might be larger due to padding, etc. Passing 0
  /// will return a non-NULL pointer, assuming the system isn't out of
  /// memory.
  /// \returns a pointer to the newly-reallocated block, NULL if out of memory.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDRealloc(
    ffi.Pointer<ffi.Void> mem,
    int len,
  ) {
    return _SDL_SIMDRealloc(
      mem,
      len,
    );
  }

  late final _SDL_SIMDReallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_SIMDRealloc');
  late final _SDL_SIMDRealloc = _SDL_SIMDReallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Deallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from
  /// malloc, realloc, SDL_malloc, memalign, new[], etc.
  ///
  /// However, SDL_SIMDFree(NULL) is a legal no-op.
  ///
  /// The memory pointed to by `ptr` is no longer valid for access upon return,
  /// and may be returned to the system or reused by a future allocation. The
  /// pointer passed to this function is no longer safe to dereference once this
  /// function returns, and should be discarded.
  ///
  /// \param ptr The pointer, returned from SDL_SIMDAlloc or SDL_SIMDRealloc, to
  /// deallocate. NULL is a legal no-op.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDRealloc
  void SDL_SIMDFree(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _SDL_SIMDFree(
      ptr,
    );
  }

  late final _SDL_SIMDFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_SIMDFree');
  late final _SDL_SIMDFree =
      _SDL_SIMDFreePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the human readable name of a pixel format.
  ///
  /// \param format the pixel format to query
  /// \returns the human readable name of the specified pixel format or
  /// `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPixelFormatName(
    int format,
  ) {
    return _SDL_GetPixelFormatName(
      format,
    );
  }

  late final _SDL_GetPixelFormatNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Uint32)>>(
          'SDL_GetPixelFormatName');
  late final _SDL_GetPixelFormatName = _SDL_GetPixelFormatNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
  ///
  /// \param format one of the SDL_PixelFormatEnum values
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask a pointer filled in with the red mask for the format
  /// \param Gmask a pointer filled in with the green mask for the format
  /// \param Bmask a pointer filled in with the blue mask for the format
  /// \param Amask a pointer filled in with the alpha mask for the format
  /// \returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't
  /// possible; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MasksToPixelFormatEnum
  int SDL_PixelFormatEnumToMasks(
    int format,
    ffi.Pointer<ffi.Int> bpp,
    ffi.Pointer<Uint32> Rmask,
    ffi.Pointer<Uint32> Gmask,
    ffi.Pointer<Uint32> Bmask,
    ffi.Pointer<Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>)>>('SDL_PixelFormatEnumToMasks');
  late final _SDL_PixelFormatEnumToMasks =
      _SDL_PixelFormatEnumToMasksPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>, ffi.Pointer<Uint32>, ffi.Pointer<Uint32>)>();

  /// Convert a bpp value and RGBA masks to an enumerated pixel format.
  ///
  /// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
  /// possible.
  ///
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask the red mask for the format
  /// \param Gmask the green mask for the format
  /// \param Bmask the blue mask for the format
  /// \param Amask the alpha mask for the format
  /// \returns one of the SDL_PixelFormatEnum values
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PixelFormatEnumToMasks
  int SDL_MasksToPixelFormatEnum(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnumPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Int, Uint32, Uint32, Uint32,
              Uint32)>>('SDL_MasksToPixelFormatEnum');
  late final _SDL_MasksToPixelFormatEnum = _SDL_MasksToPixelFormatEnumPtr
      .asFunction<int Function(int, int, int, int, int)>();

  /// Create an SDL_PixelFormat structure corresponding to a pixel format.
  ///
  /// Returned structure may come from a shared global cache (i.e. not newly
  /// allocated), and hence should not be modified, especially the palette. Weird
  /// errors such as `Blit combination not supported` may occur.
  ///
  /// \param pixel_format one of the SDL_PixelFormatEnum values
  /// \returns the new SDL_PixelFormat structure or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeFormat
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat(
    int pixel_format,
  ) {
    return _SDL_AllocFormat(
      pixel_format,
    );
  }

  late final _SDL_AllocFormatPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_PixelFormat> Function(Uint32)>>(
      'SDL_AllocFormat');
  late final _SDL_AllocFormat = _SDL_AllocFormatPtr.asFunction<
      ffi.Pointer<SDL_PixelFormat> Function(int)>();

  /// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().
  ///
  /// \param format the SDL_PixelFormat structure to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  void SDL_FreeFormat(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat(
      format,
    );
  }

  late final _SDL_FreeFormatPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_PixelFormat>)>>(
      'SDL_FreeFormat');
  late final _SDL_FreeFormat = _SDL_FreeFormatPtr.asFunction<
      void Function(ffi.Pointer<SDL_PixelFormat>)>();

  /// Create a palette structure with the specified number of color entries.
  ///
  /// The palette entries are initialized to white.
  ///
  /// \param ncolors represents the number of color entries in the color palette
  /// \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
  /// there wasn't enough memory); call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreePalette
  ffi.Pointer<SDL_Palette> SDL_AllocPalette(
    int ncolors,
  ) {
    return _SDL_AllocPalette(
      ncolors,
    );
  }

  late final _SDL_AllocPalettePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Palette> Function(ffi.Int)>>(
          'SDL_AllocPalette');
  late final _SDL_AllocPalette =
      _SDL_AllocPalettePtr.asFunction<ffi.Pointer<SDL_Palette> Function(int)>();

  /// Set the palette for a pixel format structure.
  ///
  /// \param format the SDL_PixelFormat structure that will use the palette
  /// \param palette the SDL_Palette structure that will be used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_FreePalette
  int SDL_SetPixelFormatPalette(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalettePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetPixelFormatPalette');
  late final _SDL_SetPixelFormatPalette =
      _SDL_SetPixelFormatPalettePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<SDL_Palette>)>();

  /// Set a range of colors in a palette.
  ///
  /// \param palette the SDL_Palette structure to modify
  /// \param colors an array of SDL_Color structures to copy into the palette
  /// \param firstcolor the index of the first palette entry to modify
  /// \param ncolors the number of entries to modify
  /// \returns 0 on success or a negative error code if not all of the colors
  /// could be set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_CreateRGBSurface
  int SDL_SetPaletteColors(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>,
              ffi.Int, ffi.Int)>>('SDL_SetPaletteColors');
  late final _SDL_SetPaletteColors = _SDL_SetPaletteColorsPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>, int, int)>();

  /// Free a palette created with SDL_AllocPalette().
  ///
  /// \param palette the SDL_Palette structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  void SDL_FreePalette(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette(
      palette,
    );
  }

  late final _SDL_FreePalettePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Palette>)>>(
          'SDL_FreePalette');
  late final _SDL_FreePalette =
      _SDL_FreePalettePtr.asFunction<void Function(ffi.Pointer<SDL_Palette>)>();

  /// Map an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// This function maps the RGB color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGB color value for
  /// the given pixel format.
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the specified pixel format has an alpha component it will be returned as
  /// all 1 bits (fully opaque).
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the pixel format
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGBA
  int SDL_MapRGB(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGBPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8,
              Uint8)>>('SDL_MapRGB');
  late final _SDL_MapRGB = _SDL_MapRGBPtr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int)>();

  /// Map an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// This function maps the RGBA color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGBA color value for
  /// the given pixel format.
  ///
  /// If the specified pixel format has no alpha component the alpha value will
  /// be ignored (as it will be in formats with a palette).
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \param a the alpha component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  int SDL_MapRGBA(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBAPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_MapRGBA');
  late final _SDL_MapRGBA = _SDL_MapRGBAPtr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int, int)>();

  /// Get RGB values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGB(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetRGB(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGB');
  late final _SDL_GetRGB = _SDL_GetRGBPtr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Get RGBA values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// If the surface has no alpha component, the alpha will be returned as 0xff
  /// (100% opaque).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  /// \param a a pointer filled in with the alpha component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGBA(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRGBA(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGBA');
  late final _SDL_GetRGBA = _SDL_GetRGBAPtr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Calculate a 256 entry gamma ramp for a gamma value.
  ///
  /// \param gamma a gamma value where 0.0 is black and 1.0 is identity
  /// \param ramp an array of 256 values filled in with the gamma ramp
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  void SDL_CalculateGammaRamp(
    double gamma,
    ffi.Pointer<Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Float, ffi.Pointer<Uint16>)>>('SDL_CalculateGammaRamp');
  late final _SDL_CalculateGammaRamp = _SDL_CalculateGammaRampPtr.asFunction<
      void Function(double, ffi.Pointer<Uint16>)>();

  /// Determine whether two rectangles intersect.
  ///
  /// If either pointer is NULL the function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_IntersectRect
  int SDL_HasIntersection(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection(
      A,
      B,
    );
  }

  late final _SDL_HasIntersectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_HasIntersection');
  late final _SDL_HasIntersection = _SDL_HasIntersectionPtr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of two rectangles.
  ///
  /// If `result` is NULL then this function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the intersection of
  /// rectangles `A` and `B`
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasIntersection
  int SDL_IntersectRect(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_IntersectRect');
  late final _SDL_IntersectRect = _SDL_IntersectRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the union of two rectangles.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the union of rectangles
  /// `A` and `B`
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_UnionRect(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UnionRect');
  late final _SDL_UnionRect = _SDL_UnionRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate a minimal rectangle enclosing a set of points.
  ///
  /// If `clip` is not NULL then only points inside of the clipping rectangle are
  /// considered.
  ///
  /// \param points an array of SDL_Point structures representing points to be
  /// enclosed
  /// \param count the number of structures in the `points` array
  /// \param clip an SDL_Rect used for clipping or NULL to enclose all points
  /// \param result an SDL_Rect structure filled in with the minimal enclosing
  /// rectangle
  /// \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
  /// points were outside of the clipping rectangle.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_EnclosePoints(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Point>,
              ffi.Int,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_EnclosePoints');
  late final _SDL_EnclosePoints = _SDL_EnclosePointsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Point>, int, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of a rectangle and line segment.
  ///
  /// This function is used to clip a line segment to a rectangle. A line segment
  /// contained entirely within the rectangle or that does not intersect will
  /// remain unchanged. A line segment that crosses the rectangle at either or
  /// both ends will be clipped to the boundary of the rectangle and the new
  /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
  ///
  /// \param rect an SDL_Rect structure representing the rectangle to intersect
  /// \param X1 a pointer to the starting X-coordinate of the line
  /// \param Y1 a pointer to the starting Y-coordinate of the line
  /// \param X2 a pointer to the ending X-coordinate of the line
  /// \param Y2 a pointer to the ending Y-coordinate of the line
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_IntersectRectAndLine(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int> X1,
    ffi.Pointer<ffi.Int> Y1,
    ffi.Pointer<ffi.Int> X2,
    ffi.Pointer<ffi.Int> Y2,
  ) {
    return _SDL_IntersectRectAndLine(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_IntersectRectAndLine');
  late final _SDL_IntersectRectAndLine =
      _SDL_IntersectRectAndLinePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Compose a custom blend mode for renderers.
  ///
  /// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
  /// the SDL_BlendMode returned by this function if the renderer supports it.
  ///
  /// A blend mode controls how the pixels from a drawing operation (source) get
  /// combined with the pixels from the render target (destination). First, the
  /// components of the source and destination pixels get multiplied with their
  /// blend factors. Then, the blend operation takes the two products and
  /// calculates the result that will get stored in the render target.
  ///
  /// Expressed in pseudocode, it would look like this:
  ///
  /// ```c
  /// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
  /// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
  /// ```
  ///
  /// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
  /// dst)` can return one of the following:
  ///
  /// - `src + dst`
  /// - `src - dst`
  /// - `dst - src`
  /// - `min(src, dst)`
  /// - `max(src, dst)`
  ///
  /// The red, green, and blue components are always multiplied with the first,
  /// second, and third components of the SDL_BlendFactor, respectively. The
  /// fourth component is not used.
  ///
  /// The alpha component is always multiplied with the fourth component of the
  /// SDL_BlendFactor. The other components are not used in the alpha
  /// calculation.
  ///
  /// Support for these blend modes varies for each renderer. To check if a
  /// specific SDL_BlendMode is supported, create a renderer and pass it to
  /// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
  /// return with an error if the blend mode is not supported.
  ///
  /// This list describes the support of custom blend modes for each renderer in
  /// SDL 2.0.6. All renderers support the four blend modes listed in the
  /// SDL_BlendMode enumeration.
  ///
  /// - **direct3d**: Supports `SDL_BLENDOPERATION_ADD` with all factors.
  /// - **direct3d11**: Supports all operations with all factors. However, some
  /// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
  /// `SDL_BLENDOPERATION_MAXIMUM`.
  /// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL
  /// 2.0.6.
  /// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. Color and alpha factors need to be the same. OpenGL ES 1
  /// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`
  /// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha
  /// operations being different from each other. May support color and alpha
  /// factors being different from each other.
  /// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
  /// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
  /// operations with all factors.
  /// - **psp**: No custom blend mode support.
  /// - **software**: No custom blend mode support.
  ///
  /// Some renderers do not provide an alpha component for the default render
  /// target. The `SDL_BLENDFACTOR_DST_ALPHA` and
  /// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
  /// case.
  ///
  /// \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the source pixels
  /// \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the destination pixels
  /// \param colorOperation the SDL_BlendOperation used to combine the red,
  /// green, and blue components of the source and
  /// destination pixels
  /// \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the source pixels
  /// \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the destination pixels
  /// \param alphaOperation the SDL_BlendOperation used to combine the alpha
  /// component of the source and destination pixels
  /// \returns an SDL_BlendMode that represents the chosen factors and
  /// operations.
  ///
  /// \since This function is available since SDL 2.0.6.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_GetTextureBlendMode
  int SDL_ComposeCustomBlendMode(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_ComposeCustomBlendMode');
  late final _SDL_ComposeCustomBlendMode = _SDL_ComposeCustomBlendModePtr
      .asFunction<int Function(int, int, int, int, int, int)>();

  /// Allocate a new RGB surface.
  ///
  /// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If `depth` is greater than 8 bits, the pixel format is set using the
  /// [RGBA]mask parameters.
  ///
  /// The [RGBA]mask parameters are the bitmasks used to extract that color from
  /// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
  /// stored in the most significant byte. Using zeros for the RGB masks sets a
  /// default value, based on the depth. For example:
  ///
  /// ```c++
  /// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
  /// ```
  ///
  /// However, using zero for the Amask results in an Amask of 0.
  ///
  /// By default surfaces with an alpha mask are set up for blending as with:
  ///
  /// ```c++
  /// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
  /// ```
  ///
  /// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
  /// different `blendMode`.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32, Uint32, Uint32, Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface = _SDL_CreateRGBSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with a specific pixel format.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except instead
  /// of providing pixel color masks, you provide it with a predefined format
  /// from SDL_PixelFormatEnum.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat =
      _SDL_CreateRGBSurfaceWithFormatPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  /// Allocate a new RGB surface with existing pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except it does
  /// not allocate memory for the pixel data, instead the caller provides an
  /// existing buffer of data for the surface to use.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom =
      _SDL_CreateRGBSurfaceFromPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with with a specific pixel format and existing
  /// pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
  /// instead of providing pixel color masks, you provide it with a predefined
  /// format from SDL_PixelFormatEnum.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom =
      _SDL_CreateRGBSurfaceWithFormatFromPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// Free an RGB surface.
  ///
  /// It is safe to pass NULL to this function.
  ///
  /// \param surface the SDL_Surface to free.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_LoadBMP
  /// \sa SDL_LoadBMP_RW
  void SDL_FreeSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface(
      surface,
    );
  }

  late final _SDL_FreeSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface =
      _SDL_FreeSurfacePtr.asFunction<void Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the palette used by a surface.
  ///
  /// A single palette can be shared with many surfaces.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param palette the SDL_Palette structure to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetSurfacePalette(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalettePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette = _SDL_SetSurfacePalettePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// Set up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
  /// and read from `surface->pixels`, using the pixel format stored in
  /// `surface->format`. Once you are done accessing the surface, you should use
  /// SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
  /// 0, then you can read and write to the surface at any time, and the pixel
  /// format of the surface will not change.
  ///
  /// \param surface the SDL_Surface structure to be locked
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MUSTLOCK
  /// \sa SDL_UnlockSurface
  int SDL_LockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface(
      surface,
    );
  }

  late final _SDL_LockSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface =
      _SDL_LockSurfacePtr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Release a surface after directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockSurface
  void SDL_UnlockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface(
      surface,
    );
  }

  late final _SDL_UnlockSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface = _SDL_UnlockSurfacePtr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a BMP image from a seekable SDL data stream.
  ///
  /// The new surface should be freed with SDL_FreeSurface(). Not doing so will
  /// result in a memory leak.
  ///
  /// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
  /// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
  /// from a file, convert it to an SDL_Surface and then close the file.
  ///
  /// \param src the data stream for the surface
  /// \param freesrc non-zero to close the stream after being read
  /// \returns a pointer to a new SDL_Surface structure or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeSurface
  /// \sa SDL_RWFromFile
  /// \sa SDL_LoadBMP
  /// \sa SDL_SaveBMP_RW
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW = _SDL_LoadBMP_RWPtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream in BMP format.
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// \param surface the SDL_Surface structure containing the image to be saved
  /// \param dst a data stream to save to
  /// \param freedst non-zero to close the stream after being written
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadBMP_RW
  /// \sa SDL_SaveBMP
  int SDL_SaveBMP_RW(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW = _SDL_SaveBMP_RWPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// Set the RLE acceleration hint for a surface.
  ///
  /// If RLE is enabled, color key and alpha blending blits are much faster, but
  /// the surface must be locked before directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to optimize
  /// \param flag 0 to disable, non-zero to enable RLE acceleration
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_LockSurface
  /// \sa SDL_UnlockSurface
  int SDL_SetSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLEPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int)>>('SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE = _SDL_SetSurfaceRLEPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Returns whether the surface is RLE enabled
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SetSurfaceRLE
  int SDL_HasSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLEPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE = _SDL_HasSurfaceRLEPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the color key (transparent pixel) in a surface.
  ///
  /// The color key defines a pixel value that will be treated as transparent in
  /// a blit. For example, one can use this to specify that cyan pixels should be
  /// considered transparent, and therefore not rendered.
  ///
  /// It is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// RLE acceleration can substantially speed up blitting of images with large
  /// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
  /// \param key the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetColorKey
  int SDL_SetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey = _SDL_SetColorKeyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Returns whether the surface has a color key
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_SetColorKey
  /// \sa SDL_GetColorKey
  int SDL_HasColorKey(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey(
      surface,
    );
  }

  late final _SDL_HasColorKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasColorKey');
  late final _SDL_HasColorKey =
      _SDL_HasColorKeyPtr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the color key (transparent pixel) for a surface.
  ///
  /// The color key is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// If the surface doesn't have color key enabled this function returns -1.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param key a pointer filled in with the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetColorKey
  int SDL_GetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey = _SDL_GetColorKeyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// Set an additional color value multiplied into blit operations.
  ///
  /// When this surface is blitted, during the blit operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param r the red color value multiplied into blit operations
  /// \param g the green color value multiplied into blit operations
  /// \param b the blue color value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_SetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod = _SDL_SetSurfaceColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// Get the additional color value multiplied into blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_GetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod = _SDL_GetSurfaceColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value used in blit operations.
  ///
  /// When this surface is blitted, during the blit operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param alpha the alpha value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_SetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, Uint8)>>('SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod = _SDL_SetSurfaceAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the additional alpha value used in blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_GetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod = _SDL_GetSurfaceAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for blit operations.
  ///
  /// To copy a surface to another surface (or texture) without blending with the
  /// existing data, the blendmode of the SOURCE surface should be set to
  /// `SDL_BLENDMODE_NONE`.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param blendMode the SDL_BlendMode to use for blit blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceBlendMode
  int SDL_SetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode = _SDL_SetSurfaceBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the blend mode used for blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetSurfaceBlendMode
  int SDL_GetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode = _SDL_GetSurfaceBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.Int32>)>();

  /// Set the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// Note that blits are automatically clipped to the edges of the source and
  /// destination surfaces.
  ///
  /// \param surface the SDL_Surface structure to be clipped
  /// \param rect the SDL_Rect structure representing the clipping rectangle, or
  /// NULL to disable clipping
  /// \returns SDL_TRUE if the rectangle intersects the surface, otherwise
  /// SDL_FALSE and blits will be completely clipped.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetClipRect
  int SDL_SetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect = _SDL_SetClipRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// \param surface the SDL_Surface structure representing the surface to be
  /// clipped
  /// \param rect an SDL_Rect structure filled in with the clipping rectangle for
  /// the surface
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetClipRect
  void SDL_GetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect = _SDL_GetClipRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface(
      surface,
    );
  }

  late final _SDL_DuplicateSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface = _SDL_DuplicateSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Copy an existing surface to a new surface of the specified format.
  ///
  /// This function is used to optimize images for faster *repeat* blitting. This
  /// is accomplished by converting the original and storing the result as a new
  /// surface. The new, optimized surface can then be used as the source for
  /// future blits, making them faster.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param fmt the SDL_PixelFormat structure that the new surface is optimized
  /// for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurfaceFormat
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface = _SDL_ConvertSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  /// Copy an existing surface to a new surface of the specified format enum.
  ///
  /// This function operates just like SDL_ConvertSurface(), but accepts an
  /// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
  /// it might be easier to call but it doesn't have access to palette
  /// information for the destination surface, in case that would be important.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param pixel_format the SDL_PixelFormatEnum that the new surface is
  /// optimized for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurface
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat =
      _SDL_ConvertSurfaceFormatPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// Copy a block of pixels of one format to another format.
  ///
  /// \param width the width of the block to copy, in pixels
  /// \param height the height of the block to copy, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with new pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_ConvertPixels(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels = _SDL_ConvertPixelsPtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Premultiply the alpha on a block of pixels.
  ///
  /// This is safe to use with src == dst, but not for other overlapping areas.
  ///
  /// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
  ///
  /// \param width the width of the block to convert, in pixels
  /// \param height the height of the block to convert, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with premultiplied pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_PremultiplyAlpha(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_PremultiplyAlpha(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_PremultiplyAlphaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_PremultiplyAlpha');
  late final _SDL_PremultiplyAlpha = _SDL_PremultiplyAlphaPtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Perform a fast fill of a rectangle with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL to fill the entire surface
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRects
  int SDL_FillRect(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect = _SDL_FillRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  /// Perform a fast fill of a set of rectangles with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rects an array of SDL_Rects representing the rectangles to fill.
  /// \param count the number of rectangles in the array
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRect
  int SDL_FillRects(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects = _SDL_FillRectsPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// Perform a fast blit from the source surface to the destination surface.
  ///
  /// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
  /// macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_UpperBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit = _SDL_UpperBlitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface blitting only.
  ///
  /// This is a semi-private blit function and it performs low-level surface
  /// blitting, assuming the input rectangles have already been clipped.
  ///
  /// Unless you know what you're doing, you should be using SDL_BlitSurface()
  /// instead.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied, or NULL to copy the entire surface
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_LowerBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit = _SDL_LowerBlitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a fast, low quality, stretch blit between two surfaces of the same
  /// format.
  ///
  /// Please use SDL_BlitScaled() instead.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SoftStretch(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch = _SDL_SoftStretchPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform bilinear scaling between two surfaces of the same format, 32BPP.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_SoftStretchLinear(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretchLinear(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchLinearPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretchLinear');
  late final _SDL_SoftStretchLinear = _SDL_SoftStretchLinearPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a scaled surface copy to a destination surface.
  ///
  /// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
  /// merely a macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_UpperBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled = _SDL_UpperBlitScaledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface scaled blitting only.
  ///
  /// This is a semi-private function and it performs low-level surface blitting,
  /// assuming the input rectangles have already been clipped.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_LowerBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled = _SDL_LowerBlitScaledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Set the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  void SDL_SetYUVConversionMode(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode(
      mode,
    );
  }

  late final _SDL_SetYUVConversionModePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode =
      _SDL_SetYUVConversionModePtr.asFunction<void Function(int)>();

  /// Get the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionMode() {
    return _SDL_GetYUVConversionMode();
  }

  late final _SDL_GetYUVConversionModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode =
      _SDL_GetYUVConversionModePtr.asFunction<int Function()>();

  /// Get the YUV conversion mode, returning the correct mode for the resolution
  /// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionModeForResolution(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolutionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int, ffi.Int)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution =
      _SDL_GetYUVConversionModeForResolutionPtr.asFunction<
          int Function(int, int)>();

  /// Get the number of video drivers compiled into SDL.
  ///
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVideoDriver
  int SDL_GetNumVideoDrivers() {
    return _SDL_GetNumVideoDrivers();
  }

  late final _SDL_GetNumVideoDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers =
      _SDL_GetNumVideoDriversPtr.asFunction<int Function()>();

  /// Get the name of a built in video driver.
  ///
  /// The video drivers are presented in the order in which they are normally
  /// checked during initialization.
  ///
  /// \param index the index of a video driver
  /// \returns the name of the video driver with the given **index**.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  ffi.Pointer<ffi.Char> SDL_GetVideoDriver(
    int index,
  ) {
    return _SDL_GetVideoDriver(
      index,
    );
  }

  late final _SDL_GetVideoDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver =
      _SDL_GetVideoDriverPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// This function initializes the video subsystem, setting up a connection to
  /// the window manager, etc, and determines the available display modes and
  /// pixel formats, but does not initialize a window or graphics mode.
  ///
  /// If you use this function and you haven't used the SDL_INIT_VIDEO flag with
  /// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
  /// before calling SDL_Quit().
  ///
  /// It is safe to call this function multiple times. SDL_VideoInit() will call
  /// SDL_VideoQuit() itself if the video subsystem has already been initialized.
  ///
  /// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
  /// specific `driver_name`.
  ///
  /// \param driver_name the name of a video driver to initialize, or NULL for
  /// the default driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  /// \sa SDL_InitSubSystem
  /// \sa SDL_VideoQuit
  int SDL_VideoInit(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_VideoInit(
      driver_name,
    );
  }

  late final _SDL_VideoInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit =
      _SDL_VideoInitPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Shut down the video subsystem, if initialized with SDL_VideoInit().
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_VideoInit
  void SDL_VideoQuit() {
    return _SDL_VideoQuit();
  }

  late final _SDL_VideoQuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit = _SDL_VideoQuitPtr.asFunction<void Function()>();

  /// Get the name of the currently initialized video driver.
  ///
  /// \returns the name of the current video driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  ffi.Pointer<ffi.Char> SDL_GetCurrentVideoDriver() {
    return _SDL_GetCurrentVideoDriver();
  }

  late final _SDL_GetCurrentVideoDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver = _SDL_GetCurrentVideoDriverPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the number of available video displays.
  ///
  /// \returns a number >= 1 or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  int SDL_GetNumVideoDisplays() {
    return _SDL_GetNumVideoDisplays();
  }

  late final _SDL_GetNumVideoDisplaysPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays =
      _SDL_GetNumVideoDisplaysPtr.asFunction<int Function()>();

  /// Get the name of a display in UTF-8 encoding.
  ///
  /// \param displayIndex the index of display from which the name should be
  /// queried
  /// \returns the name of a display or NULL for an invalid display index or
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  ffi.Pointer<ffi.Char> SDL_GetDisplayName(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName =
      _SDL_GetDisplayNamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// \param displayIndex the index of the display to query
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBoundsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds = _SDL_GetDisplayBoundsPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the usable desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Apple's macOS, this
  /// subtracts the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// The parameter `rect` is ignored if it is NULL.
  ///
  /// This function also returns -1 if the parameter `displayIndex` is out of
  /// range.
  ///
  /// \param displayIndex the index of the display to query the usable bounds
  /// from
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayUsableBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBoundsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds = _SDL_GetDisplayUsableBoundsPtr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the dots/pixels-per-inch for a display.
  ///
  /// Diagonal, horizontal and vertical DPI can all be optionally returned if the
  /// appropriate parameter is non-NULL.
  ///
  /// A failure of this function usually means that either no DPI information is
  /// available or the `displayIndex` is out of range.
  ///
  /// \param displayIndex the index of the display from which DPI information
  /// should be queried
  /// \param ddpi a pointer filled in with the diagonal DPI of the display; may
  /// be NULL
  /// \param hdpi a pointer filled in with the horizontal DPI of the display; may
  /// be NULL
  /// \param vdpi a pointer filled in with the vertical DPI of the display; may
  /// be NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayDPI(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPIPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI = _SDL_GetDisplayDPIPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get the orientation of a display.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns The SDL_DisplayOrientation enum value of the display, or
  /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayOrientation(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientationPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation =
      _SDL_GetDisplayOrientationPtr.asFunction<int Function(int)>();

  /// Get the number of available display modes.
  ///
  /// The `displayIndex` needs to be in the range from 0 to
  /// SDL_GetNumVideoDisplays() - 1.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetNumDisplayModes(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes =
      _SDL_GetNumDisplayModesPtr.asFunction<int Function(int)>();

  /// Get information about a specific display mode.
  ///
  /// The display modes are sorted in this priority:
  ///
  /// - width -> largest to smallest
  /// - height -> largest to smallest
  /// - bits per pixel -> more colors to fewer colors
  /// - packed pixel layout -> largest to smallest
  /// - refresh rate -> highest to lowest
  ///
  /// \param displayIndex the index of the display to query
  /// \param modeIndex the index of the display mode to query
  /// \param mode an SDL_DisplayMode structure filled in with the mode at
  /// `modeIndex`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumDisplayModes
  int SDL_GetDisplayMode(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode = _SDL_GetDisplayModePtr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the desktop's display mode.
  ///
  /// There's a difference between this function and SDL_GetCurrentDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the previous native display mode, and not the current
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetCurrentDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetDesktopDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode = _SDL_GetDesktopDisplayModePtr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the current display mode.
  ///
  /// There's a difference between this function and SDL_GetDesktopDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the current display mode, and not the previous native
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDesktopDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetCurrentDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode = _SDL_GetCurrentDisplayModePtr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the closest match to the requested display mode.
  ///
  /// The available display modes are scanned and `closest` is filled in with the
  /// closest mode matching the requested mode and returned. The mode format and
  /// refresh rate default to the desktop mode if they are set to 0. The modes
  /// are scanned with size being first priority, format being second priority,
  /// and finally checking the refresh rate. If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure containing the desired display
  /// mode
  /// \param closest an SDL_DisplayMode structure filled in with the closest
  /// match of the available display modes
  /// \returns the passed in value `closest` or NULL if no matching video mode
  /// was available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumDisplayModes
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode =
      _SDL_GetClosestDisplayModePtr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the index of the display associated with a window.
  ///
  /// \param window the window to query
  /// \returns the index of the display containing the center of the window on
  /// success or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetWindowDisplayIndex(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex = _SDL_GetWindowDisplayIndexPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the display mode to use when a window is visible at fullscreen.
  ///
  /// This only affects the display mode used when the window is fullscreen. To
  /// change the window size when the window is not fullscreen, use
  /// SDL_SetWindowSize().
  ///
  /// \param window the window to affect
  /// \param mode the SDL_DisplayMode structure representing the mode to use, or
  /// NULL to use the window's dimensions and the desktop's format
  /// and refresh rate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_SetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode =
      _SDL_SetWindowDisplayModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Query the display mode to use when a window is visible at fullscreen.
  ///
  /// \param window the window to query
  /// \param mode an SDL_DisplayMode structure filled in with the fullscreen
  /// display mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_GetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode =
      _SDL_GetWindowDisplayModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the raw ICC profile data for the screen the window is currently on.
  ///
  /// Data returned should be freed with SDL_free.
  ///
  /// \param window the window to query
  /// \param size the size of the ICC profile
  /// \returns the raw ICC profile data on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<ffi.Void> SDL_GetWindowICCProfile(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _SDL_GetWindowICCProfile(
      window,
      size,
    );
  }

  late final _SDL_GetWindowICCProfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Size>)>>('SDL_GetWindowICCProfile');
  late final _SDL_GetWindowICCProfile = _SDL_GetWindowICCProfilePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Size>)>();

  /// Get the pixel format associated with the window.
  ///
  /// \param window the window to query
  /// \returns the pixel format of the window on success or
  /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetWindowPixelFormat(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormatPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat = _SDL_GetWindowPixelFormatPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Create a window with the specified position, dimensions, and flags.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window
  /// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
  /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
  /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
  /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
  /// - `SDL_WINDOW_HIDDEN`: window is not visible
  /// - `SDL_WINDOW_BORDERLESS`: no window decoration
  /// - `SDL_WINDOW_RESIZABLE`: window can be resized
  /// - `SDL_WINDOW_MINIMIZED`: window is minimized
  /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
  /// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
  /// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
  /// supported (>= SDL 2.0.1)
  ///
  /// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
  /// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
  /// queried later using SDL_GetWindowFlags().
  ///
  /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
  /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
  ///
  /// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
  /// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to query the drawable size in pixels.
  ///
  /// If the window is set fullscreen, the width and height parameters `w` and
  /// `h` will not be used. However, invalid size parameters (e.g. too large) may
  /// still fail. Window size is actually limited to 16384 x 16384 for all
  /// platforms at window creation.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// On non-Apple devices, SDL requires you to either not link to the Vulkan
  /// loader or link to a dynamic library version. This limitation may be removed
  /// in a future version of SDL.
  ///
  /// \param title the title of the window, in UTF-8 encoding
  /// \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param w the width of the window, in screen coordinates
  /// \param h the height of the window, in screen coordinates
  /// \param flags 0, or one or more SDL_WindowFlags OR'd together
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindowFrom
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindow(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow = _SDL_CreateWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Create an SDL window from an existing native window.
  ///
  /// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
  /// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
  /// before using SDL_CreateWindowFrom().
  ///
  /// \param data a pointer to driver-dependent window creation data, typically
  /// your native window cast to a void*
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom(
      data,
    );
  }

  late final _SDL_CreateWindowFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom = _SDL_CreateWindowFromPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// Get the numeric ID of a window.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param window the window to query
  /// \returns the ID of the window on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFromID
  int SDL_GetWindowID(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID(
      window,
    );
  }

  late final _SDL_GetWindowIDPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID =
      _SDL_GetWindowIDPtr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window from a stored ID.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param id the ID of the window
  /// \returns the window associated with `id` or NULL if it doesn't exist; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowID
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID(
    int id,
  ) {
    return _SDL_GetWindowFromID(
      id,
    );
  }

  late final _SDL_GetWindowFromIDPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID = _SDL_GetWindowFromIDPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// Get the window flags.
  ///
  /// \param window the window to query
  /// \returns a mask of the SDL_WindowFlags associated with `window`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_HideWindow
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_SetWindowFullscreen
  /// \sa SDL_SetWindowGrab
  /// \sa SDL_ShowWindow
  int SDL_GetWindowFlags(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags(
      window,
    );
  }

  late final _SDL_GetWindowFlagsPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags = _SDL_GetWindowFlagsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the title of a window.
  ///
  /// This string is expected to be in UTF-8 encoding.
  ///
  /// \param window the window to change
  /// \param title the desired window title in UTF-8 format
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowTitle
  void SDL_SetWindowTitle(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _SDL_SetWindowTitle(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle = _SDL_SetWindowTitlePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Get the title of a window.
  ///
  /// \param window the window to query
  /// \returns the title of the window in UTF-8 format or "" if there is no
  /// title.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowTitle
  ffi.Pointer<ffi.Char> SDL_GetWindowTitle(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle(
      window,
    );
  }

  late final _SDL_GetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle = _SDL_GetWindowTitlePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the icon for a window.
  ///
  /// \param window the window to change
  /// \param icon an SDL_Surface structure containing the icon for the window
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_SetWindowIcon(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon = _SDL_SetWindowIconPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// Associate an arbitrary named pointer with a window.
  ///
  /// `name` is case-sensitive.
  ///
  /// \param window the window to associate with the pointer
  /// \param name the name of the pointer
  /// \param userdata the associated pointer
  /// \returns the previous value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowData
  ffi.Pointer<ffi.Void> SDL_SetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData = _SDL_SetWindowDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Retrieve the data pointer associated with a window.
  ///
  /// \param window the window to query
  /// \param name the name of the pointer
  /// \returns the value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowData
  ffi.Pointer<ffi.Void> SDL_GetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetWindowData(
      window,
      name,
    );
  }

  late final _SDL_GetWindowDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData = _SDL_GetWindowDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Set the position of a window.
  ///
  /// The window coordinate origin is the upper left of the display.
  ///
  /// \param window the window to reposition
  /// \param x the x coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowPosition
  void SDL_SetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition = _SDL_SetWindowPositionPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the position of a window.
  ///
  /// If you do not need the value for one of the positions a NULL may be passed
  /// in the `x` or `y` parameter.
  ///
  /// \param window the window to query
  /// \param x a pointer filled in with the x position of the window, in screen
  /// coordinates, may be NULL
  /// \param y a pointer filled in with the y position of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowPosition
  void SDL_GetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition = _SDL_GetWindowPositionPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the size of a window's client area.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// Fullscreen windows automatically match the size of the display mode, and
  /// you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// \param window the window to change
  /// \param w the width of the window in pixels, in screen coordinates, must be
  /// > 0
  /// \param h the height of the window in pixels, in screen coordinates, must be
  /// > 0
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_SetWindowDisplayMode
  void SDL_SetWindowSize(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int, ffi.Int)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize = _SDL_SetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the size of a window's client area.
  ///
  /// NULL can safely be passed as the `w` or `h` parameter if the width or
  /// height value is not desired.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
  /// real client area size in pixels.
  ///
  /// \param window the window to query the width and height from
  /// \param w a pointer filled in with the width of the window, in screen
  /// coordinates, may be NULL
  /// \param h a pointer filled in with the height of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetDrawableSize
  /// \sa SDL_Vulkan_GetDrawableSize
  /// \sa SDL_SetWindowSize
  void SDL_GetWindowSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize = _SDL_GetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window's borders (decorations) around the client area.
  ///
  /// Note: If this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
  /// window in question was borderless.
  ///
  /// Note: This function may fail on systems where the window has not yet been
  /// decorated by the display server (for example, immediately after calling
  /// SDL_CreateWindow). It is recommended that you wait at least until the
  /// window has been presented and composited, so that the window system has a
  /// chance to decorate the window and provide the border dimensions to SDL.
  ///
  /// This function also returns -1 if getting the information is not supported.
  ///
  /// \param window the window to query the size values of the border
  /// (decorations) from
  /// \param top pointer to variable for storing the size of the top border; NULL
  /// is permitted
  /// \param left pointer to variable for storing the size of the left border;
  /// NULL is permitted
  /// \param bottom pointer to variable for storing the size of the bottom
  /// border; NULL is permitted
  /// \param right pointer to variable for storing the size of the right border;
  /// NULL is permitted
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowSize
  int SDL_GetWindowBordersSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> bottom,
    ffi.Pointer<ffi.Int> right,
  ) {
    return _SDL_GetWindowBordersSize(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize =
      _SDL_GetWindowBordersSizePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the minimum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param min_w the minimum width of the window in pixels
  /// \param min_h the minimum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_SetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize = _SDL_SetWindowMinimumSizePtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the minimum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the minimum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the minimum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_GetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMinimumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize =
      _SDL_GetWindowMinimumSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the maximum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param max_w the maximum width of the window in pixels
  /// \param max_h the maximum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_SetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize = _SDL_SetWindowMaximumSizePtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the maximum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the maximum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the maximum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_GetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMaximumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize =
      _SDL_GetWindowMaximumSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the border state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
  /// or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// You can't change the border state of a fullscreen window.
  ///
  /// \param window the window of which to change the border state
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowBordered(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBorderedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered = _SDL_SetWindowBorderedPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
  /// allow/disallow user resizing of the window. This is a no-op if the window's
  /// resizable state already matches the requested state.
  ///
  /// You can't change the resizable state of a fullscreen window.
  ///
  /// \param window the window of which to change the resizable state
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowResizable(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable = _SDL_SetWindowResizablePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the window to always be above the others.
  ///
  /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
  /// will bring the window to the front and keep the window above the rest.
  ///
  /// \param window The window of which to change the always on top state
  /// \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
  /// disable
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowAlwaysOnTop(
    ffi.Pointer<SDL_Window> window,
    int on_top,
  ) {
    return _SDL_SetWindowAlwaysOnTop(
      window,
      on_top,
    );
  }

  late final _SDL_SetWindowAlwaysOnTopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowAlwaysOnTop');
  late final _SDL_SetWindowAlwaysOnTop = _SDL_SetWindowAlwaysOnTopPtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Show a window.
  ///
  /// \param window the window to show
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HideWindow
  /// \sa SDL_RaiseWindow
  void SDL_ShowWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow(
      window,
    );
  }

  late final _SDL_ShowWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow =
      _SDL_ShowWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Hide a window.
  ///
  /// \param window the window to hide
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowWindow
  void SDL_HideWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow(
      window,
    );
  }

  late final _SDL_HideWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow =
      _SDL_HideWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Raise a window above other windows and set the input focus.
  ///
  /// \param window the window to raise
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_RaiseWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow(
      window,
    );
  }

  late final _SDL_RaiseWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow =
      _SDL_RaiseWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Make a window as large as possible.
  ///
  /// \param window the window to maximize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MaximizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow(
      window,
    );
  }

  late final _SDL_MaximizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow = _SDL_MaximizeWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Minimize a window to an iconic representation.
  ///
  /// \param window the window to minimize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MinimizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow(
      window,
    );
  }

  late final _SDL_MinimizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow = _SDL_MinimizeWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Restore the size and position of a minimized or maximized window.
  ///
  /// \param window the window to restore
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  void SDL_RestoreWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow(
      window,
    );
  }

  late final _SDL_RestoreWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow = _SDL_RestoreWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's fullscreen state.
  ///
  /// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
  /// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
  /// that takes the size of the desktop; and 0 for windowed mode.
  ///
  /// \param window the window to change
  /// \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_SetWindowFullscreen(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, Uint32)>>('SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen = _SDL_SetWindowFullscreenPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get the SDL surface associated with the window.
  ///
  /// A new surface will be created with the optimal format for the window, if
  /// necessary. This surface will be freed when the window is destroyed. Do not
  /// free this surface.
  ///
  /// This surface will be invalidated if the window is resized. After resizing a
  /// window this function must be called again to return a valid surface.
  ///
  /// You may not combine this with 3D or the rendering API on this window.
  ///
  /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
  ///
  /// \param window the window to query
  /// \returns the surface associated with the window, or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UpdateWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface(
      window,
    );
  }

  late final _SDL_GetWindowSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface = _SDL_GetWindowSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// Copy the window surface to the screen.
  ///
  /// This is the function you use to reflect any changes to the surface on the
  /// screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_Flip().
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  int SDL_UpdateWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface(
      window,
    );
  }

  late final _SDL_UpdateWindowSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface = _SDL_UpdateWindowSurfacePtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Copy areas of the window surface to the screen.
  ///
  /// This is the function you use to reflect changes to portions of the surface
  /// on the screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
  ///
  /// \param window the window to update
  /// \param rects an array of SDL_Rect structures representing areas of the
  /// surface to copy
  /// \param numrects the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurface
  int SDL_UpdateWindowSurfaceRects(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects =
      _SDL_UpdateWindowSurfaceRectsPtr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// Set a window's input grab mode.
  ///
  /// When input is grabbed, the mouse is confined to the window. This function
  /// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
  /// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window the window for which the input grab mode should be set
  /// \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGrabbedWindow
  /// \sa SDL_GetWindowGrab
  void SDL_SetWindowGrab(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab = _SDL_SetWindowGrabPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's keyboard grab mode.
  ///
  /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
  /// the Meta/Super key. Note that not all system keyboard shortcuts can be
  /// captured by applications (one example is Ctrl+Alt+Del on Windows).
  ///
  /// This is primarily intended for specialized applications such as VNC clients
  /// or VM frontends. Normal games should not use keyboard grab.
  ///
  /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
  /// window is full-screen to ensure the user is not trapped in your
  /// application. If you have a custom keyboard shortcut to exit fullscreen
  /// mode, you may suppress this behavior with
  /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window The window for which the keyboard grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowKeyboardGrab
  /// \sa SDL_SetWindowMouseGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowKeyboardGrab(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowKeyboardGrab(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowKeyboardGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Int32)>>('SDL_SetWindowKeyboardGrab');
  late final _SDL_SetWindowKeyboardGrab = _SDL_SetWindowKeyboardGrabPtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's mouse grab mode.
  ///
  /// Mouse grab confines the mouse cursor to the window.
  ///
  /// \param window The window for which the mouse grab mode should be set.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowMouseGrab
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowMouseGrab(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowMouseGrab(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowMouseGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowMouseGrab');
  late final _SDL_SetWindowMouseGrab = _SDL_SetWindowMouseGrabPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get a window's input grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGrab
  int SDL_GetWindowGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab(
      window,
    );
  }

  late final _SDL_GetWindowGrabPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab =
      _SDL_GetWindowGrabPtr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's keyboard grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowKeyboardGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowKeyboardGrab(
      window,
    );
  }

  late final _SDL_GetWindowKeyboardGrabPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowKeyboardGrab');
  late final _SDL_GetWindowKeyboardGrab = _SDL_GetWindowKeyboardGrabPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's mouse grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowMouseGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseGrab(
      window,
    );
  }

  late final _SDL_GetWindowMouseGrabPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowMouseGrab');
  late final _SDL_GetWindowMouseGrab = _SDL_GetWindowMouseGrabPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window that currently has an input grab enabled.
  ///
  /// \returns the window if input is grabbed or NULL otherwise.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetWindowGrab
  /// \sa SDL_SetWindowGrab
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow() {
    return _SDL_GetGrabbedWindow();
  }

  late final _SDL_GetGrabbedWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow =
      _SDL_GetGrabbedWindowPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Confines the cursor to the specified area of a window.
  ///
  /// Note that this does NOT grab the cursor, it only defines the area a cursor
  /// is restricted to when the window has mouse focus.
  ///
  /// \param window The window that will be associated with the barrier.
  /// \param rect A rectangle area in window-relative coordinates. If NULL the
  /// barrier for the specified window will be destroyed.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetWindowMouseRect
  /// \sa SDL_SetWindowMouseGrab
  int SDL_SetWindowMouseRect(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetWindowMouseRect(
      window,
      rect,
    );
  }

  late final _SDL_SetWindowMouseRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetWindowMouseRect');
  late final _SDL_SetWindowMouseRect = _SDL_SetWindowMouseRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>)>();

  /// Get the mouse confinement rectangle of a window.
  ///
  /// \param window The window to query
  /// \returns A pointer to the mouse confinement rectangle of a window, or NULL
  /// if there isn't one.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetWindowMouseRect
  ffi.Pointer<SDL_Rect> SDL_GetWindowMouseRect(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseRect(
      window,
    );
  }

  late final _SDL_GetWindowMouseRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Rect> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowMouseRect');
  late final _SDL_GetWindowMouseRect = _SDL_GetWindowMouseRectPtr.asFunction<
      ffi.Pointer<SDL_Rect> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method sets the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The
  /// brightness set will not follow the window if it is moved to another
  /// display.
  ///
  /// Many platforms will refuse to set the display brightness in modern times.
  /// You are better off using a shader to adjust gamma during rendering, or
  /// something similar.
  ///
  /// \param window the window used to select the display whose brightness will
  /// be changed
  /// \param brightness the brightness (gamma multiplier) value to set where 0.0
  /// is completely dark and 1.0 is normal brightness
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowBrightness
  /// \sa SDL_SetWindowGammaRamp
  int SDL_SetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightnessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness = _SDL_SetWindowBrightnessPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose brightness will
  /// be queried
  /// \returns the brightness for the display where 0.0 is completely dark and
  /// 1.0 is normal brightness.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowBrightness
  double SDL_GetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness(
      window,
    );
  }

  late final _SDL_GetWindowBrightnessPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness = _SDL_GetWindowBrightnessPtr.asFunction<
      double Function(ffi.Pointer<SDL_Window>)>();

  /// Set the opacity for a window.
  ///
  /// The parameter `opacity` will be clamped internally between 0.0f
  /// (transparent) and 1.0f (opaque).
  ///
  /// This function also returns -1 if setting the opacity isn't supported.
  ///
  /// \param window the window which will be made transparent or opaque
  /// \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowOpacity
  int SDL_SetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity = _SDL_SetWindowOpacityPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// The parameter `opacity` is ignored if it is NULL.
  ///
  /// This function also returns -1 if an invalid window was provided.
  ///
  /// \param window the window to get the current opacity value from
  /// \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_SetWindowOpacity
  int SDL_GetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity = _SDL_GetWindowOpacityPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// Set the window as a modal for another window.
  ///
  /// \param modal_window the window that should be set modal
  /// \param parent_window the parent window for the modal window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  int SDL_SetWindowModalFor(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalForPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor = _SDL_SetWindowModalForPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// Explicitly set input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that is completely
  /// obscured by other windows.
  ///
  /// \param window the window that should get the input focus
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RaiseWindow
  int SDL_SetWindowInputFocus(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus(
      window,
    );
  }

  late final _SDL_SetWindowInputFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus = _SDL_SetWindowInputFocusPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the gamma ramp for the display that owns a given window.
  ///
  /// Set the gamma translation table for the red, green, and blue channels of
  /// the video hardware. Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel. The
  /// input is the index into the array, and the output is the 16-bit gamma value
  /// at that index, scaled to the output color precision.
  ///
  /// Despite the name and signature, this method sets the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
  /// ramp set will not follow the window if it is moved to another display.
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be changed
  /// \param red a 256 element array of 16-bit quantities representing the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities representing the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities representing the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowGammaRamp
  int SDL_SetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp = _SDL_SetWindowGammaRampPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Get the gamma ramp for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be queried
  /// \param red a 256 element array of 16-bit quantities filled in with the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities filled in with the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities filled in with the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  int SDL_GetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp = _SDL_GetWindowGammaRampPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable from
  /// any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of a
  /// given window as special. This callback is run during event processing if we
  /// need to tell the OS to treat a region of the window specially; the use of
  /// this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within a
  /// special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire when
  /// the OS is deciding whether to drag your window, but it fires for lots of
  /// other reasons, too, some unrelated to anything you probably care about _and
  /// when the mouse isn't actually at the location it is testing_). Since this
  /// can fire at any time, you should try to keep your callback efficient,
  /// devoid of allocations, etc.
  ///
  /// \param window the window to set hit-testing on
  /// \param callback the function to call when doing a hit-test
  /// \param callback_data an app-defined void pointer passed to **callback**
  /// \returns 0 on success or -1 on error (including unsupported); call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_SetWindowHitTest(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest = _SDL_SetWindowHitTestPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// Request a window to demand attention from the user.
  ///
  /// \param window the window to be flashed
  /// \param operation the flash operation
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_FlashWindow(
    ffi.Pointer<SDL_Window> window,
    int operation,
  ) {
    return _SDL_FlashWindow(
      window,
      operation,
    );
  }

  late final _SDL_FlashWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_FlashWindow');
  late final _SDL_FlashWindow = _SDL_FlashWindowPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Destroy a window.
  ///
  /// If `window` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid window". See SDL_GetError().
  ///
  /// \param window the window to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_CreateWindowFrom
  void SDL_DestroyWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow(
      window,
    );
  }

  late final _SDL_DestroyWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow = _SDL_DestroyWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Check whether the screensaver is currently enabled.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
  ///
  /// \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
  /// disabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_EnableScreenSaver
  int SDL_IsScreenSaverEnabled() {
    return _SDL_IsScreenSaverEnabled();
  }

  late final _SDL_IsScreenSaverEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled =
      _SDL_IsScreenSaverEnabledPtr.asFunction<int Function()>();

  /// Allow the screen to be blanked by a screen saver.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_EnableScreenSaver() {
    return _SDL_EnableScreenSaver();
  }

  late final _SDL_EnableScreenSaverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver =
      _SDL_EnableScreenSaverPtr.asFunction<void Function()>();

  /// Prevent the screen from being blanked by a screen saver.
  ///
  /// If you disable the screensaver, it is automatically re-enabled when SDL
  /// quits.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_EnableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_DisableScreenSaver() {
    return _SDL_DisableScreenSaver();
  }

  late final _SDL_DisableScreenSaverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver =
      _SDL_DisableScreenSaverPtr.asFunction<void Function()>();

  /// Dynamically load an OpenGL library.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows. If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// If you do this, you need to retrieve all of the GL functions used in your
  /// program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \param path the platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetProcAddress
  /// \sa SDL_GL_UnloadLibrary
  int SDL_GL_LoadLibrary(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _SDL_GL_LoadLibrary(
      path,
    );
  }

  late final _SDL_GL_LoadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary =
      _SDL_GL_LoadLibraryPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get an OpenGL function by name.
  ///
  /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
  /// GL functions must be retrieved this way. Usually this is used to retrieve
  /// function pointers to OpenGL extensions.
  ///
  /// There are some quirks to looking up OpenGL functions that require some
  /// extra care from the application. If you code carefully, you can handle
  /// these quirks without any platform-specific code, though:
  ///
  /// - On Windows, function pointers are specific to the current GL context;
  /// this means you need to have created a GL context and made it current
  /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
  /// create a second context, you should assume that any existing function
  /// pointers aren't valid to use with it. This is (currently) a
  /// Windows-specific limitation, and in practice lots of drivers don't suffer
  /// this limitation, but it is still the way the wgl API is documented to
  /// work and you should expect crashes if you don't respect it. Store a copy
  /// of the function pointers that comes and goes with context lifespan.
  /// - On X11, function pointers returned by this function are valid for any
  /// context, and can even be looked up before a context is created at all.
  /// This means that, for at least some common OpenGL implementations, if you
  /// look up a function that doesn't exist, you'll get a non-NULL result that
  /// is _NOT_ safe to call. You must always make sure the function is actually
  /// available for a given GL context before calling it, by checking for the
  /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
  /// or verifying that the version of OpenGL you're using offers the function
  /// as core functionality.
  /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
  /// isn't supported, but you can't count on this behavior. Check for
  /// extensions you use, and if you get a NULL anyway, act as if that
  /// extension wasn't available. This is probably a bug in the driver, but you
  /// can code defensively for this scenario anyhow.
  /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
  /// Next-gen display servers are waiting to replace it, and may or may not
  /// make the same promises about function pointers.
  /// - OpenGL function pointers must be declared `APIENTRY` as in the example
  /// code. This will ensure the proper calling convention is followed on
  /// platforms where this matters (Win32) thereby avoiding stack corruption.
  ///
  /// \param proc the name of an OpenGL function
  /// \returns a pointer to the named OpenGL function. The returned pointer
  /// should be cast to the appropriate function signature.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ExtensionSupported
  /// \sa SDL_GL_LoadLibrary
  /// \sa SDL_GL_UnloadLibrary
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress(
    ffi.Pointer<ffi.Char> proc,
  ) {
    return _SDL_GL_GetProcAddress(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress = _SDL_GL_GetProcAddressPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_LoadLibrary
  void SDL_GL_UnloadLibrary() {
    return _SDL_GL_UnloadLibrary();
  }

  late final _SDL_GL_UnloadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary =
      _SDL_GL_UnloadLibraryPtr.asFunction<void Function()>();

  /// Check if an OpenGL extension is supported for the current context.
  ///
  /// This function operates on the current GL context; you must have created a
  /// context and it must be current before calling this function. Do not assume
  /// that all contexts you create will have the same set of extensions
  /// available, or that recreating an existing context will offer the same
  /// extensions again.
  ///
  /// While it's probably not a massive overhead, this function is not an O(1)
  /// operation. Check the extensions you care about after creating the GL
  /// context and save that information somewhere instead of calling the function
  /// every time you need to know.
  ///
  /// \param extension the name of the extension to check
  /// \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GL_ExtensionSupported(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _SDL_GL_ExtensionSupported(
      extension1,
    );
  }

  late final _SDL_GL_ExtensionSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported = _SDL_GL_ExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Reset all previously set OpenGL context attributes to their default values.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_SetAttribute
  void SDL_GL_ResetAttributes() {
    return _SDL_GL_ResetAttributes();
  }

  late final _SDL_GL_ResetAttributesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes =
      _SDL_GL_ResetAttributesPtr.asFunction<void Function()>();

  /// Set an OpenGL window attribute before window creation.
  ///
  /// This function sets the OpenGL attribute `attr` to `value`. The requested
  /// attributes should be set before creating an OpenGL window. You should use
  /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
  /// context, since the values obtained can differ from the requested ones.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
  /// \param value the desired value for the attribute
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_ResetAttributes
  int SDL_GL_SetAttribute(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttributePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32, ffi.Int)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute =
      _SDL_GL_SetAttributePtr.asFunction<int Function(int, int)>();

  /// Get the actual value for an attribute from the current context.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
  /// \param value a pointer filled in with the current value of `attr`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ResetAttributes
  /// \sa SDL_GL_SetAttribute
  int SDL_GL_GetAttribute(
    int attr,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _SDL_GL_GetAttribute(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttributePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, ffi.Pointer<ffi.Int>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute = _SDL_GL_GetAttributePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Create an OpenGL context for an OpenGL window, and make it current.
  ///
  /// Windows users new to OpenGL should note that, for historical reasons, GL
  /// functions added after OpenGL version 1.1 are not available by default.
  /// Those functions must be loaded at run-time, either with an OpenGL
  /// extension-handling library or with SDL_GL_GetProcAddress() and its related
  /// functions.
  ///
  /// SDL_GLContext is an alias for `void *`. It's opaque to the application.
  ///
  /// \param window the window to associate with the context
  /// \returns the OpenGL context associated with `window` or NULL on error; call
  /// SDL_GetError() for more details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_DeleteContext
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_CreateContext(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext(
      window,
    );
  }

  late final _SDL_GL_CreateContextPtr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext = _SDL_GL_CreateContextPtr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// The context must have been created with a compatible window.
  ///
  /// \param window the window to associate with the context
  /// \param context the OpenGL context to associate with the window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  int SDL_GL_MakeCurrent(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent = _SDL_GL_MakeCurrentPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// Get the currently active OpenGL window.
  ///
  /// \returns the currently active OpenGL window on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow() {
    return _SDL_GL_GetCurrentWindow();
  }

  late final _SDL_GL_GetCurrentWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow = _SDL_GL_GetCurrentWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Get the currently active OpenGL context.
  ///
  /// \returns the currently active OpenGL context or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_GetCurrentContext() {
    return _SDL_GL_GetCurrentContext();
  }

  late final _SDL_GL_GetCurrentContextPtr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext =
      _SDL_GL_GetCurrentContextPtr.asFunction<SDL_GLContext Function()>();

  /// Get the size of a window's underlying drawable in pixels.
  ///
  /// This returns info useful for calling glViewport().
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GL_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GL_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize = _SDL_GL_GetDrawableSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the swap interval for the current OpenGL context.
  ///
  /// Some systems allow specifying -1 for the interval, to enable adaptive
  /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
  /// the vertical retrace for a given frame, it swaps buffers immediately, which
  /// might be less jarring for the user during occasional framerate drops. If an
  /// application requests adaptive vsync and the system does not support it,
  /// this function will fail and return -1. In such a case, you should probably
  /// retry the call with 1 for the interval.
  ///
  /// Adaptive vsync is implemented for some glX drivers with
  /// GLX_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/glx_swap_control_tear.txt
  ///
  /// and for some Windows drivers with WGL_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/wgl_swap_control_tear.txt
  ///
  /// Read more on the Khronos wiki:
  /// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with
  /// the vertical retrace, -1 for adaptive vsync
  /// \returns 0 on success or -1 if setting the swap interval is not supported;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetSwapInterval
  int SDL_GL_SetSwapInterval(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval(
      interval,
    );
  }

  late final _SDL_GL_SetSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval =
      _SDL_GL_SetSwapIntervalPtr.asFunction<int Function(int)>();

  /// Get the swap interval for the current OpenGL context.
  ///
  /// If the system can't determine the swap interval, or there isn't a valid
  /// current context, this function will return 0 as a safe default.
  ///
  /// \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_SetSwapInterval
  int SDL_GL_GetSwapInterval() {
    return _SDL_GL_GetSwapInterval();
  }

  late final _SDL_GL_GetSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval =
      _SDL_GL_GetSwapIntervalPtr.asFunction<int Function()>();

  /// Update a window with OpenGL rendering.
  ///
  /// This is used with double-buffered OpenGL contexts, which are the default.
  ///
  /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
  /// window, otherwise nothing will happen. If you aren't using
  /// glBindFramebuffer(), this is the default and you won't have to do anything
  /// extra.
  ///
  /// \param window the window to change
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GL_SwapWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow(
      window,
    );
  }

  late final _SDL_GL_SwapWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow = _SDL_GL_SwapWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Delete an OpenGL context.
  ///
  /// \param context the OpenGL context to be deleted
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  void SDL_GL_DeleteContext(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext(
      context,
    );
  }

  late final _SDL_GL_DeleteContextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext =
      _SDL_GL_DeleteContextPtr.asFunction<void Function(SDL_GLContext)>();

  /// Query the window which currently has keyboard focus.
  ///
  /// \returns the window with keyboard focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetKeyboardFocus() {
    return _SDL_GetKeyboardFocus();
  }

  late final _SDL_GetKeyboardFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetKeyboardFocus');
  late final _SDL_GetKeyboardFocus =
      _SDL_GetKeyboardFocusPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Get a snapshot of the current state of the keyboard.
  ///
  /// The pointer returned is a pointer to an internal SDL array. It will be
  /// valid for the whole lifetime of the application and should not be freed by
  /// the caller.
  ///
  /// A array element with a value of 1 means that the key is pressed and a value
  /// of 0 means that it is not. Indexes into this array are obtained by using
  /// SDL_Scancode values.
  ///
  /// Use SDL_PumpEvents() to update the state array.
  ///
  /// This function gives you the current state after all events have been
  /// processed, so if a key or button has been pressed and released before you
  /// process events, then the pressed state will never show up in the
  /// SDL_GetKeyboardState() calls.
  ///
  /// Note: This function doesn't take into account whether shift has been
  /// pressed or not.
  ///
  /// \param numkeys if non-NULL, receives the length of the returned array
  /// \returns a pointer to an array of key states.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PumpEvents
  ffi.Pointer<Uint8> SDL_GetKeyboardState(
    ffi.Pointer<ffi.Int> numkeys,
  ) {
    return _SDL_GetKeyboardState(
      numkeys,
    );
  }

  late final _SDL_GetKeyboardStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Uint8> Function(
              ffi.Pointer<ffi.Int>)>>('SDL_GetKeyboardState');
  late final _SDL_GetKeyboardState = _SDL_GetKeyboardStatePtr.asFunction<
      ffi.Pointer<Uint8> Function(ffi.Pointer<ffi.Int>)>();

  /// Get the current key modifier state for the keyboard.
  ///
  /// \returns an OR'd combination of the modifier keys for the keyboard. See
  /// SDL_Keymod for details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyboardState
  /// \sa SDL_SetModState
  int SDL_GetModState() {
    return _SDL_GetModState();
  }

  late final _SDL_GetModStatePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetModState');
  late final _SDL_GetModState =
      _SDL_GetModStatePtr.asFunction<int Function()>();

  /// Set the current key modifier state for the keyboard.
  ///
  /// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
  /// modifier key states on your application. Simply pass your desired modifier
  /// states into `modstate`. This value may be a bitwise, OR'd combination of
  /// SDL_Keymod values.
  ///
  /// This does not change the keyboard state, only the key modifier flags that
  /// SDL reports.
  ///
  /// \param modstate the desired SDL_Keymod for the keyboard
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetModState
  void SDL_SetModState(
    int modstate,
  ) {
    return _SDL_SetModState(
      modstate,
    );
  }

  late final _SDL_SetModStatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetModState');
  late final _SDL_SetModState =
      _SDL_SetModStatePtr.asFunction<void Function(int)>();

  /// Get the key code corresponding to the given scancode according to the
  /// current keyboard layout.
  ///
  /// See SDL_Keycode for details.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns the SDL_Keycode that corresponds to the given SDL_Scancode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromKey
  int SDL_GetKeyFromScancode(
    int scancode,
  ) {
    return _SDL_GetKeyFromScancode(
      scancode,
    );
  }

  late final _SDL_GetKeyFromScancodePtr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Int32)>>(
          'SDL_GetKeyFromScancode');
  late final _SDL_GetKeyFromScancode =
      _SDL_GetKeyFromScancodePtr.asFunction<int Function(int)>();

  /// Get the scancode corresponding to the given key code according to the
  /// current keyboard layout.
  ///
  /// See SDL_Scancode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns the SDL_Scancode that corresponds to the given SDL_Keycode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromKey(
    int key,
  ) {
    return _SDL_GetScancodeFromKey(
      key,
    );
  }

  late final _SDL_GetScancodeFromKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_Keycode)>>(
          'SDL_GetScancodeFromKey');
  late final _SDL_GetScancodeFromKey =
      _SDL_GetScancodeFromKeyPtr.asFunction<int Function(int)>();

  /// Get a human-readable name for a scancode.
  ///
  /// See SDL_Scancode for details.
  ///
  /// **Warning**: The returned name is by design not stable across platforms,
  /// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
  /// Windows" under Microsoft Windows, and some scancodes like
  /// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
  /// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
  /// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
  /// unsuitable for creating a stable cross-platform two-way mapping between
  /// strings and scancodes.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns a pointer to the name for the scancode. If the scancode doesn't
  /// have a name this function returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeFromName
  ffi.Pointer<ffi.Char> SDL_GetScancodeName(
    int scancode,
  ) {
    return _SDL_GetScancodeName(
      scancode,
    );
  }

  late final _SDL_GetScancodeNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GetScancodeName');
  late final _SDL_GetScancodeName =
      _SDL_GetScancodeNamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a scancode from a human-readable name.
  ///
  /// \param name the human-readable scancode name
  /// \returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
  /// recognized; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromName(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetScancodeFromName(
      name,
    );
  }

  late final _SDL_GetScancodeFromNamePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetScancodeFromName');
  late final _SDL_GetScancodeFromName = _SDL_GetScancodeFromNamePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a human-readable name for a key.
  ///
  /// See SDL_Scancode and SDL_Keycode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns a pointer to a UTF-8 string that stays valid at least until the
  /// next call to this function. If you need it around any longer, you
  /// must copy it. If the key doesn't have a name, this function
  /// returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeFromKey
  ffi.Pointer<ffi.Char> SDL_GetKeyName(
    int key,
  ) {
    return _SDL_GetKeyName(
      key,
    );
  }

  late final _SDL_GetKeyNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SDL_Keycode)>>(
          'SDL_GetKeyName');
  late final _SDL_GetKeyName =
      _SDL_GetKeyNamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a key code from a human-readable name.
  ///
  /// \param name the human-readable key name
  /// \returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromName
  int SDL_GetKeyFromName(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetKeyFromName(
      name,
    );
  }

  late final _SDL_GetKeyFromNamePtr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetKeyFromName');
  late final _SDL_GetKeyFromName =
      _SDL_GetKeyFromNamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Start accepting Unicode text input events.
  ///
  /// This function will start accepting Unicode text input events in the focused
  /// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and
  /// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in
  /// pair with SDL_StopTextInput().
  ///
  /// On some platforms using this function activates the screen keyboard.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextInputRect
  /// \sa SDL_StopTextInput
  void SDL_StartTextInput() {
    return _SDL_StartTextInput();
  }

  late final _SDL_StartTextInputPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StartTextInput');
  late final _SDL_StartTextInput =
      _SDL_StartTextInputPtr.asFunction<void Function()>();

  /// Check whether or not Unicode text input events are enabled.
  ///
  /// \returns SDL_TRUE if text input events are enabled else SDL_FALSE.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  int SDL_IsTextInputActive() {
    return _SDL_IsTextInputActive();
  }

  late final _SDL_IsTextInputActivePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsTextInputActive');
  late final _SDL_IsTextInputActive =
      _SDL_IsTextInputActivePtr.asFunction<int Function()>();

  /// Stop receiving any text input events.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_StopTextInput() {
    return _SDL_StopTextInput();
  }

  late final _SDL_StopTextInputPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StopTextInput');
  late final _SDL_StopTextInput =
      _SDL_StopTextInputPtr.asFunction<void Function()>();

  /// Set the rectangle used to type Unicode text inputs.
  ///
  /// \param rect the SDL_Rect structure representing the rectangle to receive
  /// text (ignored if NULL)
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_SetTextInputRect(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetTextInputRect(
      rect,
    );
  }

  late final _SDL_SetTextInputRectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Rect>)>>(
          'SDL_SetTextInputRect');
  late final _SDL_SetTextInputRect = _SDL_SetTextInputRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>)>();

  /// Check whether the platform has screen keyboard support.
  ///
  /// \returns SDL_TRUE if the platform has some screen keyboard support or
  /// SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  /// \sa SDL_IsScreenKeyboardShown
  int SDL_HasScreenKeyboardSupport() {
    return _SDL_HasScreenKeyboardSupport();
  }

  late final _SDL_HasScreenKeyboardSupportPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_HasScreenKeyboardSupport');
  late final _SDL_HasScreenKeyboardSupport =
      _SDL_HasScreenKeyboardSupportPtr.asFunction<int Function()>();

  /// Check whether the screen keyboard is shown for given window.
  ///
  /// \param window the window for which screen keyboard should be queried
  /// \returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasScreenKeyboardSupport
  int SDL_IsScreenKeyboardShown(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsScreenKeyboardShown(
      window,
    );
  }

  late final _SDL_IsScreenKeyboardShownPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsScreenKeyboardShown');
  late final _SDL_IsScreenKeyboardShown = _SDL_IsScreenKeyboardShownPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window which currently has mouse focus.
  ///
  /// \returns the window with mouse focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetMouseFocus() {
    return _SDL_GetMouseFocus();
  }

  late final _SDL_GetMouseFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetMouseFocus');
  late final _SDL_GetMouseFocus =
      _SDL_GetMouseFocusPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Retrieve the current state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can be
  /// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
  /// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
  /// mouse cursor position relative to the focus window. You can pass NULL for
  /// either `x` or `y`.
  ///
  /// \param x the x coordinate of the mouse cursor position relative to the
  /// focus window
  /// \param y the y coordinate of the mouse cursor position relative to the
  /// focus window
  /// \returns a 32-bit button bitmask of the current button state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGlobalMouseState
  /// \sa SDL_GetRelativeMouseState
  /// \sa SDL_PumpEvents
  int SDL_GetMouseState(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetMouseState');
  late final _SDL_GetMouseState = _SDL_GetMouseStatePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Get the current state of the mouse in relation to the desktop.
  ///
  /// This works similarly to SDL_GetMouseState(), but the coordinates will be
  /// reported relative to the top-left of the desktop. This can be useful if you
  /// need to track the mouse outside of a specific window and SDL_CaptureMouse()
  /// doesn't fit your needs. For example, it could be useful if you need to
  /// track the mouse while dragging a window, where coordinates relative to a
  /// window might not be in sync at all times.
  ///
  /// Note: SDL_GetMouseState() returns the mouse position as SDL understands it
  /// from the last pump of the event queue. This function, however, queries the
  /// OS for the current mouse position, and as such, might be a slightly less
  /// efficient function. Unless you know what you're doing and have a good
  /// reason to use this function, you probably want SDL_GetMouseState() instead.
  ///
  /// \param x filled in with the current X coord relative to the desktop; can be
  /// NULL
  /// \param y filled in with the current Y coord relative to the desktop; can be
  /// NULL
  /// \returns the current button state as a bitmask which can be tested using
  /// the SDL_BUTTON(X) macros.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_CaptureMouse
  int SDL_GetGlobalMouseState(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetGlobalMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetGlobalMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetGlobalMouseState');
  late final _SDL_GetGlobalMouseState = _SDL_GetGlobalMouseStatePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Retrieve the relative state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can be
  /// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
  /// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
  /// mouse deltas since the last call to SDL_GetRelativeMouseState() or since
  /// event initialization. You can pass NULL for either `x` or `y`.
  ///
  /// \param x a pointer filled with the last recorded x coordinate of the mouse
  /// \param y a pointer filled with the last recorded y coordinate of the mouse
  /// \returns a 32-bit button bitmask of the relative button state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetMouseState
  int SDL_GetRelativeMouseState(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetRelativeMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetRelativeMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetRelativeMouseState');
  late final _SDL_GetRelativeMouseState = _SDL_GetRelativeMouseStatePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Move the mouse cursor to the given position within the window.
  ///
  /// This function generates a mouse motion event.
  ///
  /// Note that this function will appear to succeed, but not actually move the
  /// mouse when used over Microsoft Remote Desktop.
  ///
  /// \param window the window to move the mouse into, or NULL for the current
  /// mouse focus
  /// \param x the x coordinate within the window
  /// \param y the y coordinate within the window
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WarpMouseGlobal
  void SDL_WarpMouseInWindow(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_WarpMouseInWindow(
      window,
      x,
      y,
    );
  }

  late final _SDL_WarpMouseInWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_WarpMouseInWindow');
  late final _SDL_WarpMouseInWindow = _SDL_WarpMouseInWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Move the mouse to the given position in global screen space.
  ///
  /// This function generates a mouse motion event.
  ///
  /// A failure of this function usually means that it is unsupported by a
  /// platform.
  ///
  /// Note that this function will appear to succeed, but not actually move the
  /// mouse when used over Microsoft Remote Desktop.
  ///
  /// \param x the x coordinate
  /// \param y the y coordinate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_WarpMouseInWindow
  int SDL_WarpMouseGlobal(
    int x,
    int y,
  ) {
    return _SDL_WarpMouseGlobal(
      x,
      y,
    );
  }

  late final _SDL_WarpMouseGlobalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'SDL_WarpMouseGlobal');
  late final _SDL_WarpMouseGlobal =
      _SDL_WarpMouseGlobalPtr.asFunction<int Function(int, int)>();

  /// Set relative mouse mode.
  ///
  /// While the mouse is in relative mode, the cursor is hidden, and the driver
  /// will try to report continuous motion in the current window. Only relative
  /// motion events will be delivered, the mouse position will not change.
  ///
  /// Note that this function will not be able to provide continuous relative
  /// motion when used over Microsoft Remote Desktop, instead motion is limited
  /// to the bounds of the screen.
  ///
  /// This function will flush any pending mouse motion.
  ///
  /// \param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// If relative mode is not supported, this returns -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRelativeMouseMode
  int SDL_SetRelativeMouseMode(
    int enabled,
  ) {
    return _SDL_SetRelativeMouseMode(
      enabled,
    );
  }

  late final _SDL_SetRelativeMouseModePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_SetRelativeMouseMode');
  late final _SDL_SetRelativeMouseMode =
      _SDL_SetRelativeMouseModePtr.asFunction<int Function(int)>();

  /// Capture the mouse and to track input outside an SDL window.
  ///
  /// Capturing enables your app to obtain mouse events globally, instead of just
  /// within your window. Not all video targets support this function. When
  /// capturing is enabled, the current window will get all mouse events, but
  /// unlike relative mode, no change is made to the cursor and it is not
  /// restrained to your window.
  ///
  /// This function may also deny mouse input to other windows--both those in
  /// your application and others on the system--so you should use this function
  /// sparingly, and in small bursts. For example, you might want to track the
  /// mouse while the user is dragging something, until the user releases a mouse
  /// button. It is not recommended that you capture the mouse for long periods
  /// of time, such as the entire time your app is running. For that, you should
  /// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending
  /// on your goals.
  ///
  /// While captured, mouse events still report coordinates relative to the
  /// current (foreground) window, but those coordinates may be outside the
  /// bounds of the window (including negative values). Capturing is only allowed
  /// for the foreground window. If the window loses focus while capturing, the
  /// capture will be disabled automatically.
  ///
  /// While capturing is enabled, the current window will have the
  /// `SDL_WINDOW_MOUSE_CAPTURE` flag set.
  ///
  /// \param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable.
  /// \returns 0 on success or -1 if not supported; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetGlobalMouseState
  int SDL_CaptureMouse(
    int enabled,
  ) {
    return _SDL_CaptureMouse(
      enabled,
    );
  }

  late final _SDL_CaptureMousePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_CaptureMouse');
  late final _SDL_CaptureMouse =
      _SDL_CaptureMousePtr.asFunction<int Function(int)>();

  /// Query whether relative mouse mode is enabled.
  ///
  /// \returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRelativeMouseMode
  int SDL_GetRelativeMouseMode() {
    return _SDL_GetRelativeMouseMode();
  }

  late final _SDL_GetRelativeMouseModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetRelativeMouseMode');
  late final _SDL_GetRelativeMouseMode =
      _SDL_GetRelativeMouseModePtr.asFunction<int Function()>();

  /// Create a cursor using the specified bitmap data and mask (in MSB format).
  ///
  /// `mask` has to be in MSB (Most Significant Bit) format.
  ///
  /// The cursor width (`w`) must be a multiple of 8 bits.
  ///
  /// The cursor is created in black and white according to the following:
  ///
  /// - data=0, mask=1: white
  /// - data=1, mask=1: black
  /// - data=0, mask=0: transparent
  /// - data=1, mask=0: inverted color if possible, black if not.
  ///
  /// Cursors created with this function must be freed with SDL_FreeCursor().
  ///
  /// If you want to have a color cursor, or create your cursor from an
  /// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
  /// hide the cursor and draw your own as part of your game's rendering, but it
  /// will be bound to the framerate.
  ///
  /// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which
  /// provides twelve readily available system cursors to pick from.
  ///
  /// \param data the color value for each pixel of the cursor
  /// \param mask the mask value for each pixel of the cursor
  /// \param w the width of the cursor
  /// \param h the height of the cursor
  /// \param hot_x the X-axis location of the upper left corner of the cursor
  /// relative to the actual mouse position
  /// \param hot_y the Y-axis location of the upper left corner of the cursor
  /// relative to the actual mouse position
  /// \returns a new cursor with the specified parameters on success or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeCursor
  /// \sa SDL_SetCursor
  /// \sa SDL_ShowCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateCursor(
    ffi.Pointer<Uint8> data,
    ffi.Pointer<Uint8> mask,
    int w,
    int h,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateCursor(
      data,
      mask,
      w,
      h,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('SDL_CreateCursor');
  late final _SDL_CreateCursor = _SDL_CreateCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int, int)>();

  /// Create a color cursor.
  ///
  /// \param surface an SDL_Surface structure representing the cursor image
  /// \param hot_x the x position of the cursor hot spot
  /// \param hot_y the y position of the cursor hot spot
  /// \returns the new cursor on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_FreeCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateColorCursor(
    ffi.Pointer<SDL_Surface> surface,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateColorCursor(
      surface,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateColorCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, ffi.Int,
              ffi.Int)>>('SDL_CreateColorCursor');
  late final _SDL_CreateColorCursor = _SDL_CreateColorCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Create a system cursor.
  ///
  /// \param id an SDL_SystemCursor enum value
  /// \returns a cursor on success or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateSystemCursor(
    int id,
  ) {
    return _SDL_CreateSystemCursor(
      id,
    );
  }

  late final _SDL_CreateSystemCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function(ffi.Int32)>>(
          'SDL_CreateSystemCursor');
  late final _SDL_CreateSystemCursor = _SDL_CreateSystemCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(int)>();

  /// Set the active cursor.
  ///
  /// This function sets the currently active cursor to the specified one. If the
  /// cursor is currently visible, the change will be immediately represented on
  /// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
  /// this is desired for any reason.
  ///
  /// \param cursor a cursor to make active
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_GetCursor
  /// \sa SDL_ShowCursor
  void SDL_SetCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_SetCursor(
      cursor,
    );
  }

  late final _SDL_SetCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_SetCursor');
  late final _SDL_SetCursor =
      _SDL_SetCursorPtr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// Get the active cursor.
  ///
  /// This function returns a pointer to the current cursor which is owned by the
  /// library. It is not necessary to free the cursor with SDL_FreeCursor().
  ///
  /// \returns the active cursor or NULL if there is no mouse.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetCursor
  ffi.Pointer<SDL_Cursor> SDL_GetCursor() {
    return _SDL_GetCursor();
  }

  late final _SDL_GetCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetCursor');
  late final _SDL_GetCursor =
      _SDL_GetCursorPtr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// Get the default cursor.
  ///
  /// \returns the default cursor on success or NULL on failure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSystemCursor
  ffi.Pointer<SDL_Cursor> SDL_GetDefaultCursor() {
    return _SDL_GetDefaultCursor();
  }

  late final _SDL_GetDefaultCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetDefaultCursor');
  late final _SDL_GetDefaultCursor =
      _SDL_GetDefaultCursorPtr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// Free a previously-created cursor.
  ///
  /// Use this function to free cursor resources created with SDL_CreateCursor(),
  /// SDL_CreateColorCursor() or SDL_CreateSystemCursor().
  ///
  /// \param cursor the cursor to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateColorCursor
  /// \sa SDL_CreateCursor
  /// \sa SDL_CreateSystemCursor
  void SDL_FreeCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_FreeCursor(
      cursor,
    );
  }

  late final _SDL_FreeCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_FreeCursor');
  late final _SDL_FreeCursor =
      _SDL_FreeCursorPtr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// Toggle whether or not the cursor is shown.
  ///
  /// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`
  /// displays the cursor and passing `SDL_DISABLE` hides it.
  ///
  /// The current state of the mouse cursor can be queried by passing
  /// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.
  ///
  /// \param toggle `SDL_ENABLE` to show the cursor, `SDL_DISABLE` to hide it,
  /// `SDL_QUERY` to query the current state without changing it.
  /// \returns `SDL_ENABLE` if the cursor is shown, or `SDL_DISABLE` if the
  /// cursor is hidden, or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_SetCursor
  int SDL_ShowCursor(
    int toggle,
  ) {
    return _SDL_ShowCursor(
      toggle,
    );
  }

  late final _SDL_ShowCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ShowCursor');
  late final _SDL_ShowCursor =
      _SDL_ShowCursorPtr.asFunction<int Function(int)>();

  /// Locking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_LockJoysticks() {
    return _SDL_LockJoysticks();
  }

  late final _SDL_LockJoysticksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockJoysticks');
  late final _SDL_LockJoysticks =
      _SDL_LockJoysticksPtr.asFunction<void Function()>();

  /// Unlocking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_UnlockJoysticks() {
    return _SDL_UnlockJoysticks();
  }

  late final _SDL_UnlockJoysticksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockJoysticks');
  late final _SDL_UnlockJoysticks =
      _SDL_UnlockJoysticksPtr.asFunction<void Function()>();

  /// Count the number of joysticks attached to the system.
  ///
  /// \returns the number of attached joysticks on success or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  int SDL_NumJoysticks() {
    return _SDL_NumJoysticks();
  }

  late final _SDL_NumJoysticksPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumJoysticks');
  late final _SDL_NumJoysticks =
      _SDL_NumJoysticksPtr.asFunction<int Function()>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system)
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickNameForIndex(
    int device_index,
  ) {
    return _SDL_JoystickNameForIndex(
      device_index,
    );
  }

  late final _SDL_JoystickNameForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_JoystickNameForIndex');
  late final _SDL_JoystickNameForIndex = _SDL_JoystickNameForIndexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the player index of a joystick, or -1 if it's not available This can be
  /// called before any joysticks are opened.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetDevicePlayerIndex(
    int device_index,
  ) {
    return _SDL_JoystickGetDevicePlayerIndex(
      device_index,
    );
  }

  late final _SDL_JoystickGetDevicePlayerIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickGetDevicePlayerIndex');
  late final _SDL_JoystickGetDevicePlayerIndex =
      _SDL_JoystickGetDevicePlayerIndexPtr.asFunction<int Function(int)>();

  /// Get the implementation-dependent GUID for the joystick at a given device
  /// index.
  ///
  /// This function can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the GUID of the selected joystick. If called on an invalid index,
  /// this function returns a zero GUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetDeviceGUID(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceGUID(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceGUIDPtr =
      _lookup<ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceGUID');
  late final _SDL_JoystickGetDeviceGUID = _SDL_JoystickGetDeviceGUIDPtr
      .asFunction<SDL_JoystickGUID Function(int)>();

  /// Get the USB vendor ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the vendor ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB vendor ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceVendor(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceVendor(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceVendorPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceVendor');
  late final _SDL_JoystickGetDeviceVendor =
      _SDL_JoystickGetDeviceVendorPtr.asFunction<int Function(int)>();

  /// Get the USB product ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB product ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProduct(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProduct(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProduct');
  late final _SDL_JoystickGetDeviceProduct =
      _SDL_JoystickGetDeviceProductPtr.asFunction<int Function(int)>();

  /// Get the product version of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product version
  /// isn't available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the product version of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProductVersion(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProductVersion(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductVersionPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProductVersion');
  late final _SDL_JoystickGetDeviceProductVersion =
      _SDL_JoystickGetDeviceProductVersionPtr.asFunction<int Function(int)>();

  /// Get the type of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the SDL_JoystickType of the selected joystick. If called on an
  /// invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceType(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceType(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceType');
  late final _SDL_JoystickGetDeviceType =
      _SDL_JoystickGetDeviceTypePtr.asFunction<int Function(int)>();

  /// Get the instance ID of a joystick.
  ///
  /// This can be called before any joysticks are opened. If the index is out of
  /// range, this function will return -1.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the instance id of the selected joystick. If called on an invalid
  /// index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceInstanceID(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceInstanceID(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceInstanceIDPtr =
      _lookup<ffi.NativeFunction<SDL_JoystickID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceInstanceID');
  late final _SDL_JoystickGetDeviceInstanceID =
      _SDL_JoystickGetDeviceInstanceIDPtr.asFunction<int Function(int)>();

  /// Open a joystick for use.
  ///
  /// The `device_index` argument refers to the N'th joystick presently
  /// recognized by SDL on the system. It is **NOT** the same as the instance ID
  /// used to identify the joystick in future events. See
  /// SDL_JoystickInstanceID() for more details about instance IDs.
  ///
  /// The joystick subsystem must be initialized before a joystick can be opened
  /// for use.
  ///
  /// \param device_index the index of the joystick to query
  /// \returns a joystick identifier or NULL if an error occurred; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickInstanceID
  ffi.Pointer<SDL_Joystick> SDL_JoystickOpen(
    int device_index,
  ) {
    return _SDL_JoystickOpen(
      device_index,
    );
  }

  late final _SDL_JoystickOpenPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickOpen');
  late final _SDL_JoystickOpen = _SDL_JoystickOpenPtr.asFunction<
      ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with an instance id.
  ///
  /// \param instance_id the instance id to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromInstanceID(
    int instance_id,
  ) {
    return _SDL_JoystickFromInstanceID(
      instance_id,
    );
  }

  late final _SDL_JoystickFromInstanceIDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Joystick> Function(
              SDL_JoystickID)>>('SDL_JoystickFromInstanceID');
  late final _SDL_JoystickFromInstanceID = _SDL_JoystickFromInstanceIDPtr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with a player index.
  ///
  /// \param player_index the player index to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.12.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromPlayerIndex(
    int player_index,
  ) {
    return _SDL_JoystickFromPlayerIndex(
      player_index,
    );
  }

  late final _SDL_JoystickFromPlayerIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickFromPlayerIndex');
  late final _SDL_JoystickFromPlayerIndex = _SDL_JoystickFromPlayerIndexPtr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Attach a new virtual joystick.
  ///
  /// \returns the joystick's device index, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickAttachVirtual(
    int type,
    int naxes,
    int nbuttons,
    int nhats,
  ) {
    return _SDL_JoystickAttachVirtual(
      type,
      naxes,
      nbuttons,
      nhats,
    );
  }

  late final _SDL_JoystickAttachVirtualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int32, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_JoystickAttachVirtual');
  late final _SDL_JoystickAttachVirtual = _SDL_JoystickAttachVirtualPtr
      .asFunction<int Function(int, int, int, int)>();

  /// Detach a virtual joystick.
  ///
  /// \param device_index a value previously returned from
  /// SDL_JoystickAttachVirtual()
  /// \returns 0 on success, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickDetachVirtual(
    int device_index,
  ) {
    return _SDL_JoystickDetachVirtual(
      device_index,
    );
  }

  late final _SDL_JoystickDetachVirtualPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickDetachVirtual');
  late final _SDL_JoystickDetachVirtual =
      _SDL_JoystickDetachVirtualPtr.asFunction<int Function(int)>();

  /// Query whether or not the joystick at a given device index is virtual.
  ///
  /// \param device_index a joystick device index.
  /// \returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickIsVirtual(
    int device_index,
  ) {
    return _SDL_JoystickIsVirtual(
      device_index,
    );
  }

  late final _SDL_JoystickIsVirtualPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickIsVirtual');
  late final _SDL_JoystickIsVirtual =
      _SDL_JoystickIsVirtualPtr.asFunction<int Function(int)>();

  /// Set values on an opened, virtual-joystick's axis.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param axis the specific axis on the virtual joystick to set.
  /// \param value the new value for the specified axis.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualAxis(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    int value,
  ) {
    return _SDL_JoystickSetVirtualAxis(
      joystick,
      axis,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Sint16)>>('SDL_JoystickSetVirtualAxis');
  late final _SDL_JoystickSetVirtualAxis = _SDL_JoystickSetVirtualAxisPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's button.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param button the specific button on the virtual joystick to set.
  /// \param value the new value for the specified button.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualButton(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
    int value,
  ) {
    return _SDL_JoystickSetVirtualButton(
      joystick,
      button,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualButtonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualButton');
  late final _SDL_JoystickSetVirtualButton = _SDL_JoystickSetVirtualButtonPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's hat.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param hat the specific hat on the virtual joystick to set.
  /// \param value the new value for the specified hat.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualHat(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
    int value,
  ) {
    return _SDL_JoystickSetVirtualHat(
      joystick,
      hat,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualHatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualHat');
  late final _SDL_JoystickSetVirtualHat = _SDL_JoystickSetVirtualHatPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNameForIndex
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickName(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickName(
      joystick,
    );
  }

  late final _SDL_JoystickNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickName');
  late final _SDL_JoystickName = _SDL_JoystickNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the player index of an opened joystick.
  ///
  /// For XInput controllers this returns the XInput user index. Many joysticks
  /// will not be able to supply this information.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the player index, or -1 if it's not available.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetPlayerIndex(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetPlayerIndex(
      joystick,
    );
  }

  late final _SDL_JoystickGetPlayerIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetPlayerIndex');
  late final _SDL_JoystickGetPlayerIndex = _SDL_JoystickGetPlayerIndexPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Set the player index of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \param player_index the player index to set.
  ///
  /// \since This function is available since SDL 2.0.12.
  void SDL_JoystickSetPlayerIndex(
    ffi.Pointer<SDL_Joystick> joystick,
    int player_index,
  ) {
    return _SDL_JoystickSetPlayerIndex(
      joystick,
      player_index,
    );
  }

  late final _SDL_JoystickSetPlayerIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Joystick>,
              ffi.Int)>>('SDL_JoystickSetPlayerIndex');
  late final _SDL_JoystickSetPlayerIndex = _SDL_JoystickSetPlayerIndexPtr
      .asFunction<void Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the implementation-dependent GUID for the joystick.
  ///
  /// This function requires an open joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the GUID of the given joystick. If called on an invalid index,
  /// this function returns a zero GUID; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUID(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetGUID(
      joystick,
    );
  }

  late final _SDL_JoystickGetGUIDPtr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickGUID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetGUID');
  late final _SDL_JoystickGetGUID = _SDL_JoystickGetGUIDPtr.asFunction<
      SDL_JoystickGUID Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB vendor ID of an opened joystick, if available.
  ///
  /// If the vendor ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB vendor ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetVendor(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetVendor(
      joystick,
    );
  }

  late final _SDL_JoystickGetVendorPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetVendor');
  late final _SDL_JoystickGetVendor = _SDL_JoystickGetVendorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB product ID of an opened joystick, if available.
  ///
  /// If the product ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB product ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProduct(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProduct(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProduct');
  late final _SDL_JoystickGetProduct = _SDL_JoystickGetProductPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the product version of an opened joystick, if available.
  ///
  /// If the product version isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the product version of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProductVersion(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProductVersion(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductVersionPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProductVersion');
  late final _SDL_JoystickGetProductVersion = _SDL_JoystickGetProductVersionPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the serial number of an opened joystick, if available.
  ///
  /// Returns the serial number of the joystick, or NULL if it is not available.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the serial number of the selected joystick, or NULL if
  /// unavailable.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<ffi.Char> SDL_JoystickGetSerial(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetSerial(
      joystick,
    );
  }

  late final _SDL_JoystickGetSerialPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetSerial');
  late final _SDL_JoystickGetSerial = _SDL_JoystickGetSerialPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the type of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the SDL_JoystickType of the selected joystick.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetType(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetType(
      joystick,
    );
  }

  late final _SDL_JoystickGetTypePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetType');
  late final _SDL_JoystickGetType = _SDL_JoystickGetTypePtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get an ASCII string representation for a given SDL_JoystickGUID.
  ///
  /// You should supply at least 33 bytes for pszGUID.
  ///
  /// \param guid the SDL_JoystickGUID you wish to convert to string
  /// \param pszGUID buffer in which to write the ASCII string
  /// \param cbGUID the size of pszGUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDFromString
  void SDL_JoystickGetGUIDString(
    SDL_JoystickGUID guid,
    ffi.Pointer<ffi.Char> pszGUID,
    int cbGUID,
  ) {
    return _SDL_JoystickGetGUIDString(
      guid,
      pszGUID,
      cbGUID,
    );
  }

  late final _SDL_JoystickGetGUIDStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_JoystickGetGUIDString');
  late final _SDL_JoystickGetGUIDString =
      _SDL_JoystickGetGUIDStringPtr.asFunction<
          void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>, int)>();

  /// Convert a GUID string into a SDL_JoystickGUID structure.
  ///
  /// Performs no error checking. If this function is given a string containing
  /// an invalid GUID, the function will silently succeed, but the GUID generated
  /// will not be useful.
  ///
  /// \param pchGUID string containing an ASCII representation of a GUID
  /// \returns a SDL_JoystickGUID structure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUIDFromString(
    ffi.Pointer<ffi.Char> pchGUID,
  ) {
    return _SDL_JoystickGetGUIDFromString(
      pchGUID,
    );
  }

  late final _SDL_JoystickGetGUIDFromStringPtr = _lookup<
          ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>>(
      'SDL_JoystickGetGUIDFromString');
  late final _SDL_JoystickGetGUIDFromString = _SDL_JoystickGetGUIDFromStringPtr
      .asFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>();

  /// Get the status of a specified joystick.
  ///
  /// \param joystick the joystick to query
  /// \returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickOpen
  int SDL_JoystickGetAttached(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetAttached(
      joystick,
    );
  }

  late final _SDL_JoystickGetAttachedPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetAttached');
  late final _SDL_JoystickGetAttached = _SDL_JoystickGetAttachedPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the instance ID of an opened joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the instance ID of the specified joystick on success or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  int SDL_JoystickInstanceID(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickInstanceID(
      joystick,
    );
  }

  late final _SDL_JoystickInstanceIDPtr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickInstanceID');
  late final _SDL_JoystickInstanceID = _SDL_JoystickInstanceIDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of general axis controls on a joystick.
  ///
  /// Often, the directional pad on a game controller will either look like 4
  /// separate buttons or a POV hat, and not axes, but all of this is up to the
  /// device and platform.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of axis controls/number of axes on success or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetAxis
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumAxes(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumAxes(
      joystick,
    );
  }

  late final _SDL_JoystickNumAxesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumAxes');
  late final _SDL_JoystickNumAxes = _SDL_JoystickNumAxesPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of trackballs on a joystick.
  ///
  /// Joystick trackballs have only relative motion events associated with them
  /// and their state cannot be polled.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of trackballs on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetBall
  int SDL_JoystickNumBalls(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumBalls(
      joystick,
    );
  }

  late final _SDL_JoystickNumBallsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumBalls');
  late final _SDL_JoystickNumBalls = _SDL_JoystickNumBallsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of POV hats on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of POV hats on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetHat
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumHats(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumHats(
      joystick,
    );
  }

  late final _SDL_JoystickNumHatsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumHats');
  late final _SDL_JoystickNumHats = _SDL_JoystickNumHatsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of buttons on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of buttons on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetButton
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumButtons(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumButtons(
      joystick,
    );
  }

  late final _SDL_JoystickNumButtonsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumButtons');
  late final _SDL_JoystickNumButtons = _SDL_JoystickNumButtonsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update the current state of the open joysticks.
  ///
  /// This is called automatically by the event loop if any joystick events are
  /// enabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickEventState
  void SDL_JoystickUpdate() {
    return _SDL_JoystickUpdate();
  }

  late final _SDL_JoystickUpdatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_JoystickUpdate');
  late final _SDL_JoystickUpdate =
      _SDL_JoystickUpdatePtr.asFunction<void Function()>();

  /// Enable/disable joystick event polling.
  ///
  /// If joystick events are disabled, you must call SDL_JoystickUpdate()
  /// yourself and manually check the state of the joystick when you want
  /// joystick information.
  ///
  /// It is recommended that you leave joystick event handling enabled.
  ///
  /// **WARNING**: Calling this function may delete all events currently in SDL's
  /// event queue.
  ///
  /// \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
  /// \returns 1 if enabled, 0 if disabled, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// If `state` is `SDL_QUERY` then the current state is returned,
  /// otherwise the new processing state is returned.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerEventState
  int SDL_JoystickEventState(
    int state,
  ) {
    return _SDL_JoystickEventState(
      state,
    );
  }

  late final _SDL_JoystickEventStatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickEventState');
  late final _SDL_JoystickEventState =
      _SDL_JoystickEventStatePtr.asFunction<int Function(int)>();

  /// Get the current state of an axis control on a joystick.
  ///
  /// SDL makes no promises about what part of the joystick any given axis refers
  /// to. Your game should have some sort of configuration UI to let users
  /// specify what each axis should be bound to. Alternately, SDL's higher-level
  /// Game Controller API makes a great effort to apply order to this lower-level
  /// interface, so you know that a specific axis is the "left thumb stick," etc.
  ///
  /// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to
  /// 32767) representing the current position of the axis. It may be necessary
  /// to impose certain tolerances on these values to account for jitter.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \returns a 16-bit signed integer representing the current position of the
  /// axis or 0 on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumAxes
  int SDL_JoystickGetAxis(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
  ) {
    return _SDL_JoystickGetAxis(
      joystick,
      axis,
    );
  }

  late final _SDL_JoystickGetAxisPtr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetAxis');
  late final _SDL_JoystickGetAxis = _SDL_JoystickGetAxisPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the initial state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \param state Upon return, the initial value is supplied here.
  /// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetAxisInitialState(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    ffi.Pointer<Sint16> state,
  ) {
    return _SDL_JoystickGetAxisInitialState(
      joystick,
      axis,
      state,
    );
  }

  late final _SDL_JoystickGetAxisInitialStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              ffi.Pointer<Sint16>)>>('SDL_JoystickGetAxisInitialState');
  late final _SDL_JoystickGetAxisInitialState =
      _SDL_JoystickGetAxisInitialStatePtr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<Sint16>)>();

  /// Get the current state of a POV hat on a joystick.
  ///
  /// The returned value will be one of the following positions:
  ///
  /// - `SDL_HAT_CENTERED`
  /// - `SDL_HAT_UP`
  /// - `SDL_HAT_RIGHT`
  /// - `SDL_HAT_DOWN`
  /// - `SDL_HAT_LEFT`
  /// - `SDL_HAT_RIGHTUP`
  /// - `SDL_HAT_RIGHTDOWN`
  /// - `SDL_HAT_LEFTUP`
  /// - `SDL_HAT_LEFTDOWN`
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param hat the hat index to get the state from; indices start at index 0
  /// \returns the current hat position.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumHats
  int SDL_JoystickGetHat(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
  ) {
    return _SDL_JoystickGetHat(
      joystick,
      hat,
    );
  }

  late final _SDL_JoystickGetHatPtr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetHat');
  late final _SDL_JoystickGetHat = _SDL_JoystickGetHatPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the ball axis change since the last poll.
  ///
  /// Trackballs can only return relative motion since the last call to
  /// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \param ball the ball index to query; ball indices start at index 0
  /// \param dx stores the difference in the x axis position since the last poll
  /// \param dy stores the difference in the y axis position since the last poll
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumBalls
  int SDL_JoystickGetBall(
    ffi.Pointer<SDL_Joystick> joystick,
    int ball,
    ffi.Pointer<ffi.Int> dx,
    ffi.Pointer<ffi.Int> dy,
  ) {
    return _SDL_JoystickGetBall(
      joystick,
      ball,
      dx,
      dy,
    );
  }

  late final _SDL_JoystickGetBallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Joystick>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_JoystickGetBall');
  late final _SDL_JoystickGetBall = _SDL_JoystickGetBallPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the current state of a button on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param button the button index to get the state from; indices start at
  /// index 0
  /// \returns 1 if the specified button is pressed, 0 otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumButtons
  int SDL_JoystickGetButton(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
  ) {
    return _SDL_JoystickGetButton(
      joystick,
      button,
    );
  }

  late final _SDL_JoystickGetButtonPtr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetButton');
  late final _SDL_JoystickGetButton = _SDL_JoystickGetButtonPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Start a rumble effect.
  ///
  /// Each call to this function cancels any previous rumble effect, and calling
  /// it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left)
  /// rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right)
  /// rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_JoystickHasRumble
  int SDL_JoystickRumble(
    ffi.Pointer<SDL_Joystick> joystick,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumble(
      joystick,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumble');
  late final _SDL_JoystickRumble = _SDL_JoystickRumblePtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Start a rumble effect in the joystick's triggers
  ///
  /// Each call to this function cancels any previous trigger rumble effect, and
  /// calling it with 0 intensity stops any rumbling.
  ///
  /// Note that this function is for _trigger_ rumble; the first joystick to
  /// support this was the PlayStation 5's DualShock 5 controller. If you want
  /// the (more common) whole-controller rumble, use SDL_JoystickRumble()
  /// instead.
  ///
  /// \param joystick The joystick to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if trigger rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_JoystickHasRumbleTriggers
  int SDL_JoystickRumbleTriggers(
    ffi.Pointer<SDL_Joystick> joystick,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumbleTriggers(
      joystick,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumbleTriggersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumbleTriggers');
  late final _SDL_JoystickRumbleTriggers = _SDL_JoystickRumbleTriggersPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Query whether a joystick has an LED.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickHasLED(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasLED(
      joystick,
    );
  }

  late final _SDL_JoystickHasLEDPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasLED');
  late final _SDL_JoystickHasLED = _SDL_JoystickHasLEDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumble
  int SDL_JoystickHasRumble(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumble(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumblePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumble');
  late final _SDL_JoystickHasRumble = _SDL_JoystickHasRumblePtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support on triggers.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumbleTriggers
  int SDL_JoystickHasRumbleTriggers(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumbleTriggers(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumbleTriggersPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumbleTriggers');
  late final _SDL_JoystickHasRumbleTriggers = _SDL_JoystickHasRumbleTriggersPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update a joystick's LED color.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  /// \returns 0 on success, -1 if this joystick does not have a modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetLED(
    ffi.Pointer<SDL_Joystick> joystick,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_JoystickSetLED(
      joystick,
      red,
      green,
      blue,
    );
  }

  late final _SDL_JoystickSetLEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint8, Uint8,
              Uint8)>>('SDL_JoystickSetLED');
  late final _SDL_JoystickSetLED = _SDL_JoystickSetLEDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Send a joystick specific effect packet
  ///
  /// \param joystick The joystick to affect
  /// \param data The data to send to the joystick
  /// \param size The size of the data to send to the joystick
  /// \returns 0, or -1 if this joystick or driver doesn't support effect packets
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_JoystickSendEffect(
    ffi.Pointer<SDL_Joystick> joystick,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _SDL_JoystickSendEffect(
      joystick,
      data,
      size,
    );
  }

  late final _SDL_JoystickSendEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_JoystickSendEffect');
  late final _SDL_JoystickSendEffect = _SDL_JoystickSendEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>, int)>();

  /// Close a joystick previously opened with SDL_JoystickOpen().
  ///
  /// \param joystick The joystick device to close
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  void SDL_JoystickClose(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickClose(
      joystick,
    );
  }

  late final _SDL_JoystickClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickClose');
  late final _SDL_JoystickClose = _SDL_JoystickClosePtr.asFunction<
      void Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the battery level of a joystick as SDL_JoystickPowerLevel.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \returns the current battery level as SDL_JoystickPowerLevel on success or
  /// `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_JoystickCurrentPowerLevel(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickCurrentPowerLevel(
      joystick,
    );
  }

  late final _SDL_JoystickCurrentPowerLevelPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickCurrentPowerLevel');
  late final _SDL_JoystickCurrentPowerLevel = _SDL_JoystickCurrentPowerLevelPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Locking for multi-threaded access to the sensor API
  ///
  /// If you are using the sensor API or handling events from multiple threads
  /// you should use these locking functions to protect access to the sensors.
  ///
  /// In particular, you are guaranteed that the sensor list won't change, so the
  /// API functions that take a sensor index will be valid, and sensor events
  /// will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.14.
  void SDL_LockSensors() {
    return _SDL_LockSensors();
  }

  late final _SDL_LockSensorsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockSensors');
  late final _SDL_LockSensors =
      _SDL_LockSensorsPtr.asFunction<void Function()>();

  void SDL_UnlockSensors() {
    return _SDL_UnlockSensors();
  }

  late final _SDL_UnlockSensorsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockSensors');
  late final _SDL_UnlockSensors =
      _SDL_UnlockSensorsPtr.asFunction<void Function()>();

  /// Count the number of sensors attached to the system right now.
  ///
  /// \returns the number of sensors detected.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_NumSensors() {
    return _SDL_NumSensors();
  }

  late final _SDL_NumSensorsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumSensors');
  late final _SDL_NumSensors = _SDL_NumSensorsPtr.asFunction<int Function()>();

  /// Get the implementation dependent name of a sensor.
  ///
  /// \param device_index The sensor to obtain name from
  /// \returns the sensor name, or NULL if `device_index` is out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_SensorGetDeviceName(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceName(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_SensorGetDeviceName');
  late final _SDL_SensorGetDeviceName = _SDL_SensorGetDeviceNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the type of a sensor.
  ///
  /// \param device_index The sensor to get the type from
  /// \returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `device_index` is
  /// out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceType(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceType(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_SensorGetDeviceType');
  late final _SDL_SensorGetDeviceType =
      _SDL_SensorGetDeviceTypePtr.asFunction<int Function(int)>();

  /// Get the platform dependent type of a sensor.
  ///
  /// \param device_index The sensor to check
  /// \returns the sensor platform dependent type, or -1 if `device_index` is out
  /// of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceNonPortableType(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceNonPortableType(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNonPortableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_SensorGetDeviceNonPortableType');
  late final _SDL_SensorGetDeviceNonPortableType =
      _SDL_SensorGetDeviceNonPortableTypePtr.asFunction<int Function(int)>();

  /// Get the instance ID of a sensor.
  ///
  /// \param device_index The sensor to get instance id from
  /// \returns the sensor instance ID, or -1 if `device_index` is out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceInstanceID(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceInstanceID(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceInstanceIDPtr =
      _lookup<ffi.NativeFunction<SDL_SensorID Function(ffi.Int)>>(
          'SDL_SensorGetDeviceInstanceID');
  late final _SDL_SensorGetDeviceInstanceID =
      _SDL_SensorGetDeviceInstanceIDPtr.asFunction<int Function(int)>();

  /// Open a sensor for use.
  ///
  /// \param device_index The sensor to open
  /// \returns an SDL_Sensor sensor object, or NULL if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<SDL_Sensor> SDL_SensorOpen(
    int device_index,
  ) {
    return _SDL_SensorOpen(
      device_index,
    );
  }

  late final _SDL_SensorOpenPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Sensor> Function(ffi.Int)>>(
          'SDL_SensorOpen');
  late final _SDL_SensorOpen =
      _SDL_SensorOpenPtr.asFunction<ffi.Pointer<SDL_Sensor> Function(int)>();

  /// Return the SDL_Sensor associated with an instance id.
  ///
  /// \param instance_id The sensor from instance id
  /// \returns an SDL_Sensor object.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<SDL_Sensor> SDL_SensorFromInstanceID(
    int instance_id,
  ) {
    return _SDL_SensorFromInstanceID(
      instance_id,
    );
  }

  late final _SDL_SensorFromInstanceIDPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_Sensor> Function(SDL_SensorID)>>(
      'SDL_SensorFromInstanceID');
  late final _SDL_SensorFromInstanceID = _SDL_SensorFromInstanceIDPtr
      .asFunction<ffi.Pointer<SDL_Sensor> Function(int)>();

  /// Get the implementation dependent name of a sensor
  ///
  /// \param sensor The SDL_Sensor object
  /// \returns the sensor name, or NULL if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_SensorGetName(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetName(
      sensor,
    );
  }

  late final _SDL_SensorGetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Sensor>)>>('SDL_SensorGetName');
  late final _SDL_SensorGetName = _SDL_SensorGetNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the type of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
  /// NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetType(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetType(
      sensor,
    );
  }

  late final _SDL_SensorGetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorGetType');
  late final _SDL_SensorGetType =
      _SDL_SensorGetTypePtr.asFunction<int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the platform dependent type of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the sensor platform dependent type, or -1 if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetNonPortableType(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetNonPortableType(
      sensor,
    );
  }

  late final _SDL_SensorGetNonPortableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorGetNonPortableType');
  late final _SDL_SensorGetNonPortableType = _SDL_SensorGetNonPortableTypePtr
      .asFunction<int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the instance ID of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the sensor instance ID, or -1 if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetInstanceID(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetInstanceID(
      sensor,
    );
  }

  late final _SDL_SensorGetInstanceIDPtr = _lookup<
          ffi.NativeFunction<SDL_SensorID Function(ffi.Pointer<SDL_Sensor>)>>(
      'SDL_SensorGetInstanceID');
  late final _SDL_SensorGetInstanceID = _SDL_SensorGetInstanceIDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the current state of an opened sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  ///
  /// \param sensor The SDL_Sensor object to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  /// \returns 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetData(
    ffi.Pointer<SDL_Sensor> sensor,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_SensorGetData(
      sensor,
      data,
      num_values,
    );
  }

  late final _SDL_SensorGetDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Sensor>, ffi.Pointer<ffi.Float>,
              ffi.Int)>>('SDL_SensorGetData');
  late final _SDL_SensorGetData = _SDL_SensorGetDataPtr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor>, ffi.Pointer<ffi.Float>, int)>();

  /// Close a sensor previously opened with SDL_SensorOpen().
  ///
  /// \param sensor The SDL_Sensor object to close
  ///
  /// \since This function is available since SDL 2.0.9.
  void SDL_SensorClose(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorClose(
      sensor,
    );
  }

  late final _SDL_SensorClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorClose');
  late final _SDL_SensorClose =
      _SDL_SensorClosePtr.asFunction<void Function(ffi.Pointer<SDL_Sensor>)>();

  /// Update the current state of the open sensors.
  ///
  /// This is called automatically by the event loop if sensor events are
  /// enabled.
  ///
  /// This needs to be called from the thread that initialized the sensor
  /// subsystem.
  ///
  /// \since This function is available since SDL 2.0.9.
  void SDL_SensorUpdate() {
    return _SDL_SensorUpdate();
  }

  late final _SDL_SensorUpdatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_SensorUpdate');
  late final _SDL_SensorUpdate =
      _SDL_SensorUpdatePtr.asFunction<void Function()>();

  /// Load a set of Game Controller mappings from a seekable SDL data stream.
  ///
  /// You can call this function several times, if needed, to load different
  /// database files.
  ///
  /// If a new mapping is loaded for an already known controller GUID, the later
  /// version will overwrite the one currently loaded.
  ///
  /// Mappings not belonging to the current platform or with no platform field
  /// specified will be ignored (i.e. mappings for Linux will be ignored in
  /// Windows, etc).
  ///
  /// This function will load the text database entirely in memory before
  /// processing it, so take this into consideration if you are in a memory
  /// constrained environment.
  ///
  /// \param rw the data stream for the mappings to be added
  /// \param freerw non-zero to close the stream after being read
  /// \returns the number of mappings added or -1 on error; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GameControllerAddMapping
  /// \sa SDL_GameControllerAddMappingsFromFile
  /// \sa SDL_GameControllerMappingForGUID
  int SDL_GameControllerAddMappingsFromRW(
    ffi.Pointer<SDL_RWops> rw,
    int freerw,
  ) {
    return _SDL_GameControllerAddMappingsFromRW(
      rw,
      freerw,
    );
  }

  late final _SDL_GameControllerAddMappingsFromRWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_GameControllerAddMappingsFromRW');
  late final _SDL_GameControllerAddMappingsFromRW =
      _SDL_GameControllerAddMappingsFromRWPtr.asFunction<
          int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Add support for controllers that SDL is unaware of or to cause an existing
  /// controller to have a different binding.
  ///
  /// The mapping string has the format "GUID,name,mapping", where GUID is the
  /// string value from SDL_JoystickGetGUIDString(), name is the human readable
  /// string for the device and mappings are controller mappings to joystick
  /// ones. Under Windows there is a reserved GUID of "xinput" that covers all
  /// XInput devices. The mapping format for joystick is: {| |bX |a joystick
  /// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick
  /// |} Buttons can be used as a controller axes and vice versa.
  ///
  /// This string shows an example of a valid mapping for a controller:
  ///
  /// ```c
  /// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
  /// ```
  ///
  /// \param mappingString the mapping string
  /// \returns 1 if a new mapping is added, 0 if an existing mapping is updated,
  /// -1 on error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerMapping
  /// \sa SDL_GameControllerMappingForGUID
  int SDL_GameControllerAddMapping(
    ffi.Pointer<ffi.Char> mappingString,
  ) {
    return _SDL_GameControllerAddMapping(
      mappingString,
    );
  }

  late final _SDL_GameControllerAddMappingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GameControllerAddMapping');
  late final _SDL_GameControllerAddMapping = _SDL_GameControllerAddMappingPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get the number of mappings installed.
  ///
  /// \returns the number of mappings.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerNumMappings() {
    return _SDL_GameControllerNumMappings();
  }

  late final _SDL_GameControllerNumMappingsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GameControllerNumMappings');
  late final _SDL_GameControllerNumMappings =
      _SDL_GameControllerNumMappingsPtr.asFunction<int Function()>();

  /// Get the mapping at a particular index.
  ///
  /// \returns the mapping string. Must be freed with SDL_free(). Returns NULL if
  /// the index is out of range.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Char> SDL_GameControllerMappingForIndex(
    int mapping_index,
  ) {
    return _SDL_GameControllerMappingForIndex(
      mapping_index,
    );
  }

  late final _SDL_GameControllerMappingForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GameControllerMappingForIndex');
  late final _SDL_GameControllerMappingForIndex =
      _SDL_GameControllerMappingForIndexPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the game controller mapping string for a given GUID.
  ///
  /// The returned string must be freed with SDL_free().
  ///
  /// \param guid a structure containing the GUID for which a mapping is desired
  /// \returns a mapping string or NULL on error; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUID
  ffi.Pointer<ffi.Char> SDL_GameControllerMappingForGUID(
    SDL_JoystickGUID guid,
  ) {
    return _SDL_GameControllerMappingForGUID(
      guid,
    );
  }

  late final _SDL_GameControllerMappingForGUIDPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SDL_JoystickGUID)>>(
      'SDL_GameControllerMappingForGUID');
  late final _SDL_GameControllerMappingForGUID =
      _SDL_GameControllerMappingForGUIDPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(SDL_JoystickGUID)>();

  /// Get the current mapping of a Game Controller.
  ///
  /// The returned string must be freed with SDL_free().
  ///
  /// Details about mappings are discussed with SDL_GameControllerAddMapping().
  ///
  /// \param gamecontroller the game controller you want to get the current
  /// mapping for
  /// \returns a string that has the controller's mapping or NULL if no mapping
  /// is available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerAddMapping
  /// \sa SDL_GameControllerMappingForGUID
  ffi.Pointer<ffi.Char> SDL_GameControllerMapping(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerMapping(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerMappingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerMapping');
  late final _SDL_GameControllerMapping =
      _SDL_GameControllerMappingPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>)>();

  /// Check if the given joystick is supported by the game controller interface.
  ///
  /// `joystick_index` is the same as the `device_index` passed to
  /// SDL_JoystickOpen().
  ///
  /// \param joystick_index the device_index of a device, up to
  /// SDL_NumJoysticks()
  /// \returns SDL_TRUE if the given joystick is supported by the game controller
  /// interface, SDL_FALSE if it isn't or it's an invalid index.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerNameForIndex
  /// \sa SDL_GameControllerOpen
  int SDL_IsGameController(
    int joystick_index,
  ) {
    return _SDL_IsGameController(
      joystick_index,
    );
  }

  late final _SDL_IsGameControllerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_IsGameController');
  late final _SDL_IsGameController =
      _SDL_IsGameControllerPtr.asFunction<int Function(int)>();

  /// Get the implementation dependent name for the game controller.
  ///
  /// This function can be called before any controllers are opened.
  ///
  /// `joystick_index` is the same as the `device_index` passed to
  /// SDL_JoystickOpen().
  ///
  /// \param joystick_index the device_index of a device, from zero to
  /// SDL_NumJoysticks()-1
  /// \returns the implementation-dependent name for the game controller, or NULL
  /// if there is no name or the index is invalid.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerName
  /// \sa SDL_GameControllerOpen
  /// \sa SDL_IsGameController
  ffi.Pointer<ffi.Char> SDL_GameControllerNameForIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerNameForIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerNameForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GameControllerNameForIndex');
  late final _SDL_GameControllerNameForIndex =
      _SDL_GameControllerNameForIndexPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the type of a game controller.
  ///
  /// This can be called before any controllers are opened.
  ///
  /// \param joystick_index the device_index of a device, from zero to
  /// SDL_NumJoysticks()-1
  /// \returns the controller type.
  ///
  /// \since This function is available since SDL 2.0.12.
  int SDL_GameControllerTypeForIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerTypeForIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerTypeForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GameControllerTypeForIndex');
  late final _SDL_GameControllerTypeForIndex =
      _SDL_GameControllerTypeForIndexPtr.asFunction<int Function(int)>();

  /// Get the mapping of a game controller.
  ///
  /// This can be called before any controllers are opened.
  ///
  /// \param joystick_index the device_index of a device, from zero to
  /// SDL_NumJoysticks()-1
  /// \returns the mapping string. Must be freed with SDL_free(). Returns NULL if
  /// no mapping is available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_GameControllerMappingForDeviceIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerMappingForDeviceIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerMappingForDeviceIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GameControllerMappingForDeviceIndex');
  late final _SDL_GameControllerMappingForDeviceIndex =
      _SDL_GameControllerMappingForDeviceIndexPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Open a game controller for use.
  ///
  /// `joystick_index` is the same as the `device_index` passed to
  /// SDL_JoystickOpen().
  ///
  /// The index passed as an argument refers to the N'th game controller on the
  /// system. This index is not the value which will identify this controller in
  /// future controller events. The joystick's instance id (SDL_JoystickID) will
  /// be used there instead.
  ///
  /// \param joystick_index the device_index of a device, up to
  /// SDL_NumJoysticks()
  /// \returns a gamecontroller identifier or NULL if an error occurred; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerClose
  /// \sa SDL_GameControllerNameForIndex
  /// \sa SDL_IsGameController
  ffi.Pointer<SDL_GameController> SDL_GameControllerOpen(
    int joystick_index,
  ) {
    return _SDL_GameControllerOpen(
      joystick_index,
    );
  }

  late final _SDL_GameControllerOpenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController> Function(
              ffi.Int)>>('SDL_GameControllerOpen');
  late final _SDL_GameControllerOpen = _SDL_GameControllerOpenPtr.asFunction<
      ffi.Pointer<SDL_GameController> Function(int)>();

  /// Get the SDL_GameController associated with an instance id.
  ///
  /// \param joyid the instance id to get the SDL_GameController for
  /// \returns an SDL_GameController on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ffi.Pointer<SDL_GameController> SDL_GameControllerFromInstanceID(
    int joyid,
  ) {
    return _SDL_GameControllerFromInstanceID(
      joyid,
    );
  }

  late final _SDL_GameControllerFromInstanceIDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController> Function(
              SDL_JoystickID)>>('SDL_GameControllerFromInstanceID');
  late final _SDL_GameControllerFromInstanceID =
      _SDL_GameControllerFromInstanceIDPtr.asFunction<
          ffi.Pointer<SDL_GameController> Function(int)>();

  /// Get the SDL_GameController associated with a player index.
  ///
  /// Please note that the player index is _not_ the device index, nor is it the
  /// instance id!
  ///
  /// \param player_index the player index, which is not the device index or the
  /// instance id!
  /// \returns the SDL_GameController associated with a player index.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_GameControllerGetPlayerIndex
  /// \sa SDL_GameControllerSetPlayerIndex
  ffi.Pointer<SDL_GameController> SDL_GameControllerFromPlayerIndex(
    int player_index,
  ) {
    return _SDL_GameControllerFromPlayerIndex(
      player_index,
    );
  }

  late final _SDL_GameControllerFromPlayerIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController> Function(
              ffi.Int)>>('SDL_GameControllerFromPlayerIndex');
  late final _SDL_GameControllerFromPlayerIndex =
      _SDL_GameControllerFromPlayerIndexPtr.asFunction<
          ffi.Pointer<SDL_GameController> Function(int)>();

  /// Get the implementation-dependent name for an opened game controller.
  ///
  /// This is the same name as returned by SDL_GameControllerNameForIndex(), but
  /// it takes a controller identifier instead of the (unstable) device index.
  ///
  /// \param gamecontroller a game controller identifier previously returned by
  /// SDL_GameControllerOpen()
  /// \returns the implementation dependent name for the game controller, or NULL
  /// if there is no name or the identifier passed is invalid.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerNameForIndex
  /// \sa SDL_GameControllerOpen
  ffi.Pointer<ffi.Char> SDL_GameControllerName(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerName(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerName');
  late final _SDL_GameControllerName = _SDL_GameControllerNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the type of this currently opened controller
  ///
  /// This is the same name as returned by SDL_GameControllerTypeForIndex(), but
  /// it takes a controller identifier instead of the (unstable) device index.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \returns the controller type.
  ///
  /// \since This function is available since SDL 2.0.12.
  int SDL_GameControllerGetType(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetType(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerGetType');
  late final _SDL_GameControllerGetType = _SDL_GameControllerGetTypePtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the player index of an opened game controller.
  ///
  /// For XInput controllers this returns the XInput user index.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \returns the player index for controller, or -1 if it's not available.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_GameControllerGetPlayerIndex(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetPlayerIndex(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetPlayerIndexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetPlayerIndex');
  late final _SDL_GameControllerGetPlayerIndex =
      _SDL_GameControllerGetPlayerIndexPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Set the player index of an opened game controller.
  ///
  /// \param gamecontroller the game controller object to adjust.
  /// \param player_index Player index to assign to this controller.
  ///
  /// \since This function is available since SDL 2.0.12.
  void SDL_GameControllerSetPlayerIndex(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int player_index,
  ) {
    return _SDL_GameControllerSetPlayerIndex(
      gamecontroller,
      player_index,
    );
  }

  late final _SDL_GameControllerSetPlayerIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_GameController>,
              ffi.Int)>>('SDL_GameControllerSetPlayerIndex');
  late final _SDL_GameControllerSetPlayerIndex =
      _SDL_GameControllerSetPlayerIndexPtr.asFunction<
          void Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the USB vendor ID of an opened controller, if available.
  ///
  /// If the vendor ID isn't available this function returns 0.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the USB vendor ID, or zero if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerGetVendor(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetVendor(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetVendorPtr = _lookup<
          ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetVendor');
  late final _SDL_GameControllerGetVendor = _SDL_GameControllerGetVendorPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the USB product ID of an opened controller, if available.
  ///
  /// If the product ID isn't available this function returns 0.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the USB product ID, or zero if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerGetProduct(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetProduct(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProductPtr = _lookup<
          ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetProduct');
  late final _SDL_GameControllerGetProduct = _SDL_GameControllerGetProductPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the product version of an opened controller, if available.
  ///
  /// If the product version isn't available this function returns 0.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the USB product version, or zero if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerGetProductVersion(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetProductVersion(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProductVersionPtr = _lookup<
          ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetProductVersion');
  late final _SDL_GameControllerGetProductVersion =
      _SDL_GameControllerGetProductVersionPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the serial number of an opened controller, if available.
  ///
  /// Returns the serial number of the controller, or NULL if it is not
  /// available.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the serial number, or NULL if unavailable.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<ffi.Char> SDL_GameControllerGetSerial(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetSerial(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetSerialPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerGetSerial');
  late final _SDL_GameControllerGetSerial =
      _SDL_GameControllerGetSerialPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>)>();

  /// Check if a controller has been opened and is currently connected.
  ///
  /// \param gamecontroller a game controller identifier previously returned by
  /// SDL_GameControllerOpen()
  /// \returns SDL_TRUE if the controller has been opened and is currently
  /// connected, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerClose
  /// \sa SDL_GameControllerOpen
  int SDL_GameControllerGetAttached(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetAttached(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetAttachedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetAttached');
  late final _SDL_GameControllerGetAttached = _SDL_GameControllerGetAttachedPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the Joystick ID from a Game Controller.
  ///
  /// This function will give you a SDL_Joystick object, which allows you to use
  /// the SDL_Joystick functions with a SDL_GameController object. This would be
  /// useful for getting a joystick's position at any given time, even if it
  /// hasn't moved (moving it would produce an event, which would have the axis'
  /// value).
  ///
  /// The pointer returned is owned by the SDL_GameController. You should not
  /// call SDL_JoystickClose() on it, for example, since doing so will likely
  /// cause SDL to crash.
  ///
  /// \param gamecontroller the game controller object that you want to get a
  /// joystick from
  /// \returns a SDL_Joystick object; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Joystick> SDL_GameControllerGetJoystick(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetJoystick(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetJoystickPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SDL_Joystick> Function(
                  ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetJoystick');
  late final _SDL_GameControllerGetJoystick =
      _SDL_GameControllerGetJoystickPtr.asFunction<
          ffi.Pointer<SDL_Joystick> Function(
              ffi.Pointer<SDL_GameController>)>();

  /// Query or change current state of Game Controller events.
  ///
  /// If controller events are disabled, you must call SDL_GameControllerUpdate()
  /// yourself and check the state of the controller when you want controller
  /// information.
  ///
  /// Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,
  /// and 1 will have any effect. Other numbers will just be returned.
  ///
  /// \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
  /// \returns the same value passed to the function, with exception to -1
  /// (SDL_QUERY), which will return the current state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickEventState
  int SDL_GameControllerEventState(
    int state,
  ) {
    return _SDL_GameControllerEventState(
      state,
    );
  }

  late final _SDL_GameControllerEventStatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GameControllerEventState');
  late final _SDL_GameControllerEventState =
      _SDL_GameControllerEventStatePtr.asFunction<int Function(int)>();

  /// Manually pump game controller updates if not using the loop.
  ///
  /// This function is called automatically by the event loop if events are
  /// enabled. Under such circumstances, it will not be necessary to call this
  /// function.
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GameControllerUpdate() {
    return _SDL_GameControllerUpdate();
  }

  late final _SDL_GameControllerUpdatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GameControllerUpdate');
  late final _SDL_GameControllerUpdate =
      _SDL_GameControllerUpdatePtr.asFunction<void Function()>();

  /// Convert a string into SDL_GameControllerAxis enum.
  ///
  /// This function is called internally to translate SDL_GameController mapping
  /// strings for the underlying joystick device into the consistent
  /// SDL_GameController mapping. You do not normally need to call this function
  /// unless you are parsing SDL_GameController mappings in your own code.
  ///
  /// Note specially that "righttrigger" and "lefttrigger" map to
  /// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,
  /// respectively.
  ///
  /// \param str string representing a SDL_GameController axis
  /// \returns the SDL_GameControllerAxis enum corresponding to the input string,
  /// or `SDL_CONTROLLER_AXIS_INVALID` if no match was found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetStringForAxis
  int SDL_GameControllerGetAxisFromString(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_GameControllerGetAxisFromString(
      str,
    );
  }

  late final _SDL_GameControllerGetAxisFromStringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GameControllerGetAxisFromString');
  late final _SDL_GameControllerGetAxisFromString =
      _SDL_GameControllerGetAxisFromStringPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>)>();

  /// Convert from an SDL_GameControllerAxis enum to a string.
  ///
  /// The caller should not SDL_free() the returned string.
  ///
  /// \param axis an enum value for a given SDL_GameControllerAxis
  /// \returns a string for the given axis, or NULL if an invalid axis is
  /// specified. The string returned is of the format used by
  /// SDL_GameController mapping strings.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetAxisFromString
  ffi.Pointer<ffi.Char> SDL_GameControllerGetStringForAxis(
    int axis,
  ) {
    return _SDL_GameControllerGetStringForAxis(
      axis,
    );
  }

  late final _SDL_GameControllerGetStringForAxisPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GameControllerGetStringForAxis');
  late final _SDL_GameControllerGetStringForAxis =
      _SDL_GameControllerGetStringForAxisPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the SDL joystick layer binding for a controller axis mapping.
  ///
  /// \param gamecontroller a game controller
  /// \param axis an axis enum value (one of the SDL_GameControllerAxis values)
  /// \returns a SDL_GameControllerButtonBind describing the bind. On failure
  /// (like the given Controller axis doesn't exist on the device), its
  /// `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetBindForButton
  SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetBindForAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetBindForAxisPtr = _lookup<
      ffi.NativeFunction<
          SDL_GameControllerButtonBind Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetBindForAxis');
  late final _SDL_GameControllerGetBindForAxis =
      _SDL_GameControllerGetBindForAxisPtr.asFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Query whether a game controller has a given axis.
  ///
  /// This merely reports whether the controller's mapping defined this axis, as
  /// that is all the information SDL has about the physical device.
  ///
  /// \param gamecontroller a game controller
  /// \param axis an axis enum value (an SDL_GameControllerAxis value)
  /// \returns SDL_TRUE if the controller has this axis, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasAxis(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerHasAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerHasAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerHasAxis');
  late final _SDL_GameControllerHasAxis = _SDL_GameControllerHasAxisPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of an axis control on a game controller.
  ///
  /// The axis indices start at index 0.
  ///
  /// The state is a value ranging from -32768 to 32767. Triggers, however, range
  /// from 0 to 32767 (they never return a negative value).
  ///
  /// \param gamecontroller a game controller
  /// \param axis an axis index (one of the SDL_GameControllerAxis values)
  /// \returns axis state (including 0) on success or 0 (also) on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetButton
  int SDL_GameControllerGetAxis(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetAxisPtr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetAxis');
  late final _SDL_GameControllerGetAxis = _SDL_GameControllerGetAxisPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Convert a string into an SDL_GameControllerButton enum.
  ///
  /// This function is called internally to translate SDL_GameController mapping
  /// strings for the underlying joystick device into the consistent
  /// SDL_GameController mapping. You do not normally need to call this function
  /// unless you are parsing SDL_GameController mappings in your own code.
  ///
  /// \param str string representing a SDL_GameController axis
  /// \returns the SDL_GameControllerButton enum corresponding to the input
  /// string, or `SDL_CONTROLLER_AXIS_INVALID` if no match was found.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GameControllerGetButtonFromString(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_GameControllerGetButtonFromString(
      str,
    );
  }

  late final _SDL_GameControllerGetButtonFromStringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GameControllerGetButtonFromString');
  late final _SDL_GameControllerGetButtonFromString =
      _SDL_GameControllerGetButtonFromStringPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>)>();

  /// Convert from an SDL_GameControllerButton enum to a string.
  ///
  /// The caller should not SDL_free() the returned string.
  ///
  /// \param button an enum value for a given SDL_GameControllerButton
  /// \returns a string for the given button, or NULL if an invalid axis is
  /// specified. The string returned is of the format used by
  /// SDL_GameController mapping strings.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetButtonFromString
  ffi.Pointer<ffi.Char> SDL_GameControllerGetStringForButton(
    int button,
  ) {
    return _SDL_GameControllerGetStringForButton(
      button,
    );
  }

  late final _SDL_GameControllerGetStringForButtonPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GameControllerGetStringForButton');
  late final _SDL_GameControllerGetStringForButton =
      _SDL_GameControllerGetStringForButtonPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the SDL joystick layer binding for a controller button mapping.
  ///
  /// \param gamecontroller a game controller
  /// \param button an button enum value (an SDL_GameControllerButton value)
  /// \returns a SDL_GameControllerButtonBind describing the bind. On failure
  /// (like the given Controller button doesn't exist on the device),
  /// its `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetBindForAxis
  SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetBindForButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetBindForButtonPtr = _lookup<
      ffi.NativeFunction<
          SDL_GameControllerButtonBind Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetBindForButton');
  late final _SDL_GameControllerGetBindForButton =
      _SDL_GameControllerGetBindForButtonPtr.asFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Query whether a game controller has a given button.
  ///
  /// This merely reports whether the controller's mapping defined this button,
  /// as that is all the information SDL has about the physical device.
  ///
  /// \param gamecontroller a game controller
  /// \param button a button enum value (an SDL_GameControllerButton value)
  /// \returns SDL_TRUE if the controller has this button, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasButton(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerHasButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerHasButtonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerHasButton');
  late final _SDL_GameControllerHasButton = _SDL_GameControllerHasButtonPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of a button on a game controller.
  ///
  /// \param gamecontroller a game controller
  /// \param button a button index (one of the SDL_GameControllerButton values)
  /// \returns 1 for pressed state or 0 for not pressed state or error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetAxis
  int SDL_GameControllerGetButton(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetButtonPtr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetButton');
  late final _SDL_GameControllerGetButton = _SDL_GameControllerGetButtonPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the number of touchpads on a game controller.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetNumTouchpads(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetNumTouchpads(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetNumTouchpadsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetNumTouchpads');
  late final _SDL_GameControllerGetNumTouchpads =
      _SDL_GameControllerGetNumTouchpadsPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the number of supported simultaneous fingers on a touchpad on a game
  /// controller.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetNumTouchpadFingers(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int touchpad,
  ) {
    return _SDL_GameControllerGetNumTouchpadFingers(
      gamecontroller,
      touchpad,
    );
  }

  late final _SDL_GameControllerGetNumTouchpadFingersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>,
              ffi.Int)>>('SDL_GameControllerGetNumTouchpadFingers');
  late final _SDL_GameControllerGetNumTouchpadFingers =
      _SDL_GameControllerGetNumTouchpadFingersPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of a finger on a touchpad on a game controller.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetTouchpadFinger(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int touchpad,
    int finger,
    ffi.Pointer<Uint8> state,
    ffi.Pointer<ffi.Float> x,
    ffi.Pointer<ffi.Float> y,
    ffi.Pointer<ffi.Float> pressure,
  ) {
    return _SDL_GameControllerGetTouchpadFinger(
      gamecontroller,
      touchpad,
      finger,
      state,
      x,
      y,
      pressure,
    );
  }

  late final _SDL_GameControllerGetTouchpadFingerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_GameController>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GameControllerGetTouchpadFinger');
  late final _SDL_GameControllerGetTouchpadFinger =
      _SDL_GameControllerGetTouchpadFingerPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_GameController>,
              int,
              int,
              ffi.Pointer<Uint8>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>();

  /// Return whether a game controller has a particular sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \returns SDL_TRUE if the sensor exists, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasSensor(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerHasSensor(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerHasSensorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerHasSensor');
  late final _SDL_GameControllerHasSensor = _SDL_GameControllerHasSensorPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Set whether data reporting for a game controller sensor is enabled.
  ///
  /// \param gamecontroller The controller to update
  /// \param type The type of sensor to enable/disable
  /// \param enabled Whether data reporting should be enabled
  /// \returns 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerSetSensorEnabled(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
    int enabled,
  ) {
    return _SDL_GameControllerSetSensorEnabled(
      gamecontroller,
      type,
      enabled,
    );
  }

  late final _SDL_GameControllerSetSensorEnabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, ffi.Int32,
              ffi.Int32)>>('SDL_GameControllerSetSensorEnabled');
  late final _SDL_GameControllerSetSensorEnabled =
      _SDL_GameControllerSetSensorEnabledPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int)>();

  /// Query whether sensor data reporting is enabled for a game controller.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \returns SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerIsSensorEnabled(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerIsSensorEnabled(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerIsSensorEnabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerIsSensorEnabled');
  late final _SDL_GameControllerIsSensorEnabled =
      _SDL_GameControllerIsSensorEnabledPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the data rate (number of events per second) of a game controller
  /// sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \return the data rate, or 0.0f if the data rate is not available.
  ///
  /// \since This function is available since SDL 2.0.16.
  double SDL_GameControllerGetSensorDataRate(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerGetSensorDataRate(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerGetSensorDataRatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetSensorDataRate');
  late final _SDL_GameControllerGetSensorDataRate =
      _SDL_GameControllerGetSensorDataRatePtr.asFunction<
          double Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of a game controller sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  /// See SDL_sensor.h for the details for each type of sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  /// \return 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetSensorData(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_GameControllerGetSensorData(
      gamecontroller,
      type,
      data,
      num_values,
    );
  }

  late final _SDL_GameControllerGetSensorDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_GameController>,
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Int)>>('SDL_GameControllerGetSensorData');
  late final _SDL_GameControllerGetSensorData =
      _SDL_GameControllerGetSensorDataPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int,
              ffi.Pointer<ffi.Float>, int)>();

  /// Start a rumble effect on a game controller.
  ///
  /// Each call to this function cancels any previous rumble effect, and calling
  /// it with 0 intensity stops any rumbling.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left)
  /// rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right)
  /// rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if rumble isn't supported on this controller
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GameControllerHasRumble
  int SDL_GameControllerRumble(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumble(
      gamecontroller,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, Uint16, Uint16,
              Uint32)>>('SDL_GameControllerRumble');
  late final _SDL_GameControllerRumble =
      _SDL_GameControllerRumblePtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int, int)>();

  /// Start a rumble effect in the game controller's triggers.
  ///
  /// Each call to this function cancels any previous trigger rumble effect, and
  /// calling it with 0 intensity stops any rumbling.
  ///
  /// Note that this is rumbling of the _triggers_ and not the game controller as
  /// a whole. The first controller to offer this feature was the PlayStation 5's
  /// DualShock 5.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if trigger rumble isn't supported on this controller
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GameControllerHasRumbleTriggers
  int SDL_GameControllerRumbleTriggers(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumbleTriggers(
      gamecontroller,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumbleTriggersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, Uint16, Uint16,
              Uint32)>>('SDL_GameControllerRumbleTriggers');
  late final _SDL_GameControllerRumbleTriggers =
      _SDL_GameControllerRumbleTriggersPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int, int)>();

  /// Query whether a game controller has an LED.
  ///
  /// \param gamecontroller The controller to query
  /// \returns SDL_TRUE, or SDL_FALSE if this controller does not have a
  /// modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasLED(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasLED(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasLEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerHasLED');
  late final _SDL_GameControllerHasLED = _SDL_GameControllerHasLEDPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Query whether a game controller has rumble support.
  ///
  /// \param gamecontroller The controller to query
  /// \returns SDL_TRUE, or SDL_FALSE if this controller does not have rumble
  /// support
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerRumble
  int SDL_GameControllerHasRumble(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasRumble(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasRumblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerHasRumble');
  late final _SDL_GameControllerHasRumble = _SDL_GameControllerHasRumblePtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Query whether a game controller has rumble support on triggers.
  ///
  /// \param gamecontroller The controller to query
  /// \returns SDL_TRUE, or SDL_FALSE if this controller does not have trigger
  /// rumble support
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerRumbleTriggers
  int SDL_GameControllerHasRumbleTriggers(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasRumbleTriggers(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasRumbleTriggersPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerHasRumbleTriggers');
  late final _SDL_GameControllerHasRumbleTriggers =
      _SDL_GameControllerHasRumbleTriggersPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Update a game controller's LED color.
  ///
  /// \param gamecontroller The controller to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  /// \returns 0, or -1 if this controller does not have a modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerSetLED(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_GameControllerSetLED(
      gamecontroller,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GameControllerSetLEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, Uint8, Uint8,
              Uint8)>>('SDL_GameControllerSetLED');
  late final _SDL_GameControllerSetLED =
      _SDL_GameControllerSetLEDPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int, int)>();

  /// Send a controller specific effect packet
  ///
  /// \param gamecontroller The controller to affect
  /// \param data The data to send to the controller
  /// \param size The size of the data to send to the controller
  /// \returns 0, or -1 if this controller or driver doesn't support effect
  /// packets
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_GameControllerSendEffect(
    ffi.Pointer<SDL_GameController> gamecontroller,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _SDL_GameControllerSendEffect(
      gamecontroller,
      data,
      size,
    );
  }

  late final _SDL_GameControllerSendEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>,
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_GameControllerSendEffect');
  late final _SDL_GameControllerSendEffect =
      _SDL_GameControllerSendEffectPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_GameController>, ffi.Pointer<ffi.Void>, int)>();

  /// Close a game controller previously opened with SDL_GameControllerOpen().
  ///
  /// \param gamecontroller a game controller identifier previously returned by
  /// SDL_GameControllerOpen()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerOpen
  void SDL_GameControllerClose(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerClose(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerClosePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerClose');
  late final _SDL_GameControllerClose = _SDL_GameControllerClosePtr.asFunction<
      void Function(ffi.Pointer<SDL_GameController>)>();

  /// Return the sfSymbolsName for a given button on a game controller on Apple
  /// platforms.
  ///
  /// \param gamecontroller the controller to query
  /// \param button a button on the game controller
  /// \returns the sfSymbolsName or NULL if the name can't be found
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerGetAppleSFSymbolsNameForAxis
  ffi.Pointer<ffi.Char> SDL_GameControllerGetAppleSFSymbolsNameForButton(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetAppleSFSymbolsNameForButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetAppleSFSymbolsNameForButtonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetAppleSFSymbolsNameForButton');
  late final _SDL_GameControllerGetAppleSFSymbolsNameForButton =
      _SDL_GameControllerGetAppleSFSymbolsNameForButtonPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Return the sfSymbolsName for a given axis on a game controller on Apple
  /// platforms.
  ///
  /// \param gamecontroller the controller to query
  /// \param axis an axis on the game controller
  /// \returns the sfSymbolsName or NULL if the name can't be found
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerGetAppleSFSymbolsNameForButton
  ffi.Pointer<ffi.Char> SDL_GameControllerGetAppleSFSymbolsNameForAxis(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetAppleSFSymbolsNameForAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetAppleSFSymbolsNameForAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetAppleSFSymbolsNameForAxis');
  late final _SDL_GameControllerGetAppleSFSymbolsNameForAxis =
      _SDL_GameControllerGetAppleSFSymbolsNameForAxisPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Get the number of registered touch devices.
  ///
  /// On some platforms SDL first sees the touch device if it was actually used.
  /// Therefore SDL_GetNumTouchDevices() may return 0 although devices are
  /// available. After using all devices at least once the number will be
  /// correct.
  ///
  /// This was fixed for Android in SDL 2.0.1.
  ///
  /// \returns the number of registered touch devices.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTouchDevice
  int SDL_GetNumTouchDevices() {
    return _SDL_GetNumTouchDevices();
  }

  late final _SDL_GetNumTouchDevicesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumTouchDevices');
  late final _SDL_GetNumTouchDevices =
      _SDL_GetNumTouchDevicesPtr.asFunction<int Function()>();

  /// Get the touch ID with the given index.
  ///
  /// \param index the touch device index
  /// \returns the touch ID with the given index on success or 0 if the index is
  /// invalid; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumTouchDevices
  int SDL_GetTouchDevice(
    int index,
  ) {
    return _SDL_GetTouchDevice(
      index,
    );
  }

  late final _SDL_GetTouchDevicePtr =
      _lookup<ffi.NativeFunction<SDL_TouchID Function(ffi.Int)>>(
          'SDL_GetTouchDevice');
  late final _SDL_GetTouchDevice =
      _SDL_GetTouchDevicePtr.asFunction<int Function(int)>();

  /// Get the type of the given touch device.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_GetTouchDeviceType(
    int touchID,
  ) {
    return _SDL_GetTouchDeviceType(
      touchID,
    );
  }

  late final _SDL_GetTouchDeviceTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TouchID)>>(
          'SDL_GetTouchDeviceType');
  late final _SDL_GetTouchDeviceType =
      _SDL_GetTouchDeviceTypePtr.asFunction<int Function(int)>();

  /// Get the number of active fingers for a given touch device.
  ///
  /// \param touchID the ID of a touch device
  /// \returns the number of active fingers for a given touch device on success
  /// or 0 on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTouchFinger
  int SDL_GetNumTouchFingers(
    int touchID,
  ) {
    return _SDL_GetNumTouchFingers(
      touchID,
    );
  }

  late final _SDL_GetNumTouchFingersPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_TouchID)>>(
          'SDL_GetNumTouchFingers');
  late final _SDL_GetNumTouchFingers =
      _SDL_GetNumTouchFingersPtr.asFunction<int Function(int)>();

  /// Get the finger object for specified touch device ID and finger index.
  ///
  /// The returned resource is owned by SDL and should not be deallocated.
  ///
  /// \param touchID the ID of the requested touch device
  /// \param index the index of the requested finger
  /// \returns a pointer to the SDL_Finger object or NULL if no object at the
  /// given ID and index could be found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RecordGesture
  ffi.Pointer<SDL_Finger> SDL_GetTouchFinger(
    int touchID,
    int index,
  ) {
    return _SDL_GetTouchFinger(
      touchID,
      index,
    );
  }

  late final _SDL_GetTouchFingerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Finger> Function(
              SDL_TouchID, ffi.Int)>>('SDL_GetTouchFinger');
  late final _SDL_GetTouchFinger = _SDL_GetTouchFingerPtr.asFunction<
      ffi.Pointer<SDL_Finger> Function(int, int)>();

  /// Begin recording a gesture on a specified touch device or all touch devices.
  ///
  /// If the parameter `touchId` is -1 (i.e., all devices), this function will
  /// always return 1, regardless of whether there actually are any devices.
  ///
  /// \param touchId the touch device id, or -1 for all touch devices
  /// \returns 1 on success or 0 if the specified device could not be found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTouchDevice
  int SDL_RecordGesture(
    int touchId,
  ) {
    return _SDL_RecordGesture(
      touchId,
    );
  }

  late final _SDL_RecordGesturePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_TouchID)>>(
          'SDL_RecordGesture');
  late final _SDL_RecordGesture =
      _SDL_RecordGesturePtr.asFunction<int Function(int)>();

  /// Save all currently loaded Dollar Gesture templates.
  ///
  /// \param dst a SDL_RWops to save to
  /// \returns the number of saved templates on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadDollarTemplates
  /// \sa SDL_SaveDollarTemplate
  int SDL_SaveAllDollarTemplates(
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveAllDollarTemplates(
      dst,
    );
  }

  late final _SDL_SaveAllDollarTemplatesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_SaveAllDollarTemplates');
  late final _SDL_SaveAllDollarTemplates = _SDL_SaveAllDollarTemplatesPtr
      .asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Save a currently loaded Dollar Gesture template.
  ///
  /// \param gestureId a gesture id
  /// \param dst a SDL_RWops to save to
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadDollarTemplates
  /// \sa SDL_SaveAllDollarTemplates
  int SDL_SaveDollarTemplate(
    int gestureId,
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveDollarTemplate(
      gestureId,
      dst,
    );
  }

  late final _SDL_SaveDollarTemplatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_GestureID,
              ffi.Pointer<SDL_RWops>)>>('SDL_SaveDollarTemplate');
  late final _SDL_SaveDollarTemplate = _SDL_SaveDollarTemplatePtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RWops>)>();

  /// Load Dollar Gesture templates from a file.
  ///
  /// \param touchId a touch id
  /// \param src a SDL_RWops to load from
  /// \returns the number of loaded templates on success or a negative error code
  /// (or 0) on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SaveAllDollarTemplates
  /// \sa SDL_SaveDollarTemplate
  int SDL_LoadDollarTemplates(
    int touchId,
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_LoadDollarTemplates(
      touchId,
      src,
    );
  }

  late final _SDL_LoadDollarTemplatesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              SDL_TouchID, ffi.Pointer<SDL_RWops>)>>('SDL_LoadDollarTemplates');
  late final _SDL_LoadDollarTemplates = _SDL_LoadDollarTemplatesPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RWops>)>();

  /// Pump the event loop, gathering events from the input devices.
  ///
  /// This function updates the event queue and internal input device state.
  ///
  /// **WARNING**: This should only be run in the thread that initialized the
  /// video subsystem, and for extra safety, you should consider only doing those
  /// things on the main thread in any case.
  ///
  /// SDL_PumpEvents() gathers all the pending input information from devices and
  /// places it in the event queue. Without calls to SDL_PumpEvents() no events
  /// would ever be placed on the queue. Often the need for calls to
  /// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
  /// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
  /// polling or waiting for events (e.g. you are filtering them), then you must
  /// call SDL_PumpEvents() to force an event queue update.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_WaitEvent
  void SDL_PumpEvents() {
    return _SDL_PumpEvents();
  }

  late final _SDL_PumpEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_PumpEvents');
  late final _SDL_PumpEvents = _SDL_PumpEventsPtr.asFunction<void Function()>();

  /// Check the event queue for messages and optionally return them.
  ///
  /// `action` may be any of the following:
  ///
  /// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
  /// event queue.
  /// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
  /// within the specified minimum and maximum type, will be returned to the
  /// caller and will _not_ be removed from the queue.
  /// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
  /// within the specified minimum and maximum type, will be returned to the
  /// caller and will be removed from the queue.
  ///
  /// You may have to call SDL_PumpEvents() before calling this function.
  /// Otherwise, the events may not be ready to be filtered when you call
  /// SDL_PeepEvents().
  ///
  /// This function is thread-safe.
  ///
  /// \param events destination buffer for the retrieved events
  /// \param numevents if action is SDL_ADDEVENT, the number of events to add
  /// back to the event queue; if action is SDL_PEEKEVENT or
  /// SDL_GETEVENT, the maximum number of events to retrieve
  /// \param action action to take; see [[#action|Remarks]] for details
  /// \param minType minimum value of the event type to be considered;
  /// SDL_FIRSTEVENT is a safe choice
  /// \param maxType maximum value of the event type to be considered;
  /// SDL_LASTEVENT is a safe choice
  /// \returns the number of events actually stored or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_PushEvent
  int SDL_PeepEvents(
    ffi.Pointer<SDL_Event> events,
    int numevents,
    int action,
    int minType,
    int maxType,
  ) {
    return _SDL_PeepEvents(
      events,
      numevents,
      action,
      minType,
      maxType,
    );
  }

  late final _SDL_PeepEventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Event>, ffi.Int, ffi.Int32, Uint32,
              Uint32)>>('SDL_PeepEvents');
  late final _SDL_PeepEvents = _SDL_PeepEventsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int, int, int, int)>();

  /// Check for the existence of a certain event type in the event queue.
  ///
  /// If you need to check for a range of event types, use SDL_HasEvents()
  /// instead.
  ///
  /// \param type the type of event to be queried; see SDL_EventType for details
  /// \returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if
  /// events matching `type` are not present.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasEvents
  int SDL_HasEvent(
    int type,
  ) {
    return _SDL_HasEvent(
      type,
    );
  }

  late final _SDL_HasEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32)>>('SDL_HasEvent');
  late final _SDL_HasEvent = _SDL_HasEventPtr.asFunction<int Function(int)>();

  /// Check for the existence of certain event types in the event queue.
  ///
  /// If you need to check for a single event type, use SDL_HasEvent() instead.
  ///
  /// \param minType the low end of event type to be queried, inclusive; see
  /// SDL_EventType for details
  /// \param maxType the high end of event type to be queried, inclusive; see
  /// SDL_EventType for details
  /// \returns SDL_TRUE if events with type >= `minType` and <= `maxType` are
  /// present, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasEvents
  int SDL_HasEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_HasEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_HasEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32, Uint32)>>(
          'SDL_HasEvents');
  late final _SDL_HasEvents =
      _SDL_HasEventsPtr.asFunction<int Function(int, int)>();

  /// Clear events of a specific type from the event queue.
  ///
  /// This will unconditionally remove any events from the queue that match
  /// `type`. If you need to remove a range of event types, use SDL_FlushEvents()
  /// instead.
  ///
  /// It's also normal to just ignore events you don't care about in your event
  /// loop without calling this function.
  ///
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  ///
  /// \param type the type of event to be cleared; see SDL_EventType for details
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FlushEvents
  void SDL_FlushEvent(
    int type,
  ) {
    return _SDL_FlushEvent(
      type,
    );
  }

  late final _SDL_FlushEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_FlushEvent');
  late final _SDL_FlushEvent =
      _SDL_FlushEventPtr.asFunction<void Function(int)>();

  /// Clear events of a range of types from the event queue.
  ///
  /// This will unconditionally remove any events from the queue that are in the
  /// range of `minType` to `maxType`, inclusive. If you need to remove a single
  /// event type, use SDL_FlushEvent() instead.
  ///
  /// It's also normal to just ignore events you don't care about in your event
  /// loop without calling this function.
  ///
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  ///
  /// \param minType the low end of event type to be cleared, inclusive; see
  /// SDL_EventType for details
  /// \param maxType the high end of event type to be cleared, inclusive; see
  /// SDL_EventType for details
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FlushEvent
  void SDL_FlushEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_FlushEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_FlushEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32, Uint32)>>(
          'SDL_FlushEvents');
  late final _SDL_FlushEvents =
      _SDL_FlushEventsPtr.asFunction<void Function(int, int)>();

  /// Poll for currently pending events.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`. The 1 returned refers to
  /// this event, immediately stored in the SDL Event structure -- not an event
  /// to follow.
  ///
  /// If `event` is NULL, it simply returns 1 if there is an event in the queue,
  /// but will not remove it from the queue.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that set the video mode.
  ///
  /// SDL_PollEvent() is the favored way of receiving system events since it can
  /// be done from the main loop and does not suspend the main loop while waiting
  /// on an event to be posted.
  ///
  /// The common practice is to fully process the event queue once every frame,
  /// usually as a first step before updating the game's state:
  ///
  /// ```c
  /// while (game_is_still_running) {
  /// SDL_Event event;
  /// while (SDL_PollEvent(&event)) {  // poll until all events are handled!
  /// // decide what to do with this event.
  /// }
  ///
  /// // update game state, draw the current frame
  /// }
  /// ```
  ///
  /// \param event the SDL_Event structure to be filled with the next event from
  /// the queue, or NULL
  /// \returns 1 if there is a pending event or 0 if there are none available.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventFilter
  /// \sa SDL_PeepEvents
  /// \sa SDL_PushEvent
  /// \sa SDL_SetEventFilter
  /// \sa SDL_WaitEvent
  /// \sa SDL_WaitEventTimeout
  int SDL_PollEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PollEvent(
      event,
    );
  }

  late final _SDL_PollEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PollEvent');
  late final _SDL_PollEvent =
      _SDL_PollEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Wait indefinitely for the next available event.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that initialized the video subsystem.
  ///
  /// \param event the SDL_Event structure to be filled in with the next event
  /// from the queue, or NULL
  /// \returns 1 on success or 0 if there was an error while waiting for events;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_WaitEventTimeout
  int SDL_WaitEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_WaitEvent(
      event,
    );
  }

  late final _SDL_WaitEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_WaitEvent');
  late final _SDL_WaitEvent =
      _SDL_WaitEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Wait until the specified timeout (in milliseconds) for the next available
  /// event.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that initialized the video subsystem.
  ///
  /// \param event the SDL_Event structure to be filled in with the next event
  /// from the queue, or NULL
  /// \param timeout the maximum number of milliseconds to wait for the next
  /// available event
  /// \returns 1 on success or 0 if there was an error while waiting for events;
  /// call SDL_GetError() for more information. This also returns 0 if
  /// the timeout elapsed without an event arriving.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_WaitEvent
  int SDL_WaitEventTimeout(
    ffi.Pointer<SDL_Event> event,
    int timeout,
  ) {
    return _SDL_WaitEventTimeout(
      event,
      timeout,
    );
  }

  late final _SDL_WaitEventTimeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Event>, ffi.Int)>>('SDL_WaitEventTimeout');
  late final _SDL_WaitEventTimeout = _SDL_WaitEventTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int)>();

  /// Add an event to the event queue.
  ///
  /// The event queue can actually be used as a two way communication channel.
  /// Not only can events be read from the queue, but the user can also push
  /// their own events onto it. `event` is a pointer to the event structure you
  /// wish to push onto the queue. The event is copied into the queue, and the
  /// caller may dispose of the memory pointed to after SDL_PushEvent() returns.
  ///
  /// Note: Pushing device input events onto the queue doesn't modify the state
  /// of the device within SDL.
  ///
  /// This function is thread-safe, and can be called from other threads safely.
  ///
  /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
  /// the event filter but events added with SDL_PeepEvents() do not.
  ///
  /// For pushing application-specific events, please use SDL_RegisterEvents() to
  /// get an event type that does not conflict with other code that also wants
  /// its own custom event types.
  ///
  /// \param event the SDL_Event to be added to the queue
  /// \returns 1 on success, 0 if the event was filtered, or a negative error
  /// code on failure; call SDL_GetError() for more information. A
  /// common reason for error is the event queue being full.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PeepEvents
  /// \sa SDL_PollEvent
  /// \sa SDL_RegisterEvents
  int SDL_PushEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PushEvent(
      event,
    );
  }

  late final _SDL_PushEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PushEvent');
  late final _SDL_PushEvent =
      _SDL_PushEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Set up a filter to process all events before they change internal state and
  /// are posted to the internal event queue.
  ///
  /// If the filter function returns 1 when called, then the event will be added
  /// to the internal queue. If it returns 0, then the event will be dropped from
  /// the queue, but the internal state will still be updated. This allows
  /// selective filtering of dynamically arriving events.
  ///
  /// **WARNING**: Be very careful of what you do in the event filter function,
  /// as it may run in a different thread!
  ///
  /// On platforms that support it, if the quit event is generated by an
  /// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
  /// application at the next event poll.
  ///
  /// There is one caveat when dealing with the ::SDL_QuitEvent event type. The
  /// event filter is only called when the window manager desires to close the
  /// application window. If the event filter returns 1, then the window will be
  /// closed, otherwise the window will remain open if possible.
  ///
  /// Note: Disabled events never make it to the event filter function; see
  /// SDL_EventState().
  ///
  /// Note: If you just want to inspect events without filtering, you should use
  /// SDL_AddEventWatch() instead.
  ///
  /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
  /// the event filter, but events pushed onto the queue with SDL_PeepEvents() do
  /// not.
  ///
  /// \param filter An SDL_EventFilter function to call when an event happens
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddEventWatch
  /// \sa SDL_EventState
  /// \sa SDL_GetEventFilter
  /// \sa SDL_PeepEvents
  /// \sa SDL_PushEvent
  void SDL_SetEventFilter(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetEventFilter(
      filter,
      userdata,
    );
  }

  late final _SDL_SetEventFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_SetEventFilter');
  late final _SDL_SetEventFilter = _SDL_SetEventFilterPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Query the current event filter.
  ///
  /// This function can be used to "chain" filters, by saving the existing filter
  /// before replacing it with a function that will call that saved filter.
  ///
  /// \param filter the current callback function will be stored here
  /// \param userdata the pointer that is passed to the current event filter will
  /// be stored here
  /// \returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetEventFilter
  int SDL_GetEventFilter(
    ffi.Pointer<SDL_EventFilter> filter,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_GetEventFilter(
      filter,
      userdata,
    );
  }

  late final _SDL_GetEventFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_EventFilter>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetEventFilter');
  late final _SDL_GetEventFilter = _SDL_GetEventFilterPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_EventFilter>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Add a callback to be triggered when an event is added to the event queue.
  ///
  /// `filter` will be called when an event happens, and its return value is
  /// ignored.
  ///
  /// **WARNING**: Be very careful of what you do in the event filter function,
  /// as it may run in a different thread!
  ///
  /// If the quit event is generated by a signal (e.g. SIGINT), it will bypass
  /// the internal queue and be delivered to the watch callback immediately, and
  /// arrive at the next event poll.
  ///
  /// Note: the callback is called for events posted by the user through
  /// SDL_PushEvent(), but not for disabled events, nor for events by a filter
  /// callback set with SDL_SetEventFilter(), nor for events posted by the user
  /// through SDL_PeepEvents().
  ///
  /// \param filter an SDL_EventFilter function to call when an event happens.
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DelEventWatch
  /// \sa SDL_SetEventFilter
  void SDL_AddEventWatch(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddEventWatch(
      filter,
      userdata,
    );
  }

  late final _SDL_AddEventWatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_AddEventWatch');
  late final _SDL_AddEventWatch = _SDL_AddEventWatchPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Remove an event watch callback added with SDL_AddEventWatch().
  ///
  /// This function takes the same input as SDL_AddEventWatch() to identify and
  /// delete the corresponding callback.
  ///
  /// \param filter the function originally passed to SDL_AddEventWatch()
  /// \param userdata the pointer originally passed to SDL_AddEventWatch()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddEventWatch
  void SDL_DelEventWatch(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelEventWatch(
      filter,
      userdata,
    );
  }

  late final _SDL_DelEventWatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_DelEventWatch');
  late final _SDL_DelEventWatch = _SDL_DelEventWatchPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Run a specific filter function on the current event queue, removing any
  /// events for which the filter returns 0.
  ///
  /// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
  /// this function does not change the filter permanently, it only uses the
  /// supplied filter until this function returns.
  ///
  /// \param filter the SDL_EventFilter function to call when an event happens
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventFilter
  /// \sa SDL_SetEventFilter
  void SDL_FilterEvents(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_FilterEvents(
      filter,
      userdata,
    );
  }

  late final _SDL_FilterEventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_FilterEvents');
  late final _SDL_FilterEvents = _SDL_FilterEventsPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Set the state of processing events by type.
  ///
  /// `state` may be any of the following:
  ///
  /// - `SDL_QUERY`: returns the current processing state of the specified event
  /// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped
  /// from the event queue and will not be filtered
  /// - `SDL_ENABLE`: the event will be processed normally
  ///
  /// \param type the type of event; see SDL_EventType for details
  /// \param state how to process the event
  /// \returns `SDL_DISABLE` or `SDL_ENABLE`, representing the processing state
  /// of the event before this function makes any changes to it.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventState
  int SDL_EventState(
    int type,
    int state,
  ) {
    return _SDL_EventState(
      type,
      state,
    );
  }

  late final _SDL_EventStatePtr =
      _lookup<ffi.NativeFunction<Uint8 Function(Uint32, ffi.Int)>>(
          'SDL_EventState');
  late final _SDL_EventState =
      _SDL_EventStatePtr.asFunction<int Function(int, int)>();

  /// Allocate a set of user-defined events, and return the beginning event
  /// number for that set of events.
  ///
  /// Calling this function with `numevents` <= 0 is an error and will return
  /// (Uint32)-1.
  ///
  /// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or
  /// 0xFFFFFFFF), but is clearer to write.
  ///
  /// \param numevents the number of events to be allocated
  /// \returns the beginning event number, or (Uint32)-1 if there are not enough
  /// user-defined events left.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PushEvent
  int SDL_RegisterEvents(
    int numevents,
  ) {
    return _SDL_RegisterEvents(
      numevents,
    );
  }

  late final _SDL_RegisterEventsPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Int)>>(
          'SDL_RegisterEvents');
  late final _SDL_RegisterEvents =
      _SDL_RegisterEventsPtr.asFunction<int Function(int)>();

  /// Get the directory where the application was run from.
  ///
  /// This is not necessarily a fast call, so you should call this once near
  /// startup and save the string if you need it.
  ///
  /// **Mac OS X and iOS Specific Functionality**: If the application is in a
  /// ".app" bundle, this function returns the Resource directory (e.g.
  /// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
  /// a property to the Info.plist file. Adding a string key with the name
  /// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
  /// behaviour.
  ///
  /// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
  /// application in /Applications/SDLApp/MyApp.app):
  ///
  /// - `resource`: bundle resource directory (the default). For example:
  /// `/Applications/SDLApp/MyApp.app/Contents/Resources`
  /// - `bundle`: the Bundle directory. For example:
  /// `/Applications/SDLApp/MyApp.app/`
  /// - `parent`: the containing directory of the bundle. For example:
  /// `/Applications/SDLApp/`
  ///
  /// The returned path is guaranteed to end with a path separator ('\' on
  /// Windows, '/' on most other platforms).
  ///
  /// The pointer returned is owned by the caller. Please call SDL_free() on the
  /// pointer when done with it.
  ///
  /// \returns an absolute path in UTF-8 encoding to the application data
  /// directory. NULL will be returned on error or when the platform
  /// doesn't implement this functionality, call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_GetPrefPath
  ffi.Pointer<ffi.Char> SDL_GetBasePath() {
    return _SDL_GetBasePath();
  }

  late final _SDL_GetBasePathPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetBasePath');
  late final _SDL_GetBasePath =
      _SDL_GetBasePathPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the user-and-app-specific path where files can be written.
  ///
  /// Get the "pref dir". This is meant to be where users can write personal
  /// files (preferences and save games, etc) that are specific to your
  /// application. This directory is unique per user, per application.
  ///
  /// This function will decide the appropriate location in the native
  /// filesystem, create the directory if necessary, and return a string of the
  /// absolute path to the directory in UTF-8 encoding.
  ///
  /// On Windows, the string might look like:
  ///
  /// `C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\`
  ///
  /// On Linux, the string might look like"
  ///
  /// `/home/bob/.local/share/My Program Name/`
  ///
  /// On Mac OS X, the string might look like:
  ///
  /// `/Users/bob/Library/Application Support/My Program Name/`
  ///
  /// You should assume the path returned by this function is the only safe place
  /// to write files (and that SDL_GetBasePath(), while it might be writable, or
  /// even the parent of the returned path, isn't where you should be writing
  /// things).
  ///
  /// Both the org and app strings may become part of a directory name, so please
  /// follow these rules:
  ///
  /// - Try to use the same org string (_including case-sensitivity_) for all
  /// your applications that use this function.
  /// - Always use a unique app string for each one, and make sure it never
  /// changes for an app once you've decided on it.
  /// - Unicode characters are legal, as long as it's UTF-8 encoded, but...
  /// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
  /// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
  ///
  /// The returned path is guaranteed to end with a path separator ('\' on
  /// Windows, '/' on most other platforms).
  ///
  /// The pointer returned is owned by the caller. Please call SDL_free() on the
  /// pointer when done with it.
  ///
  /// \param org the name of your organization
  /// \param app the name of your application
  /// \returns a UTF-8 string of the user directory in platform-dependent
  /// notation. NULL if there's a problem (creating directory failed,
  /// etc.).
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_GetBasePath
  ffi.Pointer<ffi.Char> SDL_GetPrefPath(
    ffi.Pointer<ffi.Char> org,
    ffi.Pointer<ffi.Char> app,
  ) {
    return _SDL_GetPrefPath(
      org,
      app,
    );
  }

  late final _SDL_GetPrefPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetPrefPath');
  late final _SDL_GetPrefPath = _SDL_GetPrefPathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Count the number of haptic devices attached to the system.
  ///
  /// \returns the number of haptic devices detected on the system or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticName
  int SDL_NumHaptics() {
    return _SDL_NumHaptics();
  }

  late final _SDL_NumHapticsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumHaptics');
  late final _SDL_NumHaptics = _SDL_NumHapticsPtr.asFunction<int Function()>();

  /// Get the implementation dependent name of a haptic device.
  ///
  /// This can be called before any joysticks are opened. If no name can be
  /// found, this function returns NULL.
  ///
  /// \param device_index index of the device to query.
  /// \returns the name of the device or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_NumHaptics
  ffi.Pointer<ffi.Char> SDL_HapticName(
    int device_index,
  ) {
    return _SDL_HapticName(
      device_index,
    );
  }

  late final _SDL_HapticNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_HapticName');
  late final _SDL_HapticName =
      _SDL_HapticNamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Open a haptic device for use.
  ///
  /// The index passed as an argument refers to the N'th haptic device on this
  /// system.
  ///
  /// When opening a haptic device, its gain will be set to maximum and
  /// autocenter will be disabled. To modify these values use SDL_HapticSetGain()
  /// and SDL_HapticSetAutocenter().
  ///
  /// \param device_index index of the device to open
  /// \returns the device identifier or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticClose
  /// \sa SDL_HapticIndex
  /// \sa SDL_HapticOpenFromJoystick
  /// \sa SDL_HapticOpenFromMouse
  /// \sa SDL_HapticPause
  /// \sa SDL_HapticSetAutocenter
  /// \sa SDL_HapticSetGain
  /// \sa SDL_HapticStopAll
  ffi.Pointer<SDL_Haptic> SDL_HapticOpen(
    int device_index,
  ) {
    return _SDL_HapticOpen(
      device_index,
    );
  }

  late final _SDL_HapticOpenPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Haptic> Function(ffi.Int)>>(
          'SDL_HapticOpen');
  late final _SDL_HapticOpen =
      _SDL_HapticOpenPtr.asFunction<ffi.Pointer<SDL_Haptic> Function(int)>();

  /// Check if the haptic device at the designated index has been opened.
  ///
  /// \param device_index the index of the device to query
  /// \returns 1 if it has been opened, 0 if it hasn't or on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticIndex
  /// \sa SDL_HapticOpen
  int SDL_HapticOpened(
    int device_index,
  ) {
    return _SDL_HapticOpened(
      device_index,
    );
  }

  late final _SDL_HapticOpenedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_HapticOpened');
  late final _SDL_HapticOpened =
      _SDL_HapticOpenedPtr.asFunction<int Function(int)>();

  /// Get the index of a haptic device.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns the index of the specified haptic device or a negative error code
  /// on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticOpened
  int SDL_HapticIndex(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticIndex(
      haptic,
    );
  }

  late final _SDL_HapticIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticIndex');
  late final _SDL_HapticIndex =
      _SDL_HapticIndexPtr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Query whether or not the current mouse has haptic capabilities.
  ///
  /// \returns SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpenFromMouse
  int SDL_MouseIsHaptic() {
    return _SDL_MouseIsHaptic();
  }

  late final _SDL_MouseIsHapticPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_MouseIsHaptic');
  late final _SDL_MouseIsHaptic =
      _SDL_MouseIsHapticPtr.asFunction<int Function()>();

  /// Try to open a haptic device from the current mouse.
  ///
  /// \returns the haptic device identifier or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_MouseIsHaptic
  ffi.Pointer<SDL_Haptic> SDL_HapticOpenFromMouse() {
    return _SDL_HapticOpenFromMouse();
  }

  late final _SDL_HapticOpenFromMousePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Haptic> Function()>>(
          'SDL_HapticOpenFromMouse');
  late final _SDL_HapticOpenFromMouse = _SDL_HapticOpenFromMousePtr.asFunction<
      ffi.Pointer<SDL_Haptic> Function()>();

  /// Query if a joystick has haptic features.
  ///
  /// \param joystick the SDL_Joystick to test for haptic capabilities
  /// \returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpenFromJoystick
  int SDL_JoystickIsHaptic(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickIsHaptic(
      joystick,
    );
  }

  late final _SDL_JoystickIsHapticPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickIsHaptic');
  late final _SDL_JoystickIsHaptic = _SDL_JoystickIsHapticPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Open a haptic device for use from a joystick device.
  ///
  /// You must still close the haptic device separately. It will not be closed
  /// with the joystick.
  ///
  /// When opened from a joystick you should first close the haptic device before
  /// closing the joystick device. If not, on some implementations the haptic
  /// device will also get unallocated and you'll be unable to use force feedback
  /// on that device.
  ///
  /// \param joystick the SDL_Joystick to create a haptic device from
  /// \returns a valid haptic device identifier on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticClose
  /// \sa SDL_HapticOpen
  /// \sa SDL_JoystickIsHaptic
  ffi.Pointer<SDL_Haptic> SDL_HapticOpenFromJoystick(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_HapticOpenFromJoystick(
      joystick,
    );
  }

  late final _SDL_HapticOpenFromJoystickPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Haptic> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_HapticOpenFromJoystick');
  late final _SDL_HapticOpenFromJoystick =
      _SDL_HapticOpenFromJoystickPtr.asFunction<
          ffi.Pointer<SDL_Haptic> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Close a haptic device previously opened with SDL_HapticOpen().
  ///
  /// \param haptic the SDL_Haptic device to close
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  void SDL_HapticClose(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticClose(
      haptic,
    );
  }

  late final _SDL_HapticClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticClose');
  late final _SDL_HapticClose =
      _SDL_HapticClosePtr.asFunction<void Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the number of effects a haptic device can store.
  ///
  /// On some platforms this isn't fully supported, and therefore is an
  /// approximation. Always check to see if your created effect was actually
  /// created and do not rely solely on SDL_HapticNumEffects().
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns the number of effects the haptic device can store or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNumEffectsPlaying
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffects(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumEffects(
      haptic,
    );
  }

  late final _SDL_HapticNumEffectsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticNumEffects');
  late final _SDL_HapticNumEffects = _SDL_HapticNumEffectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the number of effects a haptic device can play at the same time.
  ///
  /// This is not supported on all platforms, but will always return a value.
  ///
  /// \param haptic the SDL_Haptic device to query maximum playing effects
  /// \returns the number of effects the haptic device can play at the same time
  /// or a negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNumEffects
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffectsPlaying(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumEffectsPlaying(
      haptic,
    );
  }

  late final _SDL_HapticNumEffectsPlayingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticNumEffectsPlaying');
  late final _SDL_HapticNumEffectsPlaying = _SDL_HapticNumEffectsPlayingPtr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the haptic device's supported features in bitwise manner.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns a list of supported haptic features in bitwise manner (OR'd), or 0
  /// on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticEffectSupported
  /// \sa SDL_HapticNumEffects
  int SDL_HapticQuery(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticQuery(
      haptic,
    );
  }

  late final _SDL_HapticQueryPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<SDL_Haptic>)>>('SDL_HapticQuery');
  late final _SDL_HapticQuery =
      _SDL_HapticQueryPtr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the number of haptic axes the device has.
  ///
  /// The number of haptic axes might be useful if working with the
  /// SDL_HapticDirection effect.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns the number of axes on success or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_HapticNumAxes(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumAxes(
      haptic,
    );
  }

  late final _SDL_HapticNumAxesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticNumAxes');
  late final _SDL_HapticNumAxes =
      _SDL_HapticNumAxesPtr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Check to see if an effect is supported by a haptic device.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \param effect the desired effect to query
  /// \returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNewEffect
  /// \sa SDL_HapticQuery
  int SDL_HapticEffectSupported(
    ffi.Pointer<SDL_Haptic> haptic,
    ffi.Pointer<SDL_HapticEffect> effect,
  ) {
    return _SDL_HapticEffectSupported(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticEffectSupportedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticEffectSupported');
  late final _SDL_HapticEffectSupported =
      _SDL_HapticEffectSupportedPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Pointer<SDL_HapticEffect>)>();

  /// Create a new haptic effect on a specified device.
  ///
  /// \param haptic an SDL_Haptic device to create the effect on
  /// \param effect an SDL_HapticEffect structure containing the properties of
  /// the effect to create
  /// \returns the ID of the effect on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticUpdateEffect
  int SDL_HapticNewEffect(
    ffi.Pointer<SDL_Haptic> haptic,
    ffi.Pointer<SDL_HapticEffect> effect,
  ) {
    return _SDL_HapticNewEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticNewEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticNewEffect');
  late final _SDL_HapticNewEffect = _SDL_HapticNewEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, ffi.Pointer<SDL_HapticEffect>)>();

  /// Update the properties of an effect.
  ///
  /// Can be used dynamically, although behavior when dynamically changing
  /// direction may be strange. Specifically the effect may re-upload itself and
  /// start playing from the start. You also cannot change the type either when
  /// running SDL_HapticUpdateEffect().
  ///
  /// \param haptic the SDL_Haptic device that has the effect
  /// \param effect the identifier of the effect to update
  /// \param data an SDL_HapticEffect structure containing the new effect
  /// properties to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticNewEffect
  /// \sa SDL_HapticRunEffect
  int SDL_HapticUpdateEffect(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
    ffi.Pointer<SDL_HapticEffect> data,
  ) {
    return _SDL_HapticUpdateEffect(
      haptic,
      effect,
      data,
    );
  }

  late final _SDL_HapticUpdateEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>, ffi.Int,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticUpdateEffect');
  late final _SDL_HapticUpdateEffect = _SDL_HapticUpdateEffectPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Haptic>, int, ffi.Pointer<SDL_HapticEffect>)>();

  /// Run the haptic effect on its associated haptic device.
  ///
  /// To repeat the effect over and over indefinitely, set `iterations` to
  /// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
  /// one instance of the effect last indefinitely (so the effect does not fade),
  /// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
  /// instead.
  ///
  /// \param haptic the SDL_Haptic device to run the effect on
  /// \param effect the ID of the haptic effect to run
  /// \param iterations the number of iterations to run the effect; use
  /// `SDL_HAPTIC_INFINITY` to repeat forever
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticGetEffectStatus
  /// \sa SDL_HapticStopEffect
  int SDL_HapticRunEffect(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
    int iterations,
  ) {
    return _SDL_HapticRunEffect(
      haptic,
      effect,
      iterations,
    );
  }

  late final _SDL_HapticRunEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>, ffi.Int,
              Uint32)>>('SDL_HapticRunEffect');
  late final _SDL_HapticRunEffect = _SDL_HapticRunEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int, int)>();

  /// Stop the haptic effect on its associated haptic device.
  ///
  /// *
  ///
  /// \param haptic the SDL_Haptic device to stop the effect on
  /// \param effect the ID of the haptic effect to stop
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticRunEffect
  int SDL_HapticStopEffect(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticStopEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticStopEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticStopEffect');
  late final _SDL_HapticStopEffect = _SDL_HapticStopEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Destroy a haptic effect on the device.
  ///
  /// This will stop the effect if it's running. Effects are automatically
  /// destroyed when the device is closed.
  ///
  /// \param haptic the SDL_Haptic device to destroy the effect on
  /// \param effect the ID of the haptic effect to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNewEffect
  void SDL_HapticDestroyEffect(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticDestroyEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticDestroyEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticDestroyEffect');
  late final _SDL_HapticDestroyEffect = _SDL_HapticDestroyEffectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Get the status of the current effect on the specified haptic device.
  ///
  /// Device must support the SDL_HAPTIC_STATUS feature.
  ///
  /// \param haptic the SDL_Haptic device to query for the effect status on
  /// \param effect the ID of the haptic effect to query its status
  /// \returns 0 if it isn't playing, 1 if it is playing, or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticStopEffect
  int SDL_HapticGetEffectStatus(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticGetEffectStatus(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticGetEffectStatusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticGetEffectStatus');
  late final _SDL_HapticGetEffectStatus = _SDL_HapticGetEffectStatusPtr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Set the global gain of the specified haptic device.
  ///
  /// Device must support the SDL_HAPTIC_GAIN feature.
  ///
  /// The user may specify the maximum gain by setting the environment variable
  /// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
  /// SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
  /// maximum.
  ///
  /// \param haptic the SDL_Haptic device to set the gain on
  /// \param gain value to set the gain to, should be between 0 and 100 (0 - 100)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetGain(
    ffi.Pointer<SDL_Haptic> haptic,
    int gain,
  ) {
    return _SDL_HapticSetGain(
      haptic,
      gain,
    );
  }

  late final _SDL_HapticSetGainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticSetGain');
  late final _SDL_HapticSetGain = _SDL_HapticSetGainPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Set the global autocenter of the device.
  ///
  /// Autocenter should be between 0 and 100. Setting it to 0 will disable
  /// autocentering.
  ///
  /// Device must support the SDL_HAPTIC_AUTOCENTER feature.
  ///
  /// \param haptic the SDL_Haptic device to set autocentering on
  /// \param autocenter value to set autocenter to (0-100)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetAutocenter(
    ffi.Pointer<SDL_Haptic> haptic,
    int autocenter,
  ) {
    return _SDL_HapticSetAutocenter(
      haptic,
      autocenter,
    );
  }

  late final _SDL_HapticSetAutocenterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticSetAutocenter');
  late final _SDL_HapticSetAutocenter = _SDL_HapticSetAutocenterPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Pause a haptic device.
  ///
  /// Device must support the `SDL_HAPTIC_PAUSE` feature. Call
  /// SDL_HapticUnpause() to resume playback.
  ///
  /// Do not modify the effects nor add new ones while the device is paused. That
  /// can cause all sorts of weird errors.
  ///
  /// \param haptic the SDL_Haptic device to pause
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticUnpause
  int SDL_HapticPause(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticPause(
      haptic,
    );
  }

  late final _SDL_HapticPausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticPause');
  late final _SDL_HapticPause =
      _SDL_HapticPausePtr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Unpause a haptic device.
  ///
  /// Call to unpause after SDL_HapticPause().
  ///
  /// \param haptic the SDL_Haptic device to unpause
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticPause
  int SDL_HapticUnpause(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticUnpause(
      haptic,
    );
  }

  late final _SDL_HapticUnpausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticUnpause');
  late final _SDL_HapticUnpause =
      _SDL_HapticUnpausePtr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Stop all the currently playing effects on a haptic device.
  ///
  /// \param haptic the SDL_Haptic device to stop
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_HapticStopAll(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticStopAll(
      haptic,
    );
  }

  late final _SDL_HapticStopAllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticStopAll');
  late final _SDL_HapticStopAll =
      _SDL_HapticStopAllPtr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Check whether rumble is supported on a haptic device.
  ///
  /// \param haptic haptic device to check for rumble support
  /// \returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumbleSupported(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleSupported(
      haptic,
    );
  }

  late final _SDL_HapticRumbleSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticRumbleSupported');
  late final _SDL_HapticRumbleSupported = _SDL_HapticRumbleSupportedPtr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Initialize a haptic device for simple rumble playback.
  ///
  /// \param haptic the haptic device to initialize for simple rumble playback
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  /// \sa SDL_HapticRumbleSupported
  int SDL_HapticRumbleInit(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleInit(
      haptic,
    );
  }

  late final _SDL_HapticRumbleInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticRumbleInit');
  late final _SDL_HapticRumbleInit = _SDL_HapticRumbleInitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Run a simple rumble effect on a haptic device.
  ///
  /// \param haptic the haptic device to play the rumble effect on
  /// \param strength strength of the rumble to play as a 0-1 float value
  /// \param length length of the rumble to play in milliseconds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumbleStop
  /// \sa SDL_HapticRumbleSupported
  int SDL_HapticRumblePlay(
    ffi.Pointer<SDL_Haptic> haptic,
    double strength,
    int length,
  ) {
    return _SDL_HapticRumblePlay(
      haptic,
      strength,
      length,
    );
  }

  late final _SDL_HapticRumblePlayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>, ffi.Float,
              Uint32)>>('SDL_HapticRumblePlay');
  late final _SDL_HapticRumblePlay = _SDL_HapticRumblePlayPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, double, int)>();

  /// Stop the simple rumble on a haptic device.
  ///
  /// \param haptic the haptic device to stop the rumble effect on
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleSupported
  int SDL_HapticRumbleStop(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleStop(
      haptic,
    );
  }

  late final _SDL_HapticRumbleStopPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticRumbleStop');
  late final _SDL_HapticRumbleStop = _SDL_HapticRumbleStopPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Initialize the HIDAPI library.
  ///
  /// This function initializes the HIDAPI library. Calling it is not strictly
  /// necessary, as it will be called automatically by SDL_hid_enumerate() and
  /// any of the SDL_hid_open_*() functions if it is needed. This function should
  /// be called at the beginning of execution however, if there is a chance of
  /// HIDAPI handles being opened by different threads simultaneously.
  ///
  /// Each call to this function should have a matching call to SDL_hid_exit()
  ///
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_hid_exit
  int SDL_hid_init() {
    return _SDL_hid_init();
  }

  late final _SDL_hid_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_hid_init');
  late final _SDL_hid_init = _SDL_hid_initPtr.asFunction<int Function()>();

  /// Finalize the HIDAPI library.
  ///
  /// This function frees all of the static data associated with HIDAPI. It
  /// should be called at the end of execution to avoid memory leaks.
  ///
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_hid_init
  int SDL_hid_exit() {
    return _SDL_hid_exit();
  }

  late final _SDL_hid_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_hid_exit');
  late final _SDL_hid_exit = _SDL_hid_exitPtr.asFunction<int Function()>();

  /// Check to see if devices may have been added or removed.
  ///
  /// Enumerating the HID devices is an expensive operation, so you can call this
  /// to see if there have been any system device changes since the last call to
  /// this function. A change in the counter returned doesn't necessarily mean
  /// that anything has changed, but you can call SDL_hid_enumerate() to get an
  /// updated device list.
  ///
  /// Calling this function for the first time may cause a thread or other system
  /// resource to be allocated to track device change notifications.
  ///
  /// \returns a change counter that is incremented with each potential device
  /// change, or 0 if device change detection isn't available.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_hid_enumerate
  int SDL_hid_device_change_count() {
    return _SDL_hid_device_change_count();
  }

  late final _SDL_hid_device_change_countPtr =
      _lookup<ffi.NativeFunction<Uint32 Function()>>(
          'SDL_hid_device_change_count');
  late final _SDL_hid_device_change_count =
      _SDL_hid_device_change_countPtr.asFunction<int Function()>();

  /// Enumerate the HID Devices.
  ///
  /// This function returns a linked list of all the HID devices attached to the
  /// system which match vendor_id and product_id. If `vendor_id` is set to 0
  /// then any vendor matches. If `product_id` is set to 0 then any product
  /// matches. If `vendor_id` and `product_id` are both set to 0, then all HID
  /// devices will be returned.
  ///
  /// \param vendor_id The Vendor ID (VID) of the types of device to open.
  /// \param product_id The Product ID (PID) of the types of device to open.
  /// \returns a pointer to a linked list of type SDL_hid_device_info, containing
  /// information about the HID devices attached to the system, or NULL
  /// in the case of failure. Free this linked list by calling
  /// SDL_hid_free_enumeration().
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_hid_device_change_count
  ffi.Pointer<SDL_hid_device_info> SDL_hid_enumerate(
    int vendor_id,
    int product_id,
  ) {
    return _SDL_hid_enumerate(
      vendor_id,
      product_id,
    );
  }

  late final _SDL_hid_enumeratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_hid_device_info> Function(
              ffi.UnsignedShort, ffi.UnsignedShort)>>('SDL_hid_enumerate');
  late final _SDL_hid_enumerate = _SDL_hid_enumeratePtr.asFunction<
      ffi.Pointer<SDL_hid_device_info> Function(int, int)>();

  /// Free an enumeration Linked List
  ///
  /// This function frees a linked list created by SDL_hid_enumerate().
  ///
  /// \param devs Pointer to a list of struct_device returned from
  /// SDL_hid_enumerate().
  ///
  /// \since This function is available since SDL 2.0.18.
  void SDL_hid_free_enumeration(
    ffi.Pointer<SDL_hid_device_info> devs,
  ) {
    return _SDL_hid_free_enumeration(
      devs,
    );
  }

  late final _SDL_hid_free_enumerationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_hid_device_info>)>>('SDL_hid_free_enumeration');
  late final _SDL_hid_free_enumeration = _SDL_hid_free_enumerationPtr
      .asFunction<void Function(ffi.Pointer<SDL_hid_device_info>)>();

  /// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally
  /// a serial number.
  ///
  /// If `serial_number` is NULL, the first device with the specified VID and PID
  /// is opened.
  ///
  /// \param vendor_id The Vendor ID (VID) of the device to open.
  /// \param product_id The Product ID (PID) of the device to open.
  /// \param serial_number The Serial Number of the device to open (Optionally
  /// NULL).
  /// \returns a pointer to a SDL_hid_device object on success or NULL on
  /// failure.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<SDL_hid_device> SDL_hid_open(
    int vendor_id,
    int product_id,
    ffi.Pointer<ffi.WChar> serial_number,
  ) {
    return _SDL_hid_open(
      vendor_id,
      product_id,
      serial_number,
    );
  }

  late final _SDL_hid_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_hid_device> Function(ffi.UnsignedShort,
              ffi.UnsignedShort, ffi.Pointer<ffi.WChar>)>>('SDL_hid_open');
  late final _SDL_hid_open = _SDL_hid_openPtr.asFunction<
      ffi.Pointer<SDL_hid_device> Function(int, int, ffi.Pointer<ffi.WChar>)>();

  /// Open a HID device by its path name.
  ///
  /// The path name be determined by calling SDL_hid_enumerate(), or a
  /// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).
  ///
  /// \param path The path name of the device to open
  /// \returns a pointer to a SDL_hid_device object on success or NULL on
  /// failure.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<SDL_hid_device> SDL_hid_open_path(
    ffi.Pointer<ffi.Char> path,
    int bExclusive,
  ) {
    return _SDL_hid_open_path(
      path,
      bExclusive,
    );
  }

  late final _SDL_hid_open_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_hid_device> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_hid_open_path');
  late final _SDL_hid_open_path = _SDL_hid_open_pathPtr.asFunction<
      ffi.Pointer<SDL_hid_device> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Write an Output report to a HID device.
  ///
  /// The first byte of `data` must contain the Report ID. For devices which only
  /// support a single report, this must be set to 0x0. The remaining bytes
  /// contain the report data. Since the Report ID is mandatory, calls to
  /// SDL_hid_write() will always contain one more byte than the report contains.
  /// For example, if a hid report is 16 bytes long, 17 bytes must be passed to
  /// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),
  /// followed by the report data (16 bytes). In this example, the length passed
  /// in would be 17.
  ///
  /// SDL_hid_write() will send the data on the first OUT endpoint, if one
  /// exists. If it does not, it will send the data through the Control Endpoint
  /// (Endpoint 0).
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param data The data to send, including the report number as the first
  /// byte.
  /// \param length The length in bytes of the data to send.
  /// \returns the actual number of bytes written and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_write(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _SDL_hid_write(
      dev,
      data,
      length,
    );
  }

  late final _SDL_hid_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('SDL_hid_write');
  late final _SDL_hid_write = _SDL_hid_writePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Read an Input report from a HID device with timeout.
  ///
  /// Input reports are returned to the host through the INTERRUPT IN endpoint.
  /// The first byte will contain the Report number if the device uses numbered
  /// reports.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param data A buffer to put the read data into.
  /// \param length The number of bytes to read. For devices with multiple
  /// reports, make sure to read an extra byte for the report
  /// number.
  /// \param milliseconds timeout in milliseconds or -1 for blocking wait.
  /// \returns the actual number of bytes read and -1 on error. If no packet was
  /// available to be read within the timeout period, this function
  /// returns 0.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_read_timeout(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
    int milliseconds,
  ) {
    return _SDL_hid_read_timeout(
      dev,
      data,
      length,
      milliseconds,
    );
  }

  late final _SDL_hid_read_timeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Int)>>('SDL_hid_read_timeout');
  late final _SDL_hid_read_timeout = _SDL_hid_read_timeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.UnsignedChar>,
          int, int)>();

  /// Read an Input report from a HID device.
  ///
  /// Input reports are returned to the host through the INTERRUPT IN endpoint.
  /// The first byte will contain the Report number if the device uses numbered
  /// reports.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param data A buffer to put the read data into.
  /// \param length The number of bytes to read. For devices with multiple
  /// reports, make sure to read an extra byte for the report
  /// number.
  /// \returns the actual number of bytes read and -1 on error. If no packet was
  /// available to be read and the handle is in non-blocking mode, this
  /// function returns 0.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_read(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _SDL_hid_read(
      dev,
      data,
      length,
    );
  }

  late final _SDL_hid_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('SDL_hid_read');
  late final _SDL_hid_read = _SDL_hid_readPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Set the device handle to be non-blocking.
  ///
  /// In non-blocking mode calls to SDL_hid_read() will return immediately with a
  /// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()
  /// will wait (block) until there is data to read before returning.
  ///
  /// Nonblocking can be turned on and off at any time.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param nonblock enable or not the nonblocking reads - 1 to enable
  /// nonblocking - 0 to disable nonblocking.
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_set_nonblocking(
    ffi.Pointer<SDL_hid_device> dev,
    int nonblock,
  ) {
    return _SDL_hid_set_nonblocking(
      dev,
      nonblock,
    );
  }

  late final _SDL_hid_set_nonblockingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>,
              ffi.Int)>>('SDL_hid_set_nonblocking');
  late final _SDL_hid_set_nonblocking = _SDL_hid_set_nonblockingPtr.asFunction<
      int Function(ffi.Pointer<SDL_hid_device>, int)>();

  /// Send a Feature report to the device.
  ///
  /// Feature reports are sent over the Control endpoint as a Set_Report
  /// transfer. The first byte of `data` must contain the Report ID. For devices
  /// which only support a single report, this must be set to 0x0. The remaining
  /// bytes contain the report data. Since the Report ID is mandatory, calls to
  /// SDL_hid_send_feature_report() will always contain one more byte than the
  /// report contains. For example, if a hid report is 16 bytes long, 17 bytes
  /// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for
  /// devices which do not use numbered reports), followed by the report data (16
  /// bytes). In this example, the length passed in would be 17.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param data The data to send, including the report number as the first
  /// byte.
  /// \param length The length in bytes of the data to send, including the report
  /// number.
  /// \returns the actual number of bytes written and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_send_feature_report(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _SDL_hid_send_feature_report(
      dev,
      data,
      length,
    );
  }

  late final _SDL_hid_send_feature_reportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('SDL_hid_send_feature_report');
  late final _SDL_hid_send_feature_report =
      _SDL_hid_send_feature_reportPtr.asFunction<
          int Function(ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Get a feature report from a HID device.
  ///
  /// Set the first byte of `data` to the Report ID of the report to be read.
  /// Make sure to allow space for this extra byte in `data`. Upon return, the
  /// first byte will still contain the Report ID, and the report data will start
  /// in data[1].
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param data A buffer to put the read data into, including the Report ID.
  /// Set the first byte of `data` to the Report ID of the report to
  /// be read, or set it to zero if your device does not use numbered
  /// reports.
  /// \param length The number of bytes to read, including an extra byte for the
  /// report ID. The buffer can be longer than the actual report.
  /// \returns the number of bytes read plus one for the report ID (which is
  /// still in the first byte), or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_get_feature_report(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _SDL_hid_get_feature_report(
      dev,
      data,
      length,
    );
  }

  late final _SDL_hid_get_feature_reportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('SDL_hid_get_feature_report');
  late final _SDL_hid_get_feature_report =
      _SDL_hid_get_feature_reportPtr.asFunction<
          int Function(ffi.Pointer<SDL_hid_device>,
              ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Close a HID device.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  ///
  /// \since This function is available since SDL 2.0.18.
  void SDL_hid_close(
    ffi.Pointer<SDL_hid_device> dev,
  ) {
    return _SDL_hid_close(
      dev,
    );
  }

  late final _SDL_hid_closePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_hid_device>)>>(
      'SDL_hid_close');
  late final _SDL_hid_close = _SDL_hid_closePtr.asFunction<
      void Function(ffi.Pointer<SDL_hid_device>)>();

  /// Get The Manufacturer String from a HID device.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param string A wide string buffer to put the data into.
  /// \param maxlen The length of the buffer in multiples of wchar_t.
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_get_manufacturer_string(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _SDL_hid_get_manufacturer_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _SDL_hid_get_manufacturer_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_hid_get_manufacturer_string');
  late final _SDL_hid_get_manufacturer_string =
      _SDL_hid_get_manufacturer_stringPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.WChar>, int)>();

  /// Get The Product String from a HID device.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param string A wide string buffer to put the data into.
  /// \param maxlen The length of the buffer in multiples of wchar_t.
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_get_product_string(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _SDL_hid_get_product_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _SDL_hid_get_product_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_hid_get_product_string');
  late final _SDL_hid_get_product_string =
      _SDL_hid_get_product_stringPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.WChar>, int)>();

  /// Get The Serial Number String from a HID device.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param string A wide string buffer to put the data into.
  /// \param maxlen The length of the buffer in multiples of wchar_t.
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_get_serial_number_string(
    ffi.Pointer<SDL_hid_device> dev,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _SDL_hid_get_serial_number_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _SDL_hid_get_serial_number_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_hid_get_serial_number_string');
  late final _SDL_hid_get_serial_number_string =
      _SDL_hid_get_serial_number_stringPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_hid_device>, ffi.Pointer<ffi.WChar>, int)>();

  /// Get a string from a HID device, based on its string index.
  ///
  /// \param dev A device handle returned from SDL_hid_open().
  /// \param string_index The index of the string to get.
  /// \param string A wide string buffer to put the data into.
  /// \param maxlen The length of the buffer in multiples of wchar_t.
  /// \returns 0 on success and -1 on error.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_hid_get_indexed_string(
    ffi.Pointer<SDL_hid_device> dev,
    int string_index,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _SDL_hid_get_indexed_string(
      dev,
      string_index,
      string,
      maxlen,
    );
  }

  late final _SDL_hid_get_indexed_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_hid_device>, ffi.Int,
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('SDL_hid_get_indexed_string');
  late final _SDL_hid_get_indexed_string =
      _SDL_hid_get_indexed_stringPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_hid_device>, int, ffi.Pointer<ffi.WChar>, int)>();

  /// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers
  ///
  /// \param active SDL_TRUE to start the scan, SDL_FALSE to stop the scan
  ///
  /// \since This function is available since SDL 2.0.18.
  void SDL_hid_ble_scan(
    int active,
  ) {
    return _SDL_hid_ble_scan(
      active,
    );
  }

  late final _SDL_hid_ble_scanPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_hid_ble_scan');
  late final _SDL_hid_ble_scan =
      _SDL_hid_ble_scanPtr.asFunction<void Function(int)>();

  /// Set a hint with a specific priority.
  ///
  /// The priority controls the behavior when setting a hint that already has a
  /// value. Hints will replace existing hints of their priority and lower.
  /// Environment variables are considered to have override priority.
  ///
  /// \param name the hint to set
  /// \param value the value of the hint variable
  /// \param priority the SDL_HintPriority level for the hint
  /// \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetHint
  /// \sa SDL_SetHint
  int SDL_SetHintWithPriority(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int priority,
  ) {
    return _SDL_SetHintWithPriority(
      name,
      value,
      priority,
    );
  }

  late final _SDL_SetHintWithPriorityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('SDL_SetHintWithPriority');
  late final _SDL_SetHintWithPriority = _SDL_SetHintWithPriorityPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set a hint with normal priority.
  ///
  /// Hints will not be set if there is an existing override hint or environment
  /// variable that takes precedence. You can use SDL_SetHintWithPriority() to
  /// set the hint with override priority instead.
  ///
  /// \param name the hint to set
  /// \param value the value of the hint variable
  /// \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetHint
  /// \sa SDL_SetHintWithPriority
  int SDL_SetHint(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _SDL_SetHint(
      name,
      value,
    );
  }

  late final _SDL_SetHintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_SetHint');
  late final _SDL_SetHint = _SDL_SetHintPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Get the value of a hint.
  ///
  /// \param name the hint to query
  /// \returns the string value of a hint or NULL if the hint isn't set.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetHint
  /// \sa SDL_SetHintWithPriority
  ffi.Pointer<ffi.Char> SDL_GetHint(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetHint(
      name,
    );
  }

  late final _SDL_GetHintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GetHint');
  late final _SDL_GetHint = _SDL_GetHintPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Get the boolean value of a hint variable.
  ///
  /// \param name the name of the hint to get the boolean value from
  /// \param default_value the value to return if the hint does not exist
  /// \returns the boolean value of a hint or the provided default value if the
  /// hint does not exist.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetHint
  /// \sa SDL_SetHint
  int SDL_GetHintBoolean(
    ffi.Pointer<ffi.Char> name,
    int default_value,
  ) {
    return _SDL_GetHintBoolean(
      name,
      default_value,
    );
  }

  late final _SDL_GetHintBooleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Char>, ffi.Int32)>>('SDL_GetHintBoolean');
  late final _SDL_GetHintBoolean = _SDL_GetHintBooleanPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Add a function to watch a particular hint.
  ///
  /// \param name the hint to watch
  /// \param callback An SDL_HintCallback function that will be called when the
  /// hint value changes
  /// \param userdata a pointer to pass to the callback function
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DelHintCallback
  void SDL_AddHintCallback(
    ffi.Pointer<ffi.Char> name,
    SDL_HintCallback callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddHintCallback(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_AddHintCallbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, SDL_HintCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddHintCallback');
  late final _SDL_AddHintCallback = _SDL_AddHintCallbackPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Char>, SDL_HintCallback, ffi.Pointer<ffi.Void>)>();

  /// Remove a function watching a particular hint.
  ///
  /// \param name the hint being watched
  /// \param callback An SDL_HintCallback function that will be called when the
  /// hint value changes
  /// \param userdata a pointer being passed to the callback function
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddHintCallback
  void SDL_DelHintCallback(
    ffi.Pointer<ffi.Char> name,
    SDL_HintCallback callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelHintCallback(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_DelHintCallbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, SDL_HintCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_DelHintCallback');
  late final _SDL_DelHintCallback = _SDL_DelHintCallbackPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Char>, SDL_HintCallback, ffi.Pointer<ffi.Void>)>();

  /// Clear all hints.
  ///
  /// This function is automatically called during SDL_Quit().
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_ClearHints() {
    return _SDL_ClearHints();
  }

  late final _SDL_ClearHintsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearHints');
  late final _SDL_ClearHints = _SDL_ClearHintsPtr.asFunction<void Function()>();

  /// Dynamically load a shared object.
  ///
  /// \param sofile a system-dependent name of the object file
  /// \returns an opaque pointer to the object handle or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadFunction
  /// \sa SDL_UnloadObject
  ffi.Pointer<ffi.Void> SDL_LoadObject(
    ffi.Pointer<ffi.Char> sofile,
  ) {
    return _SDL_LoadObject(
      sofile,
    );
  }

  late final _SDL_LoadObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_LoadObject');
  late final _SDL_LoadObject = _SDL_LoadObjectPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Look up the address of the named function in a shared object.
  ///
  /// This function pointer is no longer valid after calling SDL_UnloadObject().
  ///
  /// This function can only look up C function names. Other languages may have
  /// name mangling and intrinsic language support that varies from compiler to
  /// compiler.
  ///
  /// Make sure you declare your function pointers with the same calling
  /// convention as the actual library function. Your code will crash
  /// mysteriously if you do not do this.
  ///
  /// If the requested function doesn't exist, NULL is returned.
  ///
  /// \param handle a valid shared object handle returned by SDL_LoadObject()
  /// \param name the name of the function to look up
  /// \returns a pointer to the function or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadObject
  /// \sa SDL_UnloadObject
  ffi.Pointer<ffi.Void> SDL_LoadFunction(
    ffi.Pointer<ffi.Void> handle,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_LoadFunction(
      handle,
      name,
    );
  }

  late final _SDL_LoadFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>)>>('SDL_LoadFunction');
  late final _SDL_LoadFunction = _SDL_LoadFunctionPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  /// Unload a shared object from memory.
  ///
  /// \param handle a valid shared object handle returned by SDL_LoadObject()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadFunction
  /// \sa SDL_LoadObject
  void SDL_UnloadObject(
    ffi.Pointer<ffi.Void> handle,
  ) {
    return _SDL_UnloadObject(
      handle,
    );
  }

  late final _SDL_UnloadObjectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_UnloadObject');
  late final _SDL_UnloadObject =
      _SDL_UnloadObjectPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Set the priority of all log categories.
  ///
  /// \param priority the SDL_LogPriority to assign
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetPriority
  void SDL_LogSetAllPriority(
    int priority,
  ) {
    return _SDL_LogSetAllPriority(
      priority,
    );
  }

  late final _SDL_LogSetAllPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_LogSetAllPriority');
  late final _SDL_LogSetAllPriority =
      _SDL_LogSetAllPriorityPtr.asFunction<void Function(int)>();

  /// Set the priority of a particular log category.
  ///
  /// \param category the category to assign a priority to
  /// \param priority the SDL_LogPriority to assign
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogGetPriority
  /// \sa SDL_LogSetAllPriority
  void SDL_LogSetPriority(
    int category,
    int priority,
  ) {
    return _SDL_LogSetPriority(
      category,
      priority,
    );
  }

  late final _SDL_LogSetPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int, ffi.Int32)>>(
          'SDL_LogSetPriority');
  late final _SDL_LogSetPriority =
      _SDL_LogSetPriorityPtr.asFunction<void Function(int, int)>();

  /// Get the priority of a particular log category.
  ///
  /// \param category the category to query
  /// \returns the SDL_LogPriority for the requested category
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetPriority
  int SDL_LogGetPriority(
    int category,
  ) {
    return _SDL_LogGetPriority(
      category,
    );
  }

  late final _SDL_LogGetPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_LogGetPriority');
  late final _SDL_LogGetPriority =
      _SDL_LogGetPriorityPtr.asFunction<int Function(int)>();

  /// Reset all priorities to default.
  ///
  /// This is called by SDL_Quit().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetAllPriority
  /// \sa SDL_LogSetPriority
  void SDL_LogResetPriorities() {
    return _SDL_LogResetPriorities();
  }

  late final _SDL_LogResetPrioritiesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_LogResetPriorities');
  late final _SDL_LogResetPriorities =
      _SDL_LogResetPrioritiesPtr.asFunction<void Function()>();

  /// Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.
  ///
  /// = * \param fmt a printf() style message format string
  ///
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_Log(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_Log(
      fmt,
    );
  }

  late final _SDL_LogPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_Log');
  late final _SDL_Log =
      _SDL_LogPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_VERBOSE.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogWarn
  void SDL_LogVerbose(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogVerbose(
      category,
      fmt,
    );
  }

  late final _SDL_LogVerbosePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogVerbose');
  late final _SDL_LogVerbose = _SDL_LogVerbosePtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_DEBUG.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogDebug(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogDebug(
      category,
      fmt,
    );
  }

  late final _SDL_LogDebugPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogDebug');
  late final _SDL_LogDebug =
      _SDL_LogDebugPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_INFO.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogInfo(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogInfo(
      category,
      fmt,
    );
  }

  late final _SDL_LogInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogInfo');
  late final _SDL_LogInfo =
      _SDL_LogInfoPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_WARN.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  void SDL_LogWarn(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogWarn(
      category,
      fmt,
    );
  }

  late final _SDL_LogWarnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogWarn');
  late final _SDL_LogWarn =
      _SDL_LogWarnPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_ERROR.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogError(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogError(
      category,
      fmt,
    );
  }

  late final _SDL_LogErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogError');
  late final _SDL_LogError =
      _SDL_LogErrorPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_CRITICAL.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogCritical(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogCritical(
      category,
      fmt,
    );
  }

  late final _SDL_LogCriticalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogCritical');
  late final _SDL_LogCritical = _SDL_LogCriticalPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with the specified category and priority.
  ///
  /// \param category the category of the message
  /// \param priority the priority of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogMessage(
    int category,
    int priority,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogMessage(
      category,
      priority,
      fmt,
    );
  }

  late final _SDL_LogMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int, ffi.Int32, ffi.Pointer<ffi.Char>)>>('SDL_LogMessage');
  late final _SDL_LogMessage = _SDL_LogMessagePtr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with the specified category and priority.
  ///
  /// \param category the category of the message
  /// \param priority the priority of the message
  /// \param fmt a printf() style message format string
  /// \param ap a variable argument list
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogMessageV(
    int category,
    int priority,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_LogMessageV(
      category,
      priority,
      fmt,
      ap,
    );
  }

  late final _SDL_LogMessageVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Int32, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_LogMessageV');
  late final _SDL_LogMessageV = _SDL_LogMessageVPtr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Char>, va_list)>();

  /// Get the current log output function.
  ///
  /// \param callback an SDL_LogOutputFunction filled in with the current log
  /// callback
  /// \param userdata a pointer filled in with the pointer that is passed to
  /// `callback`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetOutputFunction
  void SDL_LogGetOutputFunction(
    ffi.Pointer<SDL_LogOutputFunction> callback,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_LogGetOutputFunction(
      callback,
      userdata,
    );
  }

  late final _SDL_LogGetOutputFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_LogOutputFunction>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_LogGetOutputFunction');
  late final _SDL_LogGetOutputFunction =
      _SDL_LogGetOutputFunctionPtr.asFunction<
          void Function(ffi.Pointer<SDL_LogOutputFunction>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Replace the default log output function with one of your own.
  ///
  /// \param callback an SDL_LogOutputFunction to call instead of the default
  /// \param userdata a pointer that is passed to `callback`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogGetOutputFunction
  void SDL_LogSetOutputFunction(
    SDL_LogOutputFunction callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_LogSetOutputFunction(
      callback,
      userdata,
    );
  }

  late final _SDL_LogSetOutputFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_LogOutputFunction,
              ffi.Pointer<ffi.Void>)>>('SDL_LogSetOutputFunction');
  late final _SDL_LogSetOutputFunction =
      _SDL_LogSetOutputFunctionPtr.asFunction<
          void Function(SDL_LogOutputFunction, ffi.Pointer<ffi.Void>)>();

  /// Create a modal message box.
  ///
  /// If your needs aren't complex, it might be easier to use
  /// SDL_ShowSimpleMessageBox.
  ///
  /// This function should be called on the thread that created the parent
  /// window, or on the main thread if the messagebox has no parent. It will
  /// block execution of that thread until the user clicks a button or closes the
  /// messagebox.
  ///
  /// This function may be called at any time, even before SDL_Init(). This makes
  /// it useful for reporting errors like a failure to create a renderer or
  /// OpenGL context.
  ///
  /// On X11, SDL rolls its own dialog box with X11 primitives instead of a
  /// formal toolkit like GTK+ or Qt.
  ///
  /// Note that if SDL_Init() would fail because there isn't any available video
  /// target, this function is likely to fail for the same reasons. If this is a
  /// concern, check the return value from this function and fall back to writing
  /// to stderr if you can.
  ///
  /// \param messageboxdata the SDL_MessageBoxData structure with title, text and
  /// other options
  /// \param buttonid the pointer to which user id of hit button should be copied
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowSimpleMessageBox
  int SDL_ShowMessageBox(
    ffi.Pointer<SDL_MessageBoxData> messageboxdata,
    ffi.Pointer<ffi.Int> buttonid,
  ) {
    return _SDL_ShowMessageBox(
      messageboxdata,
      buttonid,
    );
  }

  late final _SDL_ShowMessageBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_MessageBoxData>,
              ffi.Pointer<ffi.Int>)>>('SDL_ShowMessageBox');
  late final _SDL_ShowMessageBox = _SDL_ShowMessageBoxPtr.asFunction<
      int Function(ffi.Pointer<SDL_MessageBoxData>, ffi.Pointer<ffi.Int>)>();

  /// Display a simple modal message box.
  ///
  /// If your needs aren't complex, this function is preferred over
  /// SDL_ShowMessageBox.
  ///
  /// `flags` may be any of the following:
  ///
  /// - `SDL_MESSAGEBOX_ERROR`: error dialog
  /// - `SDL_MESSAGEBOX_WARNING`: warning dialog
  /// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog
  ///
  /// This function should be called on the thread that created the parent
  /// window, or on the main thread if the messagebox has no parent. It will
  /// block execution of that thread until the user clicks a button or closes the
  /// messagebox.
  ///
  /// This function may be called at any time, even before SDL_Init(). This makes
  /// it useful for reporting errors like a failure to create a renderer or
  /// OpenGL context.
  ///
  /// On X11, SDL rolls its own dialog box with X11 primitives instead of a
  /// formal toolkit like GTK+ or Qt.
  ///
  /// Note that if SDL_Init() would fail because there isn't any available video
  /// target, this function is likely to fail for the same reasons. If this is a
  /// concern, check the return value from this function and fall back to writing
  /// to stderr if you can.
  ///
  /// \param flags an SDL_MessageBoxFlags value
  /// \param title UTF-8 title text
  /// \param message UTF-8 message text
  /// \param window the parent window, or NULL for no parent
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowMessageBox
  int SDL_ShowSimpleMessageBox(
    int flags,
    ffi.Pointer<ffi.Char> title,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowSimpleMessageBox(
      flags,
      title,
      message,
      window,
    );
  }

  late final _SDL_ShowSimpleMessageBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Uint32, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<SDL_Window>)>>('SDL_ShowSimpleMessageBox');
  late final _SDL_ShowSimpleMessageBox =
      _SDL_ShowSimpleMessageBoxPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<SDL_Window>)>();

  /// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified
  /// window.
  ///
  /// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on
  /// its own. It is up to user code to do that.
  ///
  /// The returned handle can be casted directly to a NSView or UIView. To access
  /// the backing CAMetalLayer, call SDL_Metal_GetLayer().
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_Metal_DestroyView
  /// \sa SDL_Metal_GetLayer
  SDL_MetalView SDL_Metal_CreateView(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_Metal_CreateView(
      window,
    );
  }

  late final _SDL_Metal_CreateViewPtr = _lookup<
          ffi.NativeFunction<SDL_MetalView Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_Metal_CreateView');
  late final _SDL_Metal_CreateView = _SDL_Metal_CreateViewPtr.asFunction<
      SDL_MetalView Function(ffi.Pointer<SDL_Window>)>();

  /// Destroy an existing SDL_MetalView object.
  ///
  /// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was
  /// called after SDL_CreateWindow.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_Metal_CreateView
  void SDL_Metal_DestroyView(
    SDL_MetalView view,
  ) {
    return _SDL_Metal_DestroyView(
      view,
    );
  }

  late final _SDL_Metal_DestroyViewPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_MetalView)>>(
          'SDL_Metal_DestroyView');
  late final _SDL_Metal_DestroyView =
      _SDL_Metal_DestroyViewPtr.asFunction<void Function(SDL_MetalView)>();

  /// Get a pointer to the backing CAMetalLayer for the given view.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_MetalCreateView
  ffi.Pointer<ffi.Void> SDL_Metal_GetLayer(
    SDL_MetalView view,
  ) {
    return _SDL_Metal_GetLayer(
      view,
    );
  }

  late final _SDL_Metal_GetLayerPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(SDL_MetalView)>>(
      'SDL_Metal_GetLayer');
  late final _SDL_Metal_GetLayer = _SDL_Metal_GetLayerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(SDL_MetalView)>();

  /// Get the size of a window's underlying drawable in pixels (for use with
  /// setting viewport, scissor & etc).
  ///
  /// \param window SDL_Window from which the drawable size should be queried
  /// \param w Pointer to variable for storing the width in pixels, may be NULL
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_CreateWindow
  void SDL_Metal_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_Metal_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_Metal_GetDrawableSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_Metal_GetDrawableSize');
  late final _SDL_Metal_GetDrawableSize =
      _SDL_Metal_GetDrawableSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Get the current power supply details.
  ///
  /// You should never take a battery status as absolute truth. Batteries
  /// (especially failing batteries) are delicate hardware, and the values
  /// reported here are best estimates based on what that hardware reports. It's
  /// not uncommon for older batteries to lose stored power much faster than it
  /// reports, or completely drain when reporting it has 20 percent left, etc.
  ///
  /// Battery status can change at any time; if you are concerned with power
  /// state, you should call this function frequently, and perhaps ignore changes
  /// until they seem to be stable for a few seconds.
  ///
  /// It's possible a platform can only report battery percentage or time left
  /// but not both.
  ///
  /// \param secs seconds of battery life left, you can pass a NULL here if you
  /// don't care, will return -1 if we can't determine a value, or
  /// we're not running on a battery
  /// \param pct percentage of battery life left, between 0 and 100, you can pass
  /// a NULL here if you don't care, will return -1 if we can't
  /// determine a value, or we're not running on a battery
  /// \returns an SDL_PowerState enum representing the current battery state.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetPowerInfo(
    ffi.Pointer<ffi.Int> secs,
    ffi.Pointer<ffi.Int> pct,
  ) {
    return _SDL_GetPowerInfo(
      secs,
      pct,
    );
  }

  late final _SDL_GetPowerInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('SDL_GetPowerInfo');
  late final _SDL_GetPowerInfo = _SDL_GetPowerInfoPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Get the number of 2D rendering drivers available for the current display.
  ///
  /// A render driver is a set of code that handles rendering and texture
  /// management on a particular display. Normally there is only one, but some
  /// drivers may have several available with different capabilities.
  ///
  /// There may be none if SDL was compiled without render support.
  ///
  /// \returns a number >= 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_GetRenderDriverInfo
  int SDL_GetNumRenderDrivers() {
    return _SDL_GetNumRenderDrivers();
  }

  late final _SDL_GetNumRenderDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumRenderDrivers');
  late final _SDL_GetNumRenderDrivers =
      _SDL_GetNumRenderDriversPtr.asFunction<int Function()>();

  /// Get info about a specific 2D rendering driver for the current display.
  ///
  /// \param index the index of the driver to query information about
  /// \param info an SDL_RendererInfo structure to be filled with information on
  /// the rendering driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_GetNumRenderDrivers
  int SDL_GetRenderDriverInfo(
    int index,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRenderDriverInfo(
      index,
      info,
    );
  }

  late final _SDL_GetRenderDriverInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRenderDriverInfo');
  late final _SDL_GetRenderDriverInfo = _SDL_GetRenderDriverInfoPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RendererInfo>)>();

  /// Create a window and default renderer.
  ///
  /// \param width the width of the window
  /// \param height the height of the window
  /// \param window_flags the flags used to create the window (see
  /// SDL_CreateWindow())
  /// \param window a pointer filled with the window, or NULL on error
  /// \param renderer a pointer filled with the renderer, or NULL on error
  /// \returns 0 on success, or -1 on error; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_CreateWindow
  int SDL_CreateWindowAndRenderer(
    int width,
    int height,
    int window_flags,
    ffi.Pointer<ffi.Pointer<SDL_Window>> window,
    ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
  ) {
    return _SDL_CreateWindowAndRenderer(
      width,
      height,
      window_flags,
      window,
      renderer,
    );
  }

  late final _SDL_CreateWindowAndRendererPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Int,
                  ffi.Int,
                  Uint32,
                  ffi.Pointer<ffi.Pointer<SDL_Window>>,
                  ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>>(
      'SDL_CreateWindowAndRenderer');
  late final _SDL_CreateWindowAndRenderer =
      _SDL_CreateWindowAndRendererPtr.asFunction<
          int Function(int, int, int, ffi.Pointer<ffi.Pointer<SDL_Window>>,
              ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>();

  /// Create a 2D rendering context for a window.
  ///
  /// \param window the window where rendering is displayed
  /// \param index the index of the rendering driver to initialize, or -1 to
  /// initialize the first one supporting the requested flags
  /// \param flags 0, or one or more SDL_RendererFlags OR'd together
  /// \returns a valid rendering context or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSoftwareRenderer
  /// \sa SDL_DestroyRenderer
  /// \sa SDL_GetNumRenderDrivers
  /// \sa SDL_GetRendererInfo
  ffi.Pointer<SDL_Renderer> SDL_CreateRenderer(
    ffi.Pointer<SDL_Window> window,
    int index,
    int flags,
  ) {
    return _SDL_CreateRenderer(
      window,
      index,
      flags,
    );
  }

  late final _SDL_CreateRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>, ffi.Int, Uint32)>>('SDL_CreateRenderer');
  late final _SDL_CreateRenderer = _SDL_CreateRendererPtr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Create a 2D software rendering context for a surface.
  ///
  /// Two other API which can be used to create SDL_Renderer:
  /// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
  /// create a software renderer, but they are intended to be used with an
  /// SDL_Window as the final destination and not an SDL_Surface.
  ///
  /// \param surface the SDL_Surface structure representing the surface where
  /// rendering is done
  /// \returns a valid rendering context or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_CreateWindowRenderer
  /// \sa SDL_DestroyRenderer
  ffi.Pointer<SDL_Renderer> SDL_CreateSoftwareRenderer(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateSoftwareRenderer(
      surface,
    );
  }

  late final _SDL_CreateSoftwareRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateSoftwareRenderer');
  late final _SDL_CreateSoftwareRenderer =
      _SDL_CreateSoftwareRendererPtr.asFunction<
          ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the renderer associated with a window.
  ///
  /// \param window the window to query
  /// \returns the rendering context on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  ffi.Pointer<SDL_Renderer> SDL_GetRenderer(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetRenderer(
      window,
    );
  }

  late final _SDL_GetRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetRenderer');
  late final _SDL_GetRenderer = _SDL_GetRendererPtr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>)>();

  /// Get information about a rendering context.
  ///
  /// \param renderer the rendering context
  /// \param info an SDL_RendererInfo structure filled with information about the
  /// current renderer
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  int SDL_GetRendererInfo(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRendererInfo(
      renderer,
      info,
    );
  }

  late final _SDL_GetRendererInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRendererInfo');
  late final _SDL_GetRendererInfo = _SDL_GetRendererInfoPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_RendererInfo>)>();

  /// Get the output size in pixels of a rendering context.
  ///
  /// Due to high-dpi displays, you might end up with a rendering context that
  /// has more pixels than the window that contains it, so use this instead of
  /// SDL_GetWindowSize() to decide how much drawing area you have.
  ///
  /// \param renderer the rendering context
  /// \param w an int filled with the width
  /// \param h an int filled with the height
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderer
  int SDL_GetRendererOutputSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetRendererOutputSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_GetRendererOutputSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetRendererOutputSize');
  late final _SDL_GetRendererOutputSize =
      _SDL_GetRendererOutputSizePtr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Create a texture for a rendering context.
  ///
  /// You can set the texture scaling method by setting
  /// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.
  ///
  /// \param renderer the rendering context
  /// \param format one of the enumerated values in SDL_PixelFormatEnum
  /// \param access one of the enumerated values in SDL_TextureAccess
  /// \param w the width of the texture in pixels
  /// \param h the height of the texture in pixels
  /// \returns a pointer to the created texture or NULL if no rendering context
  /// was active, the format was unsupported, or the width or height
  /// were out of range; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTextureFromSurface
  /// \sa SDL_DestroyTexture
  /// \sa SDL_QueryTexture
  /// \sa SDL_UpdateTexture
  ffi.Pointer<SDL_Texture> SDL_CreateTexture(
    ffi.Pointer<SDL_Renderer> renderer,
    int format,
    int access,
    int w,
    int h,
  ) {
    return _SDL_CreateTexture(
      renderer,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_CreateTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>, Uint32,
              ffi.Int, ffi.Int, ffi.Int)>>('SDL_CreateTexture');
  late final _SDL_CreateTexture = _SDL_CreateTexturePtr.asFunction<
      ffi.Pointer<SDL_Texture> Function(
          ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Create a texture from an existing surface.
  ///
  /// The surface is not modified or freed by this function.
  ///
  /// The SDL_TextureAccess hint for the created texture is
  /// `SDL_TEXTUREACCESS_STATIC`.
  ///
  /// The pixel format of the created texture may be different from the pixel
  /// format of the surface. Use SDL_QueryTexture() to query the pixel format of
  /// the texture.
  ///
  /// \param renderer the rendering context
  /// \param surface the SDL_Surface structure containing pixel data used to fill
  /// the texture
  /// \returns the created texture or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_DestroyTexture
  /// \sa SDL_QueryTexture
  ffi.Pointer<SDL_Texture> SDL_CreateTextureFromSurface(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateTextureFromSurface(
      renderer,
      surface,
    );
  }

  late final _SDL_CreateTextureFromSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateTextureFromSurface');
  late final _SDL_CreateTextureFromSurface =
      _SDL_CreateTextureFromSurfacePtr.asFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Surface>)>();

  /// Query the attributes of a texture.
  ///
  /// \param texture the texture to query
  /// \param format a pointer filled in with the raw format of the texture; the
  /// actual format may differ, but pixel transfers will use this
  /// format (one of the SDL_PixelFormatEnum values)
  /// \param access a pointer filled in with the actual access to the texture
  /// (one of the SDL_TextureAccess values)
  /// \param w a pointer filled in with the width of the texture in pixels
  /// \param h a pointer filled in with the height of the texture in pixels
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  int SDL_QueryTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint32> format,
    ffi.Pointer<ffi.Int> access,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_QueryTexture(
      texture,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_QueryTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_QueryTexture');
  late final _SDL_QueryTexture = _SDL_QueryTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint32>,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Set an additional color value multiplied into render copy operations.
  ///
  /// When this texture is rendered, during the copy operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// Color modulation is not always supported by the renderer; it will return -1
  /// if color modulation is not supported.
  ///
  /// \param texture the texture to update
  /// \param r the red color value multiplied into copy operations
  /// \param g the green color value multiplied into copy operations
  /// \param b the blue color value multiplied into copy operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureColorMod
  /// \sa SDL_SetTextureAlphaMod
  int SDL_SetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetTextureColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, Uint8, Uint8,
              Uint8)>>('SDL_SetTextureColorMod');
  late final _SDL_SetTextureColorMod = _SDL_SetTextureColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int, int, int)>();

  /// Get the additional color value multiplied into render copy operations.
  ///
  /// \param texture the texture to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureAlphaMod
  /// \sa SDL_SetTextureColorMod
  int SDL_GetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetTextureColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureColorMod');
  late final _SDL_GetTextureColorMod = _SDL_GetTextureColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value multiplied into render copy operations.
  ///
  /// When this texture is rendered, during the copy operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// Alpha modulation is not always supported by the renderer; it will return -1
  /// if alpha modulation is not supported.
  ///
  /// \param texture the texture to update
  /// \param alpha the source alpha value multiplied into copy operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureAlphaMod
  /// \sa SDL_SetTextureColorMod
  int SDL_SetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    int alpha,
  ) {
    return _SDL_SetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_SetTextureAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>, Uint8)>>('SDL_SetTextureAlphaMod');
  late final _SDL_SetTextureAlphaMod = _SDL_SetTextureAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the additional alpha value multiplied into render copy operations.
  ///
  /// \param texture the texture to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureColorMod
  /// \sa SDL_SetTextureAlphaMod
  int SDL_GetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_GetTextureAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureAlphaMod');
  late final _SDL_GetTextureAlphaMod = _SDL_GetTextureAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode for a texture, used by SDL_RenderCopy().
  ///
  /// If the blend mode is not supported, the closest supported mode is chosen
  /// and this function returns -1.
  ///
  /// \param texture the texture to update
  /// \param blendMode the SDL_BlendMode to use for texture blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureBlendMode
  /// \sa SDL_RenderCopy
  int SDL_SetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    int blendMode,
  ) {
    return _SDL_SetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_SetTextureBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>, ffi.Int32)>>('SDL_SetTextureBlendMode');
  late final _SDL_SetTextureBlendMode = _SDL_SetTextureBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the blend mode used for texture copy operations.
  ///
  /// \param texture the texture to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextureBlendMode
  int SDL_GetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_GetTextureBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetTextureBlendMode');
  late final _SDL_GetTextureBlendMode = _SDL_GetTextureBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Int32>)>();

  /// Set the scale mode used for texture scale operations.
  ///
  /// If the scale mode is not supported, the closest supported mode is chosen.
  ///
  /// \param texture The texture to update.
  /// \param scaleMode the SDL_ScaleMode to use for texture scaling.
  /// \returns 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_GetTextureScaleMode
  int SDL_SetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    int scaleMode,
  ) {
    return _SDL_SetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_SetTextureScaleModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>, ffi.Int32)>>('SDL_SetTextureScaleMode');
  late final _SDL_SetTextureScaleMode = _SDL_SetTextureScaleModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the scale mode used for texture scale operations.
  ///
  /// \param texture the texture to query.
  /// \param scaleMode a pointer filled in with the current scale mode.
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_SetTextureScaleMode
  int SDL_GetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> scaleMode,
  ) {
    return _SDL_GetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_GetTextureScaleModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetTextureScaleMode');
  late final _SDL_GetTextureScaleMode = _SDL_GetTextureScaleModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Int32>)>();

  /// Associate a user-specified pointer with a texture.
  ///
  /// \param texture the texture to update.
  /// \param userdata the pointer to associate with the texture.
  /// \returns 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetTextureUserData
  int SDL_SetTextureUserData(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetTextureUserData(
      texture,
      userdata,
    );
  }

  late final _SDL_SetTextureUserDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetTextureUserData');
  late final _SDL_SetTextureUserData = _SDL_SetTextureUserDataPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Void>)>();

  /// Get the user-specified pointer associated with a texture
  ///
  /// \param texture the texture to query.
  /// \return the pointer associated with the texture, or NULL if the texture is
  /// not valid.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetTextureUserData
  ffi.Pointer<ffi.Void> SDL_GetTextureUserData(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GetTextureUserData(
      texture,
    );
  }

  late final _SDL_GetTextureUserDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Texture>)>>('SDL_GetTextureUserData');
  late final _SDL_GetTextureUserData = _SDL_GetTextureUserDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Texture>)>();

  /// Update the given texture rectangle with new pixel data.
  ///
  /// The pixel data must be in the pixel format of the texture. Use
  /// SDL_QueryTexture() to query the pixel format of the texture.
  ///
  /// This is a fairly slow function, intended for use with static textures that
  /// do not change often.
  ///
  /// If the texture is intended to be updated often, it is preferred to create
  /// the texture as streaming and use the locking functions referenced below.
  /// While this function will work with streaming textures, for optimization
  /// reasons you may not get the pixels back if you lock the texture afterward.
  ///
  /// \param texture the texture to update
  /// \param rect an SDL_Rect structure representing the area to update, or NULL
  /// to update the entire texture
  /// \param pixels the raw pixel data in the format of the texture
  /// \param pitch the number of bytes in a row of pixel data, including padding
  /// between lines
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_LockTexture
  /// \sa SDL_UnlockTexture
  int SDL_UpdateTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_UpdateTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_UpdateTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_UpdateTexture');
  late final _SDL_UpdateTexture = _SDL_UpdateTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Void>, int)>();

  /// Update a rectangle within a planar YV12 or IYUV texture with new pixel
  /// data.
  ///
  /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
  /// block of Y and U/V planes in the proper order, but this function is
  /// available if your pixel data is not contiguous.
  ///
  /// \param texture the texture to update
  /// \param rect a pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture
  /// \param Yplane the raw pixel data for the Y plane
  /// \param Ypitch the number of bytes between rows of pixel data for the Y
  /// plane
  /// \param Uplane the raw pixel data for the U plane
  /// \param Upitch the number of bytes between rows of pixel data for the U
  /// plane
  /// \param Vplane the raw pixel data for the V plane
  /// \param Vpitch the number of bytes between rows of pixel data for the V
  /// plane
  /// \returns 0 on success or -1 if the texture is not valid; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_UpdateTexture
  int SDL_UpdateYUVTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> Uplane,
    int Upitch,
    ffi.Pointer<Uint8> Vplane,
    int Vpitch,
  ) {
    return _SDL_UpdateYUVTexture(
      texture,
      rect,
      Yplane,
      Ypitch,
      Uplane,
      Upitch,
      Vplane,
      Vpitch,
    );
  }

  late final _SDL_UpdateYUVTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int)>>('SDL_UpdateYUVTexture');
  late final _SDL_UpdateYUVTexture = _SDL_UpdateYUVTexturePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int)>();

  /// Update a rectangle within a planar NV12 or NV21 texture with new pixels.
  ///
  /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
  /// block of NV12/21 planes in the proper order, but this function is available
  /// if your pixel data is not contiguous.
  ///
  /// \param texture the texture to update
  /// \param rect a pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param Yplane the raw pixel data for the Y plane.
  /// \param Ypitch the number of bytes between rows of pixel data for the Y
  /// plane.
  /// \param UVplane the raw pixel data for the UV plane.
  /// \param UVpitch the number of bytes between rows of pixel data for the UV
  /// plane.
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_UpdateNVTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> UVplane,
    int UVpitch,
  ) {
    return _SDL_UpdateNVTexture(
      texture,
      rect,
      Yplane,
      Ypitch,
      UVplane,
      UVpitch,
    );
  }

  late final _SDL_UpdateNVTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int)>>('SDL_UpdateNVTexture');
  late final _SDL_UpdateNVTexture = _SDL_UpdateNVTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>, int, ffi.Pointer<Uint8>, int)>();

  /// Lock a portion of the texture for **write-only** pixel access.
  ///
  /// As an optimization, the pixels made available for editing don't necessarily
  /// contain the old texture data. This is a write-only operation, and if you
  /// need to keep a copy of the texture data you should do that at the
  /// application level.
  ///
  /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
  /// changes.
  ///
  /// \param texture the texture to lock for access, which was created with
  /// `SDL_TEXTUREACCESS_STREAMING`
  /// \param rect an SDL_Rect structure representing the area to lock for access;
  /// NULL to lock the entire texture
  /// \param pixels this is filled in with a pointer to the locked pixels,
  /// appropriately offset by the locked area
  /// \param pitch this is filled in with the pitch of the locked pixels; the
  /// pitch is the length of one row in bytes
  /// \returns 0 on success or a negative error code if the texture is not valid
  /// or was not created with `SDL_TEXTUREACCESS_STREAMING`; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UnlockTexture
  int SDL_LockTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
    ffi.Pointer<ffi.Int> pitch,
  ) {
    return _SDL_LockTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_LockTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Int>)>>('SDL_LockTexture');
  late final _SDL_LockTexture = _SDL_LockTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Int>)>();

  /// Lock a portion of the texture for **write-only** pixel access, and expose
  /// it as a SDL surface.
  ///
  /// Besides providing an SDL_Surface instead of raw pixel data, this function
  /// operates like SDL_LockTexture.
  ///
  /// As an optimization, the pixels made available for editing don't necessarily
  /// contain the old texture data. This is a write-only operation, and if you
  /// need to keep a copy of the texture data you should do that at the
  /// application level.
  ///
  /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
  /// changes.
  ///
  /// The returned surface is freed internally after calling SDL_UnlockTexture()
  /// or SDL_DestroyTexture(). The caller should not free it.
  ///
  /// \param texture the texture to lock for access, which was created with
  /// `SDL_TEXTUREACCESS_STREAMING`
  /// \param rect a pointer to the rectangle to lock for access. If the rect is
  /// NULL, the entire texture will be locked
  /// \param surface this is filled in with an SDL surface representing the
  /// locked area
  /// \returns 0 on success, or -1 if the texture is not valid or was not created
  /// with `SDL_TEXTUREACCESS_STREAMING`
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_LockTexture
  /// \sa SDL_UnlockTexture
  int SDL_LockTextureToSurface(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
  ) {
    return _SDL_LockTextureToSurface(
      texture,
      rect,
      surface,
    );
  }

  late final _SDL_LockTextureToSurfacePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
                  ffi.Pointer<ffi.Pointer<SDL_Surface>>)>>(
      'SDL_LockTextureToSurface');
  late final _SDL_LockTextureToSurface =
      _SDL_LockTextureToSurfacePtr.asFunction<
          int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<SDL_Surface>>)>();

  /// Unlock a texture, uploading the changes to video memory, if needed.
  ///
  /// **Warning**: Please note that SDL_LockTexture() is intended to be
  /// write-only; it will not guarantee the previous contents of the texture will
  /// be provided. You must fully initialize any area of a texture that you lock
  /// before unlocking it, as the pixels might otherwise be uninitialized memory.
  ///
  /// Which is to say: locking and immediately unlocking a texture can result in
  /// corrupted textures, depending on the renderer in use.
  ///
  /// \param texture a texture locked by SDL_LockTexture()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockTexture
  void SDL_UnlockTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_UnlockTexture(
      texture,
    );
  }

  late final _SDL_UnlockTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_UnlockTexture');
  late final _SDL_UnlockTexture = _SDL_UnlockTexturePtr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// Determine whether a renderer supports the use of render targets.
  ///
  /// \param renderer the renderer that will be checked
  /// \returns SDL_TRUE if supported or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderTarget
  int SDL_RenderTargetSupported(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderTargetSupported(
      renderer,
    );
  }

  late final _SDL_RenderTargetSupportedPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderTargetSupported');
  late final _SDL_RenderTargetSupported = _SDL_RenderTargetSupportedPtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set a texture as the current rendering target.
  ///
  /// Before using this function, you should check the
  /// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if
  /// render targets are supported.
  ///
  /// The default render target is the window for which the renderer was created.
  /// To stop rendering to a texture and render to the window again, call this
  /// function with a NULL `texture`.
  ///
  /// \param renderer the rendering context
  /// \param texture the targeted texture, which must be created with the
  /// `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
  /// window instead of a texture.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderTarget
  int SDL_SetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_SetRenderTarget(
      renderer,
      texture,
    );
  }

  late final _SDL_SetRenderTargetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>)>>('SDL_SetRenderTarget');
  late final _SDL_SetRenderTarget = _SDL_SetRenderTargetPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>)>();

  /// Get the current render target.
  ///
  /// The default render target is the window for which the renderer was created,
  /// and is reported a NULL here.
  ///
  /// \param renderer the rendering context
  /// \returns the current render target or NULL for the default render target.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderTarget
  ffi.Pointer<SDL_Texture> SDL_GetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_GetRenderTarget(
      renderer,
    );
  }

  late final _SDL_GetRenderTargetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_GetRenderTarget');
  late final _SDL_GetRenderTarget = _SDL_GetRenderTargetPtr.asFunction<
      ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set a device independent resolution for rendering.
  ///
  /// This function uses the viewport and scaling functionality to allow a fixed
  /// logical resolution for rendering, regardless of the actual output
  /// resolution. If the actual output resolution doesn't have the same aspect
  /// ratio the output rendering will be centered within the output display.
  ///
  /// If the output display is a window, mouse and touch events in the window
  /// will be filtered and scaled so they seem to arrive within the logical
  /// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether
  /// relative motion events are also scaled.
  ///
  /// If this function results in scaling or subpixel drawing by the rendering
  /// backend, it will be handled using the appropriate quality hints.
  ///
  /// \param renderer the renderer for which resolution should be set
  /// \param w the width of the logical resolution
  /// \param h the height of the logical resolution
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetLogicalSize
  int SDL_RenderSetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    int w,
    int h,
  ) {
    return _SDL_RenderSetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderSetLogicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int,
              ffi.Int)>>('SDL_RenderSetLogicalSize');
  late final _SDL_RenderSetLogicalSize = _SDL_RenderSetLogicalSizePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// Get device independent resolution for rendering.
  ///
  /// This may return 0 for `w` and `h` if the SDL_Renderer has never had its
  /// logical size set by SDL_RenderSetLogicalSize() and never had a render
  /// target set.
  ///
  /// \param renderer a rendering context
  /// \param w an int to be filled with the width
  /// \param h an int to be filled with the height
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderGetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_RenderGetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderGetLogicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_RenderGetLogicalSize');
  late final _SDL_RenderGetLogicalSize =
      _SDL_RenderGetLogicalSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set whether to force integer scales for resolution-independent rendering.
  ///
  /// This function restricts the logical viewport to integer values - that is,
  /// when a resolution is between two multiples of a logical size, the viewport
  /// size is rounded down to the lower multiple.
  ///
  /// \param renderer the renderer for which integer scaling should be set
  /// \param enable enable or disable the integer scaling for rendering
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RenderGetIntegerScale
  /// \sa SDL_RenderSetLogicalSize
  int SDL_RenderSetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
    int enable,
  ) {
    return _SDL_RenderSetIntegerScale(
      renderer,
      enable,
    );
  }

  late final _SDL_RenderSetIntegerScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Int32)>>('SDL_RenderSetIntegerScale');
  late final _SDL_RenderSetIntegerScale = _SDL_RenderSetIntegerScalePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get whether integer scales are forced for resolution-independent rendering.
  ///
  /// \param renderer the renderer from which integer scaling should be queried
  /// \returns SDL_TRUE if integer scales are forced or SDL_FALSE if not and on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RenderSetIntegerScale
  int SDL_RenderGetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetIntegerScale(
      renderer,
    );
  }

  late final _SDL_RenderGetIntegerScalePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderGetIntegerScale');
  late final _SDL_RenderGetIntegerScale = _SDL_RenderGetIntegerScalePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set the drawing area for rendering on the current target.
  ///
  /// When the window is resized, the viewport is reset to fill the entire new
  /// window size.
  ///
  /// \param renderer the rendering context
  /// \param rect the SDL_Rect structure representing the drawing area, or NULL
  /// to set the viewport to the entire target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetViewport
  int SDL_RenderSetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetViewport');
  late final _SDL_RenderSetViewport = _SDL_RenderSetViewportPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get the drawing area for the current target.
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure filled in with the current drawing area
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetViewport
  void SDL_RenderGetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetViewport');
  late final _SDL_RenderGetViewport = _SDL_RenderGetViewportPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Set the clip rectangle for rendering on the specified target.
  ///
  /// \param renderer the rendering context for which clip rectangle should be
  /// set
  /// \param rect an SDL_Rect structure representing the clip area, relative to
  /// the viewport, or NULL to disable clipping
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetClipRect
  /// \sa SDL_RenderIsClipEnabled
  int SDL_RenderSetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetClipRect');
  late final _SDL_RenderSetClipRect = _SDL_RenderSetClipRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clip rectangle for the current target.
  ///
  /// \param renderer the rendering context from which clip rectangle should be
  /// queried
  /// \param rect an SDL_Rect structure filled in with the current clipping area
  /// or an empty rectangle if clipping is disabled
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderIsClipEnabled
  /// \sa SDL_RenderSetClipRect
  void SDL_RenderGetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetClipRect');
  late final _SDL_RenderGetClipRect = _SDL_RenderGetClipRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get whether clipping is enabled on the given renderer.
  ///
  /// \param renderer the renderer from which clip state should be queried
  /// \returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_RenderGetClipRect
  /// \sa SDL_RenderSetClipRect
  int SDL_RenderIsClipEnabled(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderIsClipEnabled(
      renderer,
    );
  }

  late final _SDL_RenderIsClipEnabledPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderIsClipEnabled');
  late final _SDL_RenderIsClipEnabled = _SDL_RenderIsClipEnabledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set the drawing scale for rendering on the current target.
  ///
  /// The drawing coordinates are scaled by the x/y scaling factors before they
  /// are used by the renderer. This allows resolution independent drawing with a
  /// single coordinate system.
  ///
  /// If this results in scaling or subpixel drawing by the rendering backend, it
  /// will be handled using the appropriate quality hints. For best results use
  /// integer scaling factors.
  ///
  /// \param renderer a rendering context
  /// \param scaleX the horizontal scaling factor
  /// \param scaleY the vertical scaling factor
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetLogicalSize
  int SDL_RenderSetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    double scaleX,
    double scaleY,
  ) {
    return _SDL_RenderSetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderSetScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderSetScale');
  late final _SDL_RenderSetScale = _SDL_RenderSetScalePtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// Get the drawing scale for the current target.
  ///
  /// \param renderer the renderer from which drawing scale should be queried
  /// \param scaleX a pointer filled in with the horizontal scaling factor
  /// \param scaleY a pointer filled in with the vertical scaling factor
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetScale
  void SDL_RenderGetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Float> scaleX,
    ffi.Pointer<ffi.Float> scaleY,
  ) {
    return _SDL_RenderGetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderGetScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderGetScale');
  late final _SDL_RenderGetScale = _SDL_RenderGetScalePtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get logical coordinates of point in renderer when given real coordinates of
  /// point in window.
  ///
  /// Logical coordinates will differ from real coordinates when render is scaled
  /// and logical renderer size set
  ///
  /// \param renderer the renderer from which the logical coordinates should be
  /// calcualted
  /// \param windowX the real X coordinate in the window
  /// \param windowY the real Y coordinate in the window
  /// \param logicalX the pointer filled with the logical x coordinate
  /// \param logicalY the pointer filled with the logical y coordinate
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetScale
  /// \sa SDL_RenderGetLogicalSize
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderWindowToLogical(
    ffi.Pointer<SDL_Renderer> renderer,
    int windowX,
    int windowY,
    ffi.Pointer<ffi.Float> logicalX,
    ffi.Pointer<ffi.Float> logicalY,
  ) {
    return _SDL_RenderWindowToLogical(
      renderer,
      windowX,
      windowY,
      logicalX,
      logicalY,
    );
  }

  late final _SDL_RenderWindowToLogicalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderWindowToLogical');
  late final _SDL_RenderWindowToLogical =
      _SDL_RenderWindowToLogicalPtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, int, int,
              ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get real coordinates of point in window when given logical coordinates of point in renderer.
  /// Logical coordinates will differ from real coordinates when render is scaled and logical renderer size set
  ///
  /// \param renderer the renderer from which the window coordinates should be calculated
  /// \param logicalX the logical x coordinate
  /// \param logicalY the logical y coordinate
  /// \param windowX the pointer filled with the real X coordinate in the window
  /// \param windowY the pointer filled with the real Y coordinate in the window
  ///
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetScale
  /// \sa SDL_RenderGetLogicalSize
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderLogicalToWindow(
    ffi.Pointer<SDL_Renderer> renderer,
    double logicalX,
    double logicalY,
    ffi.Pointer<ffi.Int> windowX,
    ffi.Pointer<ffi.Int> windowY,
  ) {
    return _SDL_RenderLogicalToWindow(
      renderer,
      logicalX,
      logicalY,
      windowX,
      windowY,
    );
  }

  late final _SDL_RenderLogicalToWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Float,
              ffi.Float,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_RenderLogicalToWindow');
  late final _SDL_RenderLogicalToWindow =
      _SDL_RenderLogicalToWindowPtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, double, double,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Set the color used for drawing operations (Rect, Line and Clear).
  ///
  /// Set the color for drawing or filling rectangles, lines, and points, and for
  /// SDL_RenderClear().
  ///
  /// \param renderer the rendering context
  /// \param r the red value used to draw on the rendering target
  /// \param g the green value used to draw on the rendering target
  /// \param b the blue value used to draw on the rendering target
  /// \param a the alpha value used to draw on the rendering target; usually
  /// `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
  /// specify how the alpha channel is used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderDrawColor
  /// \sa SDL_RenderClear
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  int SDL_SetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_SetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_SetRenderDrawColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_SetRenderDrawColor');
  late final _SDL_SetRenderDrawColor = _SDL_SetRenderDrawColorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Get the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer the rendering context
  /// \param r a pointer filled in with the red value used to draw on the
  /// rendering target
  /// \param g a pointer filled in with the green value used to draw on the
  /// rendering target
  /// \param b a pointer filled in with the blue value used to draw on the
  /// rendering target
  /// \param a a pointer filled in with the alpha value used to draw on the
  /// rendering target; usually `SDL_ALPHA_OPAQUE` (255)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawColor
  int SDL_GetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRenderDrawColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRenderDrawColor');
  late final _SDL_GetRenderDrawColor = _SDL_GetRenderDrawColorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for drawing operations (Fill and Line).
  ///
  /// If the blend mode is not supported, the closest supported mode is chosen.
  ///
  /// \param renderer the rendering context
  /// \param blendMode the SDL_BlendMode to use for blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  int SDL_SetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    int blendMode,
  ) {
    return _SDL_SetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_SetRenderDrawBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Int32)>>('SDL_SetRenderDrawBlendMode');
  late final _SDL_SetRenderDrawBlendMode = _SDL_SetRenderDrawBlendModePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get the blend mode used for drawing operations.
  ///
  /// \param renderer the rendering context
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  int SDL_GetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_GetRenderDrawBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetRenderDrawBlendMode');
  late final _SDL_GetRenderDrawBlendMode =
      _SDL_GetRenderDrawBlendModePtr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>)>();

  /// Clear the current rendering target with the drawing color.
  ///
  /// This function clears the entire rendering target, ignoring the viewport and
  /// the clip rectangle.
  ///
  /// \param renderer the rendering context
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderClear(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderClear(
      renderer,
    );
  }

  late final _SDL_RenderClearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderClear');
  late final _SDL_RenderClear =
      _SDL_RenderClearPtr.asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Draw a point on the current rendering target.
  ///
  /// SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,
  /// use SDL_RenderDrawPoints() instead.
  ///
  /// \param renderer the rendering context
  /// \param x the x coordinate of the point
  /// \param y the y coordinate of the point
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawPoint(
    ffi.Pointer<SDL_Renderer> renderer,
    int x,
    int y,
  ) {
    return _SDL_RenderDrawPoint(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int,
              ffi.Int)>>('SDL_RenderDrawPoint');
  late final _SDL_RenderDrawPoint = _SDL_RenderDrawPointPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// Draw multiple points on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param points an array of SDL_Point structures that represent the points to
  /// draw
  /// \param count the number of points to draw
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawPoints(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawPoints(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int)>>('SDL_RenderDrawPoints');
  late final _SDL_RenderDrawPoints = _SDL_RenderDrawPointsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// Draw a line on the current rendering target.
  ///
  /// SDL_RenderDrawLine() draws the line to include both end points. If you want
  /// to draw multiple, connecting lines use SDL_RenderDrawLines() instead.
  ///
  /// \param renderer the rendering context
  /// \param x1 the x coordinate of the start point
  /// \param y1 the y coordinate of the start point
  /// \param x2 the x coordinate of the end point
  /// \param y2 the y coordinate of the end point
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawLine(
    ffi.Pointer<SDL_Renderer> renderer,
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _SDL_RenderDrawLine(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_RenderDrawLine');
  late final _SDL_RenderDrawLine = _SDL_RenderDrawLinePtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param points an array of SDL_Point structures representing points along
  /// the lines
  /// \param count the number of points, drawing count-1 lines
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawLines(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawLines(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int)>>('SDL_RenderDrawLines');
  late final _SDL_RenderDrawLines = _SDL_RenderDrawLinesPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// Draw a rectangle on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure representing the rectangle to draw, or
  /// NULL to outline the entire rendering target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderDrawRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderDrawRect');
  late final _SDL_RenderDrawRect = _SDL_RenderDrawRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param rects an array of SDL_Rect structures representing the rectangles to
  /// be drawn
  /// \param count the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_RenderDrawRects');
  late final _SDL_RenderDrawRects = _SDL_RenderDrawRectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// The current drawing color is set by SDL_SetRenderDrawColor(), and the
  /// color's alpha value is ignored unless blending is enabled with the
  /// appropriate call to SDL_SetRenderDrawBlendMode().
  ///
  /// \param renderer the rendering context
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL for the entire rendering target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderFillRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderFillRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderFillRect');
  late final _SDL_RenderFillRect = _SDL_RenderFillRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Fill some number of rectangles on the current rendering target with the
  /// drawing color.
  ///
  /// \param renderer the rendering context
  /// \param rects an array of SDL_Rect structures representing the rectangles to
  /// be filled
  /// \param count the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderPresent
  int SDL_RenderFillRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderFillRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_RenderFillRects');
  late final _SDL_RenderFillRects = _SDL_RenderFillRectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// Copy a portion of the texture to the current rendering target.
  ///
  /// The texture is blended with the destination based on its blend mode set
  /// with SDL_SetTextureBlendMode().
  ///
  /// The texture color is affected based on its color modulation set by
  /// SDL_SetTextureColorMod().
  ///
  /// The texture alpha is affected based on its alpha modulation set by
  /// SDL_SetTextureAlphaMod().
  ///
  /// \param renderer the rendering context
  /// \param texture the source texture
  /// \param srcrect the source SDL_Rect structure or NULL for the entire texture
  /// \param dstrect the destination SDL_Rect structure or NULL for the entire
  /// rendering target; the texture will be stretched to fill the
  /// given rectangle
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderCopyEx
  /// \sa SDL_SetTextureAlphaMod
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_SetTextureColorMod
  int SDL_RenderCopy(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_RenderCopy(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>>('SDL_RenderCopy');
  late final _SDL_RenderCopy = _SDL_RenderCopyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Copy a portion of the texture to the current rendering, with optional
  /// rotation and flipping.
  ///
  /// Copy a portion of the texture to the current rendering target, optionally
  /// rotating it by angle around the given center and also flipping it
  /// top-bottom and/or left-right.
  ///
  /// The texture is blended with the destination based on its blend mode set
  /// with SDL_SetTextureBlendMode().
  ///
  /// The texture color is affected based on its color modulation set by
  /// SDL_SetTextureColorMod().
  ///
  /// The texture alpha is affected based on its alpha modulation set by
  /// SDL_SetTextureAlphaMod().
  ///
  /// \param renderer the rendering context
  /// \param texture the source texture
  /// \param srcrect the source SDL_Rect structure or NULL for the entire texture
  /// \param dstrect the destination SDL_Rect structure or NULL for the entire
  /// rendering target
  /// \param angle an angle in degrees that indicates the rotation that will be
  /// applied to dstrect, rotating it in a clockwise direction
  /// \param center a pointer to a point indicating the point around which
  /// dstrect will be rotated (if NULL, rotation will be done
  /// around `dstrect.w / 2`, `dstrect.h / 2`)
  /// \param flip a SDL_RendererFlip value stating which flipping actions should
  /// be performed on the texture
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderCopy
  /// \sa SDL_SetTextureAlphaMod
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_SetTextureColorMod
  int SDL_RenderCopyEx(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
    double angle,
    ffi.Pointer<SDL_Point> center,
    int flip,
  ) {
    return _SDL_RenderCopyEx(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>,
              ffi.Double,
              ffi.Pointer<SDL_Point>,
              ffi.Int32)>>('SDL_RenderCopyEx');
  late final _SDL_RenderCopyEx = _SDL_RenderCopyExPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>,
          double,
          ffi.Pointer<SDL_Point>,
          int)>();

  /// Draw a point on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawPointF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x,
    double y,
  ) {
    return _SDL_RenderDrawPointF(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderDrawPointF');
  late final _SDL_RenderDrawPointF = _SDL_RenderDrawPointFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// Draw multiple points on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawPointsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawPointsF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int)>>('SDL_RenderDrawPointsF');
  late final _SDL_RenderDrawPointsF = _SDL_RenderDrawPointsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// Draw a line on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawLineF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _SDL_RenderDrawLineF(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLineFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float)>>('SDL_RenderDrawLineF');
  late final _SDL_RenderDrawLineF = _SDL_RenderDrawLineFPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>, double, double, double, double)>();

  /// Draw a series of connected lines on the current rendering target at
  /// subpixel precision.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawLinesF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawLinesF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int)>>('SDL_RenderDrawLinesF');
  late final _SDL_RenderDrawLinesF = _SDL_RenderDrawLinesFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// Draw a rectangle on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the
  /// entire rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderDrawRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderDrawRectF');
  late final _SDL_RenderDrawRectF = _SDL_RenderDrawRectFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// Draw some number of rectangles on the current rendering target at subpixel
  /// precision.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int)>>('SDL_RenderDrawRectsF');
  late final _SDL_RenderDrawRectsF = _SDL_RenderDrawRectsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// Fill a rectangle on the current rendering target with the drawing color at
  /// subpixel precision.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFillRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderFillRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderFillRectF');
  late final _SDL_RenderFillRectF = _SDL_RenderFillRectFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// Fill some number of rectangles on the current rendering target with the
  /// drawing color at subpixel precision.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFillRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderFillRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int)>>('SDL_RenderFillRectsF');
  late final _SDL_RenderFillRectsF = _SDL_RenderFillRectsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// Copy a portion of the texture to the current rendering target at subpixel
  /// precision.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderCopyF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
  ) {
    return _SDL_RenderCopyF(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderCopyF');
  late final _SDL_RenderCopyF = _SDL_RenderCopyFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_FRect>)>();

  /// Copy a portion of the source texture to the current rendering target, with
  /// rotation and flipping, at subpixel precision.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle An angle in degrees that indicates the rotation that will be
  /// applied to dstrect, rotating it in a clockwise direction
  /// \param center A pointer to a point indicating the point around which
  /// dstrect will be rotated (if NULL, rotation will be done
  /// around dstrect.w/2, dstrect.h/2).
  /// \param flip An SDL_RendererFlip value stating which flipping actions should
  /// be performed on the texture
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderCopyExF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
    double angle,
    ffi.Pointer<SDL_FPoint> center,
    int flip,
  ) {
    return _SDL_RenderCopyExF(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyExFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>,
              ffi.Double,
              ffi.Pointer<SDL_FPoint>,
              ffi.Int32)>>('SDL_RenderCopyExF');
  late final _SDL_RenderCopyExF = _SDL_RenderCopyExFPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_FRect>,
          double,
          ffi.Pointer<SDL_FPoint>,
          int)>();

  /// Render a list of triangles, optionally using a texture and indices into the
  /// vertex array Color and alpha modulation is done per vertex
  /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
  ///
  /// \param texture (optional) The SDL texture to use.
  /// \param vertices Vertices.
  /// \param num_vertices Number of vertices.
  /// \param indices (optional) An array of integer indices into the 'vertices'
  /// array, if NULL all vertices will be rendered in sequential
  /// order.
  /// \param num_indices Number of indices.
  /// \return 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGeometryRaw
  /// \sa SDL_Vertex
  int SDL_RenderGeometry(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Vertex> vertices,
    int num_vertices,
    ffi.Pointer<ffi.Int> indices,
    int num_indices,
  ) {
    return _SDL_RenderGeometry(
      renderer,
      texture,
      vertices,
      num_vertices,
      indices,
      num_indices,
    );
  }

  late final _SDL_RenderGeometryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Vertex>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('SDL_RenderGeometry');
  late final _SDL_RenderGeometry = _SDL_RenderGeometryPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Vertex>, int, ffi.Pointer<ffi.Int>, int)>();

  /// Render a list of triangles, optionally using a texture and indices into the
  /// vertex arrays Color and alpha modulation is done per vertex
  /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
  ///
  /// \param texture (optional) The SDL texture to use.
  /// \param xy Vertex positions
  /// \param xy_stride Byte size to move from one element to the next element
  /// \param color Vertex colors (as SDL_Color)
  /// \param color_stride Byte size to move from one element to the next element
  /// \param uv Vertex normalized texture coordinates
  /// \param uv_stride Byte size to move from one element to the next element
  /// \param num_vertices Number of vertices.
  /// \param indices (optional) An array of indices into the 'vertices' arrays,
  /// if NULL all vertices will be rendered in sequential order.
  /// \param num_indices Number of indices.
  /// \param size_indices Index size: 1 (byte), 2 (short), 4 (int)
  /// \return 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGeometry
  /// \sa SDL_Vertex
  int SDL_RenderGeometryRaw(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> xy,
    int xy_stride,
    ffi.Pointer<SDL_Color> color,
    int color_stride,
    ffi.Pointer<ffi.Float> uv,
    int uv_stride,
    int num_vertices,
    ffi.Pointer<ffi.Void> indices,
    int num_indices,
    int size_indices,
  ) {
    return _SDL_RenderGeometryRaw(
      renderer,
      texture,
      xy,
      xy_stride,
      color,
      color_stride,
      uv,
      uv_stride,
      num_vertices,
      indices,
      num_indices,
      size_indices,
    );
  }

  late final _SDL_RenderGeometryRawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<SDL_Color>,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int)>>('SDL_RenderGeometryRaw');
  late final _SDL_RenderGeometryRaw = _SDL_RenderGeometryRawPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<ffi.Float>,
          int,
          ffi.Pointer<SDL_Color>,
          int,
          ffi.Pointer<ffi.Float>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Read pixels from the current rendering target to an array of pixels.
  ///
  /// **WARNING**: This is a very slow operation, and should not be used
  /// frequently.
  ///
  /// `pitch` specifies the number of bytes between rows in the destination
  /// `pixels` data. This allows you to write to a subrectangle or have padded
  /// rows in the destination. Generally, `pitch` should equal the number of
  /// pixels per row in the `pixels` data times the number of bytes per pixel,
  /// but it might contain additional padding (for example, 24bit RGB Windows
  /// Bitmap data pads all rows to multiples of 4 bytes).
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure representing the area to read, or NULL
  /// for the entire render target
  /// \param format an SDL_PixelFormatEnum value of the desired format of the
  /// pixel data, or 0 to use the format of the rendering target
  /// \param pixels a pointer to the pixel data to copy into
  /// \param pitch the pitch of the `pixels` parameter
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_RenderReadPixels(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
    int format,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_RenderReadPixels(
      renderer,
      rect,
      format,
      pixels,
      pitch,
    );
  }

  late final _SDL_RenderReadPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              Uint32, ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RenderReadPixels');
  late final _SDL_RenderReadPixels = _SDL_RenderReadPixelsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Update the screen with any rendering performed since the previous call.
  ///
  /// SDL's rendering functions operate on a backbuffer; that is, calling a
  /// rendering function such as SDL_RenderDrawLine() does not directly put a
  /// line on the screen, but rather updates the backbuffer. As such, you compose
  /// your entire scene and *present* the composed backbuffer to the screen as a
  /// complete picture.
  ///
  /// Therefore, when using SDL's rendering API, one does all drawing intended
  /// for the frame, and then calls this function once per frame to present the
  /// final drawing to the user.
  ///
  /// The backbuffer should be considered invalidated after each present; do not
  /// assume that previous contents will exist between frames. You are strongly
  /// encouraged to call SDL_RenderClear() to initialize the backbuffer before
  /// starting each new frame's drawing, even if you plan to overwrite every
  /// pixel.
  ///
  /// \param renderer the rendering context
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderClear
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  void SDL_RenderPresent(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderPresent(
      renderer,
    );
  }

  late final _SDL_RenderPresentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderPresent');
  late final _SDL_RenderPresent = _SDL_RenderPresentPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// Destroy the specified texture.
  ///
  /// Passing NULL or an otherwise invalid texture will set the SDL error message
  /// to "Invalid texture".
  ///
  /// \param texture the texture to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_CreateTextureFromSurface
  void SDL_DestroyTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_DestroyTexture(
      texture,
    );
  }

  late final _SDL_DestroyTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_DestroyTexture');
  late final _SDL_DestroyTexture = _SDL_DestroyTexturePtr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// Destroy the rendering context for a window and free associated textures.
  ///
  /// \param renderer the rendering context
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  void SDL_DestroyRenderer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_DestroyRenderer(
      renderer,
    );
  }

  late final _SDL_DestroyRendererPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_DestroyRenderer');
  late final _SDL_DestroyRenderer = _SDL_DestroyRendererPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// Force the rendering context to flush any pending commands to the underlying
  /// rendering API.
  ///
  /// You do not need to (and in fact, shouldn't) call this function unless you
  /// are planning to call into OpenGL/Direct3D/Metal/whatever directly in
  /// addition to using an SDL_Renderer.
  ///
  /// This is for a very-specific case: if you are using SDL's render API, you
  /// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set
  /// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever
  /// calls in addition to SDL render API calls. If all of this applies, you
  /// should call SDL_RenderFlush() between calls to SDL's render API and the
  /// low-level API you're using in cooperation.
  ///
  /// In all other cases, you can ignore this function. This is only here to get
  /// maximum performance out of a specific situation. In all other cases, SDL
  /// will do the right thing, perhaps at a performance loss.
  ///
  /// This function is first available in SDL 2.0.10, and is not needed in 2.0.9
  /// and earlier, as earlier versions did not queue rendering commands at all,
  /// instead flushing them to the OS immediately.
  ///
  /// \param renderer the rendering context
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFlush(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderFlush(
      renderer,
    );
  }

  late final _SDL_RenderFlushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderFlush');
  late final _SDL_RenderFlush =
      _SDL_RenderFlushPtr.asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Bind an OpenGL/ES/ES2 texture to the current context.
  ///
  /// This is for use with OpenGL instructions when rendering OpenGL primitives
  /// directly.
  ///
  /// If not NULL, `texw` and `texh` will be filled with the width and height
  /// values suitable for the provided texture. In most cases, both will be 1.0,
  /// however, on systems that support the GL_ARB_texture_rectangle extension,
  /// these values will actually be the pixel width and height used to create the
  /// texture, so this factor needs to be taken into account when providing
  /// texture coordinates to OpenGL.
  ///
  /// You need a renderer to create an SDL_Texture, therefore you can only use
  /// this function with an implicit OpenGL context from SDL_CreateRenderer(),
  /// not with your own OpenGL context. If you need control over your OpenGL
  /// context, you need to write your own texture-loading methods.
  ///
  /// Also note that SDL may upload RGB textures as BGR (or vice-versa), and
  /// re-order the color channels in the shaders phase, so the uploaded texture
  /// may have swapped color channels.
  ///
  /// \param texture the texture to bind to the current OpenGL/ES/ES2 context
  /// \param texw a pointer to a float value which will be filled with the
  /// texture width or NULL if you don't need that value
  /// \param texh a pointer to a float value which will be filled with the
  /// texture height or NULL if you don't need that value
  /// \returns 0 on success, or -1 if the operation is not supported; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  /// \sa SDL_GL_UnbindTexture
  int SDL_GL_BindTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> texw,
    ffi.Pointer<ffi.Float> texh,
  ) {
    return _SDL_GL_BindTexture(
      texture,
      texw,
      texh,
    );
  }

  late final _SDL_GL_BindTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GL_BindTexture');
  late final _SDL_GL_BindTexture = _SDL_GL_BindTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Unbind an OpenGL/ES/ES2 texture from the current context.
  ///
  /// See SDL_GL_BindTexture() for examples on how to use these functions
  ///
  /// \param texture the texture to unbind from the current OpenGL/ES/ES2 context
  /// \returns 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_BindTexture
  /// \sa SDL_GL_MakeCurrent
  int SDL_GL_UnbindTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GL_UnbindTexture(
      texture,
    );
  }

  late final _SDL_GL_UnbindTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_GL_UnbindTexture');
  late final _SDL_GL_UnbindTexture = _SDL_GL_UnbindTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>)>();

  /// Get the CAMetalLayer associated with the given Metal renderer.
  ///
  /// This function returns `void *`, so SDL doesn't have to include Metal's
  /// headers, but it can be safely cast to a `CAMetalLayer *`.
  ///
  /// \param renderer The renderer to query
  /// \returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a
  /// Metal renderer
  ///
  /// \since This function is available since SDL 2.0.8.
  ///
  /// \sa SDL_RenderGetMetalCommandEncoder
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalLayer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalLayer(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalLayerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalLayer');
  late final _SDL_RenderGetMetalLayer = _SDL_RenderGetMetalLayerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the Metal command encoder for the current frame
  ///
  /// This function returns `void *`, so SDL doesn't have to include Metal's
  /// headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
  ///
  /// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give
  /// SDL a drawable to render to, which might happen if the window is
  /// hidden/minimized/offscreen. This doesn't apply to command encoders for
  /// render targets, just the window's backbacker. Check your return values!
  ///
  /// \param renderer The renderer to query
  /// \returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the
  /// renderer isn't a Metal renderer or there was an error.
  ///
  /// \since This function is available since SDL 2.0.8.
  ///
  /// \sa SDL_RenderGetMetalLayer
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalCommandEncoder(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalCommandEncoder(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalCommandEncoderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalCommandEncoder');
  late final _SDL_RenderGetMetalCommandEncoder =
      _SDL_RenderGetMetalCommandEncoderPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Toggle VSync of the given renderer.
  ///
  /// \param renderer The renderer to toggle
  /// \param vsync 1 for on, 0 for off. All other values are reserved
  /// \returns a 0 int on success, or non-zero on failure
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_RenderSetVSync(
    ffi.Pointer<SDL_Renderer> renderer,
    int vsync,
  ) {
    return _SDL_RenderSetVSync(
      renderer,
      vsync,
    );
  }

  late final _SDL_RenderSetVSyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>, ffi.Int)>>('SDL_RenderSetVSync');
  late final _SDL_RenderSetVSync = _SDL_RenderSetVSyncPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Create a window that can be shaped with the specified position, dimensions,
  /// and flags.
  ///
  /// \param title The title of the window, in UTF-8 encoding.
  /// \param x The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param w The width of the window.
  /// \param h The height of the window.
  /// \param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with
  /// any of the following: ::SDL_WINDOW_OPENGL,
  /// ::SDL_WINDOW_INPUT_GRABBED, ::SDL_WINDOW_HIDDEN,
  /// ::SDL_WINDOW_RESIZABLE, ::SDL_WINDOW_MAXIMIZED,
  /// ::SDL_WINDOW_MINIMIZED, ::SDL_WINDOW_BORDERLESS is always set,
  /// and ::SDL_WINDOW_FULLSCREEN is always unset.
  /// \return the window created, or NULL if window creation failed.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateShapedWindow(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateShapedWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateShapedWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              Uint32)>>('SDL_CreateShapedWindow');
  late final _SDL_CreateShapedWindow = _SDL_CreateShapedWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Return whether the given window is a shaped window.
  ///
  /// \param window The window to query for being shaped.
  /// \return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if
  /// the window is unshaped or NULL.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateShapedWindow
  int SDL_IsShapedWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsShapedWindow(
      window,
    );
  }

  late final _SDL_IsShapedWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsShapedWindow');
  late final _SDL_IsShapedWindow = _SDL_IsShapedWindowPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the shape and parameters of a shaped window.
  ///
  /// \param window The shaped window whose parameters should be set.
  /// \param shape A surface encoding the desired shape for the window.
  /// \param shape_mode The parameters to set for the shaped window.
  /// \return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape
  /// argument, or SDL_NONSHAPEABLE_WINDOW if the SDL_Window given does
  /// not reference a valid shaped window.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WindowShapeMode
  /// \sa SDL_GetShapedWindowMode
  int SDL_SetWindowShape(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> shape,
    ffi.Pointer<SDL_WindowShapeMode> shape_mode,
  ) {
    return _SDL_SetWindowShape(
      window,
      shape,
      shape_mode,
    );
  }

  late final _SDL_SetWindowShapePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_WindowShapeMode>)>>('SDL_SetWindowShape');
  late final _SDL_SetWindowShape = _SDL_SetWindowShapePtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>,
          ffi.Pointer<SDL_WindowShapeMode>)>();

  /// Get the shape parameters of a shaped window.
  ///
  /// \param window The shaped window whose parameters should be retrieved.
  /// \param shape_mode An empty shape-mode structure to fill, or NULL to check
  /// whether the window has a shape.
  /// \return 0 if the window has a shape and, provided shape_mode was not NULL,
  /// shape_mode has been filled with the mode data,
  /// SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped
  /// window, or SDL_WINDOW_LACKS_SHAPE if the SDL_Window given is a
  /// shapeable window currently lacking a shape.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WindowShapeMode
  /// \sa SDL_SetWindowShape
  int SDL_GetShapedWindowMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_WindowShapeMode> shape_mode,
  ) {
    return _SDL_GetShapedWindowMode(
      window,
      shape_mode,
    );
  }

  late final _SDL_GetShapedWindowModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_WindowShapeMode>)>>('SDL_GetShapedWindowMode');
  late final _SDL_GetShapedWindowMode = _SDL_GetShapedWindowModePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_WindowShapeMode>)>();

  /// Set a callback for every Windows message, run before TranslateMessage().
  ///
  /// \param callback The SDL_WindowsMessageHook function to call.
  /// \param userdata a pointer to pass to every iteration of `callback`
  ///
  /// \since This function is available since SDL 2.0.4.
  void SDL_SetWindowsMessageHook(
    SDL_WindowsMessageHook callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowsMessageHook(
      callback,
      userdata,
    );
  }

  late final _SDL_SetWindowsMessageHookPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_WindowsMessageHook,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowsMessageHook');
  late final _SDL_SetWindowsMessageHook =
      _SDL_SetWindowsMessageHookPtr.asFunction<
          void Function(SDL_WindowsMessageHook, ffi.Pointer<ffi.Void>)>();

  /// Get the D3D9 adapter index that matches the specified display index.
  ///
  /// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and
  /// controls on which monitor a full screen application will appear.
  ///
  /// \param displayIndex the display index for which to get the D3D9 adapter
  /// index
  /// \returns the D3D9 adapter index on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  int SDL_Direct3D9GetAdapterIndex(
    int displayIndex,
  ) {
    return _SDL_Direct3D9GetAdapterIndex(
      displayIndex,
    );
  }

  late final _SDL_Direct3D9GetAdapterIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_Direct3D9GetAdapterIndex');
  late final _SDL_Direct3D9GetAdapterIndex =
      _SDL_Direct3D9GetAdapterIndexPtr.asFunction<int Function(int)>();

  /// Get the D3D9 device associated with a renderer.
  ///
  /// Once you are done using the device, you should release it to avoid a
  /// resource leak.
  ///
  /// \param renderer the renderer from which to get the associated D3D device
  /// \returns the D3D9 device associated with given renderer or NULL if it is
  /// not a D3D9 renderer; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ffi.Pointer<IDirect3DDevice9> SDL_RenderGetD3D9Device(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetD3D9Device(
      renderer,
    );
  }

  late final _SDL_RenderGetD3D9DevicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<IDirect3DDevice9> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetD3D9Device');
  late final _SDL_RenderGetD3D9Device = _SDL_RenderGetD3D9DevicePtr.asFunction<
      ffi.Pointer<IDirect3DDevice9> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the D3D11 device associated with a renderer.
  ///
  /// Once you are done using the device, you should release it to avoid a
  /// resource leak.
  ///
  /// \param renderer the renderer from which to get the associated D3D11 device
  /// \returns the D3D11 device associated with given renderer or NULL if it is
  /// not a D3D11 renderer; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  ffi.Pointer<ID3D11Device> SDL_RenderGetD3D11Device(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetD3D11Device(
      renderer,
    );
  }

  late final _SDL_RenderGetD3D11DevicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ID3D11Device> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetD3D11Device');
  late final _SDL_RenderGetD3D11Device =
      _SDL_RenderGetD3D11DevicePtr.asFunction<
          ffi.Pointer<ID3D11Device> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the DXGI Adapter and Output indices for the specified display index.
  ///
  /// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and
  /// `EnumOutputs` respectively to get the objects required to create a DX10 or
  /// DX11 device and swap chain.
  ///
  /// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it
  /// returns an SDL_bool.
  ///
  /// \param displayIndex the display index for which to get both indices
  /// \param adapterIndex a pointer to be filled in with the adapter index
  /// \param outputIndex a pointer to be filled in with the output index
  /// \returns SDL_TRUE on success or SDL_FALSE on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.2.
  int SDL_DXGIGetOutputInfo(
    int displayIndex,
    ffi.Pointer<ffi.Int> adapterIndex,
    ffi.Pointer<ffi.Int> outputIndex,
  ) {
    return _SDL_DXGIGetOutputInfo(
      displayIndex,
      adapterIndex,
      outputIndex,
    );
  }

  late final _SDL_DXGIGetOutputInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_DXGIGetOutputInfo');
  late final _SDL_DXGIGetOutputInfo = _SDL_DXGIGetOutputInfoPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Query if the current device is a tablet.
  ///
  /// If SDL can't determine this, it will return SDL_FALSE.
  ///
  /// \returns SDL_TRUE if the device is a tablet, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_IsTablet() {
    return _SDL_IsTablet();
  }

  late final _SDL_IsTabletPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_IsTablet');
  late final _SDL_IsTablet = _SDL_IsTabletPtr.asFunction<int Function()>();

  void SDL_OnApplicationWillTerminate() {
    return _SDL_OnApplicationWillTerminate();
  }

  late final _SDL_OnApplicationWillTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillTerminate');
  late final _SDL_OnApplicationWillTerminate =
      _SDL_OnApplicationWillTerminatePtr.asFunction<void Function()>();

  void SDL_OnApplicationDidReceiveMemoryWarning() {
    return _SDL_OnApplicationDidReceiveMemoryWarning();
  }

  late final _SDL_OnApplicationDidReceiveMemoryWarningPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidReceiveMemoryWarning');
  late final _SDL_OnApplicationDidReceiveMemoryWarning =
      _SDL_OnApplicationDidReceiveMemoryWarningPtr.asFunction<
          void Function()>();

  void SDL_OnApplicationWillResignActive() {
    return _SDL_OnApplicationWillResignActive();
  }

  late final _SDL_OnApplicationWillResignActivePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillResignActive');
  late final _SDL_OnApplicationWillResignActive =
      _SDL_OnApplicationWillResignActivePtr.asFunction<void Function()>();

  void SDL_OnApplicationDidEnterBackground() {
    return _SDL_OnApplicationDidEnterBackground();
  }

  late final _SDL_OnApplicationDidEnterBackgroundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidEnterBackground');
  late final _SDL_OnApplicationDidEnterBackground =
      _SDL_OnApplicationDidEnterBackgroundPtr.asFunction<void Function()>();

  void SDL_OnApplicationWillEnterForeground() {
    return _SDL_OnApplicationWillEnterForeground();
  }

  late final _SDL_OnApplicationWillEnterForegroundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillEnterForeground');
  late final _SDL_OnApplicationWillEnterForeground =
      _SDL_OnApplicationWillEnterForegroundPtr.asFunction<void Function()>();

  void SDL_OnApplicationDidBecomeActive() {
    return _SDL_OnApplicationDidBecomeActive();
  }

  late final _SDL_OnApplicationDidBecomeActivePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidBecomeActive');
  late final _SDL_OnApplicationDidBecomeActive =
      _SDL_OnApplicationDidBecomeActivePtr.asFunction<void Function()>();

  /// Get the number of milliseconds since SDL library initialization.
  ///
  /// This value wraps if the program runs for more than ~49 days.
  ///
  /// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()
  /// instead, where the value doesn't wrap every ~49 days. There are places in
  /// SDL where we provide a 32-bit timestamp that can not change without
  /// breaking binary compatibility, though, so this function isn't officially
  /// deprecated.
  ///
  /// \returns an unsigned 32-bit value representing the number of milliseconds
  /// since the SDL library initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TICKS_PASSED
  int SDL_GetTicks() {
    return _SDL_GetTicks();
  }

  late final _SDL_GetTicksPtr =
      _lookup<ffi.NativeFunction<Uint32 Function()>>('SDL_GetTicks');
  late final _SDL_GetTicks = _SDL_GetTicksPtr.asFunction<int Function()>();

  /// Get the number of milliseconds since SDL library initialization.
  ///
  /// Note that you should not use the SDL_TICKS_PASSED macro with values
  /// returned by this function, as that macro does clever math to compensate for
  /// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit
  /// values from this function can be safely compared directly.
  ///
  /// For example, if you want to wait 100 ms, you could do this:
  ///
  /// ```c
  /// const Uint64 timeout = SDL_GetTicks64() + 100;
  /// while (SDL_GetTicks64() < timeout) {
  /// // ... do work until timeout has elapsed
  /// }
  /// ```
  ///
  /// \returns an unsigned 64-bit value representing the number of milliseconds
  /// since the SDL library initialized.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_GetTicks64() {
    return _SDL_GetTicks64();
  }

  late final _SDL_GetTicks64Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>('SDL_GetTicks64');
  late final _SDL_GetTicks64 = _SDL_GetTicks64Ptr.asFunction<int Function()>();

  /// Get the current value of the high resolution counter.
  ///
  /// This function is typically used for profiling.
  ///
  /// The counter values are only meaningful relative to each other. Differences
  /// between values can be converted to times by using
  /// SDL_GetPerformanceFrequency().
  ///
  /// \returns the current counter value.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetPerformanceFrequency
  int SDL_GetPerformanceCounter() {
    return _SDL_GetPerformanceCounter();
  }

  late final _SDL_GetPerformanceCounterPtr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceCounter');
  late final _SDL_GetPerformanceCounter =
      _SDL_GetPerformanceCounterPtr.asFunction<int Function()>();

  /// Get the count per second of the high resolution counter.
  ///
  /// \returns a platform-specific count per second.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetPerformanceCounter
  int SDL_GetPerformanceFrequency() {
    return _SDL_GetPerformanceFrequency();
  }

  late final _SDL_GetPerformanceFrequencyPtr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceFrequency');
  late final _SDL_GetPerformanceFrequency =
      _SDL_GetPerformanceFrequencyPtr.asFunction<int Function()>();

  /// Wait a specified number of milliseconds before returning.
  ///
  /// This function waits a specified number of milliseconds before returning. It
  /// waits at least the specified time, but possibly longer due to OS
  /// scheduling.
  ///
  /// \param ms the number of milliseconds to delay
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_Delay(
    int ms,
  ) {
    return _SDL_Delay(
      ms,
    );
  }

  late final _SDL_DelayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_Delay');
  late final _SDL_Delay = _SDL_DelayPtr.asFunction<void Function(int)>();

  /// Call a callback function at a future time.
  ///
  /// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().
  ///
  /// The callback function is passed the current timer interval and the user
  /// supplied parameter from the SDL_AddTimer() call and should return the next
  /// timer interval. If the value returned from the callback is 0, the timer is
  /// canceled.
  ///
  /// The callback is run on a separate thread.
  ///
  /// Timers take into account the amount of time it took to execute the
  /// callback. For example, if the callback took 250 ms to execute and returned
  /// 1000 (ms), the timer would only wait another 750 ms before its next
  /// iteration.
  ///
  /// Timing may be inexact due to OS scheduling. Be sure to note the current
  /// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your
  /// callback needs to adjust for variances.
  ///
  /// \param interval the timer delay, in milliseconds, passed to `callback`
  /// \param callback the SDL_TimerCallback function to call when the specified
  /// `interval` elapses
  /// \param param a pointer that is passed to `callback`
  /// \returns a timer ID or 0 if an error occurs; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RemoveTimer
  int SDL_AddTimer(
    int interval,
    SDL_TimerCallback callback,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _SDL_AddTimer(
      interval,
      callback,
      param,
    );
  }

  late final _SDL_AddTimerPtr = _lookup<
      ffi.NativeFunction<
          SDL_TimerID Function(Uint32, SDL_TimerCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddTimer');
  late final _SDL_AddTimer = _SDL_AddTimerPtr.asFunction<
      int Function(int, SDL_TimerCallback, ffi.Pointer<ffi.Void>)>();

  /// Remove a timer created with SDL_AddTimer().
  ///
  /// \param id the ID of the timer to remove
  /// \returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't
  /// found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddTimer
  int SDL_RemoveTimer(
    int id,
  ) {
    return _SDL_RemoveTimer(
      id,
    );
  }

  late final _SDL_RemoveTimerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TimerID)>>(
          'SDL_RemoveTimer');
  late final _SDL_RemoveTimer =
      _SDL_RemoveTimerPtr.asFunction<int Function(int)>();

  /// Get the version of SDL that is linked against your program.
  ///
  /// If you are linking to SDL dynamically, then it is possible that the current
  /// version will be different than the version you compiled against. This
  /// function returns the current version, while SDL_VERSION() is a macro that
  /// tells you what version you compiled with.
  ///
  /// This function may be called safely at any time, even before SDL_Init().
  ///
  /// \param ver the SDL_version structure that contains the version information
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRevision
  void SDL_GetVersion(
    ffi.Pointer<SDL_version> ver,
  ) {
    return _SDL_GetVersion(
      ver,
    );
  }

  late final _SDL_GetVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_version>)>>(
          'SDL_GetVersion');
  late final _SDL_GetVersion =
      _SDL_GetVersionPtr.asFunction<void Function(ffi.Pointer<SDL_version>)>();

  /// Get the code revision of SDL that is linked against your program.
  ///
  /// This value is the revision of the code you are linked with and may be
  /// different from the code you are compiling with, which is found in the
  /// constant SDL_REVISION.
  ///
  /// The revision is arbitrary string (a hash value) uniquely identifying the
  /// exact revision of the SDL library in use, and is only useful in comparing
  /// against other revisions. It is NOT an incrementing number.
  ///
  /// If SDL wasn't built from a git repository with the appropriate tools, this
  /// will return an empty string.
  ///
  /// Prior to SDL 2.0.16, before development moved to GitHub, this returned a
  /// hash for a Mercurial repository.
  ///
  /// You shouldn't use this function for anything but logging it for debugging
  /// purposes. The string is not intended to be reliable in any way.
  ///
  /// \returns an arbitrary string, uniquely identifying the exact revision of
  /// the SDL library in use.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVersion
  ffi.Pointer<ffi.Char> SDL_GetRevision() {
    return _SDL_GetRevision();
  }

  late final _SDL_GetRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetRevision');
  late final _SDL_GetRevision =
      _SDL_GetRevisionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Obsolete function, do not use.
  ///
  /// When SDL was hosted in a Mercurial repository, and was built carefully,
  /// this would return the revision number that the build was created from. This
  /// number was not reliable for several reasons, but more importantly, SDL is
  /// now hosted in a git repository, which does not offer numbers at all, only
  /// hashes. This function only ever returns zero now. Don't use it.
  ///
  /// Before SDL 2.0.16, this might have returned an unreliable, but non-zero
  /// number.
  ///
  /// \deprecated Use SDL_GetRevision() instead; if SDL was carefully built, it
  /// will return a git hash.
  ///
  /// \returns zero, always, in modern SDL releases.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRevision
  int SDL_GetRevisionNumber() {
    return _SDL_GetRevisionNumber();
  }

  late final _SDL_GetRevisionNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetRevisionNumber');
  late final _SDL_GetRevisionNumber =
      _SDL_GetRevisionNumberPtr.asFunction<int Function()>();

  /// Report the user's preferred locale.
  ///
  /// This returns an array of SDL_Locale structs, the final item zeroed out.
  /// When the caller is done with this array, it should call SDL_free() on the
  /// returned value; all the memory involved is allocated in a single block, so
  /// a single SDL_free() will suffice.
  ///
  /// Returned language strings are in the format xx, where 'xx' is an ISO-639
  /// language specifier (such as "en" for English, "de" for German, etc).
  /// Country strings are in the format YY, where "YY" is an ISO-3166 country
  /// code (such as "US" for the United States, "CA" for Canada, etc). Country
  /// might be NULL if there's no specific guidance on them (so you might get {
  /// "en", "US" } for American English, but { "en", NULL } means "English
  /// language, generically"). Language strings are never NULL, except to
  /// terminate the array.
  ///
  /// Please note that not all of these strings are 2 characters; some are three
  /// or more.
  ///
  /// The returned list of locales are in the order of the user's preference. For
  /// example, a German citizen that is fluent in US English and knows enough
  /// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",
  /// "jp", NULL }. Someone from England might prefer British English (where
  /// "color" is spelled "colour", etc), but will settle for anything like it: {
  /// "en_GB", "en", NULL }.
  ///
  /// This function returns NULL on error, including when the platform does not
  /// supply this information at all.
  ///
  /// This might be a "slow" call that has to query the operating system. It's
  /// best to ask for this once and save the results. However, this list can
  /// change, usually because the user has changed a system preference outside of
  /// your program; SDL will send an SDL_LOCALECHANGED event in this case, if
  /// possible, and you can call this function again to get an updated copy of
  /// preferred locales.
  ///
  /// \return array of locales, terminated with a locale with a NULL language
  /// field. Will return NULL on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<SDL_Locale> SDL_GetPreferredLocales() {
    return _SDL_GetPreferredLocales();
  }

  late final _SDL_GetPreferredLocalesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Locale> Function()>>(
          'SDL_GetPreferredLocales');
  late final _SDL_GetPreferredLocales = _SDL_GetPreferredLocalesPtr.asFunction<
      ffi.Pointer<SDL_Locale> Function()>();

  /// Open a URL/URI in the browser or other appropriate external application.
  ///
  /// Open a URL in a separate, system-provided application. How this works will
  /// vary wildly depending on the platform. This will likely launch what makes
  /// sense to handle a specific URL's protocol (a web browser for `http://`,
  /// etc), but it might also be able to launch file managers for directories and
  /// other things.
  ///
  /// What happens when you open a URL varies wildly as well: your game window
  /// may lose focus (and may or may not lose focus if your game was fullscreen
  /// or grabbing input at the time). On mobile devices, your app will likely
  /// move to the background or your process might be paused. Any given platform
  /// may or may not handle a given URL.
  ///
  /// If this is unimplemented (or simply unavailable) for a platform, this will
  /// fail with an error. A successful result does not mean the URL loaded, just
  /// that we launched _something_ to handle it (or at least believe we did).
  ///
  /// All this to say: this function can be useful, but you should definitely
  /// test it on every platform you target.
  ///
  /// \param url A valid URL/URI to open. Use `file:///full/path/to/file` for
  /// local files, if supported.
  /// \returns 0 on success, or -1 on error; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_OpenURL(
    ffi.Pointer<ffi.Char> url,
  ) {
    return _SDL_OpenURL(
      url,
    );
  }

  late final _SDL_OpenURLPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_OpenURL');
  late final _SDL_OpenURL =
      _SDL_OpenURLPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Initialize the SDL library.
  ///
  /// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
  /// two may be used interchangeably. Though for readability of your code
  /// SDL_InitSubSystem() might be preferred.
  ///
  /// The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)
  /// subsystems are initialized by default. Message boxes
  /// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
  /// video subsystem, in hopes of being useful in showing an error dialog when
  /// SDL_Init fails. You must specifically initialize other subsystems if you
  /// use them in your application.
  ///
  /// Logging (such as SDL_Log) works without initialization, too.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_INIT_TIMER`: timer subsystem
  /// - `SDL_INIT_AUDIO`: audio subsystem
  /// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
  /// subsystem
  /// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
  /// events subsystem
  /// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
  /// - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically
  /// initializes the joystick subsystem
  /// - `SDL_INIT_EVENTS`: events subsystem
  /// - `SDL_INIT_EVERYTHING`: all of the above subsystems
  /// - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored
  ///
  /// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
  /// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
  /// call SDL_Quit() to force shutdown). If a subsystem is already loaded then
  /// this call will increase the ref-count and return.
  ///
  /// \param flags subsystem initialization flags
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_InitSubSystem
  /// \sa SDL_Quit
  /// \sa SDL_SetMainReady
  /// \sa SDL_WasInit
  int SDL_Init(
    int flags,
  ) {
    return _SDL_Init(
      flags,
    );
  }

  late final _SDL_InitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Uint32)>>('SDL_Init');
  late final _SDL_Init = _SDL_InitPtr.asFunction<int Function(int)>();

  /// Compatibility function to initialize the SDL library.
  ///
  /// In SDL2, this function and SDL_Init() are interchangeable.
  ///
  /// \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  /// \sa SDL_Quit
  /// \sa SDL_QuitSubSystem
  int SDL_InitSubSystem(
    int flags,
  ) {
    return _SDL_InitSubSystem(
      flags,
    );
  }

  late final _SDL_InitSubSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Uint32)>>(
          'SDL_InitSubSystem');
  late final _SDL_InitSubSystem =
      _SDL_InitSubSystemPtr.asFunction<int Function(int)>();

  /// Shut down specific SDL subsystems.
  ///
  /// If you start a subsystem using a call to that subsystem's init function
  /// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
  /// SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use
  /// that subsystem's quit function (SDL_VideoQuit()) directly instead. But
  /// generally, you should not be using those functions directly anyhow; use
  /// SDL_Init() instead.
  ///
  /// You still need to call SDL_Quit() even if you close all open subsystems
  /// with SDL_QuitSubSystem().
  ///
  /// \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_InitSubSystem
  /// \sa SDL_Quit
  void SDL_QuitSubSystem(
    int flags,
  ) {
    return _SDL_QuitSubSystem(
      flags,
    );
  }

  late final _SDL_QuitSubSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>(
          'SDL_QuitSubSystem');
  late final _SDL_QuitSubSystem =
      _SDL_QuitSubSystemPtr.asFunction<void Function(int)>();

  /// Get a mask of the specified subsystems which are currently initialized.
  ///
  /// \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
  /// \returns a mask of all initialized subsystems if `flags` is 0, otherwise it
  /// returns the initialization status of the specified subsystems.
  ///
  /// The return value does not include SDL_INIT_NOPARACHUTE.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  /// \sa SDL_InitSubSystem
  int SDL_WasInit(
    int flags,
  ) {
    return _SDL_WasInit(
      flags,
    );
  }

  late final _SDL_WasInitPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(Uint32)>>('SDL_WasInit');
  late final _SDL_WasInit = _SDL_WasInitPtr.asFunction<int Function(int)>();

  /// Clean up all initialized subsystems.
  ///
  /// You should call this function even if you have already shutdown each
  /// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
  /// function even in the case of errors in initialization.
  ///
  /// If you start a subsystem using a call to that subsystem's init function
  /// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
  /// then you must use that subsystem's quit function (SDL_VideoQuit()) to shut
  /// it down before calling SDL_Quit(). But generally, you should not be using
  /// those functions directly anyhow; use SDL_Init() instead.
  ///
  /// You can use this function with atexit() to ensure that it is run when your
  /// application is shutdown, but it is not wise to do this from a library or
  /// other dynamically loaded code.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Init
  /// \sa SDL_QuitSubSystem
  void SDL_Quit() {
    return _SDL_Quit();
  }

  late final _SDL_QuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_Quit');
  late final _SDL_Quit = _SDL_QuitPtr.asFunction<void Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform1() {
    return _SDL_GetPlatform1();
  }

  late final _SDL_GetPlatform1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform1 =
      _SDL_GetPlatform1Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc1(
    int size,
  ) {
    return _SDL_malloc1(
      size,
    );
  }

  late final _SDL_malloc1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc1 =
      _SDL_malloc1Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc1(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc1(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc1 =
      _SDL_calloc1Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc1(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc1(
      mem,
      size,
    );
  }

  late final _SDL_realloc1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc1 = _SDL_realloc1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free1(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free1(
      mem,
    );
  }

  late final _SDL_free1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free1 =
      _SDL_free1Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions1(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions1(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions1 = _SDL_GetMemoryFunctions1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions1(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions1(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions1 = _SDL_SetMemoryFunctions1Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations1() {
    return _SDL_GetNumAllocations1();
  }

  late final _SDL_GetNumAllocations1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations1 =
      _SDL_GetNumAllocations1Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv1(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv1(
      name,
    );
  }

  late final _SDL_getenv1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv1 = _SDL_getenv1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv1(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv1(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv1 = _SDL_setenv1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort1(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort1(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort1 = _SDL_qsort1Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs1(
    int x,
  ) {
    return _SDL_abs1(
      x,
    );
  }

  late final _SDL_abs1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs1 = _SDL_abs1Ptr.asFunction<int Function(int)>();

  int SDL_isalpha1(
    int x,
  ) {
    return _SDL_isalpha1(
      x,
    );
  }

  late final _SDL_isalpha1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha1 = _SDL_isalpha1Ptr.asFunction<int Function(int)>();

  int SDL_isalnum1(
    int x,
  ) {
    return _SDL_isalnum1(
      x,
    );
  }

  late final _SDL_isalnum1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum1 = _SDL_isalnum1Ptr.asFunction<int Function(int)>();

  int SDL_isblank1(
    int x,
  ) {
    return _SDL_isblank1(
      x,
    );
  }

  late final _SDL_isblank1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank1 = _SDL_isblank1Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl1(
    int x,
  ) {
    return _SDL_iscntrl1(
      x,
    );
  }

  late final _SDL_iscntrl1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl1 = _SDL_iscntrl1Ptr.asFunction<int Function(int)>();

  int SDL_isdigit1(
    int x,
  ) {
    return _SDL_isdigit1(
      x,
    );
  }

  late final _SDL_isdigit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit1 = _SDL_isdigit1Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit1(
    int x,
  ) {
    return _SDL_isxdigit1(
      x,
    );
  }

  late final _SDL_isxdigit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit1 = _SDL_isxdigit1Ptr.asFunction<int Function(int)>();

  int SDL_ispunct1(
    int x,
  ) {
    return _SDL_ispunct1(
      x,
    );
  }

  late final _SDL_ispunct1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct1 = _SDL_ispunct1Ptr.asFunction<int Function(int)>();

  int SDL_isspace1(
    int x,
  ) {
    return _SDL_isspace1(
      x,
    );
  }

  late final _SDL_isspace1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace1 = _SDL_isspace1Ptr.asFunction<int Function(int)>();

  int SDL_isupper1(
    int x,
  ) {
    return _SDL_isupper1(
      x,
    );
  }

  late final _SDL_isupper1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper1 = _SDL_isupper1Ptr.asFunction<int Function(int)>();

  int SDL_islower1(
    int x,
  ) {
    return _SDL_islower1(
      x,
    );
  }

  late final _SDL_islower1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower1 = _SDL_islower1Ptr.asFunction<int Function(int)>();

  int SDL_isprint1(
    int x,
  ) {
    return _SDL_isprint1(
      x,
    );
  }

  late final _SDL_isprint1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint1 = _SDL_isprint1Ptr.asFunction<int Function(int)>();

  int SDL_isgraph1(
    int x,
  ) {
    return _SDL_isgraph1(
      x,
    );
  }

  late final _SDL_isgraph1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph1 = _SDL_isgraph1Ptr.asFunction<int Function(int)>();

  int SDL_toupper1(
    int x,
  ) {
    return _SDL_toupper1(
      x,
    );
  }

  late final _SDL_toupper1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper1 = _SDL_toupper1Ptr.asFunction<int Function(int)>();

  int SDL_tolower1(
    int x,
  ) {
    return _SDL_tolower1(
      x,
    );
  }

  late final _SDL_tolower1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower1 = _SDL_tolower1Ptr.asFunction<int Function(int)>();

  int SDL_crc321(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc321(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc321Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc321 = _SDL_crc321Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset1(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset1(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset1 = _SDL_memset1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy1(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy1(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy1 = _SDL_memcpy1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove1(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove1(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove1 = _SDL_memmove1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp1(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp1(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp1 = _SDL_memcmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen1(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen1(
      wstr,
    );
  }

  late final _SDL_wcslen1Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen1 =
      _SDL_wcslen1Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy1(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy1(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy1 = _SDL_wcslcpy1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat1(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat1(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat1 = _SDL_wcslcat1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup1(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup1(
      wstr,
    );
  }

  late final _SDL_wcsdup1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup1 = _SDL_wcsdup1Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr1(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr1(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr1 = _SDL_wcsstr1Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp1(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp1(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp1 = _SDL_wcscmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp1(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp1(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp1 = _SDL_wcsncmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp1(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp1(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp1 = _SDL_wcscasecmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp1(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp1(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp1 = _SDL_wcsncasecmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen1(
      str,
    );
  }

  late final _SDL_strlen1Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen1 =
      _SDL_strlen1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy1(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy1(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy1 = _SDL_strlcpy1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy1(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy1(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy1 = _SDL_utf8strlcpy1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat1(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat1(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat1 = _SDL_strlcat1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup1(
      str,
    );
  }

  late final _SDL_strdup1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup1 = _SDL_strdup1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev1(
      str,
    );
  }

  late final _SDL_strrev1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev1 = _SDL_strrev1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr1(
      str,
    );
  }

  late final _SDL_strupr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr1 = _SDL_strupr1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr1(
      str,
    );
  }

  late final _SDL_strlwr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr1 = _SDL_strlwr1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr1(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr1(
      str,
      c,
    );
  }

  late final _SDL_strchr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr1 = _SDL_strchr1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr1(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr1(
      str,
      c,
    );
  }

  late final _SDL_strrchr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr1 = _SDL_strrchr1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr1(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr1(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr1 = _SDL_strstr1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr1(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr1(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr1 = _SDL_strtokr1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen1(
      str,
    );
  }

  late final _SDL_utf8strlen1Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen1 =
      _SDL_utf8strlen1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa1(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa1(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa1 = _SDL_itoa1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa1(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa1(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa1 = _SDL_uitoa1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa1(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa1(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa1 = _SDL_ltoa1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa1(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa1(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa1 = _SDL_ultoa1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa1(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa1(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa1 = _SDL_lltoa1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa1(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa1(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa1 = _SDL_ulltoa1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi1(
      str,
    );
  }

  late final _SDL_atoi1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi1 =
      _SDL_atoi1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof1(
      str,
    );
  }

  late final _SDL_atof1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof1 =
      _SDL_atof1Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol1(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol1(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol1 = _SDL_strtol1Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul1(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul1(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul1 = _SDL_strtoul1Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll1(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll1(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll1Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll1 = _SDL_strtoll1Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull1(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull1(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull1Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull1 = _SDL_strtoull1Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod1(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod1(
      str,
      endp,
    );
  }

  late final _SDL_strtod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod1 = _SDL_strtod1Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp1(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp1(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp1 = _SDL_strcmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp1(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp1(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp1 = _SDL_strncmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp1(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp1(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp1 = _SDL_strcasecmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp1(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp1(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp1 = _SDL_strncasecmp1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf1(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf1(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf1 = _SDL_sscanf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf1(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf1(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf1 = _SDL_vsscanf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf1(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf1(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf1 = _SDL_snprintf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf1(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf1(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf1 = _SDL_vsnprintf1Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf1(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf1(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf1 = _SDL_asprintf1Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf1(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf1(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf1 = _SDL_vasprintf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos1(
    double x,
  ) {
    return _SDL_acos1(
      x,
    );
  }

  late final _SDL_acos1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos1 = _SDL_acos1Ptr.asFunction<double Function(double)>();

  double SDL_acosf1(
    double x,
  ) {
    return _SDL_acosf1(
      x,
    );
  }

  late final _SDL_acosf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf1 = _SDL_acosf1Ptr.asFunction<double Function(double)>();

  double SDL_asin1(
    double x,
  ) {
    return _SDL_asin1(
      x,
    );
  }

  late final _SDL_asin1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin1 = _SDL_asin1Ptr.asFunction<double Function(double)>();

  double SDL_asinf1(
    double x,
  ) {
    return _SDL_asinf1(
      x,
    );
  }

  late final _SDL_asinf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf1 = _SDL_asinf1Ptr.asFunction<double Function(double)>();

  double SDL_atan1(
    double x,
  ) {
    return _SDL_atan1(
      x,
    );
  }

  late final _SDL_atan1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan1 = _SDL_atan1Ptr.asFunction<double Function(double)>();

  double SDL_atanf1(
    double x,
  ) {
    return _SDL_atanf1(
      x,
    );
  }

  late final _SDL_atanf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf1 = _SDL_atanf1Ptr.asFunction<double Function(double)>();

  double SDL_atan21(
    double y,
    double x,
  ) {
    return _SDL_atan21(
      y,
      x,
    );
  }

  late final _SDL_atan21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan21 =
      _SDL_atan21Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f1(
    double y,
    double x,
  ) {
    return _SDL_atan2f1(
      y,
      x,
    );
  }

  late final _SDL_atan2f1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f1 =
      _SDL_atan2f1Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil1(
    double x,
  ) {
    return _SDL_ceil1(
      x,
    );
  }

  late final _SDL_ceil1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil1 = _SDL_ceil1Ptr.asFunction<double Function(double)>();

  double SDL_ceilf1(
    double x,
  ) {
    return _SDL_ceilf1(
      x,
    );
  }

  late final _SDL_ceilf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf1 = _SDL_ceilf1Ptr.asFunction<double Function(double)>();

  double SDL_copysign1(
    double x,
    double y,
  ) {
    return _SDL_copysign1(
      x,
      y,
    );
  }

  late final _SDL_copysign1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign1 =
      _SDL_copysign1Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf1(
    double x,
    double y,
  ) {
    return _SDL_copysignf1(
      x,
      y,
    );
  }

  late final _SDL_copysignf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf1 =
      _SDL_copysignf1Ptr.asFunction<double Function(double, double)>();

  double SDL_cos1(
    double x,
  ) {
    return _SDL_cos1(
      x,
    );
  }

  late final _SDL_cos1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos1 = _SDL_cos1Ptr.asFunction<double Function(double)>();

  double SDL_cosf1(
    double x,
  ) {
    return _SDL_cosf1(
      x,
    );
  }

  late final _SDL_cosf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf1 = _SDL_cosf1Ptr.asFunction<double Function(double)>();

  double SDL_exp1(
    double x,
  ) {
    return _SDL_exp1(
      x,
    );
  }

  late final _SDL_exp1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp1 = _SDL_exp1Ptr.asFunction<double Function(double)>();

  double SDL_expf1(
    double x,
  ) {
    return _SDL_expf1(
      x,
    );
  }

  late final _SDL_expf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf1 = _SDL_expf1Ptr.asFunction<double Function(double)>();

  double SDL_fabs1(
    double x,
  ) {
    return _SDL_fabs1(
      x,
    );
  }

  late final _SDL_fabs1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs1 = _SDL_fabs1Ptr.asFunction<double Function(double)>();

  double SDL_fabsf1(
    double x,
  ) {
    return _SDL_fabsf1(
      x,
    );
  }

  late final _SDL_fabsf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf1 = _SDL_fabsf1Ptr.asFunction<double Function(double)>();

  double SDL_floor1(
    double x,
  ) {
    return _SDL_floor1(
      x,
    );
  }

  late final _SDL_floor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor1 = _SDL_floor1Ptr.asFunction<double Function(double)>();

  double SDL_floorf1(
    double x,
  ) {
    return _SDL_floorf1(
      x,
    );
  }

  late final _SDL_floorf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf1 =
      _SDL_floorf1Ptr.asFunction<double Function(double)>();

  double SDL_trunc1(
    double x,
  ) {
    return _SDL_trunc1(
      x,
    );
  }

  late final _SDL_trunc1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc1 = _SDL_trunc1Ptr.asFunction<double Function(double)>();

  double SDL_truncf1(
    double x,
  ) {
    return _SDL_truncf1(
      x,
    );
  }

  late final _SDL_truncf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf1 =
      _SDL_truncf1Ptr.asFunction<double Function(double)>();

  double SDL_fmod1(
    double x,
    double y,
  ) {
    return _SDL_fmod1(
      x,
      y,
    );
  }

  late final _SDL_fmod1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod1 =
      _SDL_fmod1Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf1(
    double x,
    double y,
  ) {
    return _SDL_fmodf1(
      x,
      y,
    );
  }

  late final _SDL_fmodf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf1 =
      _SDL_fmodf1Ptr.asFunction<double Function(double, double)>();

  double SDL_log1(
    double x,
  ) {
    return _SDL_log1(
      x,
    );
  }

  late final _SDL_log1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log1 = _SDL_log1Ptr.asFunction<double Function(double)>();

  double SDL_logf1(
    double x,
  ) {
    return _SDL_logf1(
      x,
    );
  }

  late final _SDL_logf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf1 = _SDL_logf1Ptr.asFunction<double Function(double)>();

  double SDL_log101(
    double x,
  ) {
    return _SDL_log101(
      x,
    );
  }

  late final _SDL_log101Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log101 = _SDL_log101Ptr.asFunction<double Function(double)>();

  double SDL_log10f1(
    double x,
  ) {
    return _SDL_log10f1(
      x,
    );
  }

  late final _SDL_log10f1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f1 =
      _SDL_log10f1Ptr.asFunction<double Function(double)>();

  double SDL_pow1(
    double x,
    double y,
  ) {
    return _SDL_pow1(
      x,
      y,
    );
  }

  late final _SDL_pow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow1 =
      _SDL_pow1Ptr.asFunction<double Function(double, double)>();

  double SDL_powf1(
    double x,
    double y,
  ) {
    return _SDL_powf1(
      x,
      y,
    );
  }

  late final _SDL_powf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf1 =
      _SDL_powf1Ptr.asFunction<double Function(double, double)>();

  double SDL_round1(
    double x,
  ) {
    return _SDL_round1(
      x,
    );
  }

  late final _SDL_round1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round1 = _SDL_round1Ptr.asFunction<double Function(double)>();

  double SDL_roundf1(
    double x,
  ) {
    return _SDL_roundf1(
      x,
    );
  }

  late final _SDL_roundf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf1 =
      _SDL_roundf1Ptr.asFunction<double Function(double)>();

  int SDL_lround1(
    double x,
  ) {
    return _SDL_lround1(
      x,
    );
  }

  late final _SDL_lround1Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround1 = _SDL_lround1Ptr.asFunction<int Function(double)>();

  int SDL_lroundf1(
    double x,
  ) {
    return _SDL_lroundf1(
      x,
    );
  }

  late final _SDL_lroundf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf1 =
      _SDL_lroundf1Ptr.asFunction<int Function(double)>();

  double SDL_scalbn1(
    double x,
    int n,
  ) {
    return _SDL_scalbn1(
      x,
      n,
    );
  }

  late final _SDL_scalbn1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn1 =
      _SDL_scalbn1Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf1(
    double x,
    int n,
  ) {
    return _SDL_scalbnf1(
      x,
      n,
    );
  }

  late final _SDL_scalbnf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf1 =
      _SDL_scalbnf1Ptr.asFunction<double Function(double, int)>();

  double SDL_sin1(
    double x,
  ) {
    return _SDL_sin1(
      x,
    );
  }

  late final _SDL_sin1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin1 = _SDL_sin1Ptr.asFunction<double Function(double)>();

  double SDL_sinf1(
    double x,
  ) {
    return _SDL_sinf1(
      x,
    );
  }

  late final _SDL_sinf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf1 = _SDL_sinf1Ptr.asFunction<double Function(double)>();

  double SDL_sqrt1(
    double x,
  ) {
    return _SDL_sqrt1(
      x,
    );
  }

  late final _SDL_sqrt1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt1 = _SDL_sqrt1Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf1(
    double x,
  ) {
    return _SDL_sqrtf1(
      x,
    );
  }

  late final _SDL_sqrtf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf1 = _SDL_sqrtf1Ptr.asFunction<double Function(double)>();

  double SDL_tan1(
    double x,
  ) {
    return _SDL_tan1(
      x,
    );
  }

  late final _SDL_tan1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan1 = _SDL_tan1Ptr.asFunction<double Function(double)>();

  double SDL_tanf1(
    double x,
  ) {
    return _SDL_tanf1(
      x,
    );
  }

  late final _SDL_tanf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf1 = _SDL_tanf1Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open1(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open1(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open1 = _SDL_iconv_open1Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close1(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close1(
      cd,
    );
  }

  late final _SDL_iconv_close1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close1 =
      _SDL_iconv_close1Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv1(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv1(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv1 = _SDL_iconv1Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string1(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string1(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string1 = _SDL_iconv_string1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set a hint with a specific priority.
  ///
  /// The priority controls the behavior when setting a hint that already has a
  /// value. Hints will replace existing hints of their priority and lower.
  /// Environment variables are considered to have override priority.
  ///
  /// \param name the hint to set
  /// \param value the value of the hint variable
  /// \param priority the SDL_HintPriority level for the hint
  /// \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetHint
  /// \sa SDL_SetHint
  int SDL_SetHintWithPriority1(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int priority,
  ) {
    return _SDL_SetHintWithPriority1(
      name,
      value,
      priority,
    );
  }

  late final _SDL_SetHintWithPriority1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('SDL_SetHintWithPriority');
  late final _SDL_SetHintWithPriority1 =
      _SDL_SetHintWithPriority1Ptr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set a hint with normal priority.
  ///
  /// Hints will not be set if there is an existing override hint or environment
  /// variable that takes precedence. You can use SDL_SetHintWithPriority() to
  /// set the hint with override priority instead.
  ///
  /// \param name the hint to set
  /// \param value the value of the hint variable
  /// \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetHint
  /// \sa SDL_SetHintWithPriority
  int SDL_SetHint1(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _SDL_SetHint1(
      name,
      value,
    );
  }

  late final _SDL_SetHint1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_SetHint');
  late final _SDL_SetHint1 = _SDL_SetHint1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Get the value of a hint.
  ///
  /// \param name the hint to query
  /// \returns the string value of a hint or NULL if the hint isn't set.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetHint
  /// \sa SDL_SetHintWithPriority
  ffi.Pointer<ffi.Char> SDL_GetHint1(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetHint1(
      name,
    );
  }

  late final _SDL_GetHint1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GetHint');
  late final _SDL_GetHint1 = _SDL_GetHint1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Get the boolean value of a hint variable.
  ///
  /// \param name the name of the hint to get the boolean value from
  /// \param default_value the value to return if the hint does not exist
  /// \returns the boolean value of a hint or the provided default value if the
  /// hint does not exist.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetHint
  /// \sa SDL_SetHint
  int SDL_GetHintBoolean1(
    ffi.Pointer<ffi.Char> name,
    int default_value,
  ) {
    return _SDL_GetHintBoolean1(
      name,
      default_value,
    );
  }

  late final _SDL_GetHintBoolean1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Char>, ffi.Int32)>>('SDL_GetHintBoolean');
  late final _SDL_GetHintBoolean1 = _SDL_GetHintBoolean1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Add a function to watch a particular hint.
  ///
  /// \param name the hint to watch
  /// \param callback An SDL_HintCallback function that will be called when the
  /// hint value changes
  /// \param userdata a pointer to pass to the callback function
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DelHintCallback
  void SDL_AddHintCallback1(
    ffi.Pointer<ffi.Char> name,
    SDL_HintCallback callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddHintCallback1(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_AddHintCallback1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, SDL_HintCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddHintCallback');
  late final _SDL_AddHintCallback1 = _SDL_AddHintCallback1Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Char>, SDL_HintCallback, ffi.Pointer<ffi.Void>)>();

  /// Remove a function watching a particular hint.
  ///
  /// \param name the hint being watched
  /// \param callback An SDL_HintCallback function that will be called when the
  /// hint value changes
  /// \param userdata a pointer being passed to the callback function
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddHintCallback
  void SDL_DelHintCallback1(
    ffi.Pointer<ffi.Char> name,
    SDL_HintCallback callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelHintCallback1(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_DelHintCallback1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, SDL_HintCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_DelHintCallback');
  late final _SDL_DelHintCallback1 = _SDL_DelHintCallback1Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Char>, SDL_HintCallback, ffi.Pointer<ffi.Void>)>();

  /// Clear all hints.
  ///
  /// This function is automatically called during SDL_Quit().
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_ClearHints1() {
    return _SDL_ClearHints1();
  }

  late final _SDL_ClearHints1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearHints');
  late final _SDL_ClearHints1 =
      _SDL_ClearHints1Ptr.asFunction<void Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform2() {
    return _SDL_GetPlatform2();
  }

  late final _SDL_GetPlatform2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform2 =
      _SDL_GetPlatform2Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc2(
    int size,
  ) {
    return _SDL_malloc2(
      size,
    );
  }

  late final _SDL_malloc2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc2 =
      _SDL_malloc2Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc2(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc2(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc2 =
      _SDL_calloc2Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc2(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc2(
      mem,
      size,
    );
  }

  late final _SDL_realloc2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc2 = _SDL_realloc2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free2(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free2(
      mem,
    );
  }

  late final _SDL_free2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free2 =
      _SDL_free2Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions2(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions2(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions2 = _SDL_GetMemoryFunctions2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions2(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions2(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions2 = _SDL_SetMemoryFunctions2Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations2() {
    return _SDL_GetNumAllocations2();
  }

  late final _SDL_GetNumAllocations2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations2 =
      _SDL_GetNumAllocations2Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv2(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv2(
      name,
    );
  }

  late final _SDL_getenv2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv2 = _SDL_getenv2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv2(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv2(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv2 = _SDL_setenv2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort2(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort2(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort2 = _SDL_qsort2Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs2(
    int x,
  ) {
    return _SDL_abs2(
      x,
    );
  }

  late final _SDL_abs2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs2 = _SDL_abs2Ptr.asFunction<int Function(int)>();

  int SDL_isalpha2(
    int x,
  ) {
    return _SDL_isalpha2(
      x,
    );
  }

  late final _SDL_isalpha2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha2 = _SDL_isalpha2Ptr.asFunction<int Function(int)>();

  int SDL_isalnum2(
    int x,
  ) {
    return _SDL_isalnum2(
      x,
    );
  }

  late final _SDL_isalnum2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum2 = _SDL_isalnum2Ptr.asFunction<int Function(int)>();

  int SDL_isblank2(
    int x,
  ) {
    return _SDL_isblank2(
      x,
    );
  }

  late final _SDL_isblank2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank2 = _SDL_isblank2Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl2(
    int x,
  ) {
    return _SDL_iscntrl2(
      x,
    );
  }

  late final _SDL_iscntrl2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl2 = _SDL_iscntrl2Ptr.asFunction<int Function(int)>();

  int SDL_isdigit2(
    int x,
  ) {
    return _SDL_isdigit2(
      x,
    );
  }

  late final _SDL_isdigit2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit2 = _SDL_isdigit2Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit2(
    int x,
  ) {
    return _SDL_isxdigit2(
      x,
    );
  }

  late final _SDL_isxdigit2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit2 = _SDL_isxdigit2Ptr.asFunction<int Function(int)>();

  int SDL_ispunct2(
    int x,
  ) {
    return _SDL_ispunct2(
      x,
    );
  }

  late final _SDL_ispunct2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct2 = _SDL_ispunct2Ptr.asFunction<int Function(int)>();

  int SDL_isspace2(
    int x,
  ) {
    return _SDL_isspace2(
      x,
    );
  }

  late final _SDL_isspace2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace2 = _SDL_isspace2Ptr.asFunction<int Function(int)>();

  int SDL_isupper2(
    int x,
  ) {
    return _SDL_isupper2(
      x,
    );
  }

  late final _SDL_isupper2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper2 = _SDL_isupper2Ptr.asFunction<int Function(int)>();

  int SDL_islower2(
    int x,
  ) {
    return _SDL_islower2(
      x,
    );
  }

  late final _SDL_islower2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower2 = _SDL_islower2Ptr.asFunction<int Function(int)>();

  int SDL_isprint2(
    int x,
  ) {
    return _SDL_isprint2(
      x,
    );
  }

  late final _SDL_isprint2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint2 = _SDL_isprint2Ptr.asFunction<int Function(int)>();

  int SDL_isgraph2(
    int x,
  ) {
    return _SDL_isgraph2(
      x,
    );
  }

  late final _SDL_isgraph2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph2 = _SDL_isgraph2Ptr.asFunction<int Function(int)>();

  int SDL_toupper2(
    int x,
  ) {
    return _SDL_toupper2(
      x,
    );
  }

  late final _SDL_toupper2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper2 = _SDL_toupper2Ptr.asFunction<int Function(int)>();

  int SDL_tolower2(
    int x,
  ) {
    return _SDL_tolower2(
      x,
    );
  }

  late final _SDL_tolower2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower2 = _SDL_tolower2Ptr.asFunction<int Function(int)>();

  int SDL_crc322(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc322(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc322Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc322 = _SDL_crc322Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset2(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset2(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset2 = _SDL_memset2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy2(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy2(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy2 = _SDL_memcpy2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove2(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove2(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove2 = _SDL_memmove2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp2(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp2(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp2 = _SDL_memcmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen2(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen2(
      wstr,
    );
  }

  late final _SDL_wcslen2Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen2 =
      _SDL_wcslen2Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy2(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy2(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy2 = _SDL_wcslcpy2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat2(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat2(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat2 = _SDL_wcslcat2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup2(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup2(
      wstr,
    );
  }

  late final _SDL_wcsdup2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup2 = _SDL_wcsdup2Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr2(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr2(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr2 = _SDL_wcsstr2Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp2(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp2(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp2 = _SDL_wcscmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp2(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp2(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp2 = _SDL_wcsncmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp2(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp2(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp2 = _SDL_wcscasecmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp2(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp2(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp2 = _SDL_wcsncasecmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen2(
      str,
    );
  }

  late final _SDL_strlen2Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen2 =
      _SDL_strlen2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy2(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy2(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy2 = _SDL_strlcpy2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy2(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy2(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy2 = _SDL_utf8strlcpy2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat2(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat2(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat2 = _SDL_strlcat2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup2(
      str,
    );
  }

  late final _SDL_strdup2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup2 = _SDL_strdup2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev2(
      str,
    );
  }

  late final _SDL_strrev2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev2 = _SDL_strrev2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr2(
      str,
    );
  }

  late final _SDL_strupr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr2 = _SDL_strupr2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr2(
      str,
    );
  }

  late final _SDL_strlwr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr2 = _SDL_strlwr2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr2(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr2(
      str,
      c,
    );
  }

  late final _SDL_strchr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr2 = _SDL_strchr2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr2(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr2(
      str,
      c,
    );
  }

  late final _SDL_strrchr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr2 = _SDL_strrchr2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr2(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr2(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr2 = _SDL_strstr2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr2(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr2(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr2 = _SDL_strtokr2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen2(
      str,
    );
  }

  late final _SDL_utf8strlen2Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen2 =
      _SDL_utf8strlen2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa2(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa2(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa2 = _SDL_itoa2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa2(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa2(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa2 = _SDL_uitoa2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa2(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa2(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa2 = _SDL_ltoa2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa2(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa2(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa2 = _SDL_ultoa2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa2(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa2(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa2 = _SDL_lltoa2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa2(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa2(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa2 = _SDL_ulltoa2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi2(
      str,
    );
  }

  late final _SDL_atoi2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi2 =
      _SDL_atoi2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof2(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof2(
      str,
    );
  }

  late final _SDL_atof2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof2 =
      _SDL_atof2Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol2(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol2(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol2 = _SDL_strtol2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul2(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul2(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul2 = _SDL_strtoul2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll2(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll2(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll2Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll2 = _SDL_strtoll2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull2(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull2(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull2Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull2 = _SDL_strtoull2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod2(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod2(
      str,
      endp,
    );
  }

  late final _SDL_strtod2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod2 = _SDL_strtod2Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp2(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp2(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp2 = _SDL_strcmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp2(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp2(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp2 = _SDL_strncmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp2(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp2(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp2 = _SDL_strcasecmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp2(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp2(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp2 = _SDL_strncasecmp2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf2(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf2(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf2 = _SDL_sscanf2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf2(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf2(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf2 = _SDL_vsscanf2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf2(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf2(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf2 = _SDL_snprintf2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf2(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf2(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf2 = _SDL_vsnprintf2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf2(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf2(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf2 = _SDL_asprintf2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf2(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf2(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf2 = _SDL_vasprintf2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos2(
    double x,
  ) {
    return _SDL_acos2(
      x,
    );
  }

  late final _SDL_acos2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos2 = _SDL_acos2Ptr.asFunction<double Function(double)>();

  double SDL_acosf2(
    double x,
  ) {
    return _SDL_acosf2(
      x,
    );
  }

  late final _SDL_acosf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf2 = _SDL_acosf2Ptr.asFunction<double Function(double)>();

  double SDL_asin2(
    double x,
  ) {
    return _SDL_asin2(
      x,
    );
  }

  late final _SDL_asin2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin2 = _SDL_asin2Ptr.asFunction<double Function(double)>();

  double SDL_asinf2(
    double x,
  ) {
    return _SDL_asinf2(
      x,
    );
  }

  late final _SDL_asinf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf2 = _SDL_asinf2Ptr.asFunction<double Function(double)>();

  double SDL_atan3(
    double x,
  ) {
    return _SDL_atan3(
      x,
    );
  }

  late final _SDL_atan3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan3 = _SDL_atan3Ptr.asFunction<double Function(double)>();

  double SDL_atanf2(
    double x,
  ) {
    return _SDL_atanf2(
      x,
    );
  }

  late final _SDL_atanf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf2 = _SDL_atanf2Ptr.asFunction<double Function(double)>();

  double SDL_atan22(
    double y,
    double x,
  ) {
    return _SDL_atan22(
      y,
      x,
    );
  }

  late final _SDL_atan22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan22 =
      _SDL_atan22Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f2(
    double y,
    double x,
  ) {
    return _SDL_atan2f2(
      y,
      x,
    );
  }

  late final _SDL_atan2f2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f2 =
      _SDL_atan2f2Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil2(
    double x,
  ) {
    return _SDL_ceil2(
      x,
    );
  }

  late final _SDL_ceil2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil2 = _SDL_ceil2Ptr.asFunction<double Function(double)>();

  double SDL_ceilf2(
    double x,
  ) {
    return _SDL_ceilf2(
      x,
    );
  }

  late final _SDL_ceilf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf2 = _SDL_ceilf2Ptr.asFunction<double Function(double)>();

  double SDL_copysign2(
    double x,
    double y,
  ) {
    return _SDL_copysign2(
      x,
      y,
    );
  }

  late final _SDL_copysign2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign2 =
      _SDL_copysign2Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf2(
    double x,
    double y,
  ) {
    return _SDL_copysignf2(
      x,
      y,
    );
  }

  late final _SDL_copysignf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf2 =
      _SDL_copysignf2Ptr.asFunction<double Function(double, double)>();

  double SDL_cos2(
    double x,
  ) {
    return _SDL_cos2(
      x,
    );
  }

  late final _SDL_cos2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos2 = _SDL_cos2Ptr.asFunction<double Function(double)>();

  double SDL_cosf2(
    double x,
  ) {
    return _SDL_cosf2(
      x,
    );
  }

  late final _SDL_cosf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf2 = _SDL_cosf2Ptr.asFunction<double Function(double)>();

  double SDL_exp2(
    double x,
  ) {
    return _SDL_exp2(
      x,
    );
  }

  late final _SDL_exp2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp2 = _SDL_exp2Ptr.asFunction<double Function(double)>();

  double SDL_expf2(
    double x,
  ) {
    return _SDL_expf2(
      x,
    );
  }

  late final _SDL_expf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf2 = _SDL_expf2Ptr.asFunction<double Function(double)>();

  double SDL_fabs2(
    double x,
  ) {
    return _SDL_fabs2(
      x,
    );
  }

  late final _SDL_fabs2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs2 = _SDL_fabs2Ptr.asFunction<double Function(double)>();

  double SDL_fabsf2(
    double x,
  ) {
    return _SDL_fabsf2(
      x,
    );
  }

  late final _SDL_fabsf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf2 = _SDL_fabsf2Ptr.asFunction<double Function(double)>();

  double SDL_floor2(
    double x,
  ) {
    return _SDL_floor2(
      x,
    );
  }

  late final _SDL_floor2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor2 = _SDL_floor2Ptr.asFunction<double Function(double)>();

  double SDL_floorf2(
    double x,
  ) {
    return _SDL_floorf2(
      x,
    );
  }

  late final _SDL_floorf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf2 =
      _SDL_floorf2Ptr.asFunction<double Function(double)>();

  double SDL_trunc2(
    double x,
  ) {
    return _SDL_trunc2(
      x,
    );
  }

  late final _SDL_trunc2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc2 = _SDL_trunc2Ptr.asFunction<double Function(double)>();

  double SDL_truncf2(
    double x,
  ) {
    return _SDL_truncf2(
      x,
    );
  }

  late final _SDL_truncf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf2 =
      _SDL_truncf2Ptr.asFunction<double Function(double)>();

  double SDL_fmod2(
    double x,
    double y,
  ) {
    return _SDL_fmod2(
      x,
      y,
    );
  }

  late final _SDL_fmod2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod2 =
      _SDL_fmod2Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf2(
    double x,
    double y,
  ) {
    return _SDL_fmodf2(
      x,
      y,
    );
  }

  late final _SDL_fmodf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf2 =
      _SDL_fmodf2Ptr.asFunction<double Function(double, double)>();

  double SDL_log2(
    double x,
  ) {
    return _SDL_log2(
      x,
    );
  }

  late final _SDL_log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log2 = _SDL_log2Ptr.asFunction<double Function(double)>();

  double SDL_logf2(
    double x,
  ) {
    return _SDL_logf2(
      x,
    );
  }

  late final _SDL_logf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf2 = _SDL_logf2Ptr.asFunction<double Function(double)>();

  double SDL_log102(
    double x,
  ) {
    return _SDL_log102(
      x,
    );
  }

  late final _SDL_log102Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log102 = _SDL_log102Ptr.asFunction<double Function(double)>();

  double SDL_log10f2(
    double x,
  ) {
    return _SDL_log10f2(
      x,
    );
  }

  late final _SDL_log10f2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f2 =
      _SDL_log10f2Ptr.asFunction<double Function(double)>();

  double SDL_pow2(
    double x,
    double y,
  ) {
    return _SDL_pow2(
      x,
      y,
    );
  }

  late final _SDL_pow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow2 =
      _SDL_pow2Ptr.asFunction<double Function(double, double)>();

  double SDL_powf2(
    double x,
    double y,
  ) {
    return _SDL_powf2(
      x,
      y,
    );
  }

  late final _SDL_powf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf2 =
      _SDL_powf2Ptr.asFunction<double Function(double, double)>();

  double SDL_round2(
    double x,
  ) {
    return _SDL_round2(
      x,
    );
  }

  late final _SDL_round2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round2 = _SDL_round2Ptr.asFunction<double Function(double)>();

  double SDL_roundf2(
    double x,
  ) {
    return _SDL_roundf2(
      x,
    );
  }

  late final _SDL_roundf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf2 =
      _SDL_roundf2Ptr.asFunction<double Function(double)>();

  int SDL_lround2(
    double x,
  ) {
    return _SDL_lround2(
      x,
    );
  }

  late final _SDL_lround2Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround2 = _SDL_lround2Ptr.asFunction<int Function(double)>();

  int SDL_lroundf2(
    double x,
  ) {
    return _SDL_lroundf2(
      x,
    );
  }

  late final _SDL_lroundf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf2 =
      _SDL_lroundf2Ptr.asFunction<int Function(double)>();

  double SDL_scalbn2(
    double x,
    int n,
  ) {
    return _SDL_scalbn2(
      x,
      n,
    );
  }

  late final _SDL_scalbn2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn2 =
      _SDL_scalbn2Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf2(
    double x,
    int n,
  ) {
    return _SDL_scalbnf2(
      x,
      n,
    );
  }

  late final _SDL_scalbnf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf2 =
      _SDL_scalbnf2Ptr.asFunction<double Function(double, int)>();

  double SDL_sin2(
    double x,
  ) {
    return _SDL_sin2(
      x,
    );
  }

  late final _SDL_sin2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin2 = _SDL_sin2Ptr.asFunction<double Function(double)>();

  double SDL_sinf2(
    double x,
  ) {
    return _SDL_sinf2(
      x,
    );
  }

  late final _SDL_sinf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf2 = _SDL_sinf2Ptr.asFunction<double Function(double)>();

  double SDL_sqrt2(
    double x,
  ) {
    return _SDL_sqrt2(
      x,
    );
  }

  late final _SDL_sqrt2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt2 = _SDL_sqrt2Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf2(
    double x,
  ) {
    return _SDL_sqrtf2(
      x,
    );
  }

  late final _SDL_sqrtf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf2 = _SDL_sqrtf2Ptr.asFunction<double Function(double)>();

  double SDL_tan2(
    double x,
  ) {
    return _SDL_tan2(
      x,
    );
  }

  late final _SDL_tan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan2 = _SDL_tan2Ptr.asFunction<double Function(double)>();

  double SDL_tanf2(
    double x,
  ) {
    return _SDL_tanf2(
      x,
    );
  }

  late final _SDL_tanf2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf2 = _SDL_tanf2Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open2(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open2(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open2Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open2 = _SDL_iconv_open2Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close2(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close2(
      cd,
    );
  }

  late final _SDL_iconv_close2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close2 =
      _SDL_iconv_close2Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv2(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv2(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv2 = _SDL_iconv2Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string2(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string2(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string2 = _SDL_iconv_string2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError1(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError1(
      fmt,
    );
  }

  late final _SDL_SetError1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError1 =
      _SDL_SetError1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError1() {
    return _SDL_GetError1();
  }

  late final _SDL_GetError1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError1 =
      _SDL_GetError1Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg1(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg1(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg1 = _SDL_GetErrorMsg1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError1() {
    return _SDL_ClearError1();
  }

  late final _SDL_ClearError1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError1 =
      _SDL_ClearError1Ptr.asFunction<void Function()>();

  int SDL_Error1(
    int code,
  ) {
    return _SDL_Error1(
      code,
    );
  }

  late final _SDL_Error1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error1 = _SDL_Error1Ptr.asFunction<int Function(int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform3() {
    return _SDL_GetPlatform3();
  }

  late final _SDL_GetPlatform3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform3 =
      _SDL_GetPlatform3Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc3(
    int size,
  ) {
    return _SDL_malloc3(
      size,
    );
  }

  late final _SDL_malloc3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc3 =
      _SDL_malloc3Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc3(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc3(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc3 =
      _SDL_calloc3Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc3(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc3(
      mem,
      size,
    );
  }

  late final _SDL_realloc3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc3 = _SDL_realloc3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free3(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free3(
      mem,
    );
  }

  late final _SDL_free3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free3 =
      _SDL_free3Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions3(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions3(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions3 = _SDL_GetMemoryFunctions3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions3(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions3(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions3 = _SDL_SetMemoryFunctions3Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations3() {
    return _SDL_GetNumAllocations3();
  }

  late final _SDL_GetNumAllocations3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations3 =
      _SDL_GetNumAllocations3Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv3(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv3(
      name,
    );
  }

  late final _SDL_getenv3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv3 = _SDL_getenv3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv3(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv3(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv3 = _SDL_setenv3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort3(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort3(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort3 = _SDL_qsort3Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs3(
    int x,
  ) {
    return _SDL_abs3(
      x,
    );
  }

  late final _SDL_abs3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs3 = _SDL_abs3Ptr.asFunction<int Function(int)>();

  int SDL_isalpha3(
    int x,
  ) {
    return _SDL_isalpha3(
      x,
    );
  }

  late final _SDL_isalpha3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha3 = _SDL_isalpha3Ptr.asFunction<int Function(int)>();

  int SDL_isalnum3(
    int x,
  ) {
    return _SDL_isalnum3(
      x,
    );
  }

  late final _SDL_isalnum3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum3 = _SDL_isalnum3Ptr.asFunction<int Function(int)>();

  int SDL_isblank3(
    int x,
  ) {
    return _SDL_isblank3(
      x,
    );
  }

  late final _SDL_isblank3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank3 = _SDL_isblank3Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl3(
    int x,
  ) {
    return _SDL_iscntrl3(
      x,
    );
  }

  late final _SDL_iscntrl3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl3 = _SDL_iscntrl3Ptr.asFunction<int Function(int)>();

  int SDL_isdigit3(
    int x,
  ) {
    return _SDL_isdigit3(
      x,
    );
  }

  late final _SDL_isdigit3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit3 = _SDL_isdigit3Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit3(
    int x,
  ) {
    return _SDL_isxdigit3(
      x,
    );
  }

  late final _SDL_isxdigit3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit3 = _SDL_isxdigit3Ptr.asFunction<int Function(int)>();

  int SDL_ispunct3(
    int x,
  ) {
    return _SDL_ispunct3(
      x,
    );
  }

  late final _SDL_ispunct3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct3 = _SDL_ispunct3Ptr.asFunction<int Function(int)>();

  int SDL_isspace3(
    int x,
  ) {
    return _SDL_isspace3(
      x,
    );
  }

  late final _SDL_isspace3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace3 = _SDL_isspace3Ptr.asFunction<int Function(int)>();

  int SDL_isupper3(
    int x,
  ) {
    return _SDL_isupper3(
      x,
    );
  }

  late final _SDL_isupper3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper3 = _SDL_isupper3Ptr.asFunction<int Function(int)>();

  int SDL_islower3(
    int x,
  ) {
    return _SDL_islower3(
      x,
    );
  }

  late final _SDL_islower3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower3 = _SDL_islower3Ptr.asFunction<int Function(int)>();

  int SDL_isprint3(
    int x,
  ) {
    return _SDL_isprint3(
      x,
    );
  }

  late final _SDL_isprint3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint3 = _SDL_isprint3Ptr.asFunction<int Function(int)>();

  int SDL_isgraph3(
    int x,
  ) {
    return _SDL_isgraph3(
      x,
    );
  }

  late final _SDL_isgraph3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph3 = _SDL_isgraph3Ptr.asFunction<int Function(int)>();

  int SDL_toupper3(
    int x,
  ) {
    return _SDL_toupper3(
      x,
    );
  }

  late final _SDL_toupper3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper3 = _SDL_toupper3Ptr.asFunction<int Function(int)>();

  int SDL_tolower3(
    int x,
  ) {
    return _SDL_tolower3(
      x,
    );
  }

  late final _SDL_tolower3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower3 = _SDL_tolower3Ptr.asFunction<int Function(int)>();

  int SDL_crc323(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc323(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc323Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc323 = _SDL_crc323Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset3(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset3(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset3 = _SDL_memset3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy3(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy3(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy3 = _SDL_memcpy3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove3(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove3(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove3 = _SDL_memmove3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp3(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp3(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp3 = _SDL_memcmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen3(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen3(
      wstr,
    );
  }

  late final _SDL_wcslen3Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen3 =
      _SDL_wcslen3Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy3(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy3(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy3 = _SDL_wcslcpy3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat3(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat3(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat3 = _SDL_wcslcat3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup3(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup3(
      wstr,
    );
  }

  late final _SDL_wcsdup3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup3 = _SDL_wcsdup3Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr3(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr3(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr3 = _SDL_wcsstr3Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp3(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp3(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp3 = _SDL_wcscmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp3(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp3(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp3 = _SDL_wcsncmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp3(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp3(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp3 = _SDL_wcscasecmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp3(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp3(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp3 = _SDL_wcsncasecmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen3(
      str,
    );
  }

  late final _SDL_strlen3Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen3 =
      _SDL_strlen3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy3(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy3(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy3 = _SDL_strlcpy3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy3(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy3(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy3 = _SDL_utf8strlcpy3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat3(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat3(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat3 = _SDL_strlcat3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup3(
      str,
    );
  }

  late final _SDL_strdup3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup3 = _SDL_strdup3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev3(
      str,
    );
  }

  late final _SDL_strrev3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev3 = _SDL_strrev3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr3(
      str,
    );
  }

  late final _SDL_strupr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr3 = _SDL_strupr3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr3(
      str,
    );
  }

  late final _SDL_strlwr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr3 = _SDL_strlwr3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr3(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr3(
      str,
      c,
    );
  }

  late final _SDL_strchr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr3 = _SDL_strchr3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr3(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr3(
      str,
      c,
    );
  }

  late final _SDL_strrchr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr3 = _SDL_strrchr3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr3(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr3(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr3 = _SDL_strstr3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr3(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr3(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr3 = _SDL_strtokr3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen3(
      str,
    );
  }

  late final _SDL_utf8strlen3Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen3 =
      _SDL_utf8strlen3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa3(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa3(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa3 = _SDL_itoa3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa3(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa3(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa3 = _SDL_uitoa3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa3(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa3(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa3 = _SDL_ltoa3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa3(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa3(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa3 = _SDL_ultoa3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa3(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa3(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa3 = _SDL_lltoa3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa3(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa3(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa3 = _SDL_ulltoa3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi3(
      str,
    );
  }

  late final _SDL_atoi3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi3 =
      _SDL_atoi3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof3(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof3(
      str,
    );
  }

  late final _SDL_atof3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof3 =
      _SDL_atof3Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol3(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol3(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol3 = _SDL_strtol3Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul3(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul3(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul3 = _SDL_strtoul3Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll3(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll3(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll3Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll3 = _SDL_strtoll3Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull3(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull3(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull3Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull3 = _SDL_strtoull3Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod3(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod3(
      str,
      endp,
    );
  }

  late final _SDL_strtod3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod3 = _SDL_strtod3Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp3(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp3(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp3 = _SDL_strcmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp3(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp3(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp3 = _SDL_strncmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp3(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp3(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp3 = _SDL_strcasecmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp3(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp3(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp3 = _SDL_strncasecmp3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf3(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf3(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf3 = _SDL_sscanf3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf3(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf3(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf3 = _SDL_vsscanf3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf3(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf3(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf3 = _SDL_snprintf3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf3(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf3(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf3 = _SDL_vsnprintf3Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf3(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf3(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf3 = _SDL_asprintf3Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf3(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf3(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf3 = _SDL_vasprintf3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos3(
    double x,
  ) {
    return _SDL_acos3(
      x,
    );
  }

  late final _SDL_acos3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos3 = _SDL_acos3Ptr.asFunction<double Function(double)>();

  double SDL_acosf3(
    double x,
  ) {
    return _SDL_acosf3(
      x,
    );
  }

  late final _SDL_acosf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf3 = _SDL_acosf3Ptr.asFunction<double Function(double)>();

  double SDL_asin3(
    double x,
  ) {
    return _SDL_asin3(
      x,
    );
  }

  late final _SDL_asin3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin3 = _SDL_asin3Ptr.asFunction<double Function(double)>();

  double SDL_asinf3(
    double x,
  ) {
    return _SDL_asinf3(
      x,
    );
  }

  late final _SDL_asinf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf3 = _SDL_asinf3Ptr.asFunction<double Function(double)>();

  double SDL_atan4(
    double x,
  ) {
    return _SDL_atan4(
      x,
    );
  }

  late final _SDL_atan4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan4 = _SDL_atan4Ptr.asFunction<double Function(double)>();

  double SDL_atanf3(
    double x,
  ) {
    return _SDL_atanf3(
      x,
    );
  }

  late final _SDL_atanf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf3 = _SDL_atanf3Ptr.asFunction<double Function(double)>();

  double SDL_atan23(
    double y,
    double x,
  ) {
    return _SDL_atan23(
      y,
      x,
    );
  }

  late final _SDL_atan23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan23 =
      _SDL_atan23Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f3(
    double y,
    double x,
  ) {
    return _SDL_atan2f3(
      y,
      x,
    );
  }

  late final _SDL_atan2f3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f3 =
      _SDL_atan2f3Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil3(
    double x,
  ) {
    return _SDL_ceil3(
      x,
    );
  }

  late final _SDL_ceil3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil3 = _SDL_ceil3Ptr.asFunction<double Function(double)>();

  double SDL_ceilf3(
    double x,
  ) {
    return _SDL_ceilf3(
      x,
    );
  }

  late final _SDL_ceilf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf3 = _SDL_ceilf3Ptr.asFunction<double Function(double)>();

  double SDL_copysign3(
    double x,
    double y,
  ) {
    return _SDL_copysign3(
      x,
      y,
    );
  }

  late final _SDL_copysign3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign3 =
      _SDL_copysign3Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf3(
    double x,
    double y,
  ) {
    return _SDL_copysignf3(
      x,
      y,
    );
  }

  late final _SDL_copysignf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf3 =
      _SDL_copysignf3Ptr.asFunction<double Function(double, double)>();

  double SDL_cos3(
    double x,
  ) {
    return _SDL_cos3(
      x,
    );
  }

  late final _SDL_cos3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos3 = _SDL_cos3Ptr.asFunction<double Function(double)>();

  double SDL_cosf3(
    double x,
  ) {
    return _SDL_cosf3(
      x,
    );
  }

  late final _SDL_cosf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf3 = _SDL_cosf3Ptr.asFunction<double Function(double)>();

  double SDL_exp3(
    double x,
  ) {
    return _SDL_exp3(
      x,
    );
  }

  late final _SDL_exp3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp3 = _SDL_exp3Ptr.asFunction<double Function(double)>();

  double SDL_expf3(
    double x,
  ) {
    return _SDL_expf3(
      x,
    );
  }

  late final _SDL_expf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf3 = _SDL_expf3Ptr.asFunction<double Function(double)>();

  double SDL_fabs3(
    double x,
  ) {
    return _SDL_fabs3(
      x,
    );
  }

  late final _SDL_fabs3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs3 = _SDL_fabs3Ptr.asFunction<double Function(double)>();

  double SDL_fabsf3(
    double x,
  ) {
    return _SDL_fabsf3(
      x,
    );
  }

  late final _SDL_fabsf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf3 = _SDL_fabsf3Ptr.asFunction<double Function(double)>();

  double SDL_floor3(
    double x,
  ) {
    return _SDL_floor3(
      x,
    );
  }

  late final _SDL_floor3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor3 = _SDL_floor3Ptr.asFunction<double Function(double)>();

  double SDL_floorf3(
    double x,
  ) {
    return _SDL_floorf3(
      x,
    );
  }

  late final _SDL_floorf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf3 =
      _SDL_floorf3Ptr.asFunction<double Function(double)>();

  double SDL_trunc3(
    double x,
  ) {
    return _SDL_trunc3(
      x,
    );
  }

  late final _SDL_trunc3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc3 = _SDL_trunc3Ptr.asFunction<double Function(double)>();

  double SDL_truncf3(
    double x,
  ) {
    return _SDL_truncf3(
      x,
    );
  }

  late final _SDL_truncf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf3 =
      _SDL_truncf3Ptr.asFunction<double Function(double)>();

  double SDL_fmod3(
    double x,
    double y,
  ) {
    return _SDL_fmod3(
      x,
      y,
    );
  }

  late final _SDL_fmod3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod3 =
      _SDL_fmod3Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf3(
    double x,
    double y,
  ) {
    return _SDL_fmodf3(
      x,
      y,
    );
  }

  late final _SDL_fmodf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf3 =
      _SDL_fmodf3Ptr.asFunction<double Function(double, double)>();

  double SDL_log3(
    double x,
  ) {
    return _SDL_log3(
      x,
    );
  }

  late final _SDL_log3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log3 = _SDL_log3Ptr.asFunction<double Function(double)>();

  double SDL_logf3(
    double x,
  ) {
    return _SDL_logf3(
      x,
    );
  }

  late final _SDL_logf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf3 = _SDL_logf3Ptr.asFunction<double Function(double)>();

  double SDL_log103(
    double x,
  ) {
    return _SDL_log103(
      x,
    );
  }

  late final _SDL_log103Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log103 = _SDL_log103Ptr.asFunction<double Function(double)>();

  double SDL_log10f3(
    double x,
  ) {
    return _SDL_log10f3(
      x,
    );
  }

  late final _SDL_log10f3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f3 =
      _SDL_log10f3Ptr.asFunction<double Function(double)>();

  double SDL_pow3(
    double x,
    double y,
  ) {
    return _SDL_pow3(
      x,
      y,
    );
  }

  late final _SDL_pow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow3 =
      _SDL_pow3Ptr.asFunction<double Function(double, double)>();

  double SDL_powf3(
    double x,
    double y,
  ) {
    return _SDL_powf3(
      x,
      y,
    );
  }

  late final _SDL_powf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf3 =
      _SDL_powf3Ptr.asFunction<double Function(double, double)>();

  double SDL_round3(
    double x,
  ) {
    return _SDL_round3(
      x,
    );
  }

  late final _SDL_round3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round3 = _SDL_round3Ptr.asFunction<double Function(double)>();

  double SDL_roundf3(
    double x,
  ) {
    return _SDL_roundf3(
      x,
    );
  }

  late final _SDL_roundf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf3 =
      _SDL_roundf3Ptr.asFunction<double Function(double)>();

  int SDL_lround3(
    double x,
  ) {
    return _SDL_lround3(
      x,
    );
  }

  late final _SDL_lround3Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround3 = _SDL_lround3Ptr.asFunction<int Function(double)>();

  int SDL_lroundf3(
    double x,
  ) {
    return _SDL_lroundf3(
      x,
    );
  }

  late final _SDL_lroundf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf3 =
      _SDL_lroundf3Ptr.asFunction<int Function(double)>();

  double SDL_scalbn3(
    double x,
    int n,
  ) {
    return _SDL_scalbn3(
      x,
      n,
    );
  }

  late final _SDL_scalbn3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn3 =
      _SDL_scalbn3Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf3(
    double x,
    int n,
  ) {
    return _SDL_scalbnf3(
      x,
      n,
    );
  }

  late final _SDL_scalbnf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf3 =
      _SDL_scalbnf3Ptr.asFunction<double Function(double, int)>();

  double SDL_sin3(
    double x,
  ) {
    return _SDL_sin3(
      x,
    );
  }

  late final _SDL_sin3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin3 = _SDL_sin3Ptr.asFunction<double Function(double)>();

  double SDL_sinf3(
    double x,
  ) {
    return _SDL_sinf3(
      x,
    );
  }

  late final _SDL_sinf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf3 = _SDL_sinf3Ptr.asFunction<double Function(double)>();

  double SDL_sqrt3(
    double x,
  ) {
    return _SDL_sqrt3(
      x,
    );
  }

  late final _SDL_sqrt3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt3 = _SDL_sqrt3Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf3(
    double x,
  ) {
    return _SDL_sqrtf3(
      x,
    );
  }

  late final _SDL_sqrtf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf3 = _SDL_sqrtf3Ptr.asFunction<double Function(double)>();

  double SDL_tan3(
    double x,
  ) {
    return _SDL_tan3(
      x,
    );
  }

  late final _SDL_tan3Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan3 = _SDL_tan3Ptr.asFunction<double Function(double)>();

  double SDL_tanf3(
    double x,
  ) {
    return _SDL_tanf3(
      x,
    );
  }

  late final _SDL_tanf3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf3 = _SDL_tanf3Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open3(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open3(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open3Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open3 = _SDL_iconv_open3Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close3(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close3(
      cd,
    );
  }

  late final _SDL_iconv_close3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close3 =
      _SDL_iconv_close3Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv3(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv3(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv3 = _SDL_iconv3Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string3(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string3(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string3 = _SDL_iconv_string3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the priority of all log categories.
  ///
  /// \param priority the SDL_LogPriority to assign
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetPriority
  void SDL_LogSetAllPriority1(
    int priority,
  ) {
    return _SDL_LogSetAllPriority1(
      priority,
    );
  }

  late final _SDL_LogSetAllPriority1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_LogSetAllPriority');
  late final _SDL_LogSetAllPriority1 =
      _SDL_LogSetAllPriority1Ptr.asFunction<void Function(int)>();

  /// Set the priority of a particular log category.
  ///
  /// \param category the category to assign a priority to
  /// \param priority the SDL_LogPriority to assign
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogGetPriority
  /// \sa SDL_LogSetAllPriority
  void SDL_LogSetPriority1(
    int category,
    int priority,
  ) {
    return _SDL_LogSetPriority1(
      category,
      priority,
    );
  }

  late final _SDL_LogSetPriority1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int, ffi.Int32)>>(
          'SDL_LogSetPriority');
  late final _SDL_LogSetPriority1 =
      _SDL_LogSetPriority1Ptr.asFunction<void Function(int, int)>();

  /// Get the priority of a particular log category.
  ///
  /// \param category the category to query
  /// \returns the SDL_LogPriority for the requested category
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetPriority
  int SDL_LogGetPriority1(
    int category,
  ) {
    return _SDL_LogGetPriority1(
      category,
    );
  }

  late final _SDL_LogGetPriority1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_LogGetPriority');
  late final _SDL_LogGetPriority1 =
      _SDL_LogGetPriority1Ptr.asFunction<int Function(int)>();

  /// Reset all priorities to default.
  ///
  /// This is called by SDL_Quit().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetAllPriority
  /// \sa SDL_LogSetPriority
  void SDL_LogResetPriorities1() {
    return _SDL_LogResetPriorities1();
  }

  late final _SDL_LogResetPriorities1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_LogResetPriorities');
  late final _SDL_LogResetPriorities1 =
      _SDL_LogResetPriorities1Ptr.asFunction<void Function()>();

  /// Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.
  ///
  /// = * \param fmt a printf() style message format string
  ///
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_Log1(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_Log1(
      fmt,
    );
  }

  late final _SDL_Log1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_Log');
  late final _SDL_Log1 =
      _SDL_Log1Ptr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_VERBOSE.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogWarn
  void SDL_LogVerbose1(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogVerbose1(
      category,
      fmt,
    );
  }

  late final _SDL_LogVerbose1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogVerbose');
  late final _SDL_LogVerbose1 = _SDL_LogVerbose1Ptr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_DEBUG.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogDebug1(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogDebug1(
      category,
      fmt,
    );
  }

  late final _SDL_LogDebug1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogDebug');
  late final _SDL_LogDebug1 =
      _SDL_LogDebug1Ptr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_INFO.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogInfo1(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogInfo1(
      category,
      fmt,
    );
  }

  late final _SDL_LogInfo1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogInfo');
  late final _SDL_LogInfo1 =
      _SDL_LogInfo1Ptr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_WARN.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  void SDL_LogWarn1(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogWarn1(
      category,
      fmt,
    );
  }

  late final _SDL_LogWarn1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogWarn');
  late final _SDL_LogWarn1 =
      _SDL_LogWarn1Ptr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_ERROR.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogError1(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogError1(
      category,
      fmt,
    );
  }

  late final _SDL_LogError1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogError');
  late final _SDL_LogError1 =
      _SDL_LogError1Ptr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with SDL_LOG_PRIORITY_CRITICAL.
  ///
  /// \param category the category of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogCritical1(
    int category,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogCritical1(
      category,
      fmt,
    );
  }

  late final _SDL_LogCritical1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('SDL_LogCritical');
  late final _SDL_LogCritical1 = _SDL_LogCritical1Ptr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with the specified category and priority.
  ///
  /// \param category the category of the message
  /// \param priority the priority of the message
  /// \param fmt a printf() style message format string
  /// \param ... additional parameters matching % tokens in the **fmt** string,
  /// if any
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessageV
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogMessage1(
    int category,
    int priority,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_LogMessage1(
      category,
      priority,
      fmt,
    );
  }

  late final _SDL_LogMessage1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int, ffi.Int32, ffi.Pointer<ffi.Char>)>>('SDL_LogMessage');
  late final _SDL_LogMessage1 = _SDL_LogMessage1Ptr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Log a message with the specified category and priority.
  ///
  /// \param category the category of the message
  /// \param priority the priority of the message
  /// \param fmt a printf() style message format string
  /// \param ap a variable argument list
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Log
  /// \sa SDL_LogCritical
  /// \sa SDL_LogDebug
  /// \sa SDL_LogError
  /// \sa SDL_LogInfo
  /// \sa SDL_LogMessage
  /// \sa SDL_LogVerbose
  /// \sa SDL_LogWarn
  void SDL_LogMessageV1(
    int category,
    int priority,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_LogMessageV1(
      category,
      priority,
      fmt,
      ap,
    );
  }

  late final _SDL_LogMessageV1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Int32, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_LogMessageV');
  late final _SDL_LogMessageV1 = _SDL_LogMessageV1Ptr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Char>, va_list)>();

  /// Get the current log output function.
  ///
  /// \param callback an SDL_LogOutputFunction filled in with the current log
  /// callback
  /// \param userdata a pointer filled in with the pointer that is passed to
  /// `callback`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogSetOutputFunction
  void SDL_LogGetOutputFunction1(
    ffi.Pointer<SDL_LogOutputFunction> callback,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_LogGetOutputFunction1(
      callback,
      userdata,
    );
  }

  late final _SDL_LogGetOutputFunction1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_LogOutputFunction>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_LogGetOutputFunction');
  late final _SDL_LogGetOutputFunction1 =
      _SDL_LogGetOutputFunction1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_LogOutputFunction>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Replace the default log output function with one of your own.
  ///
  /// \param callback an SDL_LogOutputFunction to call instead of the default
  /// \param userdata a pointer that is passed to `callback`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LogGetOutputFunction
  void SDL_LogSetOutputFunction1(
    SDL_LogOutputFunction callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_LogSetOutputFunction1(
      callback,
      userdata,
    );
  }

  late final _SDL_LogSetOutputFunction1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_LogOutputFunction,
              ffi.Pointer<ffi.Void>)>>('SDL_LogSetOutputFunction');
  late final _SDL_LogSetOutputFunction1 =
      _SDL_LogSetOutputFunction1Ptr.asFunction<
          void Function(SDL_LogOutputFunction, ffi.Pointer<ffi.Void>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform4() {
    return _SDL_GetPlatform4();
  }

  late final _SDL_GetPlatform4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform4 =
      _SDL_GetPlatform4Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int SDL_ReportAssertion1(
    ffi.Pointer<SDL_AssertData> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _SDL_ReportAssertion1(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _SDL_ReportAssertion1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ReportAssertion');
  late final _SDL_ReportAssertion1 = _SDL_ReportAssertion1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Set an application-defined assertion handler.
  ///
  /// This function allows an application to show its own assertion UI and/or
  /// force the response to an assertion failure. If the application doesn't
  /// provide this, SDL will try to do the right thing, popping up a
  /// system-specific GUI dialog, and probably minimizing any fullscreen windows.
  ///
  /// This callback may fire from any thread, but it runs wrapped in a mutex, so
  /// it will only fire from one thread at a time.
  ///
  /// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
  ///
  /// \param handler the SDL_AssertionHandler function to call when an assertion
  /// fails or NULL for the default handler
  /// \param userdata a pointer that is passed to `handler`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAssertionHandler
  void SDL_SetAssertionHandler1(
    SDL_AssertionHandler handler,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetAssertionHandler1(
      handler,
      userdata,
    );
  }

  late final _SDL_SetAssertionHandler1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_AssertionHandler,
              ffi.Pointer<ffi.Void>)>>('SDL_SetAssertionHandler');
  late final _SDL_SetAssertionHandler1 = _SDL_SetAssertionHandler1Ptr
      .asFunction<void Function(SDL_AssertionHandler, ffi.Pointer<ffi.Void>)>();

  /// Get the default assertion handler.
  ///
  /// This returns the function pointer that is called by default when an
  /// assertion is triggered. This is an internal function provided by SDL, that
  /// is used for assertions when SDL_SetAssertionHandler() hasn't been used to
  /// provide a different function.
  ///
  /// \returns the default SDL_AssertionHandler that is called when an assert
  /// triggers.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GetAssertionHandler
  SDL_AssertionHandler SDL_GetDefaultAssertionHandler1() {
    return _SDL_GetDefaultAssertionHandler1();
  }

  late final _SDL_GetDefaultAssertionHandler1Ptr =
      _lookup<ffi.NativeFunction<SDL_AssertionHandler Function()>>(
          'SDL_GetDefaultAssertionHandler');
  late final _SDL_GetDefaultAssertionHandler1 =
      _SDL_GetDefaultAssertionHandler1Ptr.asFunction<
          SDL_AssertionHandler Function()>();

  /// Get the current assertion handler.
  ///
  /// This returns the function pointer that is called when an assertion is
  /// triggered. This is either the value last passed to
  /// SDL_SetAssertionHandler(), or if no application-specified function is set,
  /// is equivalent to calling SDL_GetDefaultAssertionHandler().
  ///
  /// The parameter `puserdata` is a pointer to a void*, which will store the
  /// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value
  /// will always be NULL for the default handler. If you don't care about this
  /// data, it is safe to pass a NULL pointer to this function to ignore it.
  ///
  /// \param puserdata pointer which is filled with the "userdata" pointer that
  /// was passed to SDL_SetAssertionHandler()
  /// \returns the SDL_AssertionHandler that is called when an assert triggers.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_SetAssertionHandler
  SDL_AssertionHandler SDL_GetAssertionHandler1(
    ffi.Pointer<ffi.Pointer<ffi.Void>> puserdata,
  ) {
    return _SDL_GetAssertionHandler1(
      puserdata,
    );
  }

  late final _SDL_GetAssertionHandler1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_AssertionHandler Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetAssertionHandler');
  late final _SDL_GetAssertionHandler1 =
      _SDL_GetAssertionHandler1Ptr.asFunction<
          SDL_AssertionHandler Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Get a list of all assertion failures.
  ///
  /// This function gets all assertions triggered since the last call to
  /// SDL_ResetAssertionReport(), or the start of the program.
  ///
  /// The proper way to examine this data looks something like this:
  ///
  /// ```c
  /// const SDL_AssertData *item = SDL_GetAssertionReport();
  /// while (item) {
  /// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
  /// item->condition, item->function, item->filename,
  /// item->linenum, item->trigger_count,
  /// item->always_ignore ? "yes" : "no");
  /// item = item->next;
  /// }
  /// ```
  ///
  /// \returns a list of all failed assertions or NULL if the list is empty. This
  /// memory should not be modified or freed by the application.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ResetAssertionReport
  ffi.Pointer<SDL_AssertData> SDL_GetAssertionReport1() {
    return _SDL_GetAssertionReport1();
  }

  late final _SDL_GetAssertionReport1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_AssertData> Function()>>(
          'SDL_GetAssertionReport');
  late final _SDL_GetAssertionReport1 = _SDL_GetAssertionReport1Ptr.asFunction<
      ffi.Pointer<SDL_AssertData> Function()>();

  /// Clear the list of all assertion failures.
  ///
  /// This function will clear the list of all assertions triggered up to that
  /// point. Immediately following this call, SDL_GetAssertionReport will return
  /// no items. In addition, any previously-triggered assertions will be reset to
  /// a trigger_count of zero, and their always_ignore state will be false.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAssertionReport
  void SDL_ResetAssertionReport1() {
    return _SDL_ResetAssertionReport1();
  }

  late final _SDL_ResetAssertionReport1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_ResetAssertionReport');
  late final _SDL_ResetAssertionReport1 =
      _SDL_ResetAssertionReport1Ptr.asFunction<void Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform5() {
    return _SDL_GetPlatform5();
  }

  late final _SDL_GetPlatform5Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform5 =
      _SDL_GetPlatform5Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc4(
    int size,
  ) {
    return _SDL_malloc4(
      size,
    );
  }

  late final _SDL_malloc4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc4 =
      _SDL_malloc4Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc4(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc4(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc4 =
      _SDL_calloc4Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc4(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc4(
      mem,
      size,
    );
  }

  late final _SDL_realloc4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc4 = _SDL_realloc4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free4(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free4(
      mem,
    );
  }

  late final _SDL_free4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free4 =
      _SDL_free4Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions4(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions4(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions4 = _SDL_GetMemoryFunctions4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions4(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions4(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions4 = _SDL_SetMemoryFunctions4Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations4() {
    return _SDL_GetNumAllocations4();
  }

  late final _SDL_GetNumAllocations4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations4 =
      _SDL_GetNumAllocations4Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv4(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv4(
      name,
    );
  }

  late final _SDL_getenv4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv4 = _SDL_getenv4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv4(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv4(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv4 = _SDL_setenv4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort4(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort4(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort4 = _SDL_qsort4Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs4(
    int x,
  ) {
    return _SDL_abs4(
      x,
    );
  }

  late final _SDL_abs4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs4 = _SDL_abs4Ptr.asFunction<int Function(int)>();

  int SDL_isalpha4(
    int x,
  ) {
    return _SDL_isalpha4(
      x,
    );
  }

  late final _SDL_isalpha4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha4 = _SDL_isalpha4Ptr.asFunction<int Function(int)>();

  int SDL_isalnum4(
    int x,
  ) {
    return _SDL_isalnum4(
      x,
    );
  }

  late final _SDL_isalnum4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum4 = _SDL_isalnum4Ptr.asFunction<int Function(int)>();

  int SDL_isblank4(
    int x,
  ) {
    return _SDL_isblank4(
      x,
    );
  }

  late final _SDL_isblank4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank4 = _SDL_isblank4Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl4(
    int x,
  ) {
    return _SDL_iscntrl4(
      x,
    );
  }

  late final _SDL_iscntrl4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl4 = _SDL_iscntrl4Ptr.asFunction<int Function(int)>();

  int SDL_isdigit4(
    int x,
  ) {
    return _SDL_isdigit4(
      x,
    );
  }

  late final _SDL_isdigit4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit4 = _SDL_isdigit4Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit4(
    int x,
  ) {
    return _SDL_isxdigit4(
      x,
    );
  }

  late final _SDL_isxdigit4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit4 = _SDL_isxdigit4Ptr.asFunction<int Function(int)>();

  int SDL_ispunct4(
    int x,
  ) {
    return _SDL_ispunct4(
      x,
    );
  }

  late final _SDL_ispunct4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct4 = _SDL_ispunct4Ptr.asFunction<int Function(int)>();

  int SDL_isspace4(
    int x,
  ) {
    return _SDL_isspace4(
      x,
    );
  }

  late final _SDL_isspace4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace4 = _SDL_isspace4Ptr.asFunction<int Function(int)>();

  int SDL_isupper4(
    int x,
  ) {
    return _SDL_isupper4(
      x,
    );
  }

  late final _SDL_isupper4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper4 = _SDL_isupper4Ptr.asFunction<int Function(int)>();

  int SDL_islower4(
    int x,
  ) {
    return _SDL_islower4(
      x,
    );
  }

  late final _SDL_islower4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower4 = _SDL_islower4Ptr.asFunction<int Function(int)>();

  int SDL_isprint4(
    int x,
  ) {
    return _SDL_isprint4(
      x,
    );
  }

  late final _SDL_isprint4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint4 = _SDL_isprint4Ptr.asFunction<int Function(int)>();

  int SDL_isgraph4(
    int x,
  ) {
    return _SDL_isgraph4(
      x,
    );
  }

  late final _SDL_isgraph4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph4 = _SDL_isgraph4Ptr.asFunction<int Function(int)>();

  int SDL_toupper4(
    int x,
  ) {
    return _SDL_toupper4(
      x,
    );
  }

  late final _SDL_toupper4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper4 = _SDL_toupper4Ptr.asFunction<int Function(int)>();

  int SDL_tolower4(
    int x,
  ) {
    return _SDL_tolower4(
      x,
    );
  }

  late final _SDL_tolower4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower4 = _SDL_tolower4Ptr.asFunction<int Function(int)>();

  int SDL_crc324(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc324(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc324Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc324 = _SDL_crc324Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset4(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset4(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset4 = _SDL_memset4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy4(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy4(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy4 = _SDL_memcpy4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove4(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove4(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove4 = _SDL_memmove4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp4(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp4(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp4 = _SDL_memcmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen4(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen4(
      wstr,
    );
  }

  late final _SDL_wcslen4Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen4 =
      _SDL_wcslen4Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy4(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy4(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy4 = _SDL_wcslcpy4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat4(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat4(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat4 = _SDL_wcslcat4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup4(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup4(
      wstr,
    );
  }

  late final _SDL_wcsdup4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup4 = _SDL_wcsdup4Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr4(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr4(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr4 = _SDL_wcsstr4Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp4(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp4(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp4 = _SDL_wcscmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp4(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp4(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp4 = _SDL_wcsncmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp4(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp4(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp4 = _SDL_wcscasecmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp4(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp4(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp4 = _SDL_wcsncasecmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen4(
      str,
    );
  }

  late final _SDL_strlen4Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen4 =
      _SDL_strlen4Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy4(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy4(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy4 = _SDL_strlcpy4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy4(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy4(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy4 = _SDL_utf8strlcpy4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat4(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat4(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat4 = _SDL_strlcat4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup4(
      str,
    );
  }

  late final _SDL_strdup4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup4 = _SDL_strdup4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev4(
      str,
    );
  }

  late final _SDL_strrev4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev4 = _SDL_strrev4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr4(
      str,
    );
  }

  late final _SDL_strupr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr4 = _SDL_strupr4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr4(
      str,
    );
  }

  late final _SDL_strlwr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr4 = _SDL_strlwr4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr4(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr4(
      str,
      c,
    );
  }

  late final _SDL_strchr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr4 = _SDL_strchr4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr4(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr4(
      str,
      c,
    );
  }

  late final _SDL_strrchr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr4 = _SDL_strrchr4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr4(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr4(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr4 = _SDL_strstr4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr4(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr4(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr4 = _SDL_strtokr4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen4(
      str,
    );
  }

  late final _SDL_utf8strlen4Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen4 =
      _SDL_utf8strlen4Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa4(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa4(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa4 = _SDL_itoa4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa4(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa4(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa4 = _SDL_uitoa4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa4(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa4(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa4 = _SDL_ltoa4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa4(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa4(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa4 = _SDL_ultoa4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa4(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa4(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa4 = _SDL_lltoa4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa4(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa4(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa4 = _SDL_ulltoa4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi4(
      str,
    );
  }

  late final _SDL_atoi4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi4 =
      _SDL_atoi4Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof4(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof4(
      str,
    );
  }

  late final _SDL_atof4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof4 =
      _SDL_atof4Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol4(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol4(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol4 = _SDL_strtol4Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul4(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul4(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul4 = _SDL_strtoul4Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll4(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll4(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll4Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll4 = _SDL_strtoll4Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull4(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull4(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull4Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull4 = _SDL_strtoull4Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod4(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod4(
      str,
      endp,
    );
  }

  late final _SDL_strtod4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod4 = _SDL_strtod4Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp4(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp4(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp4 = _SDL_strcmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp4(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp4(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp4 = _SDL_strncmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp4(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp4(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp4 = _SDL_strcasecmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp4(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp4(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp4 = _SDL_strncasecmp4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf4(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf4(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf4 = _SDL_sscanf4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf4(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf4(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf4 = _SDL_vsscanf4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf4(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf4(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf4 = _SDL_snprintf4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf4(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf4(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf4 = _SDL_vsnprintf4Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf4(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf4(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf4 = _SDL_asprintf4Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf4(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf4(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf4 = _SDL_vasprintf4Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos4(
    double x,
  ) {
    return _SDL_acos4(
      x,
    );
  }

  late final _SDL_acos4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos4 = _SDL_acos4Ptr.asFunction<double Function(double)>();

  double SDL_acosf4(
    double x,
  ) {
    return _SDL_acosf4(
      x,
    );
  }

  late final _SDL_acosf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf4 = _SDL_acosf4Ptr.asFunction<double Function(double)>();

  double SDL_asin4(
    double x,
  ) {
    return _SDL_asin4(
      x,
    );
  }

  late final _SDL_asin4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin4 = _SDL_asin4Ptr.asFunction<double Function(double)>();

  double SDL_asinf4(
    double x,
  ) {
    return _SDL_asinf4(
      x,
    );
  }

  late final _SDL_asinf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf4 = _SDL_asinf4Ptr.asFunction<double Function(double)>();

  double SDL_atan5(
    double x,
  ) {
    return _SDL_atan5(
      x,
    );
  }

  late final _SDL_atan5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan5 = _SDL_atan5Ptr.asFunction<double Function(double)>();

  double SDL_atanf4(
    double x,
  ) {
    return _SDL_atanf4(
      x,
    );
  }

  late final _SDL_atanf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf4 = _SDL_atanf4Ptr.asFunction<double Function(double)>();

  double SDL_atan24(
    double y,
    double x,
  ) {
    return _SDL_atan24(
      y,
      x,
    );
  }

  late final _SDL_atan24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan24 =
      _SDL_atan24Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f4(
    double y,
    double x,
  ) {
    return _SDL_atan2f4(
      y,
      x,
    );
  }

  late final _SDL_atan2f4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f4 =
      _SDL_atan2f4Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil4(
    double x,
  ) {
    return _SDL_ceil4(
      x,
    );
  }

  late final _SDL_ceil4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil4 = _SDL_ceil4Ptr.asFunction<double Function(double)>();

  double SDL_ceilf4(
    double x,
  ) {
    return _SDL_ceilf4(
      x,
    );
  }

  late final _SDL_ceilf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf4 = _SDL_ceilf4Ptr.asFunction<double Function(double)>();

  double SDL_copysign4(
    double x,
    double y,
  ) {
    return _SDL_copysign4(
      x,
      y,
    );
  }

  late final _SDL_copysign4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign4 =
      _SDL_copysign4Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf4(
    double x,
    double y,
  ) {
    return _SDL_copysignf4(
      x,
      y,
    );
  }

  late final _SDL_copysignf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf4 =
      _SDL_copysignf4Ptr.asFunction<double Function(double, double)>();

  double SDL_cos4(
    double x,
  ) {
    return _SDL_cos4(
      x,
    );
  }

  late final _SDL_cos4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos4 = _SDL_cos4Ptr.asFunction<double Function(double)>();

  double SDL_cosf4(
    double x,
  ) {
    return _SDL_cosf4(
      x,
    );
  }

  late final _SDL_cosf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf4 = _SDL_cosf4Ptr.asFunction<double Function(double)>();

  double SDL_exp4(
    double x,
  ) {
    return _SDL_exp4(
      x,
    );
  }

  late final _SDL_exp4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp4 = _SDL_exp4Ptr.asFunction<double Function(double)>();

  double SDL_expf4(
    double x,
  ) {
    return _SDL_expf4(
      x,
    );
  }

  late final _SDL_expf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf4 = _SDL_expf4Ptr.asFunction<double Function(double)>();

  double SDL_fabs4(
    double x,
  ) {
    return _SDL_fabs4(
      x,
    );
  }

  late final _SDL_fabs4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs4 = _SDL_fabs4Ptr.asFunction<double Function(double)>();

  double SDL_fabsf4(
    double x,
  ) {
    return _SDL_fabsf4(
      x,
    );
  }

  late final _SDL_fabsf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf4 = _SDL_fabsf4Ptr.asFunction<double Function(double)>();

  double SDL_floor4(
    double x,
  ) {
    return _SDL_floor4(
      x,
    );
  }

  late final _SDL_floor4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor4 = _SDL_floor4Ptr.asFunction<double Function(double)>();

  double SDL_floorf4(
    double x,
  ) {
    return _SDL_floorf4(
      x,
    );
  }

  late final _SDL_floorf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf4 =
      _SDL_floorf4Ptr.asFunction<double Function(double)>();

  double SDL_trunc4(
    double x,
  ) {
    return _SDL_trunc4(
      x,
    );
  }

  late final _SDL_trunc4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc4 = _SDL_trunc4Ptr.asFunction<double Function(double)>();

  double SDL_truncf4(
    double x,
  ) {
    return _SDL_truncf4(
      x,
    );
  }

  late final _SDL_truncf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf4 =
      _SDL_truncf4Ptr.asFunction<double Function(double)>();

  double SDL_fmod4(
    double x,
    double y,
  ) {
    return _SDL_fmod4(
      x,
      y,
    );
  }

  late final _SDL_fmod4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod4 =
      _SDL_fmod4Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf4(
    double x,
    double y,
  ) {
    return _SDL_fmodf4(
      x,
      y,
    );
  }

  late final _SDL_fmodf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf4 =
      _SDL_fmodf4Ptr.asFunction<double Function(double, double)>();

  double SDL_log4(
    double x,
  ) {
    return _SDL_log4(
      x,
    );
  }

  late final _SDL_log4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log4 = _SDL_log4Ptr.asFunction<double Function(double)>();

  double SDL_logf4(
    double x,
  ) {
    return _SDL_logf4(
      x,
    );
  }

  late final _SDL_logf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf4 = _SDL_logf4Ptr.asFunction<double Function(double)>();

  double SDL_log104(
    double x,
  ) {
    return _SDL_log104(
      x,
    );
  }

  late final _SDL_log104Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log104 = _SDL_log104Ptr.asFunction<double Function(double)>();

  double SDL_log10f4(
    double x,
  ) {
    return _SDL_log10f4(
      x,
    );
  }

  late final _SDL_log10f4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f4 =
      _SDL_log10f4Ptr.asFunction<double Function(double)>();

  double SDL_pow4(
    double x,
    double y,
  ) {
    return _SDL_pow4(
      x,
      y,
    );
  }

  late final _SDL_pow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow4 =
      _SDL_pow4Ptr.asFunction<double Function(double, double)>();

  double SDL_powf4(
    double x,
    double y,
  ) {
    return _SDL_powf4(
      x,
      y,
    );
  }

  late final _SDL_powf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf4 =
      _SDL_powf4Ptr.asFunction<double Function(double, double)>();

  double SDL_round4(
    double x,
  ) {
    return _SDL_round4(
      x,
    );
  }

  late final _SDL_round4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round4 = _SDL_round4Ptr.asFunction<double Function(double)>();

  double SDL_roundf4(
    double x,
  ) {
    return _SDL_roundf4(
      x,
    );
  }

  late final _SDL_roundf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf4 =
      _SDL_roundf4Ptr.asFunction<double Function(double)>();

  int SDL_lround4(
    double x,
  ) {
    return _SDL_lround4(
      x,
    );
  }

  late final _SDL_lround4Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround4 = _SDL_lround4Ptr.asFunction<int Function(double)>();

  int SDL_lroundf4(
    double x,
  ) {
    return _SDL_lroundf4(
      x,
    );
  }

  late final _SDL_lroundf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf4 =
      _SDL_lroundf4Ptr.asFunction<int Function(double)>();

  double SDL_scalbn4(
    double x,
    int n,
  ) {
    return _SDL_scalbn4(
      x,
      n,
    );
  }

  late final _SDL_scalbn4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn4 =
      _SDL_scalbn4Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf4(
    double x,
    int n,
  ) {
    return _SDL_scalbnf4(
      x,
      n,
    );
  }

  late final _SDL_scalbnf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf4 =
      _SDL_scalbnf4Ptr.asFunction<double Function(double, int)>();

  double SDL_sin4(
    double x,
  ) {
    return _SDL_sin4(
      x,
    );
  }

  late final _SDL_sin4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin4 = _SDL_sin4Ptr.asFunction<double Function(double)>();

  double SDL_sinf4(
    double x,
  ) {
    return _SDL_sinf4(
      x,
    );
  }

  late final _SDL_sinf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf4 = _SDL_sinf4Ptr.asFunction<double Function(double)>();

  double SDL_sqrt4(
    double x,
  ) {
    return _SDL_sqrt4(
      x,
    );
  }

  late final _SDL_sqrt4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt4 = _SDL_sqrt4Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf4(
    double x,
  ) {
    return _SDL_sqrtf4(
      x,
    );
  }

  late final _SDL_sqrtf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf4 = _SDL_sqrtf4Ptr.asFunction<double Function(double)>();

  double SDL_tan4(
    double x,
  ) {
    return _SDL_tan4(
      x,
    );
  }

  late final _SDL_tan4Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan4 = _SDL_tan4Ptr.asFunction<double Function(double)>();

  double SDL_tanf4(
    double x,
  ) {
    return _SDL_tanf4(
      x,
    );
  }

  late final _SDL_tanf4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf4 = _SDL_tanf4Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open4(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open4(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open4Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open4 = _SDL_iconv_open4Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close4(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close4(
      cd,
    );
  }

  late final _SDL_iconv_close4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close4 =
      _SDL_iconv_close4Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv4(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv4(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv4 = _SDL_iconv4Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string4(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string4(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string4 = _SDL_iconv_string4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the version of SDL that is linked against your program.
  ///
  /// If you are linking to SDL dynamically, then it is possible that the current
  /// version will be different than the version you compiled against. This
  /// function returns the current version, while SDL_VERSION() is a macro that
  /// tells you what version you compiled with.
  ///
  /// This function may be called safely at any time, even before SDL_Init().
  ///
  /// \param ver the SDL_version structure that contains the version information
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRevision
  void SDL_GetVersion1(
    ffi.Pointer<SDL_version> ver,
  ) {
    return _SDL_GetVersion1(
      ver,
    );
  }

  late final _SDL_GetVersion1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_version>)>>(
          'SDL_GetVersion');
  late final _SDL_GetVersion1 =
      _SDL_GetVersion1Ptr.asFunction<void Function(ffi.Pointer<SDL_version>)>();

  /// Get the code revision of SDL that is linked against your program.
  ///
  /// This value is the revision of the code you are linked with and may be
  /// different from the code you are compiling with, which is found in the
  /// constant SDL_REVISION.
  ///
  /// The revision is arbitrary string (a hash value) uniquely identifying the
  /// exact revision of the SDL library in use, and is only useful in comparing
  /// against other revisions. It is NOT an incrementing number.
  ///
  /// If SDL wasn't built from a git repository with the appropriate tools, this
  /// will return an empty string.
  ///
  /// Prior to SDL 2.0.16, before development moved to GitHub, this returned a
  /// hash for a Mercurial repository.
  ///
  /// You shouldn't use this function for anything but logging it for debugging
  /// purposes. The string is not intended to be reliable in any way.
  ///
  /// \returns an arbitrary string, uniquely identifying the exact revision of
  /// the SDL library in use.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVersion
  ffi.Pointer<ffi.Char> SDL_GetRevision1() {
    return _SDL_GetRevision1();
  }

  late final _SDL_GetRevision1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetRevision');
  late final _SDL_GetRevision1 =
      _SDL_GetRevision1Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Obsolete function, do not use.
  ///
  /// When SDL was hosted in a Mercurial repository, and was built carefully,
  /// this would return the revision number that the build was created from. This
  /// number was not reliable for several reasons, but more importantly, SDL is
  /// now hosted in a git repository, which does not offer numbers at all, only
  /// hashes. This function only ever returns zero now. Don't use it.
  ///
  /// Before SDL 2.0.16, this might have returned an unreliable, but non-zero
  /// number.
  ///
  /// \deprecated Use SDL_GetRevision() instead; if SDL was carefully built, it
  /// will return a git hash.
  ///
  /// \returns zero, always, in modern SDL releases.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRevision
  int SDL_GetRevisionNumber1() {
    return _SDL_GetRevisionNumber1();
  }

  late final _SDL_GetRevisionNumber1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetRevisionNumber');
  late final _SDL_GetRevisionNumber1 =
      _SDL_GetRevisionNumber1Ptr.asFunction<int Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform6() {
    return _SDL_GetPlatform6();
  }

  late final _SDL_GetPlatform6Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform6 =
      _SDL_GetPlatform6Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc5(
    int size,
  ) {
    return _SDL_malloc5(
      size,
    );
  }

  late final _SDL_malloc5Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc5 =
      _SDL_malloc5Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc5(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc5(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc5 =
      _SDL_calloc5Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc5(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc5(
      mem,
      size,
    );
  }

  late final _SDL_realloc5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc5 = _SDL_realloc5Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free5(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free5(
      mem,
    );
  }

  late final _SDL_free5Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free5 =
      _SDL_free5Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions5(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions5(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions5 = _SDL_GetMemoryFunctions5Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions5(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions5(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions5 = _SDL_SetMemoryFunctions5Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations5() {
    return _SDL_GetNumAllocations5();
  }

  late final _SDL_GetNumAllocations5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations5 =
      _SDL_GetNumAllocations5Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv5(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv5(
      name,
    );
  }

  late final _SDL_getenv5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv5 = _SDL_getenv5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv5(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv5(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv5 = _SDL_setenv5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort5(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort5(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort5 = _SDL_qsort5Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs5(
    int x,
  ) {
    return _SDL_abs5(
      x,
    );
  }

  late final _SDL_abs5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs5 = _SDL_abs5Ptr.asFunction<int Function(int)>();

  int SDL_isalpha5(
    int x,
  ) {
    return _SDL_isalpha5(
      x,
    );
  }

  late final _SDL_isalpha5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha5 = _SDL_isalpha5Ptr.asFunction<int Function(int)>();

  int SDL_isalnum5(
    int x,
  ) {
    return _SDL_isalnum5(
      x,
    );
  }

  late final _SDL_isalnum5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum5 = _SDL_isalnum5Ptr.asFunction<int Function(int)>();

  int SDL_isblank5(
    int x,
  ) {
    return _SDL_isblank5(
      x,
    );
  }

  late final _SDL_isblank5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank5 = _SDL_isblank5Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl5(
    int x,
  ) {
    return _SDL_iscntrl5(
      x,
    );
  }

  late final _SDL_iscntrl5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl5 = _SDL_iscntrl5Ptr.asFunction<int Function(int)>();

  int SDL_isdigit5(
    int x,
  ) {
    return _SDL_isdigit5(
      x,
    );
  }

  late final _SDL_isdigit5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit5 = _SDL_isdigit5Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit5(
    int x,
  ) {
    return _SDL_isxdigit5(
      x,
    );
  }

  late final _SDL_isxdigit5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit5 = _SDL_isxdigit5Ptr.asFunction<int Function(int)>();

  int SDL_ispunct5(
    int x,
  ) {
    return _SDL_ispunct5(
      x,
    );
  }

  late final _SDL_ispunct5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct5 = _SDL_ispunct5Ptr.asFunction<int Function(int)>();

  int SDL_isspace5(
    int x,
  ) {
    return _SDL_isspace5(
      x,
    );
  }

  late final _SDL_isspace5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace5 = _SDL_isspace5Ptr.asFunction<int Function(int)>();

  int SDL_isupper5(
    int x,
  ) {
    return _SDL_isupper5(
      x,
    );
  }

  late final _SDL_isupper5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper5 = _SDL_isupper5Ptr.asFunction<int Function(int)>();

  int SDL_islower5(
    int x,
  ) {
    return _SDL_islower5(
      x,
    );
  }

  late final _SDL_islower5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower5 = _SDL_islower5Ptr.asFunction<int Function(int)>();

  int SDL_isprint5(
    int x,
  ) {
    return _SDL_isprint5(
      x,
    );
  }

  late final _SDL_isprint5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint5 = _SDL_isprint5Ptr.asFunction<int Function(int)>();

  int SDL_isgraph5(
    int x,
  ) {
    return _SDL_isgraph5(
      x,
    );
  }

  late final _SDL_isgraph5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph5 = _SDL_isgraph5Ptr.asFunction<int Function(int)>();

  int SDL_toupper5(
    int x,
  ) {
    return _SDL_toupper5(
      x,
    );
  }

  late final _SDL_toupper5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper5 = _SDL_toupper5Ptr.asFunction<int Function(int)>();

  int SDL_tolower5(
    int x,
  ) {
    return _SDL_tolower5(
      x,
    );
  }

  late final _SDL_tolower5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower5 = _SDL_tolower5Ptr.asFunction<int Function(int)>();

  int SDL_crc325(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc325(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc325Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc325 = _SDL_crc325Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset5(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset5(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset5 = _SDL_memset5Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy5(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy5(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy5 = _SDL_memcpy5Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove5(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove5(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove5 = _SDL_memmove5Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp5(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp5(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp5 = _SDL_memcmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen5(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen5(
      wstr,
    );
  }

  late final _SDL_wcslen5Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen5 =
      _SDL_wcslen5Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy5(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy5(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy5 = _SDL_wcslcpy5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat5(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat5(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat5 = _SDL_wcslcat5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup5(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup5(
      wstr,
    );
  }

  late final _SDL_wcsdup5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup5 = _SDL_wcsdup5Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr5(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr5(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr5 = _SDL_wcsstr5Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp5(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp5(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp5 = _SDL_wcscmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp5(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp5(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp5 = _SDL_wcsncmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp5(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp5(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp5 = _SDL_wcscasecmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp5(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp5(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp5 = _SDL_wcsncasecmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen5(
      str,
    );
  }

  late final _SDL_strlen5Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen5 =
      _SDL_strlen5Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy5(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy5(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy5 = _SDL_strlcpy5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy5(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy5(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy5 = _SDL_utf8strlcpy5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat5(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat5(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat5 = _SDL_strlcat5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup5(
      str,
    );
  }

  late final _SDL_strdup5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup5 = _SDL_strdup5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev5(
      str,
    );
  }

  late final _SDL_strrev5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev5 = _SDL_strrev5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr5(
      str,
    );
  }

  late final _SDL_strupr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr5 = _SDL_strupr5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr5(
      str,
    );
  }

  late final _SDL_strlwr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr5 = _SDL_strlwr5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr5(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr5(
      str,
      c,
    );
  }

  late final _SDL_strchr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr5 = _SDL_strchr5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr5(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr5(
      str,
      c,
    );
  }

  late final _SDL_strrchr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr5 = _SDL_strrchr5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr5(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr5(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr5 = _SDL_strstr5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr5(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr5(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr5 = _SDL_strtokr5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen5(
      str,
    );
  }

  late final _SDL_utf8strlen5Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen5 =
      _SDL_utf8strlen5Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa5(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa5(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa5 = _SDL_itoa5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa5(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa5(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa5 = _SDL_uitoa5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa5(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa5(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa5 = _SDL_ltoa5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa5(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa5(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa5 = _SDL_ultoa5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa5(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa5(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa5 = _SDL_lltoa5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa5(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa5(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa5 = _SDL_ulltoa5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi5(
      str,
    );
  }

  late final _SDL_atoi5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi5 =
      _SDL_atoi5Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof5(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof5(
      str,
    );
  }

  late final _SDL_atof5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof5 =
      _SDL_atof5Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol5(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol5(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol5 = _SDL_strtol5Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul5(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul5(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul5 = _SDL_strtoul5Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll5(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll5(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll5Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll5 = _SDL_strtoll5Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull5(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull5(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull5Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull5 = _SDL_strtoull5Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod5(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod5(
      str,
      endp,
    );
  }

  late final _SDL_strtod5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod5 = _SDL_strtod5Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp5(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp5(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp5 = _SDL_strcmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp5(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp5(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp5 = _SDL_strncmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp5(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp5(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp5 = _SDL_strcasecmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp5(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp5(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp5 = _SDL_strncasecmp5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf5(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf5(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf5 = _SDL_sscanf5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf5(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf5(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf5 = _SDL_vsscanf5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf5(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf5(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf5 = _SDL_snprintf5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf5(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf5(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf5 = _SDL_vsnprintf5Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf5(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf5(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf5 = _SDL_asprintf5Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf5(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf5(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf5 = _SDL_vasprintf5Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos5(
    double x,
  ) {
    return _SDL_acos5(
      x,
    );
  }

  late final _SDL_acos5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos5 = _SDL_acos5Ptr.asFunction<double Function(double)>();

  double SDL_acosf5(
    double x,
  ) {
    return _SDL_acosf5(
      x,
    );
  }

  late final _SDL_acosf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf5 = _SDL_acosf5Ptr.asFunction<double Function(double)>();

  double SDL_asin5(
    double x,
  ) {
    return _SDL_asin5(
      x,
    );
  }

  late final _SDL_asin5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin5 = _SDL_asin5Ptr.asFunction<double Function(double)>();

  double SDL_asinf5(
    double x,
  ) {
    return _SDL_asinf5(
      x,
    );
  }

  late final _SDL_asinf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf5 = _SDL_asinf5Ptr.asFunction<double Function(double)>();

  double SDL_atan6(
    double x,
  ) {
    return _SDL_atan6(
      x,
    );
  }

  late final _SDL_atan6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan6 = _SDL_atan6Ptr.asFunction<double Function(double)>();

  double SDL_atanf5(
    double x,
  ) {
    return _SDL_atanf5(
      x,
    );
  }

  late final _SDL_atanf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf5 = _SDL_atanf5Ptr.asFunction<double Function(double)>();

  double SDL_atan25(
    double y,
    double x,
  ) {
    return _SDL_atan25(
      y,
      x,
    );
  }

  late final _SDL_atan25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan25 =
      _SDL_atan25Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f5(
    double y,
    double x,
  ) {
    return _SDL_atan2f5(
      y,
      x,
    );
  }

  late final _SDL_atan2f5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f5 =
      _SDL_atan2f5Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil5(
    double x,
  ) {
    return _SDL_ceil5(
      x,
    );
  }

  late final _SDL_ceil5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil5 = _SDL_ceil5Ptr.asFunction<double Function(double)>();

  double SDL_ceilf5(
    double x,
  ) {
    return _SDL_ceilf5(
      x,
    );
  }

  late final _SDL_ceilf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf5 = _SDL_ceilf5Ptr.asFunction<double Function(double)>();

  double SDL_copysign5(
    double x,
    double y,
  ) {
    return _SDL_copysign5(
      x,
      y,
    );
  }

  late final _SDL_copysign5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign5 =
      _SDL_copysign5Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf5(
    double x,
    double y,
  ) {
    return _SDL_copysignf5(
      x,
      y,
    );
  }

  late final _SDL_copysignf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf5 =
      _SDL_copysignf5Ptr.asFunction<double Function(double, double)>();

  double SDL_cos5(
    double x,
  ) {
    return _SDL_cos5(
      x,
    );
  }

  late final _SDL_cos5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos5 = _SDL_cos5Ptr.asFunction<double Function(double)>();

  double SDL_cosf5(
    double x,
  ) {
    return _SDL_cosf5(
      x,
    );
  }

  late final _SDL_cosf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf5 = _SDL_cosf5Ptr.asFunction<double Function(double)>();

  double SDL_exp5(
    double x,
  ) {
    return _SDL_exp5(
      x,
    );
  }

  late final _SDL_exp5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp5 = _SDL_exp5Ptr.asFunction<double Function(double)>();

  double SDL_expf5(
    double x,
  ) {
    return _SDL_expf5(
      x,
    );
  }

  late final _SDL_expf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf5 = _SDL_expf5Ptr.asFunction<double Function(double)>();

  double SDL_fabs5(
    double x,
  ) {
    return _SDL_fabs5(
      x,
    );
  }

  late final _SDL_fabs5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs5 = _SDL_fabs5Ptr.asFunction<double Function(double)>();

  double SDL_fabsf5(
    double x,
  ) {
    return _SDL_fabsf5(
      x,
    );
  }

  late final _SDL_fabsf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf5 = _SDL_fabsf5Ptr.asFunction<double Function(double)>();

  double SDL_floor5(
    double x,
  ) {
    return _SDL_floor5(
      x,
    );
  }

  late final _SDL_floor5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor5 = _SDL_floor5Ptr.asFunction<double Function(double)>();

  double SDL_floorf5(
    double x,
  ) {
    return _SDL_floorf5(
      x,
    );
  }

  late final _SDL_floorf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf5 =
      _SDL_floorf5Ptr.asFunction<double Function(double)>();

  double SDL_trunc5(
    double x,
  ) {
    return _SDL_trunc5(
      x,
    );
  }

  late final _SDL_trunc5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc5 = _SDL_trunc5Ptr.asFunction<double Function(double)>();

  double SDL_truncf5(
    double x,
  ) {
    return _SDL_truncf5(
      x,
    );
  }

  late final _SDL_truncf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf5 =
      _SDL_truncf5Ptr.asFunction<double Function(double)>();

  double SDL_fmod5(
    double x,
    double y,
  ) {
    return _SDL_fmod5(
      x,
      y,
    );
  }

  late final _SDL_fmod5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod5 =
      _SDL_fmod5Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf5(
    double x,
    double y,
  ) {
    return _SDL_fmodf5(
      x,
      y,
    );
  }

  late final _SDL_fmodf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf5 =
      _SDL_fmodf5Ptr.asFunction<double Function(double, double)>();

  double SDL_log5(
    double x,
  ) {
    return _SDL_log5(
      x,
    );
  }

  late final _SDL_log5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log5 = _SDL_log5Ptr.asFunction<double Function(double)>();

  double SDL_logf5(
    double x,
  ) {
    return _SDL_logf5(
      x,
    );
  }

  late final _SDL_logf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf5 = _SDL_logf5Ptr.asFunction<double Function(double)>();

  double SDL_log105(
    double x,
  ) {
    return _SDL_log105(
      x,
    );
  }

  late final _SDL_log105Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log105 = _SDL_log105Ptr.asFunction<double Function(double)>();

  double SDL_log10f5(
    double x,
  ) {
    return _SDL_log10f5(
      x,
    );
  }

  late final _SDL_log10f5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f5 =
      _SDL_log10f5Ptr.asFunction<double Function(double)>();

  double SDL_pow5(
    double x,
    double y,
  ) {
    return _SDL_pow5(
      x,
      y,
    );
  }

  late final _SDL_pow5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow5 =
      _SDL_pow5Ptr.asFunction<double Function(double, double)>();

  double SDL_powf5(
    double x,
    double y,
  ) {
    return _SDL_powf5(
      x,
      y,
    );
  }

  late final _SDL_powf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf5 =
      _SDL_powf5Ptr.asFunction<double Function(double, double)>();

  double SDL_round5(
    double x,
  ) {
    return _SDL_round5(
      x,
    );
  }

  late final _SDL_round5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round5 = _SDL_round5Ptr.asFunction<double Function(double)>();

  double SDL_roundf5(
    double x,
  ) {
    return _SDL_roundf5(
      x,
    );
  }

  late final _SDL_roundf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf5 =
      _SDL_roundf5Ptr.asFunction<double Function(double)>();

  int SDL_lround5(
    double x,
  ) {
    return _SDL_lround5(
      x,
    );
  }

  late final _SDL_lround5Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround5 = _SDL_lround5Ptr.asFunction<int Function(double)>();

  int SDL_lroundf5(
    double x,
  ) {
    return _SDL_lroundf5(
      x,
    );
  }

  late final _SDL_lroundf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf5 =
      _SDL_lroundf5Ptr.asFunction<int Function(double)>();

  double SDL_scalbn5(
    double x,
    int n,
  ) {
    return _SDL_scalbn5(
      x,
      n,
    );
  }

  late final _SDL_scalbn5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn5 =
      _SDL_scalbn5Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf5(
    double x,
    int n,
  ) {
    return _SDL_scalbnf5(
      x,
      n,
    );
  }

  late final _SDL_scalbnf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf5 =
      _SDL_scalbnf5Ptr.asFunction<double Function(double, int)>();

  double SDL_sin5(
    double x,
  ) {
    return _SDL_sin5(
      x,
    );
  }

  late final _SDL_sin5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin5 = _SDL_sin5Ptr.asFunction<double Function(double)>();

  double SDL_sinf5(
    double x,
  ) {
    return _SDL_sinf5(
      x,
    );
  }

  late final _SDL_sinf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf5 = _SDL_sinf5Ptr.asFunction<double Function(double)>();

  double SDL_sqrt5(
    double x,
  ) {
    return _SDL_sqrt5(
      x,
    );
  }

  late final _SDL_sqrt5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt5 = _SDL_sqrt5Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf5(
    double x,
  ) {
    return _SDL_sqrtf5(
      x,
    );
  }

  late final _SDL_sqrtf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf5 = _SDL_sqrtf5Ptr.asFunction<double Function(double)>();

  double SDL_tan5(
    double x,
  ) {
    return _SDL_tan5(
      x,
    );
  }

  late final _SDL_tan5Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan5 = _SDL_tan5Ptr.asFunction<double Function(double)>();

  double SDL_tanf5(
    double x,
  ) {
    return _SDL_tanf5(
      x,
    );
  }

  late final _SDL_tanf5Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf5 = _SDL_tanf5Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open5(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open5(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open5Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open5 = _SDL_iconv_open5Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close5(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close5(
      cd,
    );
  }

  late final _SDL_iconv_close5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close5 =
      _SDL_iconv_close5Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv5(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv5(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv5 = _SDL_iconv5Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string5(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string5(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string5 = _SDL_iconv_string5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the human readable name of a pixel format.
  ///
  /// \param format the pixel format to query
  /// \returns the human readable name of the specified pixel format or
  /// `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPixelFormatName1(
    int format,
  ) {
    return _SDL_GetPixelFormatName1(
      format,
    );
  }

  late final _SDL_GetPixelFormatName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Uint32)>>(
          'SDL_GetPixelFormatName');
  late final _SDL_GetPixelFormatName1 = _SDL_GetPixelFormatName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
  ///
  /// \param format one of the SDL_PixelFormatEnum values
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask a pointer filled in with the red mask for the format
  /// \param Gmask a pointer filled in with the green mask for the format
  /// \param Bmask a pointer filled in with the blue mask for the format
  /// \param Amask a pointer filled in with the alpha mask for the format
  /// \returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't
  /// possible; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MasksToPixelFormatEnum
  int SDL_PixelFormatEnumToMasks1(
    int format,
    ffi.Pointer<ffi.Int> bpp,
    ffi.Pointer<Uint32> Rmask,
    ffi.Pointer<Uint32> Gmask,
    ffi.Pointer<Uint32> Bmask,
    ffi.Pointer<Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks1(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasks1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>)>>('SDL_PixelFormatEnumToMasks');
  late final _SDL_PixelFormatEnumToMasks1 =
      _SDL_PixelFormatEnumToMasks1Ptr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>, ffi.Pointer<Uint32>, ffi.Pointer<Uint32>)>();

  /// Convert a bpp value and RGBA masks to an enumerated pixel format.
  ///
  /// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
  /// possible.
  ///
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask the red mask for the format
  /// \param Gmask the green mask for the format
  /// \param Bmask the blue mask for the format
  /// \param Amask the alpha mask for the format
  /// \returns one of the SDL_PixelFormatEnum values
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PixelFormatEnumToMasks
  int SDL_MasksToPixelFormatEnum1(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum1(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnum1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Int, Uint32, Uint32, Uint32,
              Uint32)>>('SDL_MasksToPixelFormatEnum');
  late final _SDL_MasksToPixelFormatEnum1 = _SDL_MasksToPixelFormatEnum1Ptr
      .asFunction<int Function(int, int, int, int, int)>();

  /// Create an SDL_PixelFormat structure corresponding to a pixel format.
  ///
  /// Returned structure may come from a shared global cache (i.e. not newly
  /// allocated), and hence should not be modified, especially the palette. Weird
  /// errors such as `Blit combination not supported` may occur.
  ///
  /// \param pixel_format one of the SDL_PixelFormatEnum values
  /// \returns the new SDL_PixelFormat structure or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeFormat
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat1(
    int pixel_format,
  ) {
    return _SDL_AllocFormat1(
      pixel_format,
    );
  }

  late final _SDL_AllocFormat1Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_PixelFormat> Function(Uint32)>>(
      'SDL_AllocFormat');
  late final _SDL_AllocFormat1 = _SDL_AllocFormat1Ptr.asFunction<
      ffi.Pointer<SDL_PixelFormat> Function(int)>();

  /// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().
  ///
  /// \param format the SDL_PixelFormat structure to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  void SDL_FreeFormat1(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat1(
      format,
    );
  }

  late final _SDL_FreeFormat1Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_PixelFormat>)>>(
      'SDL_FreeFormat');
  late final _SDL_FreeFormat1 = _SDL_FreeFormat1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_PixelFormat>)>();

  /// Create a palette structure with the specified number of color entries.
  ///
  /// The palette entries are initialized to white.
  ///
  /// \param ncolors represents the number of color entries in the color palette
  /// \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
  /// there wasn't enough memory); call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreePalette
  ffi.Pointer<SDL_Palette> SDL_AllocPalette1(
    int ncolors,
  ) {
    return _SDL_AllocPalette1(
      ncolors,
    );
  }

  late final _SDL_AllocPalette1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Palette> Function(ffi.Int)>>(
          'SDL_AllocPalette');
  late final _SDL_AllocPalette1 = _SDL_AllocPalette1Ptr.asFunction<
      ffi.Pointer<SDL_Palette> Function(int)>();

  /// Set the palette for a pixel format structure.
  ///
  /// \param format the SDL_PixelFormat structure that will use the palette
  /// \param palette the SDL_Palette structure that will be used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_FreePalette
  int SDL_SetPixelFormatPalette1(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette1(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalette1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetPixelFormatPalette');
  late final _SDL_SetPixelFormatPalette1 =
      _SDL_SetPixelFormatPalette1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<SDL_Palette>)>();

  /// Set a range of colors in a palette.
  ///
  /// \param palette the SDL_Palette structure to modify
  /// \param colors an array of SDL_Color structures to copy into the palette
  /// \param firstcolor the index of the first palette entry to modify
  /// \param ncolors the number of entries to modify
  /// \returns 0 on success or a negative error code if not all of the colors
  /// could be set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_CreateRGBSurface
  int SDL_SetPaletteColors1(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors1(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColors1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>,
              ffi.Int, ffi.Int)>>('SDL_SetPaletteColors');
  late final _SDL_SetPaletteColors1 = _SDL_SetPaletteColors1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>, int, int)>();

  /// Free a palette created with SDL_AllocPalette().
  ///
  /// \param palette the SDL_Palette structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  void SDL_FreePalette1(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette1(
      palette,
    );
  }

  late final _SDL_FreePalette1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Palette>)>>(
          'SDL_FreePalette');
  late final _SDL_FreePalette1 = _SDL_FreePalette1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Palette>)>();

  /// Map an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// This function maps the RGB color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGB color value for
  /// the given pixel format.
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the specified pixel format has an alpha component it will be returned as
  /// all 1 bits (fully opaque).
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the pixel format
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGBA
  int SDL_MapRGB1(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB1(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGB1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8,
              Uint8)>>('SDL_MapRGB');
  late final _SDL_MapRGB1 = _SDL_MapRGB1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int)>();

  /// Map an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// This function maps the RGBA color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGBA color value for
  /// the given pixel format.
  ///
  /// If the specified pixel format has no alpha component the alpha value will
  /// be ignored (as it will be in formats with a palette).
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \param a the alpha component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  int SDL_MapRGBA1(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA1(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBA1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_MapRGBA');
  late final _SDL_MapRGBA1 = _SDL_MapRGBA1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int, int)>();

  /// Get RGB values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGB1(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetRGB1(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGB1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGB');
  late final _SDL_GetRGB1 = _SDL_GetRGB1Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Get RGBA values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// If the surface has no alpha component, the alpha will be returned as 0xff
  /// (100% opaque).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  /// \param a a pointer filled in with the alpha component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGBA1(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRGBA1(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBA1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGBA');
  late final _SDL_GetRGBA1 = _SDL_GetRGBA1Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Calculate a 256 entry gamma ramp for a gamma value.
  ///
  /// \param gamma a gamma value where 0.0 is black and 1.0 is identity
  /// \param ramp an array of 256 values filled in with the gamma ramp
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  void SDL_CalculateGammaRamp1(
    double gamma,
    ffi.Pointer<Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp1(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRamp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Float, ffi.Pointer<Uint16>)>>('SDL_CalculateGammaRamp');
  late final _SDL_CalculateGammaRamp1 = _SDL_CalculateGammaRamp1Ptr.asFunction<
      void Function(double, ffi.Pointer<Uint16>)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError2(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError2(
      fmt,
    );
  }

  late final _SDL_SetError2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError2 =
      _SDL_SetError2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError2() {
    return _SDL_GetError2();
  }

  late final _SDL_GetError2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError2 =
      _SDL_GetError2Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg2(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg2(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg2 = _SDL_GetErrorMsg2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError2() {
    return _SDL_ClearError2();
  }

  late final _SDL_ClearError2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError2 =
      _SDL_ClearError2Ptr.asFunction<void Function()>();

  int SDL_Error2(
    int code,
  ) {
    return _SDL_Error2(
      code,
    );
  }

  late final _SDL_Error2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error2 = _SDL_Error2Ptr.asFunction<int Function(int)>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile1(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile1(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile1 = _SDL_RWFromFile1Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP1(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP1(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP1 = _SDL_RWFromFP1Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem1(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem1(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem1 = _SDL_RWFromMem1Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem1(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem1(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem1 = _SDL_RWFromConstMem1Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW1() {
    return _SDL_AllocRW1();
  }

  late final _SDL_AllocRW1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW1 =
      _SDL_AllocRW1Ptr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW1(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW1(
      area,
    );
  }

  late final _SDL_FreeRW1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW1 =
      _SDL_FreeRW1Ptr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize1(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize1(
      context,
    );
  }

  late final _SDL_RWsize1Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize1 =
      _SDL_RWsize1Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek1(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek1(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek1Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek1 = _SDL_RWseek1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell1(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell1(
      context,
    );
  }

  late final _SDL_RWtell1Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell1 =
      _SDL_RWtell1Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread1(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread1(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread1 = _SDL_RWread1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite1(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite1(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite1 = _SDL_RWwrite1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose1(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose1(
      context,
    );
  }

  late final _SDL_RWclose1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose1 =
      _SDL_RWclose1Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW1(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW1(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW1 = _SDL_LoadFile_RW1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile1(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile1(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile1 = _SDL_LoadFile1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU81(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU81(
      src,
    );
  }

  late final _SDL_ReadU81Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU81 =
      _SDL_ReadU81Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE161(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE161(
      src,
    );
  }

  late final _SDL_ReadLE161Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE161 =
      _SDL_ReadLE161Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE161(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE161(
      src,
    );
  }

  late final _SDL_ReadBE161Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE161 =
      _SDL_ReadBE161Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE321(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE321(
      src,
    );
  }

  late final _SDL_ReadLE321Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE321 =
      _SDL_ReadLE321Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE321(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE321(
      src,
    );
  }

  late final _SDL_ReadBE321Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE321 =
      _SDL_ReadBE321Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE641(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE641(
      src,
    );
  }

  late final _SDL_ReadLE641Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE641 =
      _SDL_ReadLE641Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE641(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE641(
      src,
    );
  }

  late final _SDL_ReadBE641Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE641 =
      _SDL_ReadBE641Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU81(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU81(
      dst,
      value,
    );
  }

  late final _SDL_WriteU81Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU81 =
      _SDL_WriteU81Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE161(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE161(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE161Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE161 = _SDL_WriteLE161Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE161(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE161(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE161Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE161 = _SDL_WriteBE161Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE321(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE321(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE321Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE321 = _SDL_WriteLE321Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE321(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE321(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE321Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE321 = _SDL_WriteBE321Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE641(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE641(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE641Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE641 = _SDL_WriteLE641Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE641(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE641(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE641Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE641 = _SDL_WriteBE641Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Determine whether two rectangles intersect.
  ///
  /// If either pointer is NULL the function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_IntersectRect
  int SDL_HasIntersection1(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection1(
      A,
      B,
    );
  }

  late final _SDL_HasIntersection1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_HasIntersection');
  late final _SDL_HasIntersection1 = _SDL_HasIntersection1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of two rectangles.
  ///
  /// If `result` is NULL then this function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the intersection of
  /// rectangles `A` and `B`
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasIntersection
  int SDL_IntersectRect1(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect1(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_IntersectRect');
  late final _SDL_IntersectRect1 = _SDL_IntersectRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the union of two rectangles.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the union of rectangles
  /// `A` and `B`
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_UnionRect1(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect1(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UnionRect');
  late final _SDL_UnionRect1 = _SDL_UnionRect1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate a minimal rectangle enclosing a set of points.
  ///
  /// If `clip` is not NULL then only points inside of the clipping rectangle are
  /// considered.
  ///
  /// \param points an array of SDL_Point structures representing points to be
  /// enclosed
  /// \param count the number of structures in the `points` array
  /// \param clip an SDL_Rect used for clipping or NULL to enclose all points
  /// \param result an SDL_Rect structure filled in with the minimal enclosing
  /// rectangle
  /// \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
  /// points were outside of the clipping rectangle.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_EnclosePoints1(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints1(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePoints1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Point>,
              ffi.Int,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_EnclosePoints');
  late final _SDL_EnclosePoints1 = _SDL_EnclosePoints1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Point>, int, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of a rectangle and line segment.
  ///
  /// This function is used to clip a line segment to a rectangle. A line segment
  /// contained entirely within the rectangle or that does not intersect will
  /// remain unchanged. A line segment that crosses the rectangle at either or
  /// both ends will be clipped to the boundary of the rectangle and the new
  /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
  ///
  /// \param rect an SDL_Rect structure representing the rectangle to intersect
  /// \param X1 a pointer to the starting X-coordinate of the line
  /// \param Y1 a pointer to the starting Y-coordinate of the line
  /// \param X2 a pointer to the ending X-coordinate of the line
  /// \param Y2 a pointer to the ending Y-coordinate of the line
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_IntersectRectAndLine1(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int> X1,
    ffi.Pointer<ffi.Int> Y1,
    ffi.Pointer<ffi.Int> X2,
    ffi.Pointer<ffi.Int> Y2,
  ) {
    return _SDL_IntersectRectAndLine1(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLine1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_IntersectRectAndLine');
  late final _SDL_IntersectRectAndLine1 =
      _SDL_IntersectRectAndLine1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Compose a custom blend mode for renderers.
  ///
  /// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
  /// the SDL_BlendMode returned by this function if the renderer supports it.
  ///
  /// A blend mode controls how the pixels from a drawing operation (source) get
  /// combined with the pixels from the render target (destination). First, the
  /// components of the source and destination pixels get multiplied with their
  /// blend factors. Then, the blend operation takes the two products and
  /// calculates the result that will get stored in the render target.
  ///
  /// Expressed in pseudocode, it would look like this:
  ///
  /// ```c
  /// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
  /// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
  /// ```
  ///
  /// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
  /// dst)` can return one of the following:
  ///
  /// - `src + dst`
  /// - `src - dst`
  /// - `dst - src`
  /// - `min(src, dst)`
  /// - `max(src, dst)`
  ///
  /// The red, green, and blue components are always multiplied with the first,
  /// second, and third components of the SDL_BlendFactor, respectively. The
  /// fourth component is not used.
  ///
  /// The alpha component is always multiplied with the fourth component of the
  /// SDL_BlendFactor. The other components are not used in the alpha
  /// calculation.
  ///
  /// Support for these blend modes varies for each renderer. To check if a
  /// specific SDL_BlendMode is supported, create a renderer and pass it to
  /// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
  /// return with an error if the blend mode is not supported.
  ///
  /// This list describes the support of custom blend modes for each renderer in
  /// SDL 2.0.6. All renderers support the four blend modes listed in the
  /// SDL_BlendMode enumeration.
  ///
  /// - **direct3d**: Supports `SDL_BLENDOPERATION_ADD` with all factors.
  /// - **direct3d11**: Supports all operations with all factors. However, some
  /// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
  /// `SDL_BLENDOPERATION_MAXIMUM`.
  /// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL
  /// 2.0.6.
  /// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. Color and alpha factors need to be the same. OpenGL ES 1
  /// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`
  /// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha
  /// operations being different from each other. May support color and alpha
  /// factors being different from each other.
  /// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
  /// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
  /// operations with all factors.
  /// - **psp**: No custom blend mode support.
  /// - **software**: No custom blend mode support.
  ///
  /// Some renderers do not provide an alpha component for the default render
  /// target. The `SDL_BLENDFACTOR_DST_ALPHA` and
  /// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
  /// case.
  ///
  /// \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the source pixels
  /// \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the destination pixels
  /// \param colorOperation the SDL_BlendOperation used to combine the red,
  /// green, and blue components of the source and
  /// destination pixels
  /// \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the source pixels
  /// \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the destination pixels
  /// \param alphaOperation the SDL_BlendOperation used to combine the alpha
  /// component of the source and destination pixels
  /// \returns an SDL_BlendMode that represents the chosen factors and
  /// operations.
  ///
  /// \since This function is available since SDL 2.0.6.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_GetTextureBlendMode
  int SDL_ComposeCustomBlendMode1(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode1(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_ComposeCustomBlendMode');
  late final _SDL_ComposeCustomBlendMode1 = _SDL_ComposeCustomBlendMode1Ptr
      .asFunction<int Function(int, int, int, int, int, int)>();

  /// Allocate a new RGB surface.
  ///
  /// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If `depth` is greater than 8 bits, the pixel format is set using the
  /// [RGBA]mask parameters.
  ///
  /// The [RGBA]mask parameters are the bitmasks used to extract that color from
  /// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
  /// stored in the most significant byte. Using zeros for the RGB masks sets a
  /// default value, based on the depth. For example:
  ///
  /// ```c++
  /// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
  /// ```
  ///
  /// However, using zero for the Amask results in an Amask of 0.
  ///
  /// By default surfaces with an alpha mask are set up for blending as with:
  ///
  /// ```c++
  /// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
  /// ```
  ///
  /// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
  /// different `blendMode`.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface1(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface1(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurface1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32, Uint32, Uint32, Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface1 = _SDL_CreateRGBSurface1Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with a specific pixel format.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except instead
  /// of providing pixel color masks, you provide it with a predefined format
  /// from SDL_PixelFormatEnum.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat1(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat1(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormat1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat1 =
      _SDL_CreateRGBSurfaceWithFormat1Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  /// Allocate a new RGB surface with existing pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except it does
  /// not allocate memory for the pixel data, instead the caller provides an
  /// existing buffer of data for the surface to use.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom1(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom1(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFrom1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom1 =
      _SDL_CreateRGBSurfaceFrom1Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with with a specific pixel format and existing
  /// pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
  /// instead of providing pixel color masks, you provide it with a predefined
  /// format from SDL_PixelFormatEnum.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom1(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom1(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFrom1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom1 =
      _SDL_CreateRGBSurfaceWithFormatFrom1Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// Free an RGB surface.
  ///
  /// It is safe to pass NULL to this function.
  ///
  /// \param surface the SDL_Surface to free.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_LoadBMP
  /// \sa SDL_LoadBMP_RW
  void SDL_FreeSurface1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface1(
      surface,
    );
  }

  late final _SDL_FreeSurface1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface1 = _SDL_FreeSurface1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the palette used by a surface.
  ///
  /// A single palette can be shared with many surfaces.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param palette the SDL_Palette structure to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetSurfacePalette1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette1(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalette1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette1 = _SDL_SetSurfacePalette1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// Set up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
  /// and read from `surface->pixels`, using the pixel format stored in
  /// `surface->format`. Once you are done accessing the surface, you should use
  /// SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
  /// 0, then you can read and write to the surface at any time, and the pixel
  /// format of the surface will not change.
  ///
  /// \param surface the SDL_Surface structure to be locked
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MUSTLOCK
  /// \sa SDL_UnlockSurface
  int SDL_LockSurface1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface1(
      surface,
    );
  }

  late final _SDL_LockSurface1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface1 =
      _SDL_LockSurface1Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Release a surface after directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockSurface
  void SDL_UnlockSurface1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface1(
      surface,
    );
  }

  late final _SDL_UnlockSurface1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface1 = _SDL_UnlockSurface1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a BMP image from a seekable SDL data stream.
  ///
  /// The new surface should be freed with SDL_FreeSurface(). Not doing so will
  /// result in a memory leak.
  ///
  /// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
  /// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
  /// from a file, convert it to an SDL_Surface and then close the file.
  ///
  /// \param src the data stream for the surface
  /// \param freesrc non-zero to close the stream after being read
  /// \returns a pointer to a new SDL_Surface structure or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeSurface
  /// \sa SDL_RWFromFile
  /// \sa SDL_LoadBMP
  /// \sa SDL_SaveBMP_RW
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW1(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW1(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RW1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW1 = _SDL_LoadBMP_RW1Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream in BMP format.
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// \param surface the SDL_Surface structure containing the image to be saved
  /// \param dst a data stream to save to
  /// \param freedst non-zero to close the stream after being written
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadBMP_RW
  /// \sa SDL_SaveBMP
  int SDL_SaveBMP_RW1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW1(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RW1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW1 = _SDL_SaveBMP_RW1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// Set the RLE acceleration hint for a surface.
  ///
  /// If RLE is enabled, color key and alpha blending blits are much faster, but
  /// the surface must be locked before directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to optimize
  /// \param flag 0 to disable, non-zero to enable RLE acceleration
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_LockSurface
  /// \sa SDL_UnlockSurface
  int SDL_SetSurfaceRLE1(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE1(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLE1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int)>>('SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE1 = _SDL_SetSurfaceRLE1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Returns whether the surface is RLE enabled
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SetSurfaceRLE
  int SDL_HasSurfaceRLE1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE1(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLE1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE1 = _SDL_HasSurfaceRLE1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the color key (transparent pixel) in a surface.
  ///
  /// The color key defines a pixel value that will be treated as transparent in
  /// a blit. For example, one can use this to specify that cyan pixels should be
  /// considered transparent, and therefore not rendered.
  ///
  /// It is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// RLE acceleration can substantially speed up blitting of images with large
  /// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
  /// \param key the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetColorKey
  int SDL_SetColorKey1(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey1(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKey1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey1 = _SDL_SetColorKey1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Returns whether the surface has a color key
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_SetColorKey
  /// \sa SDL_GetColorKey
  int SDL_HasColorKey1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey1(
      surface,
    );
  }

  late final _SDL_HasColorKey1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasColorKey');
  late final _SDL_HasColorKey1 =
      _SDL_HasColorKey1Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the color key (transparent pixel) for a surface.
  ///
  /// The color key is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// If the surface doesn't have color key enabled this function returns -1.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param key a pointer filled in with the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetColorKey
  int SDL_GetColorKey1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey1(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKey1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey1 = _SDL_GetColorKey1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// Set an additional color value multiplied into blit operations.
  ///
  /// When this surface is blitted, during the blit operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param r the red color value multiplied into blit operations
  /// \param g the green color value multiplied into blit operations
  /// \param b the blue color value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_SetSurfaceColorMod1(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod1(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod1 = _SDL_SetSurfaceColorMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// Get the additional color value multiplied into blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_GetSurfaceColorMod1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod1(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod1 = _SDL_GetSurfaceColorMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value used in blit operations.
  ///
  /// When this surface is blitted, during the blit operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param alpha the alpha value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_SetSurfaceAlphaMod1(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod1(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, Uint8)>>('SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod1 = _SDL_SetSurfaceAlphaMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the additional alpha value used in blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_GetSurfaceAlphaMod1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod1(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod1 = _SDL_GetSurfaceAlphaMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for blit operations.
  ///
  /// To copy a surface to another surface (or texture) without blending with the
  /// existing data, the blendmode of the SOURCE surface should be set to
  /// `SDL_BLENDMODE_NONE`.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param blendMode the SDL_BlendMode to use for blit blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceBlendMode
  int SDL_SetSurfaceBlendMode1(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode1(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode1 = _SDL_SetSurfaceBlendMode1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the blend mode used for blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetSurfaceBlendMode
  int SDL_GetSurfaceBlendMode1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode1(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode1 =
      _SDL_GetSurfaceBlendMode1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.Int32>)>();

  /// Set the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// Note that blits are automatically clipped to the edges of the source and
  /// destination surfaces.
  ///
  /// \param surface the SDL_Surface structure to be clipped
  /// \param rect the SDL_Rect structure representing the clipping rectangle, or
  /// NULL to disable clipping
  /// \returns SDL_TRUE if the rectangle intersects the surface, otherwise
  /// SDL_FALSE and blits will be completely clipped.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetClipRect
  int SDL_SetClipRect1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect1(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect1 = _SDL_SetClipRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// \param surface the SDL_Surface structure representing the surface to be
  /// clipped
  /// \param rect an SDL_Rect structure filled in with the clipping rectangle for
  /// the surface
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetClipRect
  void SDL_GetClipRect1(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect1(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect1 = _SDL_GetClipRect1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface1(
      surface,
    );
  }

  late final _SDL_DuplicateSurface1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface1 = _SDL_DuplicateSurface1Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Copy an existing surface to a new surface of the specified format.
  ///
  /// This function is used to optimize images for faster *repeat* blitting. This
  /// is accomplished by converting the original and storing the result as a new
  /// surface. The new, optimized surface can then be used as the source for
  /// future blits, making them faster.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param fmt the SDL_PixelFormat structure that the new surface is optimized
  /// for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurfaceFormat
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface1(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurface1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface1 = _SDL_ConvertSurface1Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  /// Copy an existing surface to a new surface of the specified format enum.
  ///
  /// This function operates just like SDL_ConvertSurface(), but accepts an
  /// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
  /// it might be easier to call but it doesn't have access to palette
  /// information for the destination surface, in case that would be important.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param pixel_format the SDL_PixelFormatEnum that the new surface is
  /// optimized for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurface
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat1(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat1(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormat1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat1 =
      _SDL_ConvertSurfaceFormat1Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// Copy a block of pixels of one format to another format.
  ///
  /// \param width the width of the block to copy, in pixels
  /// \param height the height of the block to copy, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with new pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_ConvertPixels1(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels1(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixels1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels1 = _SDL_ConvertPixels1Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Premultiply the alpha on a block of pixels.
  ///
  /// This is safe to use with src == dst, but not for other overlapping areas.
  ///
  /// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
  ///
  /// \param width the width of the block to convert, in pixels
  /// \param height the height of the block to convert, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with premultiplied pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_PremultiplyAlpha1(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_PremultiplyAlpha1(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_PremultiplyAlpha1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_PremultiplyAlpha');
  late final _SDL_PremultiplyAlpha1 = _SDL_PremultiplyAlpha1Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Perform a fast fill of a rectangle with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL to fill the entire surface
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRects
  int SDL_FillRect1(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect1(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect1 = _SDL_FillRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  /// Perform a fast fill of a set of rectangles with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rects an array of SDL_Rects representing the rectangles to fill.
  /// \param count the number of rectangles in the array
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRect
  int SDL_FillRects1(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects1(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRects1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects1 = _SDL_FillRects1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// Perform a fast blit from the source surface to the destination surface.
  ///
  /// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
  /// macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_UpperBlit1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit1(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlit1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit1 = _SDL_UpperBlit1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface blitting only.
  ///
  /// This is a semi-private blit function and it performs low-level surface
  /// blitting, assuming the input rectangles have already been clipped.
  ///
  /// Unless you know what you're doing, you should be using SDL_BlitSurface()
  /// instead.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied, or NULL to copy the entire surface
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_LowerBlit1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit1(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlit1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit1 = _SDL_LowerBlit1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a fast, low quality, stretch blit between two surfaces of the same
  /// format.
  ///
  /// Please use SDL_BlitScaled() instead.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SoftStretch1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch1(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretch1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch1 = _SDL_SoftStretch1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform bilinear scaling between two surfaces of the same format, 32BPP.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_SoftStretchLinear1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretchLinear1(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchLinear1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretchLinear');
  late final _SDL_SoftStretchLinear1 = _SDL_SoftStretchLinear1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a scaled surface copy to a destination surface.
  ///
  /// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
  /// merely a macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_UpperBlitScaled1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled1(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaled1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled1 = _SDL_UpperBlitScaled1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface scaled blitting only.
  ///
  /// This is a semi-private function and it performs low-level surface blitting,
  /// assuming the input rectangles have already been clipped.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_LowerBlitScaled1(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled1(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaled1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled1 = _SDL_LowerBlitScaled1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Set the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  void SDL_SetYUVConversionMode1(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode1(
      mode,
    );
  }

  late final _SDL_SetYUVConversionMode1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode1 =
      _SDL_SetYUVConversionMode1Ptr.asFunction<void Function(int)>();

  /// Get the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionMode1() {
    return _SDL_GetYUVConversionMode1();
  }

  late final _SDL_GetYUVConversionMode1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode1 =
      _SDL_GetYUVConversionMode1Ptr.asFunction<int Function()>();

  /// Get the YUV conversion mode, returning the correct mode for the resolution
  /// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionModeForResolution1(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution1(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolution1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int, ffi.Int)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution1 =
      _SDL_GetYUVConversionModeForResolution1Ptr.asFunction<
          int Function(int, int)>();

  /// Get the number of video drivers compiled into SDL.
  ///
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVideoDriver
  int SDL_GetNumVideoDrivers1() {
    return _SDL_GetNumVideoDrivers1();
  }

  late final _SDL_GetNumVideoDrivers1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers1 =
      _SDL_GetNumVideoDrivers1Ptr.asFunction<int Function()>();

  /// Get the name of a built in video driver.
  ///
  /// The video drivers are presented in the order in which they are normally
  /// checked during initialization.
  ///
  /// \param index the index of a video driver
  /// \returns the name of the video driver with the given **index**.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  ffi.Pointer<ffi.Char> SDL_GetVideoDriver1(
    int index,
  ) {
    return _SDL_GetVideoDriver1(
      index,
    );
  }

  late final _SDL_GetVideoDriver1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver1 =
      _SDL_GetVideoDriver1Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// This function initializes the video subsystem, setting up a connection to
  /// the window manager, etc, and determines the available display modes and
  /// pixel formats, but does not initialize a window or graphics mode.
  ///
  /// If you use this function and you haven't used the SDL_INIT_VIDEO flag with
  /// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
  /// before calling SDL_Quit().
  ///
  /// It is safe to call this function multiple times. SDL_VideoInit() will call
  /// SDL_VideoQuit() itself if the video subsystem has already been initialized.
  ///
  /// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
  /// specific `driver_name`.
  ///
  /// \param driver_name the name of a video driver to initialize, or NULL for
  /// the default driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  /// \sa SDL_InitSubSystem
  /// \sa SDL_VideoQuit
  int SDL_VideoInit1(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_VideoInit1(
      driver_name,
    );
  }

  late final _SDL_VideoInit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit1 =
      _SDL_VideoInit1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Shut down the video subsystem, if initialized with SDL_VideoInit().
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_VideoInit
  void SDL_VideoQuit1() {
    return _SDL_VideoQuit1();
  }

  late final _SDL_VideoQuit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit1 = _SDL_VideoQuit1Ptr.asFunction<void Function()>();

  /// Get the name of the currently initialized video driver.
  ///
  /// \returns the name of the current video driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  ffi.Pointer<ffi.Char> SDL_GetCurrentVideoDriver1() {
    return _SDL_GetCurrentVideoDriver1();
  }

  late final _SDL_GetCurrentVideoDriver1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver1 = _SDL_GetCurrentVideoDriver1Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the number of available video displays.
  ///
  /// \returns a number >= 1 or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  int SDL_GetNumVideoDisplays1() {
    return _SDL_GetNumVideoDisplays1();
  }

  late final _SDL_GetNumVideoDisplays1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays1 =
      _SDL_GetNumVideoDisplays1Ptr.asFunction<int Function()>();

  /// Get the name of a display in UTF-8 encoding.
  ///
  /// \param displayIndex the index of display from which the name should be
  /// queried
  /// \returns the name of a display or NULL for an invalid display index or
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  ffi.Pointer<ffi.Char> SDL_GetDisplayName1(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName1(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName1 =
      _SDL_GetDisplayName1Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// \param displayIndex the index of the display to query
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayBounds1(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds1(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBounds1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds1 = _SDL_GetDisplayBounds1Ptr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the usable desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Apple's macOS, this
  /// subtracts the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// The parameter `rect` is ignored if it is NULL.
  ///
  /// This function also returns -1 if the parameter `displayIndex` is out of
  /// range.
  ///
  /// \param displayIndex the index of the display to query the usable bounds
  /// from
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayUsableBounds1(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds1(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBounds1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds1 = _SDL_GetDisplayUsableBounds1Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the dots/pixels-per-inch for a display.
  ///
  /// Diagonal, horizontal and vertical DPI can all be optionally returned if the
  /// appropriate parameter is non-NULL.
  ///
  /// A failure of this function usually means that either no DPI information is
  /// available or the `displayIndex` is out of range.
  ///
  /// \param displayIndex the index of the display from which DPI information
  /// should be queried
  /// \param ddpi a pointer filled in with the diagonal DPI of the display; may
  /// be NULL
  /// \param hdpi a pointer filled in with the horizontal DPI of the display; may
  /// be NULL
  /// \param vdpi a pointer filled in with the vertical DPI of the display; may
  /// be NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayDPI1(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI1(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPI1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI1 = _SDL_GetDisplayDPI1Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get the orientation of a display.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns The SDL_DisplayOrientation enum value of the display, or
  /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayOrientation1(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation1(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientation1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation1 =
      _SDL_GetDisplayOrientation1Ptr.asFunction<int Function(int)>();

  /// Get the number of available display modes.
  ///
  /// The `displayIndex` needs to be in the range from 0 to
  /// SDL_GetNumVideoDisplays() - 1.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetNumDisplayModes1(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes1(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModes1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes1 =
      _SDL_GetNumDisplayModes1Ptr.asFunction<int Function(int)>();

  /// Get information about a specific display mode.
  ///
  /// The display modes are sorted in this priority:
  ///
  /// - width -> largest to smallest
  /// - height -> largest to smallest
  /// - bits per pixel -> more colors to fewer colors
  /// - packed pixel layout -> largest to smallest
  /// - refresh rate -> highest to lowest
  ///
  /// \param displayIndex the index of the display to query
  /// \param modeIndex the index of the display mode to query
  /// \param mode an SDL_DisplayMode structure filled in with the mode at
  /// `modeIndex`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumDisplayModes
  int SDL_GetDisplayMode1(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode1(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode1 = _SDL_GetDisplayMode1Ptr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the desktop's display mode.
  ///
  /// There's a difference between this function and SDL_GetCurrentDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the previous native display mode, and not the current
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetCurrentDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetDesktopDisplayMode1(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode1(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode1 = _SDL_GetDesktopDisplayMode1Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the current display mode.
  ///
  /// There's a difference between this function and SDL_GetDesktopDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the current display mode, and not the previous native
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDesktopDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetCurrentDisplayMode1(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode1(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode1 = _SDL_GetCurrentDisplayMode1Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the closest match to the requested display mode.
  ///
  /// The available display modes are scanned and `closest` is filled in with the
  /// closest mode matching the requested mode and returned. The mode format and
  /// refresh rate default to the desktop mode if they are set to 0. The modes
  /// are scanned with size being first priority, format being second priority,
  /// and finally checking the refresh rate. If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure containing the desired display
  /// mode
  /// \param closest an SDL_DisplayMode structure filled in with the closest
  /// match of the available display modes
  /// \returns the passed in value `closest` or NULL if no matching video mode
  /// was available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumDisplayModes
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode1(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode1(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode1 =
      _SDL_GetClosestDisplayMode1Ptr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the index of the display associated with a window.
  ///
  /// \param window the window to query
  /// \returns the index of the display containing the center of the window on
  /// success or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetWindowDisplayIndex1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex1(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex1 = _SDL_GetWindowDisplayIndex1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the display mode to use when a window is visible at fullscreen.
  ///
  /// This only affects the display mode used when the window is fullscreen. To
  /// change the window size when the window is not fullscreen, use
  /// SDL_SetWindowSize().
  ///
  /// \param window the window to affect
  /// \param mode the SDL_DisplayMode structure representing the mode to use, or
  /// NULL to use the window's dimensions and the desktop's format
  /// and refresh rate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_SetWindowDisplayMode1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode1(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode1 =
      _SDL_SetWindowDisplayMode1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Query the display mode to use when a window is visible at fullscreen.
  ///
  /// \param window the window to query
  /// \param mode an SDL_DisplayMode structure filled in with the fullscreen
  /// display mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_GetWindowDisplayMode1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode1(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode1 =
      _SDL_GetWindowDisplayMode1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the raw ICC profile data for the screen the window is currently on.
  ///
  /// Data returned should be freed with SDL_free.
  ///
  /// \param window the window to query
  /// \param size the size of the ICC profile
  /// \returns the raw ICC profile data on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<ffi.Void> SDL_GetWindowICCProfile1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _SDL_GetWindowICCProfile1(
      window,
      size,
    );
  }

  late final _SDL_GetWindowICCProfile1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Size>)>>('SDL_GetWindowICCProfile');
  late final _SDL_GetWindowICCProfile1 =
      _SDL_GetWindowICCProfile1Ptr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Size>)>();

  /// Get the pixel format associated with the window.
  ///
  /// \param window the window to query
  /// \returns the pixel format of the window on success or
  /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetWindowPixelFormat1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat1(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormat1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat1 = _SDL_GetWindowPixelFormat1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Create a window with the specified position, dimensions, and flags.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window
  /// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
  /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
  /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
  /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
  /// - `SDL_WINDOW_HIDDEN`: window is not visible
  /// - `SDL_WINDOW_BORDERLESS`: no window decoration
  /// - `SDL_WINDOW_RESIZABLE`: window can be resized
  /// - `SDL_WINDOW_MINIMIZED`: window is minimized
  /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
  /// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
  /// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
  /// supported (>= SDL 2.0.1)
  ///
  /// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
  /// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
  /// queried later using SDL_GetWindowFlags().
  ///
  /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
  /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
  ///
  /// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
  /// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to query the drawable size in pixels.
  ///
  /// If the window is set fullscreen, the width and height parameters `w` and
  /// `h` will not be used. However, invalid size parameters (e.g. too large) may
  /// still fail. Window size is actually limited to 16384 x 16384 for all
  /// platforms at window creation.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// On non-Apple devices, SDL requires you to either not link to the Vulkan
  /// loader or link to a dynamic library version. This limitation may be removed
  /// in a future version of SDL.
  ///
  /// \param title the title of the window, in UTF-8 encoding
  /// \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param w the width of the window, in screen coordinates
  /// \param h the height of the window, in screen coordinates
  /// \param flags 0, or one or more SDL_WindowFlags OR'd together
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindowFrom
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindow1(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow1(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindow1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow1 = _SDL_CreateWindow1Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Create an SDL window from an existing native window.
  ///
  /// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
  /// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
  /// before using SDL_CreateWindowFrom().
  ///
  /// \param data a pointer to driver-dependent window creation data, typically
  /// your native window cast to a void*
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom1(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom1(
      data,
    );
  }

  late final _SDL_CreateWindowFrom1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom1 = _SDL_CreateWindowFrom1Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// Get the numeric ID of a window.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param window the window to query
  /// \returns the ID of the window on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFromID
  int SDL_GetWindowID1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID1(
      window,
    );
  }

  late final _SDL_GetWindowID1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID1 =
      _SDL_GetWindowID1Ptr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window from a stored ID.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param id the ID of the window
  /// \returns the window associated with `id` or NULL if it doesn't exist; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowID
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID1(
    int id,
  ) {
    return _SDL_GetWindowFromID1(
      id,
    );
  }

  late final _SDL_GetWindowFromID1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID1 = _SDL_GetWindowFromID1Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// Get the window flags.
  ///
  /// \param window the window to query
  /// \returns a mask of the SDL_WindowFlags associated with `window`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_HideWindow
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_SetWindowFullscreen
  /// \sa SDL_SetWindowGrab
  /// \sa SDL_ShowWindow
  int SDL_GetWindowFlags1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags1(
      window,
    );
  }

  late final _SDL_GetWindowFlags1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags1 = _SDL_GetWindowFlags1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the title of a window.
  ///
  /// This string is expected to be in UTF-8 encoding.
  ///
  /// \param window the window to change
  /// \param title the desired window title in UTF-8 format
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowTitle
  void SDL_SetWindowTitle1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _SDL_SetWindowTitle1(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitle1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle1 = _SDL_SetWindowTitle1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Get the title of a window.
  ///
  /// \param window the window to query
  /// \returns the title of the window in UTF-8 format or "" if there is no
  /// title.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowTitle
  ffi.Pointer<ffi.Char> SDL_GetWindowTitle1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle1(
      window,
    );
  }

  late final _SDL_GetWindowTitle1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle1 = _SDL_GetWindowTitle1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the icon for a window.
  ///
  /// \param window the window to change
  /// \param icon an SDL_Surface structure containing the icon for the window
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_SetWindowIcon1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon1(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIcon1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon1 = _SDL_SetWindowIcon1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// Associate an arbitrary named pointer with a window.
  ///
  /// `name` is case-sensitive.
  ///
  /// \param window the window to associate with the pointer
  /// \param name the name of the pointer
  /// \param userdata the associated pointer
  /// \returns the previous value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowData
  ffi.Pointer<ffi.Void> SDL_SetWindowData1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData1(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowData1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData1 = _SDL_SetWindowData1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Retrieve the data pointer associated with a window.
  ///
  /// \param window the window to query
  /// \param name the name of the pointer
  /// \returns the value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowData
  ffi.Pointer<ffi.Void> SDL_GetWindowData1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetWindowData1(
      window,
      name,
    );
  }

  late final _SDL_GetWindowData1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData1 = _SDL_GetWindowData1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Set the position of a window.
  ///
  /// The window coordinate origin is the upper left of the display.
  ///
  /// \param window the window to reposition
  /// \param x the x coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowPosition
  void SDL_SetWindowPosition1(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition1(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPosition1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition1 = _SDL_SetWindowPosition1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the position of a window.
  ///
  /// If you do not need the value for one of the positions a NULL may be passed
  /// in the `x` or `y` parameter.
  ///
  /// \param window the window to query
  /// \param x a pointer filled in with the x position of the window, in screen
  /// coordinates, may be NULL
  /// \param y a pointer filled in with the y position of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowPosition
  void SDL_GetWindowPosition1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetWindowPosition1(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPosition1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition1 = _SDL_GetWindowPosition1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the size of a window's client area.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// Fullscreen windows automatically match the size of the display mode, and
  /// you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// \param window the window to change
  /// \param w the width of the window in pixels, in screen coordinates, must be
  /// > 0
  /// \param h the height of the window in pixels, in screen coordinates, must be
  /// > 0
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_SetWindowDisplayMode
  void SDL_SetWindowSize1(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize1(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int, ffi.Int)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize1 = _SDL_SetWindowSize1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the size of a window's client area.
  ///
  /// NULL can safely be passed as the `w` or `h` parameter if the width or
  /// height value is not desired.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
  /// real client area size in pixels.
  ///
  /// \param window the window to query the width and height from
  /// \param w a pointer filled in with the width of the window, in screen
  /// coordinates, may be NULL
  /// \param h a pointer filled in with the height of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetDrawableSize
  /// \sa SDL_Vulkan_GetDrawableSize
  /// \sa SDL_SetWindowSize
  void SDL_GetWindowSize1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSize1(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize1 = _SDL_GetWindowSize1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window's borders (decorations) around the client area.
  ///
  /// Note: If this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
  /// window in question was borderless.
  ///
  /// Note: This function may fail on systems where the window has not yet been
  /// decorated by the display server (for example, immediately after calling
  /// SDL_CreateWindow). It is recommended that you wait at least until the
  /// window has been presented and composited, so that the window system has a
  /// chance to decorate the window and provide the border dimensions to SDL.
  ///
  /// This function also returns -1 if getting the information is not supported.
  ///
  /// \param window the window to query the size values of the border
  /// (decorations) from
  /// \param top pointer to variable for storing the size of the top border; NULL
  /// is permitted
  /// \param left pointer to variable for storing the size of the left border;
  /// NULL is permitted
  /// \param bottom pointer to variable for storing the size of the bottom
  /// border; NULL is permitted
  /// \param right pointer to variable for storing the size of the right border;
  /// NULL is permitted
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowSize
  int SDL_GetWindowBordersSize1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> bottom,
    ffi.Pointer<ffi.Int> right,
  ) {
    return _SDL_GetWindowBordersSize1(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize1 =
      _SDL_GetWindowBordersSize1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the minimum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param min_w the minimum width of the window in pixels
  /// \param min_h the minimum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_SetWindowMinimumSize1(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize1(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize1 = _SDL_SetWindowMinimumSize1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the minimum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the minimum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the minimum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_GetWindowMinimumSize1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMinimumSize1(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize1 =
      _SDL_GetWindowMinimumSize1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the maximum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param max_w the maximum width of the window in pixels
  /// \param max_h the maximum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_SetWindowMaximumSize1(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize1(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize1 = _SDL_SetWindowMaximumSize1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the maximum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the maximum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the maximum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_GetWindowMaximumSize1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMaximumSize1(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize1 =
      _SDL_GetWindowMaximumSize1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the border state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
  /// or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// You can't change the border state of a fullscreen window.
  ///
  /// \param window the window of which to change the border state
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowBordered1(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered1(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBordered1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered1 = _SDL_SetWindowBordered1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
  /// allow/disallow user resizing of the window. This is a no-op if the window's
  /// resizable state already matches the requested state.
  ///
  /// You can't change the resizable state of a fullscreen window.
  ///
  /// \param window the window of which to change the resizable state
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowResizable1(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable1(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizable1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable1 = _SDL_SetWindowResizable1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the window to always be above the others.
  ///
  /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
  /// will bring the window to the front and keep the window above the rest.
  ///
  /// \param window The window of which to change the always on top state
  /// \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
  /// disable
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowAlwaysOnTop1(
    ffi.Pointer<SDL_Window> window,
    int on_top,
  ) {
    return _SDL_SetWindowAlwaysOnTop1(
      window,
      on_top,
    );
  }

  late final _SDL_SetWindowAlwaysOnTop1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowAlwaysOnTop');
  late final _SDL_SetWindowAlwaysOnTop1 = _SDL_SetWindowAlwaysOnTop1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Show a window.
  ///
  /// \param window the window to show
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HideWindow
  /// \sa SDL_RaiseWindow
  void SDL_ShowWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow1(
      window,
    );
  }

  late final _SDL_ShowWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow1 =
      _SDL_ShowWindow1Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Hide a window.
  ///
  /// \param window the window to hide
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowWindow
  void SDL_HideWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow1(
      window,
    );
  }

  late final _SDL_HideWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow1 =
      _SDL_HideWindow1Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Raise a window above other windows and set the input focus.
  ///
  /// \param window the window to raise
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_RaiseWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow1(
      window,
    );
  }

  late final _SDL_RaiseWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow1 =
      _SDL_RaiseWindow1Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Make a window as large as possible.
  ///
  /// \param window the window to maximize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MaximizeWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow1(
      window,
    );
  }

  late final _SDL_MaximizeWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow1 = _SDL_MaximizeWindow1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Minimize a window to an iconic representation.
  ///
  /// \param window the window to minimize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MinimizeWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow1(
      window,
    );
  }

  late final _SDL_MinimizeWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow1 = _SDL_MinimizeWindow1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Restore the size and position of a minimized or maximized window.
  ///
  /// \param window the window to restore
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  void SDL_RestoreWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow1(
      window,
    );
  }

  late final _SDL_RestoreWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow1 = _SDL_RestoreWindow1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's fullscreen state.
  ///
  /// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
  /// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
  /// that takes the size of the desktop; and 0 for windowed mode.
  ///
  /// \param window the window to change
  /// \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_SetWindowFullscreen1(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen1(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreen1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, Uint32)>>('SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen1 = _SDL_SetWindowFullscreen1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get the SDL surface associated with the window.
  ///
  /// A new surface will be created with the optimal format for the window, if
  /// necessary. This surface will be freed when the window is destroyed. Do not
  /// free this surface.
  ///
  /// This surface will be invalidated if the window is resized. After resizing a
  /// window this function must be called again to return a valid surface.
  ///
  /// You may not combine this with 3D or the rendering API on this window.
  ///
  /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
  ///
  /// \param window the window to query
  /// \returns the surface associated with the window, or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UpdateWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface1(
      window,
    );
  }

  late final _SDL_GetWindowSurface1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface1 = _SDL_GetWindowSurface1Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// Copy the window surface to the screen.
  ///
  /// This is the function you use to reflect any changes to the surface on the
  /// screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_Flip().
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  int SDL_UpdateWindowSurface1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface1(
      window,
    );
  }

  late final _SDL_UpdateWindowSurface1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface1 = _SDL_UpdateWindowSurface1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Copy areas of the window surface to the screen.
  ///
  /// This is the function you use to reflect changes to portions of the surface
  /// on the screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
  ///
  /// \param window the window to update
  /// \param rects an array of SDL_Rect structures representing areas of the
  /// surface to copy
  /// \param numrects the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurface
  int SDL_UpdateWindowSurfaceRects1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects1(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRects1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects1 =
      _SDL_UpdateWindowSurfaceRects1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// Set a window's input grab mode.
  ///
  /// When input is grabbed, the mouse is confined to the window. This function
  /// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
  /// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window the window for which the input grab mode should be set
  /// \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGrabbedWindow
  /// \sa SDL_GetWindowGrab
  void SDL_SetWindowGrab1(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab1(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrab1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab1 = _SDL_SetWindowGrab1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's keyboard grab mode.
  ///
  /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
  /// the Meta/Super key. Note that not all system keyboard shortcuts can be
  /// captured by applications (one example is Ctrl+Alt+Del on Windows).
  ///
  /// This is primarily intended for specialized applications such as VNC clients
  /// or VM frontends. Normal games should not use keyboard grab.
  ///
  /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
  /// window is full-screen to ensure the user is not trapped in your
  /// application. If you have a custom keyboard shortcut to exit fullscreen
  /// mode, you may suppress this behavior with
  /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window The window for which the keyboard grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowKeyboardGrab
  /// \sa SDL_SetWindowMouseGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowKeyboardGrab1(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowKeyboardGrab1(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowKeyboardGrab1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Int32)>>('SDL_SetWindowKeyboardGrab');
  late final _SDL_SetWindowKeyboardGrab1 = _SDL_SetWindowKeyboardGrab1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's mouse grab mode.
  ///
  /// Mouse grab confines the mouse cursor to the window.
  ///
  /// \param window The window for which the mouse grab mode should be set.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowMouseGrab
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowMouseGrab1(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowMouseGrab1(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowMouseGrab1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowMouseGrab');
  late final _SDL_SetWindowMouseGrab1 = _SDL_SetWindowMouseGrab1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get a window's input grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGrab
  int SDL_GetWindowGrab1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab1(
      window,
    );
  }

  late final _SDL_GetWindowGrab1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab1 = _SDL_GetWindowGrab1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's keyboard grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowKeyboardGrab1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowKeyboardGrab1(
      window,
    );
  }

  late final _SDL_GetWindowKeyboardGrab1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowKeyboardGrab');
  late final _SDL_GetWindowKeyboardGrab1 = _SDL_GetWindowKeyboardGrab1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's mouse grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowMouseGrab1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseGrab1(
      window,
    );
  }

  late final _SDL_GetWindowMouseGrab1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowMouseGrab');
  late final _SDL_GetWindowMouseGrab1 = _SDL_GetWindowMouseGrab1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window that currently has an input grab enabled.
  ///
  /// \returns the window if input is grabbed or NULL otherwise.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetWindowGrab
  /// \sa SDL_SetWindowGrab
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow1() {
    return _SDL_GetGrabbedWindow1();
  }

  late final _SDL_GetGrabbedWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow1 = _SDL_GetGrabbedWindow1Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Confines the cursor to the specified area of a window.
  ///
  /// Note that this does NOT grab the cursor, it only defines the area a cursor
  /// is restricted to when the window has mouse focus.
  ///
  /// \param window The window that will be associated with the barrier.
  /// \param rect A rectangle area in window-relative coordinates. If NULL the
  /// barrier for the specified window will be destroyed.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetWindowMouseRect
  /// \sa SDL_SetWindowMouseGrab
  int SDL_SetWindowMouseRect1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetWindowMouseRect1(
      window,
      rect,
    );
  }

  late final _SDL_SetWindowMouseRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetWindowMouseRect');
  late final _SDL_SetWindowMouseRect1 = _SDL_SetWindowMouseRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>)>();

  /// Get the mouse confinement rectangle of a window.
  ///
  /// \param window The window to query
  /// \returns A pointer to the mouse confinement rectangle of a window, or NULL
  /// if there isn't one.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetWindowMouseRect
  ffi.Pointer<SDL_Rect> SDL_GetWindowMouseRect1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseRect1(
      window,
    );
  }

  late final _SDL_GetWindowMouseRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Rect> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowMouseRect');
  late final _SDL_GetWindowMouseRect1 = _SDL_GetWindowMouseRect1Ptr.asFunction<
      ffi.Pointer<SDL_Rect> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method sets the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The
  /// brightness set will not follow the window if it is moved to another
  /// display.
  ///
  /// Many platforms will refuse to set the display brightness in modern times.
  /// You are better off using a shader to adjust gamma during rendering, or
  /// something similar.
  ///
  /// \param window the window used to select the display whose brightness will
  /// be changed
  /// \param brightness the brightness (gamma multiplier) value to set where 0.0
  /// is completely dark and 1.0 is normal brightness
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowBrightness
  /// \sa SDL_SetWindowGammaRamp
  int SDL_SetWindowBrightness1(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness1(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightness1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness1 = _SDL_SetWindowBrightness1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose brightness will
  /// be queried
  /// \returns the brightness for the display where 0.0 is completely dark and
  /// 1.0 is normal brightness.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowBrightness
  double SDL_GetWindowBrightness1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness1(
      window,
    );
  }

  late final _SDL_GetWindowBrightness1Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness1 = _SDL_GetWindowBrightness1Ptr
      .asFunction<double Function(ffi.Pointer<SDL_Window>)>();

  /// Set the opacity for a window.
  ///
  /// The parameter `opacity` will be clamped internally between 0.0f
  /// (transparent) and 1.0f (opaque).
  ///
  /// This function also returns -1 if setting the opacity isn't supported.
  ///
  /// \param window the window which will be made transparent or opaque
  /// \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowOpacity
  int SDL_SetWindowOpacity1(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity1(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacity1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity1 = _SDL_SetWindowOpacity1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// The parameter `opacity` is ignored if it is NULL.
  ///
  /// This function also returns -1 if an invalid window was provided.
  ///
  /// \param window the window to get the current opacity value from
  /// \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_SetWindowOpacity
  int SDL_GetWindowOpacity1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity1(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacity1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity1 = _SDL_GetWindowOpacity1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// Set the window as a modal for another window.
  ///
  /// \param modal_window the window that should be set modal
  /// \param parent_window the parent window for the modal window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  int SDL_SetWindowModalFor1(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor1(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalFor1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor1 = _SDL_SetWindowModalFor1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// Explicitly set input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that is completely
  /// obscured by other windows.
  ///
  /// \param window the window that should get the input focus
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RaiseWindow
  int SDL_SetWindowInputFocus1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus1(
      window,
    );
  }

  late final _SDL_SetWindowInputFocus1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus1 = _SDL_SetWindowInputFocus1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the gamma ramp for the display that owns a given window.
  ///
  /// Set the gamma translation table for the red, green, and blue channels of
  /// the video hardware. Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel. The
  /// input is the index into the array, and the output is the 16-bit gamma value
  /// at that index, scaled to the output color precision.
  ///
  /// Despite the name and signature, this method sets the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
  /// ramp set will not follow the window if it is moved to another display.
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be changed
  /// \param red a 256 element array of 16-bit quantities representing the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities representing the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities representing the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowGammaRamp
  int SDL_SetWindowGammaRamp1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp1(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRamp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp1 = _SDL_SetWindowGammaRamp1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Get the gamma ramp for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be queried
  /// \param red a 256 element array of 16-bit quantities filled in with the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities filled in with the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities filled in with the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  int SDL_GetWindowGammaRamp1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp1(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRamp1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp1 = _SDL_GetWindowGammaRamp1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable from
  /// any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of a
  /// given window as special. This callback is run during event processing if we
  /// need to tell the OS to treat a region of the window specially; the use of
  /// this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within a
  /// special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire when
  /// the OS is deciding whether to drag your window, but it fires for lots of
  /// other reasons, too, some unrelated to anything you probably care about _and
  /// when the mouse isn't actually at the location it is testing_). Since this
  /// can fire at any time, you should try to keep your callback efficient,
  /// devoid of allocations, etc.
  ///
  /// \param window the window to set hit-testing on
  /// \param callback the function to call when doing a hit-test
  /// \param callback_data an app-defined void pointer passed to **callback**
  /// \returns 0 on success or -1 on error (including unsupported); call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_SetWindowHitTest1(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest1(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTest1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest1 = _SDL_SetWindowHitTest1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// Request a window to demand attention from the user.
  ///
  /// \param window the window to be flashed
  /// \param operation the flash operation
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_FlashWindow1(
    ffi.Pointer<SDL_Window> window,
    int operation,
  ) {
    return _SDL_FlashWindow1(
      window,
      operation,
    );
  }

  late final _SDL_FlashWindow1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_FlashWindow');
  late final _SDL_FlashWindow1 = _SDL_FlashWindow1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Destroy a window.
  ///
  /// If `window` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid window". See SDL_GetError().
  ///
  /// \param window the window to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_CreateWindowFrom
  void SDL_DestroyWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow1(
      window,
    );
  }

  late final _SDL_DestroyWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow1 = _SDL_DestroyWindow1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Check whether the screensaver is currently enabled.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
  ///
  /// \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
  /// disabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_EnableScreenSaver
  int SDL_IsScreenSaverEnabled1() {
    return _SDL_IsScreenSaverEnabled1();
  }

  late final _SDL_IsScreenSaverEnabled1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled1 =
      _SDL_IsScreenSaverEnabled1Ptr.asFunction<int Function()>();

  /// Allow the screen to be blanked by a screen saver.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_EnableScreenSaver1() {
    return _SDL_EnableScreenSaver1();
  }

  late final _SDL_EnableScreenSaver1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver1 =
      _SDL_EnableScreenSaver1Ptr.asFunction<void Function()>();

  /// Prevent the screen from being blanked by a screen saver.
  ///
  /// If you disable the screensaver, it is automatically re-enabled when SDL
  /// quits.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_EnableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_DisableScreenSaver1() {
    return _SDL_DisableScreenSaver1();
  }

  late final _SDL_DisableScreenSaver1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver1 =
      _SDL_DisableScreenSaver1Ptr.asFunction<void Function()>();

  /// Dynamically load an OpenGL library.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows. If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// If you do this, you need to retrieve all of the GL functions used in your
  /// program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \param path the platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetProcAddress
  /// \sa SDL_GL_UnloadLibrary
  int SDL_GL_LoadLibrary1(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _SDL_GL_LoadLibrary1(
      path,
    );
  }

  late final _SDL_GL_LoadLibrary1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary1 =
      _SDL_GL_LoadLibrary1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get an OpenGL function by name.
  ///
  /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
  /// GL functions must be retrieved this way. Usually this is used to retrieve
  /// function pointers to OpenGL extensions.
  ///
  /// There are some quirks to looking up OpenGL functions that require some
  /// extra care from the application. If you code carefully, you can handle
  /// these quirks without any platform-specific code, though:
  ///
  /// - On Windows, function pointers are specific to the current GL context;
  /// this means you need to have created a GL context and made it current
  /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
  /// create a second context, you should assume that any existing function
  /// pointers aren't valid to use with it. This is (currently) a
  /// Windows-specific limitation, and in practice lots of drivers don't suffer
  /// this limitation, but it is still the way the wgl API is documented to
  /// work and you should expect crashes if you don't respect it. Store a copy
  /// of the function pointers that comes and goes with context lifespan.
  /// - On X11, function pointers returned by this function are valid for any
  /// context, and can even be looked up before a context is created at all.
  /// This means that, for at least some common OpenGL implementations, if you
  /// look up a function that doesn't exist, you'll get a non-NULL result that
  /// is _NOT_ safe to call. You must always make sure the function is actually
  /// available for a given GL context before calling it, by checking for the
  /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
  /// or verifying that the version of OpenGL you're using offers the function
  /// as core functionality.
  /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
  /// isn't supported, but you can't count on this behavior. Check for
  /// extensions you use, and if you get a NULL anyway, act as if that
  /// extension wasn't available. This is probably a bug in the driver, but you
  /// can code defensively for this scenario anyhow.
  /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
  /// Next-gen display servers are waiting to replace it, and may or may not
  /// make the same promises about function pointers.
  /// - OpenGL function pointers must be declared `APIENTRY` as in the example
  /// code. This will ensure the proper calling convention is followed on
  /// platforms where this matters (Win32) thereby avoiding stack corruption.
  ///
  /// \param proc the name of an OpenGL function
  /// \returns a pointer to the named OpenGL function. The returned pointer
  /// should be cast to the appropriate function signature.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ExtensionSupported
  /// \sa SDL_GL_LoadLibrary
  /// \sa SDL_GL_UnloadLibrary
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress1(
    ffi.Pointer<ffi.Char> proc,
  ) {
    return _SDL_GL_GetProcAddress1(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddress1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress1 = _SDL_GL_GetProcAddress1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_LoadLibrary
  void SDL_GL_UnloadLibrary1() {
    return _SDL_GL_UnloadLibrary1();
  }

  late final _SDL_GL_UnloadLibrary1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary1 =
      _SDL_GL_UnloadLibrary1Ptr.asFunction<void Function()>();

  /// Check if an OpenGL extension is supported for the current context.
  ///
  /// This function operates on the current GL context; you must have created a
  /// context and it must be current before calling this function. Do not assume
  /// that all contexts you create will have the same set of extensions
  /// available, or that recreating an existing context will offer the same
  /// extensions again.
  ///
  /// While it's probably not a massive overhead, this function is not an O(1)
  /// operation. Check the extensions you care about after creating the GL
  /// context and save that information somewhere instead of calling the function
  /// every time you need to know.
  ///
  /// \param extension the name of the extension to check
  /// \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GL_ExtensionSupported1(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _SDL_GL_ExtensionSupported1(
      extension1,
    );
  }

  late final _SDL_GL_ExtensionSupported1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported1 = _SDL_GL_ExtensionSupported1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Reset all previously set OpenGL context attributes to their default values.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_SetAttribute
  void SDL_GL_ResetAttributes1() {
    return _SDL_GL_ResetAttributes1();
  }

  late final _SDL_GL_ResetAttributes1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes1 =
      _SDL_GL_ResetAttributes1Ptr.asFunction<void Function()>();

  /// Set an OpenGL window attribute before window creation.
  ///
  /// This function sets the OpenGL attribute `attr` to `value`. The requested
  /// attributes should be set before creating an OpenGL window. You should use
  /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
  /// context, since the values obtained can differ from the requested ones.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
  /// \param value the desired value for the attribute
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_ResetAttributes
  int SDL_GL_SetAttribute1(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute1(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttribute1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32, ffi.Int)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute1 =
      _SDL_GL_SetAttribute1Ptr.asFunction<int Function(int, int)>();

  /// Get the actual value for an attribute from the current context.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
  /// \param value a pointer filled in with the current value of `attr`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ResetAttributes
  /// \sa SDL_GL_SetAttribute
  int SDL_GL_GetAttribute1(
    int attr,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _SDL_GL_GetAttribute1(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttribute1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, ffi.Pointer<ffi.Int>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute1 = _SDL_GL_GetAttribute1Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Create an OpenGL context for an OpenGL window, and make it current.
  ///
  /// Windows users new to OpenGL should note that, for historical reasons, GL
  /// functions added after OpenGL version 1.1 are not available by default.
  /// Those functions must be loaded at run-time, either with an OpenGL
  /// extension-handling library or with SDL_GL_GetProcAddress() and its related
  /// functions.
  ///
  /// SDL_GLContext is an alias for `void *`. It's opaque to the application.
  ///
  /// \param window the window to associate with the context
  /// \returns the OpenGL context associated with `window` or NULL on error; call
  /// SDL_GetError() for more details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_DeleteContext
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_CreateContext1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext1(
      window,
    );
  }

  late final _SDL_GL_CreateContext1Ptr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext1 = _SDL_GL_CreateContext1Ptr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// The context must have been created with a compatible window.
  ///
  /// \param window the window to associate with the context
  /// \param context the OpenGL context to associate with the window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  int SDL_GL_MakeCurrent1(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent1(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrent1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent1 = _SDL_GL_MakeCurrent1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// Get the currently active OpenGL window.
  ///
  /// \returns the currently active OpenGL window on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow1() {
    return _SDL_GL_GetCurrentWindow1();
  }

  late final _SDL_GL_GetCurrentWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow1 = _SDL_GL_GetCurrentWindow1Ptr
      .asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Get the currently active OpenGL context.
  ///
  /// \returns the currently active OpenGL context or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_GetCurrentContext1() {
    return _SDL_GL_GetCurrentContext1();
  }

  late final _SDL_GL_GetCurrentContext1Ptr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext1 =
      _SDL_GL_GetCurrentContext1Ptr.asFunction<SDL_GLContext Function()>();

  /// Get the size of a window's underlying drawable in pixels.
  ///
  /// This returns info useful for calling glViewport().
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GL_GetDrawableSize1(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GL_GetDrawableSize1(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize1 = _SDL_GL_GetDrawableSize1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the swap interval for the current OpenGL context.
  ///
  /// Some systems allow specifying -1 for the interval, to enable adaptive
  /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
  /// the vertical retrace for a given frame, it swaps buffers immediately, which
  /// might be less jarring for the user during occasional framerate drops. If an
  /// application requests adaptive vsync and the system does not support it,
  /// this function will fail and return -1. In such a case, you should probably
  /// retry the call with 1 for the interval.
  ///
  /// Adaptive vsync is implemented for some glX drivers with
  /// GLX_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/glx_swap_control_tear.txt
  ///
  /// and for some Windows drivers with WGL_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/wgl_swap_control_tear.txt
  ///
  /// Read more on the Khronos wiki:
  /// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with
  /// the vertical retrace, -1 for adaptive vsync
  /// \returns 0 on success or -1 if setting the swap interval is not supported;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetSwapInterval
  int SDL_GL_SetSwapInterval1(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval1(
      interval,
    );
  }

  late final _SDL_GL_SetSwapInterval1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval1 =
      _SDL_GL_SetSwapInterval1Ptr.asFunction<int Function(int)>();

  /// Get the swap interval for the current OpenGL context.
  ///
  /// If the system can't determine the swap interval, or there isn't a valid
  /// current context, this function will return 0 as a safe default.
  ///
  /// \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_SetSwapInterval
  int SDL_GL_GetSwapInterval1() {
    return _SDL_GL_GetSwapInterval1();
  }

  late final _SDL_GL_GetSwapInterval1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval1 =
      _SDL_GL_GetSwapInterval1Ptr.asFunction<int Function()>();

  /// Update a window with OpenGL rendering.
  ///
  /// This is used with double-buffered OpenGL contexts, which are the default.
  ///
  /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
  /// window, otherwise nothing will happen. If you aren't using
  /// glBindFramebuffer(), this is the default and you won't have to do anything
  /// extra.
  ///
  /// \param window the window to change
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GL_SwapWindow1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow1(
      window,
    );
  }

  late final _SDL_GL_SwapWindow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow1 = _SDL_GL_SwapWindow1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Delete an OpenGL context.
  ///
  /// \param context the OpenGL context to be deleted
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  void SDL_GL_DeleteContext1(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext1(
      context,
    );
  }

  late final _SDL_GL_DeleteContext1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext1 =
      _SDL_GL_DeleteContext1Ptr.asFunction<void Function(SDL_GLContext)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform7() {
    return _SDL_GetPlatform7();
  }

  late final _SDL_GetPlatform7Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform7 =
      _SDL_GetPlatform7Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc6(
    int size,
  ) {
    return _SDL_malloc6(
      size,
    );
  }

  late final _SDL_malloc6Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc6 =
      _SDL_malloc6Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc6(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc6(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc6 =
      _SDL_calloc6Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc6(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc6(
      mem,
      size,
    );
  }

  late final _SDL_realloc6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc6 = _SDL_realloc6Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free6(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free6(
      mem,
    );
  }

  late final _SDL_free6Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free6 =
      _SDL_free6Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions6(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions6(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions6 = _SDL_GetMemoryFunctions6Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions6(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions6(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions6 = _SDL_SetMemoryFunctions6Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations6() {
    return _SDL_GetNumAllocations6();
  }

  late final _SDL_GetNumAllocations6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations6 =
      _SDL_GetNumAllocations6Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv6(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv6(
      name,
    );
  }

  late final _SDL_getenv6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv6 = _SDL_getenv6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv6(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv6(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv6 = _SDL_setenv6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort6(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort6(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort6 = _SDL_qsort6Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs6(
    int x,
  ) {
    return _SDL_abs6(
      x,
    );
  }

  late final _SDL_abs6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs6 = _SDL_abs6Ptr.asFunction<int Function(int)>();

  int SDL_isalpha6(
    int x,
  ) {
    return _SDL_isalpha6(
      x,
    );
  }

  late final _SDL_isalpha6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha6 = _SDL_isalpha6Ptr.asFunction<int Function(int)>();

  int SDL_isalnum6(
    int x,
  ) {
    return _SDL_isalnum6(
      x,
    );
  }

  late final _SDL_isalnum6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum6 = _SDL_isalnum6Ptr.asFunction<int Function(int)>();

  int SDL_isblank6(
    int x,
  ) {
    return _SDL_isblank6(
      x,
    );
  }

  late final _SDL_isblank6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank6 = _SDL_isblank6Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl6(
    int x,
  ) {
    return _SDL_iscntrl6(
      x,
    );
  }

  late final _SDL_iscntrl6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl6 = _SDL_iscntrl6Ptr.asFunction<int Function(int)>();

  int SDL_isdigit6(
    int x,
  ) {
    return _SDL_isdigit6(
      x,
    );
  }

  late final _SDL_isdigit6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit6 = _SDL_isdigit6Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit6(
    int x,
  ) {
    return _SDL_isxdigit6(
      x,
    );
  }

  late final _SDL_isxdigit6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit6 = _SDL_isxdigit6Ptr.asFunction<int Function(int)>();

  int SDL_ispunct6(
    int x,
  ) {
    return _SDL_ispunct6(
      x,
    );
  }

  late final _SDL_ispunct6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct6 = _SDL_ispunct6Ptr.asFunction<int Function(int)>();

  int SDL_isspace6(
    int x,
  ) {
    return _SDL_isspace6(
      x,
    );
  }

  late final _SDL_isspace6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace6 = _SDL_isspace6Ptr.asFunction<int Function(int)>();

  int SDL_isupper6(
    int x,
  ) {
    return _SDL_isupper6(
      x,
    );
  }

  late final _SDL_isupper6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper6 = _SDL_isupper6Ptr.asFunction<int Function(int)>();

  int SDL_islower6(
    int x,
  ) {
    return _SDL_islower6(
      x,
    );
  }

  late final _SDL_islower6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower6 = _SDL_islower6Ptr.asFunction<int Function(int)>();

  int SDL_isprint6(
    int x,
  ) {
    return _SDL_isprint6(
      x,
    );
  }

  late final _SDL_isprint6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint6 = _SDL_isprint6Ptr.asFunction<int Function(int)>();

  int SDL_isgraph6(
    int x,
  ) {
    return _SDL_isgraph6(
      x,
    );
  }

  late final _SDL_isgraph6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph6 = _SDL_isgraph6Ptr.asFunction<int Function(int)>();

  int SDL_toupper6(
    int x,
  ) {
    return _SDL_toupper6(
      x,
    );
  }

  late final _SDL_toupper6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper6 = _SDL_toupper6Ptr.asFunction<int Function(int)>();

  int SDL_tolower6(
    int x,
  ) {
    return _SDL_tolower6(
      x,
    );
  }

  late final _SDL_tolower6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower6 = _SDL_tolower6Ptr.asFunction<int Function(int)>();

  int SDL_crc326(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc326(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc326Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc326 = _SDL_crc326Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset6(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset6(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset6 = _SDL_memset6Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy6(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy6(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy6 = _SDL_memcpy6Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove6(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove6(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove6 = _SDL_memmove6Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp6(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp6(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp6 = _SDL_memcmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen6(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen6(
      wstr,
    );
  }

  late final _SDL_wcslen6Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen6 =
      _SDL_wcslen6Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy6(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy6(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy6 = _SDL_wcslcpy6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat6(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat6(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat6 = _SDL_wcslcat6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup6(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup6(
      wstr,
    );
  }

  late final _SDL_wcsdup6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup6 = _SDL_wcsdup6Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr6(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr6(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr6 = _SDL_wcsstr6Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp6(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp6(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp6 = _SDL_wcscmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp6(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp6(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp6 = _SDL_wcsncmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp6(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp6(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp6 = _SDL_wcscasecmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp6(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp6(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp6 = _SDL_wcsncasecmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen6(
      str,
    );
  }

  late final _SDL_strlen6Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen6 =
      _SDL_strlen6Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy6(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy6(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy6 = _SDL_strlcpy6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy6(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy6(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy6 = _SDL_utf8strlcpy6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat6(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat6(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat6 = _SDL_strlcat6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup6(
      str,
    );
  }

  late final _SDL_strdup6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup6 = _SDL_strdup6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev6(
      str,
    );
  }

  late final _SDL_strrev6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev6 = _SDL_strrev6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr6(
      str,
    );
  }

  late final _SDL_strupr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr6 = _SDL_strupr6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr6(
      str,
    );
  }

  late final _SDL_strlwr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr6 = _SDL_strlwr6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr6(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr6(
      str,
      c,
    );
  }

  late final _SDL_strchr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr6 = _SDL_strchr6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr6(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr6(
      str,
      c,
    );
  }

  late final _SDL_strrchr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr6 = _SDL_strrchr6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr6(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr6(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr6 = _SDL_strstr6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr6(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr6(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr6 = _SDL_strtokr6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen6(
      str,
    );
  }

  late final _SDL_utf8strlen6Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen6 =
      _SDL_utf8strlen6Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa6(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa6(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa6 = _SDL_itoa6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa6(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa6(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa6 = _SDL_uitoa6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa6(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa6(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa6 = _SDL_ltoa6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa6(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa6(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa6 = _SDL_ultoa6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa6(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa6(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa6 = _SDL_lltoa6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa6(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa6(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa6 = _SDL_ulltoa6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi6(
      str,
    );
  }

  late final _SDL_atoi6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi6 =
      _SDL_atoi6Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof6(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof6(
      str,
    );
  }

  late final _SDL_atof6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof6 =
      _SDL_atof6Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol6(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol6(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol6 = _SDL_strtol6Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul6(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul6(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul6 = _SDL_strtoul6Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll6(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll6(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll6Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll6 = _SDL_strtoll6Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull6(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull6(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull6Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull6 = _SDL_strtoull6Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod6(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod6(
      str,
      endp,
    );
  }

  late final _SDL_strtod6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod6 = _SDL_strtod6Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp6(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp6(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp6 = _SDL_strcmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp6(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp6(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp6 = _SDL_strncmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp6(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp6(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp6 = _SDL_strcasecmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp6(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp6(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp6 = _SDL_strncasecmp6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf6(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf6(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf6 = _SDL_sscanf6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf6(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf6(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf6 = _SDL_vsscanf6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf6(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf6(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf6 = _SDL_snprintf6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf6(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf6(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf6 = _SDL_vsnprintf6Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf6(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf6(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf6 = _SDL_asprintf6Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf6(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf6(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf6 = _SDL_vasprintf6Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos6(
    double x,
  ) {
    return _SDL_acos6(
      x,
    );
  }

  late final _SDL_acos6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos6 = _SDL_acos6Ptr.asFunction<double Function(double)>();

  double SDL_acosf6(
    double x,
  ) {
    return _SDL_acosf6(
      x,
    );
  }

  late final _SDL_acosf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf6 = _SDL_acosf6Ptr.asFunction<double Function(double)>();

  double SDL_asin6(
    double x,
  ) {
    return _SDL_asin6(
      x,
    );
  }

  late final _SDL_asin6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin6 = _SDL_asin6Ptr.asFunction<double Function(double)>();

  double SDL_asinf6(
    double x,
  ) {
    return _SDL_asinf6(
      x,
    );
  }

  late final _SDL_asinf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf6 = _SDL_asinf6Ptr.asFunction<double Function(double)>();

  double SDL_atan7(
    double x,
  ) {
    return _SDL_atan7(
      x,
    );
  }

  late final _SDL_atan7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan7 = _SDL_atan7Ptr.asFunction<double Function(double)>();

  double SDL_atanf6(
    double x,
  ) {
    return _SDL_atanf6(
      x,
    );
  }

  late final _SDL_atanf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf6 = _SDL_atanf6Ptr.asFunction<double Function(double)>();

  double SDL_atan26(
    double y,
    double x,
  ) {
    return _SDL_atan26(
      y,
      x,
    );
  }

  late final _SDL_atan26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan26 =
      _SDL_atan26Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f6(
    double y,
    double x,
  ) {
    return _SDL_atan2f6(
      y,
      x,
    );
  }

  late final _SDL_atan2f6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f6 =
      _SDL_atan2f6Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil6(
    double x,
  ) {
    return _SDL_ceil6(
      x,
    );
  }

  late final _SDL_ceil6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil6 = _SDL_ceil6Ptr.asFunction<double Function(double)>();

  double SDL_ceilf6(
    double x,
  ) {
    return _SDL_ceilf6(
      x,
    );
  }

  late final _SDL_ceilf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf6 = _SDL_ceilf6Ptr.asFunction<double Function(double)>();

  double SDL_copysign6(
    double x,
    double y,
  ) {
    return _SDL_copysign6(
      x,
      y,
    );
  }

  late final _SDL_copysign6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign6 =
      _SDL_copysign6Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf6(
    double x,
    double y,
  ) {
    return _SDL_copysignf6(
      x,
      y,
    );
  }

  late final _SDL_copysignf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf6 =
      _SDL_copysignf6Ptr.asFunction<double Function(double, double)>();

  double SDL_cos6(
    double x,
  ) {
    return _SDL_cos6(
      x,
    );
  }

  late final _SDL_cos6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos6 = _SDL_cos6Ptr.asFunction<double Function(double)>();

  double SDL_cosf6(
    double x,
  ) {
    return _SDL_cosf6(
      x,
    );
  }

  late final _SDL_cosf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf6 = _SDL_cosf6Ptr.asFunction<double Function(double)>();

  double SDL_exp6(
    double x,
  ) {
    return _SDL_exp6(
      x,
    );
  }

  late final _SDL_exp6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp6 = _SDL_exp6Ptr.asFunction<double Function(double)>();

  double SDL_expf6(
    double x,
  ) {
    return _SDL_expf6(
      x,
    );
  }

  late final _SDL_expf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf6 = _SDL_expf6Ptr.asFunction<double Function(double)>();

  double SDL_fabs6(
    double x,
  ) {
    return _SDL_fabs6(
      x,
    );
  }

  late final _SDL_fabs6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs6 = _SDL_fabs6Ptr.asFunction<double Function(double)>();

  double SDL_fabsf6(
    double x,
  ) {
    return _SDL_fabsf6(
      x,
    );
  }

  late final _SDL_fabsf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf6 = _SDL_fabsf6Ptr.asFunction<double Function(double)>();

  double SDL_floor6(
    double x,
  ) {
    return _SDL_floor6(
      x,
    );
  }

  late final _SDL_floor6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor6 = _SDL_floor6Ptr.asFunction<double Function(double)>();

  double SDL_floorf6(
    double x,
  ) {
    return _SDL_floorf6(
      x,
    );
  }

  late final _SDL_floorf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf6 =
      _SDL_floorf6Ptr.asFunction<double Function(double)>();

  double SDL_trunc6(
    double x,
  ) {
    return _SDL_trunc6(
      x,
    );
  }

  late final _SDL_trunc6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc6 = _SDL_trunc6Ptr.asFunction<double Function(double)>();

  double SDL_truncf6(
    double x,
  ) {
    return _SDL_truncf6(
      x,
    );
  }

  late final _SDL_truncf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf6 =
      _SDL_truncf6Ptr.asFunction<double Function(double)>();

  double SDL_fmod6(
    double x,
    double y,
  ) {
    return _SDL_fmod6(
      x,
      y,
    );
  }

  late final _SDL_fmod6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod6 =
      _SDL_fmod6Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf6(
    double x,
    double y,
  ) {
    return _SDL_fmodf6(
      x,
      y,
    );
  }

  late final _SDL_fmodf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf6 =
      _SDL_fmodf6Ptr.asFunction<double Function(double, double)>();

  double SDL_log6(
    double x,
  ) {
    return _SDL_log6(
      x,
    );
  }

  late final _SDL_log6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log6 = _SDL_log6Ptr.asFunction<double Function(double)>();

  double SDL_logf6(
    double x,
  ) {
    return _SDL_logf6(
      x,
    );
  }

  late final _SDL_logf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf6 = _SDL_logf6Ptr.asFunction<double Function(double)>();

  double SDL_log106(
    double x,
  ) {
    return _SDL_log106(
      x,
    );
  }

  late final _SDL_log106Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log106 = _SDL_log106Ptr.asFunction<double Function(double)>();

  double SDL_log10f6(
    double x,
  ) {
    return _SDL_log10f6(
      x,
    );
  }

  late final _SDL_log10f6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f6 =
      _SDL_log10f6Ptr.asFunction<double Function(double)>();

  double SDL_pow6(
    double x,
    double y,
  ) {
    return _SDL_pow6(
      x,
      y,
    );
  }

  late final _SDL_pow6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow6 =
      _SDL_pow6Ptr.asFunction<double Function(double, double)>();

  double SDL_powf6(
    double x,
    double y,
  ) {
    return _SDL_powf6(
      x,
      y,
    );
  }

  late final _SDL_powf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf6 =
      _SDL_powf6Ptr.asFunction<double Function(double, double)>();

  double SDL_round6(
    double x,
  ) {
    return _SDL_round6(
      x,
    );
  }

  late final _SDL_round6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round6 = _SDL_round6Ptr.asFunction<double Function(double)>();

  double SDL_roundf6(
    double x,
  ) {
    return _SDL_roundf6(
      x,
    );
  }

  late final _SDL_roundf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf6 =
      _SDL_roundf6Ptr.asFunction<double Function(double)>();

  int SDL_lround6(
    double x,
  ) {
    return _SDL_lround6(
      x,
    );
  }

  late final _SDL_lround6Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround6 = _SDL_lround6Ptr.asFunction<int Function(double)>();

  int SDL_lroundf6(
    double x,
  ) {
    return _SDL_lroundf6(
      x,
    );
  }

  late final _SDL_lroundf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf6 =
      _SDL_lroundf6Ptr.asFunction<int Function(double)>();

  double SDL_scalbn6(
    double x,
    int n,
  ) {
    return _SDL_scalbn6(
      x,
      n,
    );
  }

  late final _SDL_scalbn6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn6 =
      _SDL_scalbn6Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf6(
    double x,
    int n,
  ) {
    return _SDL_scalbnf6(
      x,
      n,
    );
  }

  late final _SDL_scalbnf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf6 =
      _SDL_scalbnf6Ptr.asFunction<double Function(double, int)>();

  double SDL_sin6(
    double x,
  ) {
    return _SDL_sin6(
      x,
    );
  }

  late final _SDL_sin6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin6 = _SDL_sin6Ptr.asFunction<double Function(double)>();

  double SDL_sinf6(
    double x,
  ) {
    return _SDL_sinf6(
      x,
    );
  }

  late final _SDL_sinf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf6 = _SDL_sinf6Ptr.asFunction<double Function(double)>();

  double SDL_sqrt6(
    double x,
  ) {
    return _SDL_sqrt6(
      x,
    );
  }

  late final _SDL_sqrt6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt6 = _SDL_sqrt6Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf6(
    double x,
  ) {
    return _SDL_sqrtf6(
      x,
    );
  }

  late final _SDL_sqrtf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf6 = _SDL_sqrtf6Ptr.asFunction<double Function(double)>();

  double SDL_tan6(
    double x,
  ) {
    return _SDL_tan6(
      x,
    );
  }

  late final _SDL_tan6Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan6 = _SDL_tan6Ptr.asFunction<double Function(double)>();

  double SDL_tanf6(
    double x,
  ) {
    return _SDL_tanf6(
      x,
    );
  }

  late final _SDL_tanf6Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf6 = _SDL_tanf6Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open6(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open6(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open6Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open6 = _SDL_iconv_open6Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close6(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close6(
      cd,
    );
  }

  late final _SDL_iconv_close6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close6 =
      _SDL_iconv_close6Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv6(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv6(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv6 = _SDL_iconv6Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string6(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string6(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string6 = _SDL_iconv_string6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Put UTF-8 text into the clipboard.
  ///
  /// \param text the text to store in the clipboard
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetClipboardText
  /// \sa SDL_HasClipboardText
  int SDL_SetClipboardText1(
    ffi.Pointer<ffi.Char> text,
  ) {
    return _SDL_SetClipboardText1(
      text,
    );
  }

  late final _SDL_SetClipboardText1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetClipboardText');
  late final _SDL_SetClipboardText1 = _SDL_SetClipboardText1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>)>();

  /// Get UTF-8 text from the clipboard, which must be freed with SDL_free().
  ///
  /// This functions returns empty string if there was not enough memory left for
  /// a copy of the clipboard's content.
  ///
  /// \returns the clipboard text on success or an empty string on failure; call
  /// SDL_GetError() for more information. Caller must call SDL_free()
  /// on the returned pointer when done with it (even if there was an
  /// error).
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasClipboardText
  /// \sa SDL_SetClipboardText
  ffi.Pointer<ffi.Char> SDL_GetClipboardText1() {
    return _SDL_GetClipboardText1();
  }

  late final _SDL_GetClipboardText1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetClipboardText');
  late final _SDL_GetClipboardText1 =
      _SDL_GetClipboardText1Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Query whether the clipboard exists and contains a non-empty text string.
  ///
  /// \returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetClipboardText
  /// \sa SDL_SetClipboardText
  int SDL_HasClipboardText1() {
    return _SDL_HasClipboardText1();
  }

  late final _SDL_HasClipboardText1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasClipboardText');
  late final _SDL_HasClipboardText1 =
      _SDL_HasClipboardText1Ptr.asFunction<int Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform8() {
    return _SDL_GetPlatform8();
  }

  late final _SDL_GetPlatform8Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform8 =
      _SDL_GetPlatform8Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc7(
    int size,
  ) {
    return _SDL_malloc7(
      size,
    );
  }

  late final _SDL_malloc7Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc7 =
      _SDL_malloc7Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc7(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc7(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc7 =
      _SDL_calloc7Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc7(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc7(
      mem,
      size,
    );
  }

  late final _SDL_realloc7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc7 = _SDL_realloc7Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free7(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free7(
      mem,
    );
  }

  late final _SDL_free7Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free7 =
      _SDL_free7Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions7(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions7(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions7 = _SDL_GetMemoryFunctions7Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions7(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions7(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions7 = _SDL_SetMemoryFunctions7Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations7() {
    return _SDL_GetNumAllocations7();
  }

  late final _SDL_GetNumAllocations7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations7 =
      _SDL_GetNumAllocations7Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv7(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv7(
      name,
    );
  }

  late final _SDL_getenv7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv7 = _SDL_getenv7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv7(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv7(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv7 = _SDL_setenv7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort7(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort7(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort7 = _SDL_qsort7Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs7(
    int x,
  ) {
    return _SDL_abs7(
      x,
    );
  }

  late final _SDL_abs7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs7 = _SDL_abs7Ptr.asFunction<int Function(int)>();

  int SDL_isalpha7(
    int x,
  ) {
    return _SDL_isalpha7(
      x,
    );
  }

  late final _SDL_isalpha7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha7 = _SDL_isalpha7Ptr.asFunction<int Function(int)>();

  int SDL_isalnum7(
    int x,
  ) {
    return _SDL_isalnum7(
      x,
    );
  }

  late final _SDL_isalnum7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum7 = _SDL_isalnum7Ptr.asFunction<int Function(int)>();

  int SDL_isblank7(
    int x,
  ) {
    return _SDL_isblank7(
      x,
    );
  }

  late final _SDL_isblank7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank7 = _SDL_isblank7Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl7(
    int x,
  ) {
    return _SDL_iscntrl7(
      x,
    );
  }

  late final _SDL_iscntrl7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl7 = _SDL_iscntrl7Ptr.asFunction<int Function(int)>();

  int SDL_isdigit7(
    int x,
  ) {
    return _SDL_isdigit7(
      x,
    );
  }

  late final _SDL_isdigit7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit7 = _SDL_isdigit7Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit7(
    int x,
  ) {
    return _SDL_isxdigit7(
      x,
    );
  }

  late final _SDL_isxdigit7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit7 = _SDL_isxdigit7Ptr.asFunction<int Function(int)>();

  int SDL_ispunct7(
    int x,
  ) {
    return _SDL_ispunct7(
      x,
    );
  }

  late final _SDL_ispunct7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct7 = _SDL_ispunct7Ptr.asFunction<int Function(int)>();

  int SDL_isspace7(
    int x,
  ) {
    return _SDL_isspace7(
      x,
    );
  }

  late final _SDL_isspace7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace7 = _SDL_isspace7Ptr.asFunction<int Function(int)>();

  int SDL_isupper7(
    int x,
  ) {
    return _SDL_isupper7(
      x,
    );
  }

  late final _SDL_isupper7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper7 = _SDL_isupper7Ptr.asFunction<int Function(int)>();

  int SDL_islower7(
    int x,
  ) {
    return _SDL_islower7(
      x,
    );
  }

  late final _SDL_islower7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower7 = _SDL_islower7Ptr.asFunction<int Function(int)>();

  int SDL_isprint7(
    int x,
  ) {
    return _SDL_isprint7(
      x,
    );
  }

  late final _SDL_isprint7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint7 = _SDL_isprint7Ptr.asFunction<int Function(int)>();

  int SDL_isgraph7(
    int x,
  ) {
    return _SDL_isgraph7(
      x,
    );
  }

  late final _SDL_isgraph7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph7 = _SDL_isgraph7Ptr.asFunction<int Function(int)>();

  int SDL_toupper7(
    int x,
  ) {
    return _SDL_toupper7(
      x,
    );
  }

  late final _SDL_toupper7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper7 = _SDL_toupper7Ptr.asFunction<int Function(int)>();

  int SDL_tolower7(
    int x,
  ) {
    return _SDL_tolower7(
      x,
    );
  }

  late final _SDL_tolower7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower7 = _SDL_tolower7Ptr.asFunction<int Function(int)>();

  int SDL_crc327(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc327(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc327Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc327 = _SDL_crc327Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset7(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset7(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset7 = _SDL_memset7Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy7(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy7(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy7 = _SDL_memcpy7Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove7(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove7(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove7 = _SDL_memmove7Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp7(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp7(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp7 = _SDL_memcmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen7(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen7(
      wstr,
    );
  }

  late final _SDL_wcslen7Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen7 =
      _SDL_wcslen7Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy7(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy7(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy7 = _SDL_wcslcpy7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat7(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat7(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat7 = _SDL_wcslcat7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup7(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup7(
      wstr,
    );
  }

  late final _SDL_wcsdup7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup7 = _SDL_wcsdup7Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr7(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr7(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr7 = _SDL_wcsstr7Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp7(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp7(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp7 = _SDL_wcscmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp7(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp7(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp7 = _SDL_wcsncmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp7(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp7(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp7 = _SDL_wcscasecmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp7(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp7(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp7 = _SDL_wcsncasecmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen7(
      str,
    );
  }

  late final _SDL_strlen7Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen7 =
      _SDL_strlen7Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy7(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy7(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy7 = _SDL_strlcpy7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy7(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy7(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy7 = _SDL_utf8strlcpy7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat7(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat7(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat7 = _SDL_strlcat7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup7(
      str,
    );
  }

  late final _SDL_strdup7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup7 = _SDL_strdup7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev7(
      str,
    );
  }

  late final _SDL_strrev7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev7 = _SDL_strrev7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr7(
      str,
    );
  }

  late final _SDL_strupr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr7 = _SDL_strupr7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr7(
      str,
    );
  }

  late final _SDL_strlwr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr7 = _SDL_strlwr7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr7(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr7(
      str,
      c,
    );
  }

  late final _SDL_strchr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr7 = _SDL_strchr7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr7(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr7(
      str,
      c,
    );
  }

  late final _SDL_strrchr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr7 = _SDL_strrchr7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr7(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr7(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr7 = _SDL_strstr7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr7(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr7(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr7 = _SDL_strtokr7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen7(
      str,
    );
  }

  late final _SDL_utf8strlen7Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen7 =
      _SDL_utf8strlen7Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa7(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa7(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa7 = _SDL_itoa7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa7(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa7(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa7 = _SDL_uitoa7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa7(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa7(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa7 = _SDL_ltoa7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa7(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa7(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa7 = _SDL_ultoa7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa7(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa7(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa7 = _SDL_lltoa7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa7(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa7(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa7 = _SDL_ulltoa7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi7(
      str,
    );
  }

  late final _SDL_atoi7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi7 =
      _SDL_atoi7Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof7(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof7(
      str,
    );
  }

  late final _SDL_atof7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof7 =
      _SDL_atof7Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol7(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol7(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol7 = _SDL_strtol7Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul7(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul7(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul7 = _SDL_strtoul7Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll7(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll7(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll7Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll7 = _SDL_strtoll7Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull7(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull7(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull7Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull7 = _SDL_strtoull7Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod7(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod7(
      str,
      endp,
    );
  }

  late final _SDL_strtod7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod7 = _SDL_strtod7Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp7(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp7(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp7 = _SDL_strcmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp7(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp7(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp7 = _SDL_strncmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp7(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp7(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp7 = _SDL_strcasecmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp7(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp7(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp7 = _SDL_strncasecmp7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf7(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf7(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf7 = _SDL_sscanf7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf7(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf7(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf7 = _SDL_vsscanf7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf7(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf7(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf7 = _SDL_snprintf7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf7(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf7(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf7 = _SDL_vsnprintf7Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf7(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf7(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf7 = _SDL_asprintf7Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf7(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf7(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf7 = _SDL_vasprintf7Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos7(
    double x,
  ) {
    return _SDL_acos7(
      x,
    );
  }

  late final _SDL_acos7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos7 = _SDL_acos7Ptr.asFunction<double Function(double)>();

  double SDL_acosf7(
    double x,
  ) {
    return _SDL_acosf7(
      x,
    );
  }

  late final _SDL_acosf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf7 = _SDL_acosf7Ptr.asFunction<double Function(double)>();

  double SDL_asin7(
    double x,
  ) {
    return _SDL_asin7(
      x,
    );
  }

  late final _SDL_asin7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin7 = _SDL_asin7Ptr.asFunction<double Function(double)>();

  double SDL_asinf7(
    double x,
  ) {
    return _SDL_asinf7(
      x,
    );
  }

  late final _SDL_asinf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf7 = _SDL_asinf7Ptr.asFunction<double Function(double)>();

  double SDL_atan8(
    double x,
  ) {
    return _SDL_atan8(
      x,
    );
  }

  late final _SDL_atan8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan8 = _SDL_atan8Ptr.asFunction<double Function(double)>();

  double SDL_atanf7(
    double x,
  ) {
    return _SDL_atanf7(
      x,
    );
  }

  late final _SDL_atanf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf7 = _SDL_atanf7Ptr.asFunction<double Function(double)>();

  double SDL_atan27(
    double y,
    double x,
  ) {
    return _SDL_atan27(
      y,
      x,
    );
  }

  late final _SDL_atan27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan27 =
      _SDL_atan27Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f7(
    double y,
    double x,
  ) {
    return _SDL_atan2f7(
      y,
      x,
    );
  }

  late final _SDL_atan2f7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f7 =
      _SDL_atan2f7Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil7(
    double x,
  ) {
    return _SDL_ceil7(
      x,
    );
  }

  late final _SDL_ceil7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil7 = _SDL_ceil7Ptr.asFunction<double Function(double)>();

  double SDL_ceilf7(
    double x,
  ) {
    return _SDL_ceilf7(
      x,
    );
  }

  late final _SDL_ceilf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf7 = _SDL_ceilf7Ptr.asFunction<double Function(double)>();

  double SDL_copysign7(
    double x,
    double y,
  ) {
    return _SDL_copysign7(
      x,
      y,
    );
  }

  late final _SDL_copysign7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign7 =
      _SDL_copysign7Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf7(
    double x,
    double y,
  ) {
    return _SDL_copysignf7(
      x,
      y,
    );
  }

  late final _SDL_copysignf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf7 =
      _SDL_copysignf7Ptr.asFunction<double Function(double, double)>();

  double SDL_cos7(
    double x,
  ) {
    return _SDL_cos7(
      x,
    );
  }

  late final _SDL_cos7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos7 = _SDL_cos7Ptr.asFunction<double Function(double)>();

  double SDL_cosf7(
    double x,
  ) {
    return _SDL_cosf7(
      x,
    );
  }

  late final _SDL_cosf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf7 = _SDL_cosf7Ptr.asFunction<double Function(double)>();

  double SDL_exp7(
    double x,
  ) {
    return _SDL_exp7(
      x,
    );
  }

  late final _SDL_exp7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp7 = _SDL_exp7Ptr.asFunction<double Function(double)>();

  double SDL_expf7(
    double x,
  ) {
    return _SDL_expf7(
      x,
    );
  }

  late final _SDL_expf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf7 = _SDL_expf7Ptr.asFunction<double Function(double)>();

  double SDL_fabs7(
    double x,
  ) {
    return _SDL_fabs7(
      x,
    );
  }

  late final _SDL_fabs7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs7 = _SDL_fabs7Ptr.asFunction<double Function(double)>();

  double SDL_fabsf7(
    double x,
  ) {
    return _SDL_fabsf7(
      x,
    );
  }

  late final _SDL_fabsf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf7 = _SDL_fabsf7Ptr.asFunction<double Function(double)>();

  double SDL_floor7(
    double x,
  ) {
    return _SDL_floor7(
      x,
    );
  }

  late final _SDL_floor7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor7 = _SDL_floor7Ptr.asFunction<double Function(double)>();

  double SDL_floorf7(
    double x,
  ) {
    return _SDL_floorf7(
      x,
    );
  }

  late final _SDL_floorf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf7 =
      _SDL_floorf7Ptr.asFunction<double Function(double)>();

  double SDL_trunc7(
    double x,
  ) {
    return _SDL_trunc7(
      x,
    );
  }

  late final _SDL_trunc7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc7 = _SDL_trunc7Ptr.asFunction<double Function(double)>();

  double SDL_truncf7(
    double x,
  ) {
    return _SDL_truncf7(
      x,
    );
  }

  late final _SDL_truncf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf7 =
      _SDL_truncf7Ptr.asFunction<double Function(double)>();

  double SDL_fmod7(
    double x,
    double y,
  ) {
    return _SDL_fmod7(
      x,
      y,
    );
  }

  late final _SDL_fmod7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod7 =
      _SDL_fmod7Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf7(
    double x,
    double y,
  ) {
    return _SDL_fmodf7(
      x,
      y,
    );
  }

  late final _SDL_fmodf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf7 =
      _SDL_fmodf7Ptr.asFunction<double Function(double, double)>();

  double SDL_log7(
    double x,
  ) {
    return _SDL_log7(
      x,
    );
  }

  late final _SDL_log7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log7 = _SDL_log7Ptr.asFunction<double Function(double)>();

  double SDL_logf7(
    double x,
  ) {
    return _SDL_logf7(
      x,
    );
  }

  late final _SDL_logf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf7 = _SDL_logf7Ptr.asFunction<double Function(double)>();

  double SDL_log107(
    double x,
  ) {
    return _SDL_log107(
      x,
    );
  }

  late final _SDL_log107Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log107 = _SDL_log107Ptr.asFunction<double Function(double)>();

  double SDL_log10f7(
    double x,
  ) {
    return _SDL_log10f7(
      x,
    );
  }

  late final _SDL_log10f7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f7 =
      _SDL_log10f7Ptr.asFunction<double Function(double)>();

  double SDL_pow7(
    double x,
    double y,
  ) {
    return _SDL_pow7(
      x,
      y,
    );
  }

  late final _SDL_pow7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow7 =
      _SDL_pow7Ptr.asFunction<double Function(double, double)>();

  double SDL_powf7(
    double x,
    double y,
  ) {
    return _SDL_powf7(
      x,
      y,
    );
  }

  late final _SDL_powf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf7 =
      _SDL_powf7Ptr.asFunction<double Function(double, double)>();

  double SDL_round7(
    double x,
  ) {
    return _SDL_round7(
      x,
    );
  }

  late final _SDL_round7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round7 = _SDL_round7Ptr.asFunction<double Function(double)>();

  double SDL_roundf7(
    double x,
  ) {
    return _SDL_roundf7(
      x,
    );
  }

  late final _SDL_roundf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf7 =
      _SDL_roundf7Ptr.asFunction<double Function(double)>();

  int SDL_lround7(
    double x,
  ) {
    return _SDL_lround7(
      x,
    );
  }

  late final _SDL_lround7Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround7 = _SDL_lround7Ptr.asFunction<int Function(double)>();

  int SDL_lroundf7(
    double x,
  ) {
    return _SDL_lroundf7(
      x,
    );
  }

  late final _SDL_lroundf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf7 =
      _SDL_lroundf7Ptr.asFunction<int Function(double)>();

  double SDL_scalbn7(
    double x,
    int n,
  ) {
    return _SDL_scalbn7(
      x,
      n,
    );
  }

  late final _SDL_scalbn7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn7 =
      _SDL_scalbn7Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf7(
    double x,
    int n,
  ) {
    return _SDL_scalbnf7(
      x,
      n,
    );
  }

  late final _SDL_scalbnf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf7 =
      _SDL_scalbnf7Ptr.asFunction<double Function(double, int)>();

  double SDL_sin7(
    double x,
  ) {
    return _SDL_sin7(
      x,
    );
  }

  late final _SDL_sin7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin7 = _SDL_sin7Ptr.asFunction<double Function(double)>();

  double SDL_sinf7(
    double x,
  ) {
    return _SDL_sinf7(
      x,
    );
  }

  late final _SDL_sinf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf7 = _SDL_sinf7Ptr.asFunction<double Function(double)>();

  double SDL_sqrt7(
    double x,
  ) {
    return _SDL_sqrt7(
      x,
    );
  }

  late final _SDL_sqrt7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt7 = _SDL_sqrt7Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf7(
    double x,
  ) {
    return _SDL_sqrtf7(
      x,
    );
  }

  late final _SDL_sqrtf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf7 = _SDL_sqrtf7Ptr.asFunction<double Function(double)>();

  double SDL_tan7(
    double x,
  ) {
    return _SDL_tan7(
      x,
    );
  }

  late final _SDL_tan7Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan7 = _SDL_tan7Ptr.asFunction<double Function(double)>();

  double SDL_tanf7(
    double x,
  ) {
    return _SDL_tanf7(
      x,
    );
  }

  late final _SDL_tanf7Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf7 = _SDL_tanf7Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open7(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open7(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open7Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open7 = _SDL_iconv_open7Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close7(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close7(
      cd,
    );
  }

  late final _SDL_iconv_close7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close7 =
      _SDL_iconv_close7Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv7(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv7(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv7 = _SDL_iconv7Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string7(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string7(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string7 = _SDL_iconv_string7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError3(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError3(
      fmt,
    );
  }

  late final _SDL_SetError3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError3 =
      _SDL_SetError3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError3() {
    return _SDL_GetError3();
  }

  late final _SDL_GetError3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError3 =
      _SDL_GetError3Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg3(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg3(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg3 = _SDL_GetErrorMsg3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError3() {
    return _SDL_ClearError3();
  }

  late final _SDL_ClearError3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError3 =
      _SDL_ClearError3Ptr.asFunction<void Function()>();

  int SDL_Error3(
    int code,
  ) {
    return _SDL_Error3(
      code,
    );
  }

  late final _SDL_Error3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error3 = _SDL_Error3Ptr.asFunction<int Function(int)>();

  /// Get the human readable name of a pixel format.
  ///
  /// \param format the pixel format to query
  /// \returns the human readable name of the specified pixel format or
  /// `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPixelFormatName2(
    int format,
  ) {
    return _SDL_GetPixelFormatName2(
      format,
    );
  }

  late final _SDL_GetPixelFormatName2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Uint32)>>(
          'SDL_GetPixelFormatName');
  late final _SDL_GetPixelFormatName2 = _SDL_GetPixelFormatName2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
  ///
  /// \param format one of the SDL_PixelFormatEnum values
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask a pointer filled in with the red mask for the format
  /// \param Gmask a pointer filled in with the green mask for the format
  /// \param Bmask a pointer filled in with the blue mask for the format
  /// \param Amask a pointer filled in with the alpha mask for the format
  /// \returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't
  /// possible; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MasksToPixelFormatEnum
  int SDL_PixelFormatEnumToMasks2(
    int format,
    ffi.Pointer<ffi.Int> bpp,
    ffi.Pointer<Uint32> Rmask,
    ffi.Pointer<Uint32> Gmask,
    ffi.Pointer<Uint32> Bmask,
    ffi.Pointer<Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks2(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasks2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>)>>('SDL_PixelFormatEnumToMasks');
  late final _SDL_PixelFormatEnumToMasks2 =
      _SDL_PixelFormatEnumToMasks2Ptr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>, ffi.Pointer<Uint32>, ffi.Pointer<Uint32>)>();

  /// Convert a bpp value and RGBA masks to an enumerated pixel format.
  ///
  /// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
  /// possible.
  ///
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask the red mask for the format
  /// \param Gmask the green mask for the format
  /// \param Bmask the blue mask for the format
  /// \param Amask the alpha mask for the format
  /// \returns one of the SDL_PixelFormatEnum values
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PixelFormatEnumToMasks
  int SDL_MasksToPixelFormatEnum2(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum2(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnum2Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Int, Uint32, Uint32, Uint32,
              Uint32)>>('SDL_MasksToPixelFormatEnum');
  late final _SDL_MasksToPixelFormatEnum2 = _SDL_MasksToPixelFormatEnum2Ptr
      .asFunction<int Function(int, int, int, int, int)>();

  /// Create an SDL_PixelFormat structure corresponding to a pixel format.
  ///
  /// Returned structure may come from a shared global cache (i.e. not newly
  /// allocated), and hence should not be modified, especially the palette. Weird
  /// errors such as `Blit combination not supported` may occur.
  ///
  /// \param pixel_format one of the SDL_PixelFormatEnum values
  /// \returns the new SDL_PixelFormat structure or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeFormat
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat2(
    int pixel_format,
  ) {
    return _SDL_AllocFormat2(
      pixel_format,
    );
  }

  late final _SDL_AllocFormat2Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_PixelFormat> Function(Uint32)>>(
      'SDL_AllocFormat');
  late final _SDL_AllocFormat2 = _SDL_AllocFormat2Ptr.asFunction<
      ffi.Pointer<SDL_PixelFormat> Function(int)>();

  /// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().
  ///
  /// \param format the SDL_PixelFormat structure to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  void SDL_FreeFormat2(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat2(
      format,
    );
  }

  late final _SDL_FreeFormat2Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_PixelFormat>)>>(
      'SDL_FreeFormat');
  late final _SDL_FreeFormat2 = _SDL_FreeFormat2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_PixelFormat>)>();

  /// Create a palette structure with the specified number of color entries.
  ///
  /// The palette entries are initialized to white.
  ///
  /// \param ncolors represents the number of color entries in the color palette
  /// \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
  /// there wasn't enough memory); call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreePalette
  ffi.Pointer<SDL_Palette> SDL_AllocPalette2(
    int ncolors,
  ) {
    return _SDL_AllocPalette2(
      ncolors,
    );
  }

  late final _SDL_AllocPalette2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Palette> Function(ffi.Int)>>(
          'SDL_AllocPalette');
  late final _SDL_AllocPalette2 = _SDL_AllocPalette2Ptr.asFunction<
      ffi.Pointer<SDL_Palette> Function(int)>();

  /// Set the palette for a pixel format structure.
  ///
  /// \param format the SDL_PixelFormat structure that will use the palette
  /// \param palette the SDL_Palette structure that will be used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_FreePalette
  int SDL_SetPixelFormatPalette2(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette2(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalette2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetPixelFormatPalette');
  late final _SDL_SetPixelFormatPalette2 =
      _SDL_SetPixelFormatPalette2Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<SDL_Palette>)>();

  /// Set a range of colors in a palette.
  ///
  /// \param palette the SDL_Palette structure to modify
  /// \param colors an array of SDL_Color structures to copy into the palette
  /// \param firstcolor the index of the first palette entry to modify
  /// \param ncolors the number of entries to modify
  /// \returns 0 on success or a negative error code if not all of the colors
  /// could be set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_CreateRGBSurface
  int SDL_SetPaletteColors2(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors2(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColors2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>,
              ffi.Int, ffi.Int)>>('SDL_SetPaletteColors');
  late final _SDL_SetPaletteColors2 = _SDL_SetPaletteColors2Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>, int, int)>();

  /// Free a palette created with SDL_AllocPalette().
  ///
  /// \param palette the SDL_Palette structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  void SDL_FreePalette2(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette2(
      palette,
    );
  }

  late final _SDL_FreePalette2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Palette>)>>(
          'SDL_FreePalette');
  late final _SDL_FreePalette2 = _SDL_FreePalette2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Palette>)>();

  /// Map an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// This function maps the RGB color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGB color value for
  /// the given pixel format.
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the specified pixel format has an alpha component it will be returned as
  /// all 1 bits (fully opaque).
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the pixel format
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGBA
  int SDL_MapRGB2(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB2(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGB2Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8,
              Uint8)>>('SDL_MapRGB');
  late final _SDL_MapRGB2 = _SDL_MapRGB2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int)>();

  /// Map an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// This function maps the RGBA color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGBA color value for
  /// the given pixel format.
  ///
  /// If the specified pixel format has no alpha component the alpha value will
  /// be ignored (as it will be in formats with a palette).
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \param a the alpha component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  int SDL_MapRGBA2(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA2(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBA2Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_MapRGBA');
  late final _SDL_MapRGBA2 = _SDL_MapRGBA2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int, int)>();

  /// Get RGB values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGB2(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetRGB2(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGB2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGB');
  late final _SDL_GetRGB2 = _SDL_GetRGB2Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Get RGBA values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// If the surface has no alpha component, the alpha will be returned as 0xff
  /// (100% opaque).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  /// \param a a pointer filled in with the alpha component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGBA2(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRGBA2(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBA2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGBA');
  late final _SDL_GetRGBA2 = _SDL_GetRGBA2Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Calculate a 256 entry gamma ramp for a gamma value.
  ///
  /// \param gamma a gamma value where 0.0 is black and 1.0 is identity
  /// \param ramp an array of 256 values filled in with the gamma ramp
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  void SDL_CalculateGammaRamp2(
    double gamma,
    ffi.Pointer<Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp2(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRamp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Float, ffi.Pointer<Uint16>)>>('SDL_CalculateGammaRamp');
  late final _SDL_CalculateGammaRamp2 = _SDL_CalculateGammaRamp2Ptr.asFunction<
      void Function(double, ffi.Pointer<Uint16>)>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile2(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile2(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile2 = _SDL_RWFromFile2Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP2(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP2(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP2 = _SDL_RWFromFP2Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem2(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem2(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem2 = _SDL_RWFromMem2Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem2(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem2(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem2 = _SDL_RWFromConstMem2Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW2() {
    return _SDL_AllocRW2();
  }

  late final _SDL_AllocRW2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW2 =
      _SDL_AllocRW2Ptr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW2(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW2(
      area,
    );
  }

  late final _SDL_FreeRW2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW2 =
      _SDL_FreeRW2Ptr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize2(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize2(
      context,
    );
  }

  late final _SDL_RWsize2Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize2 =
      _SDL_RWsize2Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek2(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek2(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek2Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek2 = _SDL_RWseek2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell2(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell2(
      context,
    );
  }

  late final _SDL_RWtell2Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell2 =
      _SDL_RWtell2Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread2(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread2(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread2 = _SDL_RWread2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite2(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite2(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite2 = _SDL_RWwrite2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose2(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose2(
      context,
    );
  }

  late final _SDL_RWclose2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose2 =
      _SDL_RWclose2Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW2(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW2(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW2 = _SDL_LoadFile_RW2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile2(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile2(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile2 = _SDL_LoadFile2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU82(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU82(
      src,
    );
  }

  late final _SDL_ReadU82Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU82 =
      _SDL_ReadU82Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE162(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE162(
      src,
    );
  }

  late final _SDL_ReadLE162Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE162 =
      _SDL_ReadLE162Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE162(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE162(
      src,
    );
  }

  late final _SDL_ReadBE162Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE162 =
      _SDL_ReadBE162Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE322(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE322(
      src,
    );
  }

  late final _SDL_ReadLE322Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE322 =
      _SDL_ReadLE322Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE322(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE322(
      src,
    );
  }

  late final _SDL_ReadBE322Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE322 =
      _SDL_ReadBE322Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE642(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE642(
      src,
    );
  }

  late final _SDL_ReadLE642Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE642 =
      _SDL_ReadLE642Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE642(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE642(
      src,
    );
  }

  late final _SDL_ReadBE642Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE642 =
      _SDL_ReadBE642Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU82(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU82(
      dst,
      value,
    );
  }

  late final _SDL_WriteU82Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU82 =
      _SDL_WriteU82Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE162(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE162(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE162Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE162 = _SDL_WriteLE162Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE162(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE162(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE162Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE162 = _SDL_WriteBE162Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE322(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE322(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE322Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE322 = _SDL_WriteLE322Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE322(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE322(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE322Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE322 = _SDL_WriteBE322Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE642(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE642(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE642Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE642 = _SDL_WriteLE642Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE642(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE642(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE642Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE642 = _SDL_WriteBE642Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Determine whether two rectangles intersect.
  ///
  /// If either pointer is NULL the function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_IntersectRect
  int SDL_HasIntersection2(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection2(
      A,
      B,
    );
  }

  late final _SDL_HasIntersection2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_HasIntersection');
  late final _SDL_HasIntersection2 = _SDL_HasIntersection2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of two rectangles.
  ///
  /// If `result` is NULL then this function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the intersection of
  /// rectangles `A` and `B`
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasIntersection
  int SDL_IntersectRect2(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect2(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_IntersectRect');
  late final _SDL_IntersectRect2 = _SDL_IntersectRect2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the union of two rectangles.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the union of rectangles
  /// `A` and `B`
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_UnionRect2(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect2(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UnionRect');
  late final _SDL_UnionRect2 = _SDL_UnionRect2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate a minimal rectangle enclosing a set of points.
  ///
  /// If `clip` is not NULL then only points inside of the clipping rectangle are
  /// considered.
  ///
  /// \param points an array of SDL_Point structures representing points to be
  /// enclosed
  /// \param count the number of structures in the `points` array
  /// \param clip an SDL_Rect used for clipping or NULL to enclose all points
  /// \param result an SDL_Rect structure filled in with the minimal enclosing
  /// rectangle
  /// \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
  /// points were outside of the clipping rectangle.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_EnclosePoints2(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints2(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePoints2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Point>,
              ffi.Int,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_EnclosePoints');
  late final _SDL_EnclosePoints2 = _SDL_EnclosePoints2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Point>, int, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of a rectangle and line segment.
  ///
  /// This function is used to clip a line segment to a rectangle. A line segment
  /// contained entirely within the rectangle or that does not intersect will
  /// remain unchanged. A line segment that crosses the rectangle at either or
  /// both ends will be clipped to the boundary of the rectangle and the new
  /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
  ///
  /// \param rect an SDL_Rect structure representing the rectangle to intersect
  /// \param X1 a pointer to the starting X-coordinate of the line
  /// \param Y1 a pointer to the starting Y-coordinate of the line
  /// \param X2 a pointer to the ending X-coordinate of the line
  /// \param Y2 a pointer to the ending Y-coordinate of the line
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_IntersectRectAndLine2(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int> X1,
    ffi.Pointer<ffi.Int> Y1,
    ffi.Pointer<ffi.Int> X2,
    ffi.Pointer<ffi.Int> Y2,
  ) {
    return _SDL_IntersectRectAndLine2(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLine2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_IntersectRectAndLine');
  late final _SDL_IntersectRectAndLine2 =
      _SDL_IntersectRectAndLine2Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Compose a custom blend mode for renderers.
  ///
  /// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
  /// the SDL_BlendMode returned by this function if the renderer supports it.
  ///
  /// A blend mode controls how the pixels from a drawing operation (source) get
  /// combined with the pixels from the render target (destination). First, the
  /// components of the source and destination pixels get multiplied with their
  /// blend factors. Then, the blend operation takes the two products and
  /// calculates the result that will get stored in the render target.
  ///
  /// Expressed in pseudocode, it would look like this:
  ///
  /// ```c
  /// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
  /// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
  /// ```
  ///
  /// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
  /// dst)` can return one of the following:
  ///
  /// - `src + dst`
  /// - `src - dst`
  /// - `dst - src`
  /// - `min(src, dst)`
  /// - `max(src, dst)`
  ///
  /// The red, green, and blue components are always multiplied with the first,
  /// second, and third components of the SDL_BlendFactor, respectively. The
  /// fourth component is not used.
  ///
  /// The alpha component is always multiplied with the fourth component of the
  /// SDL_BlendFactor. The other components are not used in the alpha
  /// calculation.
  ///
  /// Support for these blend modes varies for each renderer. To check if a
  /// specific SDL_BlendMode is supported, create a renderer and pass it to
  /// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
  /// return with an error if the blend mode is not supported.
  ///
  /// This list describes the support of custom blend modes for each renderer in
  /// SDL 2.0.6. All renderers support the four blend modes listed in the
  /// SDL_BlendMode enumeration.
  ///
  /// - **direct3d**: Supports `SDL_BLENDOPERATION_ADD` with all factors.
  /// - **direct3d11**: Supports all operations with all factors. However, some
  /// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
  /// `SDL_BLENDOPERATION_MAXIMUM`.
  /// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL
  /// 2.0.6.
  /// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. Color and alpha factors need to be the same. OpenGL ES 1
  /// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`
  /// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha
  /// operations being different from each other. May support color and alpha
  /// factors being different from each other.
  /// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
  /// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
  /// operations with all factors.
  /// - **psp**: No custom blend mode support.
  /// - **software**: No custom blend mode support.
  ///
  /// Some renderers do not provide an alpha component for the default render
  /// target. The `SDL_BLENDFACTOR_DST_ALPHA` and
  /// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
  /// case.
  ///
  /// \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the source pixels
  /// \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the destination pixels
  /// \param colorOperation the SDL_BlendOperation used to combine the red,
  /// green, and blue components of the source and
  /// destination pixels
  /// \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the source pixels
  /// \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the destination pixels
  /// \param alphaOperation the SDL_BlendOperation used to combine the alpha
  /// component of the source and destination pixels
  /// \returns an SDL_BlendMode that represents the chosen factors and
  /// operations.
  ///
  /// \since This function is available since SDL 2.0.6.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_GetTextureBlendMode
  int SDL_ComposeCustomBlendMode2(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode2(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_ComposeCustomBlendMode');
  late final _SDL_ComposeCustomBlendMode2 = _SDL_ComposeCustomBlendMode2Ptr
      .asFunction<int Function(int, int, int, int, int, int)>();

  /// Allocate a new RGB surface.
  ///
  /// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If `depth` is greater than 8 bits, the pixel format is set using the
  /// [RGBA]mask parameters.
  ///
  /// The [RGBA]mask parameters are the bitmasks used to extract that color from
  /// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
  /// stored in the most significant byte. Using zeros for the RGB masks sets a
  /// default value, based on the depth. For example:
  ///
  /// ```c++
  /// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
  /// ```
  ///
  /// However, using zero for the Amask results in an Amask of 0.
  ///
  /// By default surfaces with an alpha mask are set up for blending as with:
  ///
  /// ```c++
  /// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
  /// ```
  ///
  /// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
  /// different `blendMode`.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface2(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface2(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurface2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32, Uint32, Uint32, Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface2 = _SDL_CreateRGBSurface2Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with a specific pixel format.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except instead
  /// of providing pixel color masks, you provide it with a predefined format
  /// from SDL_PixelFormatEnum.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat2(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat2(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormat2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat2 =
      _SDL_CreateRGBSurfaceWithFormat2Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  /// Allocate a new RGB surface with existing pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except it does
  /// not allocate memory for the pixel data, instead the caller provides an
  /// existing buffer of data for the surface to use.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom2(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom2(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFrom2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom2 =
      _SDL_CreateRGBSurfaceFrom2Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with with a specific pixel format and existing
  /// pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
  /// instead of providing pixel color masks, you provide it with a predefined
  /// format from SDL_PixelFormatEnum.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom2(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom2(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFrom2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom2 =
      _SDL_CreateRGBSurfaceWithFormatFrom2Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// Free an RGB surface.
  ///
  /// It is safe to pass NULL to this function.
  ///
  /// \param surface the SDL_Surface to free.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_LoadBMP
  /// \sa SDL_LoadBMP_RW
  void SDL_FreeSurface2(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface2(
      surface,
    );
  }

  late final _SDL_FreeSurface2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface2 = _SDL_FreeSurface2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the palette used by a surface.
  ///
  /// A single palette can be shared with many surfaces.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param palette the SDL_Palette structure to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetSurfacePalette2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette2(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalette2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette2 = _SDL_SetSurfacePalette2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// Set up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
  /// and read from `surface->pixels`, using the pixel format stored in
  /// `surface->format`. Once you are done accessing the surface, you should use
  /// SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
  /// 0, then you can read and write to the surface at any time, and the pixel
  /// format of the surface will not change.
  ///
  /// \param surface the SDL_Surface structure to be locked
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MUSTLOCK
  /// \sa SDL_UnlockSurface
  int SDL_LockSurface2(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface2(
      surface,
    );
  }

  late final _SDL_LockSurface2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface2 =
      _SDL_LockSurface2Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Release a surface after directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockSurface
  void SDL_UnlockSurface2(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface2(
      surface,
    );
  }

  late final _SDL_UnlockSurface2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface2 = _SDL_UnlockSurface2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a BMP image from a seekable SDL data stream.
  ///
  /// The new surface should be freed with SDL_FreeSurface(). Not doing so will
  /// result in a memory leak.
  ///
  /// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
  /// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
  /// from a file, convert it to an SDL_Surface and then close the file.
  ///
  /// \param src the data stream for the surface
  /// \param freesrc non-zero to close the stream after being read
  /// \returns a pointer to a new SDL_Surface structure or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeSurface
  /// \sa SDL_RWFromFile
  /// \sa SDL_LoadBMP
  /// \sa SDL_SaveBMP_RW
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW2(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW2(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RW2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW2 = _SDL_LoadBMP_RW2Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream in BMP format.
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// \param surface the SDL_Surface structure containing the image to be saved
  /// \param dst a data stream to save to
  /// \param freedst non-zero to close the stream after being written
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadBMP_RW
  /// \sa SDL_SaveBMP
  int SDL_SaveBMP_RW2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW2(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RW2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW2 = _SDL_SaveBMP_RW2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// Set the RLE acceleration hint for a surface.
  ///
  /// If RLE is enabled, color key and alpha blending blits are much faster, but
  /// the surface must be locked before directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to optimize
  /// \param flag 0 to disable, non-zero to enable RLE acceleration
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_LockSurface
  /// \sa SDL_UnlockSurface
  int SDL_SetSurfaceRLE2(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE2(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLE2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int)>>('SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE2 = _SDL_SetSurfaceRLE2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Returns whether the surface is RLE enabled
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SetSurfaceRLE
  int SDL_HasSurfaceRLE2(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE2(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLE2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE2 = _SDL_HasSurfaceRLE2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the color key (transparent pixel) in a surface.
  ///
  /// The color key defines a pixel value that will be treated as transparent in
  /// a blit. For example, one can use this to specify that cyan pixels should be
  /// considered transparent, and therefore not rendered.
  ///
  /// It is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// RLE acceleration can substantially speed up blitting of images with large
  /// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
  /// \param key the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetColorKey
  int SDL_SetColorKey2(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey2(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKey2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey2 = _SDL_SetColorKey2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Returns whether the surface has a color key
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_SetColorKey
  /// \sa SDL_GetColorKey
  int SDL_HasColorKey2(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey2(
      surface,
    );
  }

  late final _SDL_HasColorKey2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasColorKey');
  late final _SDL_HasColorKey2 =
      _SDL_HasColorKey2Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the color key (transparent pixel) for a surface.
  ///
  /// The color key is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// If the surface doesn't have color key enabled this function returns -1.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param key a pointer filled in with the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetColorKey
  int SDL_GetColorKey2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey2(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKey2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey2 = _SDL_GetColorKey2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// Set an additional color value multiplied into blit operations.
  ///
  /// When this surface is blitted, during the blit operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param r the red color value multiplied into blit operations
  /// \param g the green color value multiplied into blit operations
  /// \param b the blue color value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_SetSurfaceColorMod2(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod2(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorMod2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod2 = _SDL_SetSurfaceColorMod2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// Get the additional color value multiplied into blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_GetSurfaceColorMod2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod2(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorMod2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod2 = _SDL_GetSurfaceColorMod2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value used in blit operations.
  ///
  /// When this surface is blitted, during the blit operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param alpha the alpha value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_SetSurfaceAlphaMod2(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod2(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaMod2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, Uint8)>>('SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod2 = _SDL_SetSurfaceAlphaMod2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the additional alpha value used in blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_GetSurfaceAlphaMod2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod2(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaMod2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod2 = _SDL_GetSurfaceAlphaMod2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for blit operations.
  ///
  /// To copy a surface to another surface (or texture) without blending with the
  /// existing data, the blendmode of the SOURCE surface should be set to
  /// `SDL_BLENDMODE_NONE`.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param blendMode the SDL_BlendMode to use for blit blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceBlendMode
  int SDL_SetSurfaceBlendMode2(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode2(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode2 = _SDL_SetSurfaceBlendMode2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the blend mode used for blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetSurfaceBlendMode
  int SDL_GetSurfaceBlendMode2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode2(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode2 =
      _SDL_GetSurfaceBlendMode2Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.Int32>)>();

  /// Set the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// Note that blits are automatically clipped to the edges of the source and
  /// destination surfaces.
  ///
  /// \param surface the SDL_Surface structure to be clipped
  /// \param rect the SDL_Rect structure representing the clipping rectangle, or
  /// NULL to disable clipping
  /// \returns SDL_TRUE if the rectangle intersects the surface, otherwise
  /// SDL_FALSE and blits will be completely clipped.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetClipRect
  int SDL_SetClipRect2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect2(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect2 = _SDL_SetClipRect2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// \param surface the SDL_Surface structure representing the surface to be
  /// clipped
  /// \param rect an SDL_Rect structure filled in with the clipping rectangle for
  /// the surface
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetClipRect
  void SDL_GetClipRect2(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect2(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect2 = _SDL_GetClipRect2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface2(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface2(
      surface,
    );
  }

  late final _SDL_DuplicateSurface2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface2 = _SDL_DuplicateSurface2Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Copy an existing surface to a new surface of the specified format.
  ///
  /// This function is used to optimize images for faster *repeat* blitting. This
  /// is accomplished by converting the original and storing the result as a new
  /// surface. The new, optimized surface can then be used as the source for
  /// future blits, making them faster.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param fmt the SDL_PixelFormat structure that the new surface is optimized
  /// for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurfaceFormat
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface2(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurface2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface2 = _SDL_ConvertSurface2Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  /// Copy an existing surface to a new surface of the specified format enum.
  ///
  /// This function operates just like SDL_ConvertSurface(), but accepts an
  /// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
  /// it might be easier to call but it doesn't have access to palette
  /// information for the destination surface, in case that would be important.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param pixel_format the SDL_PixelFormatEnum that the new surface is
  /// optimized for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurface
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat2(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat2(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormat2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat2 =
      _SDL_ConvertSurfaceFormat2Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// Copy a block of pixels of one format to another format.
  ///
  /// \param width the width of the block to copy, in pixels
  /// \param height the height of the block to copy, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with new pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_ConvertPixels2(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels2(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixels2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels2 = _SDL_ConvertPixels2Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Premultiply the alpha on a block of pixels.
  ///
  /// This is safe to use with src == dst, but not for other overlapping areas.
  ///
  /// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
  ///
  /// \param width the width of the block to convert, in pixels
  /// \param height the height of the block to convert, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with premultiplied pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_PremultiplyAlpha2(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_PremultiplyAlpha2(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_PremultiplyAlpha2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_PremultiplyAlpha');
  late final _SDL_PremultiplyAlpha2 = _SDL_PremultiplyAlpha2Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Perform a fast fill of a rectangle with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL to fill the entire surface
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRects
  int SDL_FillRect2(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect2(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect2 = _SDL_FillRect2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  /// Perform a fast fill of a set of rectangles with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rects an array of SDL_Rects representing the rectangles to fill.
  /// \param count the number of rectangles in the array
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRect
  int SDL_FillRects2(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects2(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRects2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects2 = _SDL_FillRects2Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// Perform a fast blit from the source surface to the destination surface.
  ///
  /// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
  /// macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_UpperBlit2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit2(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlit2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit2 = _SDL_UpperBlit2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface blitting only.
  ///
  /// This is a semi-private blit function and it performs low-level surface
  /// blitting, assuming the input rectangles have already been clipped.
  ///
  /// Unless you know what you're doing, you should be using SDL_BlitSurface()
  /// instead.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied, or NULL to copy the entire surface
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_LowerBlit2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit2(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlit2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit2 = _SDL_LowerBlit2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a fast, low quality, stretch blit between two surfaces of the same
  /// format.
  ///
  /// Please use SDL_BlitScaled() instead.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SoftStretch2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch2(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretch2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch2 = _SDL_SoftStretch2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform bilinear scaling between two surfaces of the same format, 32BPP.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_SoftStretchLinear2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretchLinear2(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchLinear2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretchLinear');
  late final _SDL_SoftStretchLinear2 = _SDL_SoftStretchLinear2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a scaled surface copy to a destination surface.
  ///
  /// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
  /// merely a macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_UpperBlitScaled2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled2(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaled2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled2 = _SDL_UpperBlitScaled2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface scaled blitting only.
  ///
  /// This is a semi-private function and it performs low-level surface blitting,
  /// assuming the input rectangles have already been clipped.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_LowerBlitScaled2(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled2(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaled2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled2 = _SDL_LowerBlitScaled2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Set the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  void SDL_SetYUVConversionMode2(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode2(
      mode,
    );
  }

  late final _SDL_SetYUVConversionMode2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode2 =
      _SDL_SetYUVConversionMode2Ptr.asFunction<void Function(int)>();

  /// Get the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionMode2() {
    return _SDL_GetYUVConversionMode2();
  }

  late final _SDL_GetYUVConversionMode2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode2 =
      _SDL_GetYUVConversionMode2Ptr.asFunction<int Function()>();

  /// Get the YUV conversion mode, returning the correct mode for the resolution
  /// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionModeForResolution2(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution2(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolution2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int, ffi.Int)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution2 =
      _SDL_GetYUVConversionModeForResolution2Ptr.asFunction<
          int Function(int, int)>();

  /// Get the number of video drivers compiled into SDL.
  ///
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVideoDriver
  int SDL_GetNumVideoDrivers2() {
    return _SDL_GetNumVideoDrivers2();
  }

  late final _SDL_GetNumVideoDrivers2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers2 =
      _SDL_GetNumVideoDrivers2Ptr.asFunction<int Function()>();

  /// Get the name of a built in video driver.
  ///
  /// The video drivers are presented in the order in which they are normally
  /// checked during initialization.
  ///
  /// \param index the index of a video driver
  /// \returns the name of the video driver with the given **index**.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  ffi.Pointer<ffi.Char> SDL_GetVideoDriver2(
    int index,
  ) {
    return _SDL_GetVideoDriver2(
      index,
    );
  }

  late final _SDL_GetVideoDriver2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver2 =
      _SDL_GetVideoDriver2Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// This function initializes the video subsystem, setting up a connection to
  /// the window manager, etc, and determines the available display modes and
  /// pixel formats, but does not initialize a window or graphics mode.
  ///
  /// If you use this function and you haven't used the SDL_INIT_VIDEO flag with
  /// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
  /// before calling SDL_Quit().
  ///
  /// It is safe to call this function multiple times. SDL_VideoInit() will call
  /// SDL_VideoQuit() itself if the video subsystem has already been initialized.
  ///
  /// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
  /// specific `driver_name`.
  ///
  /// \param driver_name the name of a video driver to initialize, or NULL for
  /// the default driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  /// \sa SDL_InitSubSystem
  /// \sa SDL_VideoQuit
  int SDL_VideoInit2(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_VideoInit2(
      driver_name,
    );
  }

  late final _SDL_VideoInit2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit2 =
      _SDL_VideoInit2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Shut down the video subsystem, if initialized with SDL_VideoInit().
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_VideoInit
  void SDL_VideoQuit2() {
    return _SDL_VideoQuit2();
  }

  late final _SDL_VideoQuit2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit2 = _SDL_VideoQuit2Ptr.asFunction<void Function()>();

  /// Get the name of the currently initialized video driver.
  ///
  /// \returns the name of the current video driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  ffi.Pointer<ffi.Char> SDL_GetCurrentVideoDriver2() {
    return _SDL_GetCurrentVideoDriver2();
  }

  late final _SDL_GetCurrentVideoDriver2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver2 = _SDL_GetCurrentVideoDriver2Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the number of available video displays.
  ///
  /// \returns a number >= 1 or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  int SDL_GetNumVideoDisplays2() {
    return _SDL_GetNumVideoDisplays2();
  }

  late final _SDL_GetNumVideoDisplays2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays2 =
      _SDL_GetNumVideoDisplays2Ptr.asFunction<int Function()>();

  /// Get the name of a display in UTF-8 encoding.
  ///
  /// \param displayIndex the index of display from which the name should be
  /// queried
  /// \returns the name of a display or NULL for an invalid display index or
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  ffi.Pointer<ffi.Char> SDL_GetDisplayName2(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName2(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayName2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName2 =
      _SDL_GetDisplayName2Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// \param displayIndex the index of the display to query
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayBounds2(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds2(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBounds2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds2 = _SDL_GetDisplayBounds2Ptr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the usable desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Apple's macOS, this
  /// subtracts the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// The parameter `rect` is ignored if it is NULL.
  ///
  /// This function also returns -1 if the parameter `displayIndex` is out of
  /// range.
  ///
  /// \param displayIndex the index of the display to query the usable bounds
  /// from
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayUsableBounds2(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds2(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBounds2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds2 = _SDL_GetDisplayUsableBounds2Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the dots/pixels-per-inch for a display.
  ///
  /// Diagonal, horizontal and vertical DPI can all be optionally returned if the
  /// appropriate parameter is non-NULL.
  ///
  /// A failure of this function usually means that either no DPI information is
  /// available or the `displayIndex` is out of range.
  ///
  /// \param displayIndex the index of the display from which DPI information
  /// should be queried
  /// \param ddpi a pointer filled in with the diagonal DPI of the display; may
  /// be NULL
  /// \param hdpi a pointer filled in with the horizontal DPI of the display; may
  /// be NULL
  /// \param vdpi a pointer filled in with the vertical DPI of the display; may
  /// be NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayDPI2(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI2(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPI2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI2 = _SDL_GetDisplayDPI2Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get the orientation of a display.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns The SDL_DisplayOrientation enum value of the display, or
  /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayOrientation2(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation2(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientation2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation2 =
      _SDL_GetDisplayOrientation2Ptr.asFunction<int Function(int)>();

  /// Get the number of available display modes.
  ///
  /// The `displayIndex` needs to be in the range from 0 to
  /// SDL_GetNumVideoDisplays() - 1.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetNumDisplayModes2(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes2(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModes2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes2 =
      _SDL_GetNumDisplayModes2Ptr.asFunction<int Function(int)>();

  /// Get information about a specific display mode.
  ///
  /// The display modes are sorted in this priority:
  ///
  /// - width -> largest to smallest
  /// - height -> largest to smallest
  /// - bits per pixel -> more colors to fewer colors
  /// - packed pixel layout -> largest to smallest
  /// - refresh rate -> highest to lowest
  ///
  /// \param displayIndex the index of the display to query
  /// \param modeIndex the index of the display mode to query
  /// \param mode an SDL_DisplayMode structure filled in with the mode at
  /// `modeIndex`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumDisplayModes
  int SDL_GetDisplayMode2(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode2(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode2 = _SDL_GetDisplayMode2Ptr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the desktop's display mode.
  ///
  /// There's a difference between this function and SDL_GetCurrentDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the previous native display mode, and not the current
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetCurrentDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetDesktopDisplayMode2(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode2(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode2 = _SDL_GetDesktopDisplayMode2Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the current display mode.
  ///
  /// There's a difference between this function and SDL_GetDesktopDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the current display mode, and not the previous native
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDesktopDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetCurrentDisplayMode2(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode2(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode2 = _SDL_GetCurrentDisplayMode2Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the closest match to the requested display mode.
  ///
  /// The available display modes are scanned and `closest` is filled in with the
  /// closest mode matching the requested mode and returned. The mode format and
  /// refresh rate default to the desktop mode if they are set to 0. The modes
  /// are scanned with size being first priority, format being second priority,
  /// and finally checking the refresh rate. If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure containing the desired display
  /// mode
  /// \param closest an SDL_DisplayMode structure filled in with the closest
  /// match of the available display modes
  /// \returns the passed in value `closest` or NULL if no matching video mode
  /// was available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumDisplayModes
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode2(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode2(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode2 =
      _SDL_GetClosestDisplayMode2Ptr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the index of the display associated with a window.
  ///
  /// \param window the window to query
  /// \returns the index of the display containing the center of the window on
  /// success or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetWindowDisplayIndex2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex2(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex2 = _SDL_GetWindowDisplayIndex2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the display mode to use when a window is visible at fullscreen.
  ///
  /// This only affects the display mode used when the window is fullscreen. To
  /// change the window size when the window is not fullscreen, use
  /// SDL_SetWindowSize().
  ///
  /// \param window the window to affect
  /// \param mode the SDL_DisplayMode structure representing the mode to use, or
  /// NULL to use the window's dimensions and the desktop's format
  /// and refresh rate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_SetWindowDisplayMode2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode2(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode2 =
      _SDL_SetWindowDisplayMode2Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Query the display mode to use when a window is visible at fullscreen.
  ///
  /// \param window the window to query
  /// \param mode an SDL_DisplayMode structure filled in with the fullscreen
  /// display mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_GetWindowDisplayMode2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode2(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayMode2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode2 =
      _SDL_GetWindowDisplayMode2Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the raw ICC profile data for the screen the window is currently on.
  ///
  /// Data returned should be freed with SDL_free.
  ///
  /// \param window the window to query
  /// \param size the size of the ICC profile
  /// \returns the raw ICC profile data on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<ffi.Void> SDL_GetWindowICCProfile2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _SDL_GetWindowICCProfile2(
      window,
      size,
    );
  }

  late final _SDL_GetWindowICCProfile2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Size>)>>('SDL_GetWindowICCProfile');
  late final _SDL_GetWindowICCProfile2 =
      _SDL_GetWindowICCProfile2Ptr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Size>)>();

  /// Get the pixel format associated with the window.
  ///
  /// \param window the window to query
  /// \returns the pixel format of the window on success or
  /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetWindowPixelFormat2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat2(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormat2Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat2 = _SDL_GetWindowPixelFormat2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Create a window with the specified position, dimensions, and flags.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window
  /// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
  /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
  /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
  /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
  /// - `SDL_WINDOW_HIDDEN`: window is not visible
  /// - `SDL_WINDOW_BORDERLESS`: no window decoration
  /// - `SDL_WINDOW_RESIZABLE`: window can be resized
  /// - `SDL_WINDOW_MINIMIZED`: window is minimized
  /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
  /// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
  /// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
  /// supported (>= SDL 2.0.1)
  ///
  /// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
  /// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
  /// queried later using SDL_GetWindowFlags().
  ///
  /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
  /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
  ///
  /// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
  /// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to query the drawable size in pixels.
  ///
  /// If the window is set fullscreen, the width and height parameters `w` and
  /// `h` will not be used. However, invalid size parameters (e.g. too large) may
  /// still fail. Window size is actually limited to 16384 x 16384 for all
  /// platforms at window creation.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// On non-Apple devices, SDL requires you to either not link to the Vulkan
  /// loader or link to a dynamic library version. This limitation may be removed
  /// in a future version of SDL.
  ///
  /// \param title the title of the window, in UTF-8 encoding
  /// \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param w the width of the window, in screen coordinates
  /// \param h the height of the window, in screen coordinates
  /// \param flags 0, or one or more SDL_WindowFlags OR'd together
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindowFrom
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindow2(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow2(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindow2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow2 = _SDL_CreateWindow2Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Create an SDL window from an existing native window.
  ///
  /// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
  /// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
  /// before using SDL_CreateWindowFrom().
  ///
  /// \param data a pointer to driver-dependent window creation data, typically
  /// your native window cast to a void*
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom2(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom2(
      data,
    );
  }

  late final _SDL_CreateWindowFrom2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom2 = _SDL_CreateWindowFrom2Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// Get the numeric ID of a window.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param window the window to query
  /// \returns the ID of the window on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFromID
  int SDL_GetWindowID2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID2(
      window,
    );
  }

  late final _SDL_GetWindowID2Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID2 =
      _SDL_GetWindowID2Ptr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window from a stored ID.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param id the ID of the window
  /// \returns the window associated with `id` or NULL if it doesn't exist; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowID
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID2(
    int id,
  ) {
    return _SDL_GetWindowFromID2(
      id,
    );
  }

  late final _SDL_GetWindowFromID2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID2 = _SDL_GetWindowFromID2Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// Get the window flags.
  ///
  /// \param window the window to query
  /// \returns a mask of the SDL_WindowFlags associated with `window`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_HideWindow
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_SetWindowFullscreen
  /// \sa SDL_SetWindowGrab
  /// \sa SDL_ShowWindow
  int SDL_GetWindowFlags2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags2(
      window,
    );
  }

  late final _SDL_GetWindowFlags2Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags2 = _SDL_GetWindowFlags2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the title of a window.
  ///
  /// This string is expected to be in UTF-8 encoding.
  ///
  /// \param window the window to change
  /// \param title the desired window title in UTF-8 format
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowTitle
  void SDL_SetWindowTitle2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _SDL_SetWindowTitle2(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitle2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle2 = _SDL_SetWindowTitle2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Get the title of a window.
  ///
  /// \param window the window to query
  /// \returns the title of the window in UTF-8 format or "" if there is no
  /// title.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowTitle
  ffi.Pointer<ffi.Char> SDL_GetWindowTitle2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle2(
      window,
    );
  }

  late final _SDL_GetWindowTitle2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle2 = _SDL_GetWindowTitle2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the icon for a window.
  ///
  /// \param window the window to change
  /// \param icon an SDL_Surface structure containing the icon for the window
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_SetWindowIcon2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon2(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIcon2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon2 = _SDL_SetWindowIcon2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// Associate an arbitrary named pointer with a window.
  ///
  /// `name` is case-sensitive.
  ///
  /// \param window the window to associate with the pointer
  /// \param name the name of the pointer
  /// \param userdata the associated pointer
  /// \returns the previous value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowData
  ffi.Pointer<ffi.Void> SDL_SetWindowData2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData2(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowData2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData2 = _SDL_SetWindowData2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Retrieve the data pointer associated with a window.
  ///
  /// \param window the window to query
  /// \param name the name of the pointer
  /// \returns the value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowData
  ffi.Pointer<ffi.Void> SDL_GetWindowData2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetWindowData2(
      window,
      name,
    );
  }

  late final _SDL_GetWindowData2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData2 = _SDL_GetWindowData2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Set the position of a window.
  ///
  /// The window coordinate origin is the upper left of the display.
  ///
  /// \param window the window to reposition
  /// \param x the x coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowPosition
  void SDL_SetWindowPosition2(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition2(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPosition2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition2 = _SDL_SetWindowPosition2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the position of a window.
  ///
  /// If you do not need the value for one of the positions a NULL may be passed
  /// in the `x` or `y` parameter.
  ///
  /// \param window the window to query
  /// \param x a pointer filled in with the x position of the window, in screen
  /// coordinates, may be NULL
  /// \param y a pointer filled in with the y position of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowPosition
  void SDL_GetWindowPosition2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetWindowPosition2(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPosition2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition2 = _SDL_GetWindowPosition2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the size of a window's client area.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// Fullscreen windows automatically match the size of the display mode, and
  /// you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// \param window the window to change
  /// \param w the width of the window in pixels, in screen coordinates, must be
  /// > 0
  /// \param h the height of the window in pixels, in screen coordinates, must be
  /// > 0
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_SetWindowDisplayMode
  void SDL_SetWindowSize2(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize2(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int, ffi.Int)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize2 = _SDL_SetWindowSize2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the size of a window's client area.
  ///
  /// NULL can safely be passed as the `w` or `h` parameter if the width or
  /// height value is not desired.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
  /// real client area size in pixels.
  ///
  /// \param window the window to query the width and height from
  /// \param w a pointer filled in with the width of the window, in screen
  /// coordinates, may be NULL
  /// \param h a pointer filled in with the height of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetDrawableSize
  /// \sa SDL_Vulkan_GetDrawableSize
  /// \sa SDL_SetWindowSize
  void SDL_GetWindowSize2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSize2(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize2 = _SDL_GetWindowSize2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window's borders (decorations) around the client area.
  ///
  /// Note: If this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
  /// window in question was borderless.
  ///
  /// Note: This function may fail on systems where the window has not yet been
  /// decorated by the display server (for example, immediately after calling
  /// SDL_CreateWindow). It is recommended that you wait at least until the
  /// window has been presented and composited, so that the window system has a
  /// chance to decorate the window and provide the border dimensions to SDL.
  ///
  /// This function also returns -1 if getting the information is not supported.
  ///
  /// \param window the window to query the size values of the border
  /// (decorations) from
  /// \param top pointer to variable for storing the size of the top border; NULL
  /// is permitted
  /// \param left pointer to variable for storing the size of the left border;
  /// NULL is permitted
  /// \param bottom pointer to variable for storing the size of the bottom
  /// border; NULL is permitted
  /// \param right pointer to variable for storing the size of the right border;
  /// NULL is permitted
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowSize
  int SDL_GetWindowBordersSize2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> bottom,
    ffi.Pointer<ffi.Int> right,
  ) {
    return _SDL_GetWindowBordersSize2(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize2 =
      _SDL_GetWindowBordersSize2Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the minimum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param min_w the minimum width of the window in pixels
  /// \param min_h the minimum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_SetWindowMinimumSize2(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize2(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize2 = _SDL_SetWindowMinimumSize2Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the minimum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the minimum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the minimum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_GetWindowMinimumSize2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMinimumSize2(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize2 =
      _SDL_GetWindowMinimumSize2Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the maximum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param max_w the maximum width of the window in pixels
  /// \param max_h the maximum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_SetWindowMaximumSize2(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize2(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize2 = _SDL_SetWindowMaximumSize2Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the maximum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the maximum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the maximum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_GetWindowMaximumSize2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMaximumSize2(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize2 =
      _SDL_GetWindowMaximumSize2Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the border state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
  /// or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// You can't change the border state of a fullscreen window.
  ///
  /// \param window the window of which to change the border state
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowBordered2(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered2(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBordered2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered2 = _SDL_SetWindowBordered2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
  /// allow/disallow user resizing of the window. This is a no-op if the window's
  /// resizable state already matches the requested state.
  ///
  /// You can't change the resizable state of a fullscreen window.
  ///
  /// \param window the window of which to change the resizable state
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowResizable2(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable2(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizable2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable2 = _SDL_SetWindowResizable2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the window to always be above the others.
  ///
  /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
  /// will bring the window to the front and keep the window above the rest.
  ///
  /// \param window The window of which to change the always on top state
  /// \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
  /// disable
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowAlwaysOnTop2(
    ffi.Pointer<SDL_Window> window,
    int on_top,
  ) {
    return _SDL_SetWindowAlwaysOnTop2(
      window,
      on_top,
    );
  }

  late final _SDL_SetWindowAlwaysOnTop2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowAlwaysOnTop');
  late final _SDL_SetWindowAlwaysOnTop2 = _SDL_SetWindowAlwaysOnTop2Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Show a window.
  ///
  /// \param window the window to show
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HideWindow
  /// \sa SDL_RaiseWindow
  void SDL_ShowWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow2(
      window,
    );
  }

  late final _SDL_ShowWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow2 =
      _SDL_ShowWindow2Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Hide a window.
  ///
  /// \param window the window to hide
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowWindow
  void SDL_HideWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow2(
      window,
    );
  }

  late final _SDL_HideWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow2 =
      _SDL_HideWindow2Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Raise a window above other windows and set the input focus.
  ///
  /// \param window the window to raise
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_RaiseWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow2(
      window,
    );
  }

  late final _SDL_RaiseWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow2 =
      _SDL_RaiseWindow2Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Make a window as large as possible.
  ///
  /// \param window the window to maximize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MaximizeWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow2(
      window,
    );
  }

  late final _SDL_MaximizeWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow2 = _SDL_MaximizeWindow2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Minimize a window to an iconic representation.
  ///
  /// \param window the window to minimize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MinimizeWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow2(
      window,
    );
  }

  late final _SDL_MinimizeWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow2 = _SDL_MinimizeWindow2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Restore the size and position of a minimized or maximized window.
  ///
  /// \param window the window to restore
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  void SDL_RestoreWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow2(
      window,
    );
  }

  late final _SDL_RestoreWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow2 = _SDL_RestoreWindow2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's fullscreen state.
  ///
  /// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
  /// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
  /// that takes the size of the desktop; and 0 for windowed mode.
  ///
  /// \param window the window to change
  /// \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_SetWindowFullscreen2(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen2(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreen2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, Uint32)>>('SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen2 = _SDL_SetWindowFullscreen2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get the SDL surface associated with the window.
  ///
  /// A new surface will be created with the optimal format for the window, if
  /// necessary. This surface will be freed when the window is destroyed. Do not
  /// free this surface.
  ///
  /// This surface will be invalidated if the window is resized. After resizing a
  /// window this function must be called again to return a valid surface.
  ///
  /// You may not combine this with 3D or the rendering API on this window.
  ///
  /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
  ///
  /// \param window the window to query
  /// \returns the surface associated with the window, or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UpdateWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface2(
      window,
    );
  }

  late final _SDL_GetWindowSurface2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface2 = _SDL_GetWindowSurface2Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// Copy the window surface to the screen.
  ///
  /// This is the function you use to reflect any changes to the surface on the
  /// screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_Flip().
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  int SDL_UpdateWindowSurface2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface2(
      window,
    );
  }

  late final _SDL_UpdateWindowSurface2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface2 = _SDL_UpdateWindowSurface2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Copy areas of the window surface to the screen.
  ///
  /// This is the function you use to reflect changes to portions of the surface
  /// on the screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
  ///
  /// \param window the window to update
  /// \param rects an array of SDL_Rect structures representing areas of the
  /// surface to copy
  /// \param numrects the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurface
  int SDL_UpdateWindowSurfaceRects2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects2(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRects2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects2 =
      _SDL_UpdateWindowSurfaceRects2Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// Set a window's input grab mode.
  ///
  /// When input is grabbed, the mouse is confined to the window. This function
  /// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
  /// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window the window for which the input grab mode should be set
  /// \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGrabbedWindow
  /// \sa SDL_GetWindowGrab
  void SDL_SetWindowGrab2(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab2(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrab2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab2 = _SDL_SetWindowGrab2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's keyboard grab mode.
  ///
  /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
  /// the Meta/Super key. Note that not all system keyboard shortcuts can be
  /// captured by applications (one example is Ctrl+Alt+Del on Windows).
  ///
  /// This is primarily intended for specialized applications such as VNC clients
  /// or VM frontends. Normal games should not use keyboard grab.
  ///
  /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
  /// window is full-screen to ensure the user is not trapped in your
  /// application. If you have a custom keyboard shortcut to exit fullscreen
  /// mode, you may suppress this behavior with
  /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window The window for which the keyboard grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowKeyboardGrab
  /// \sa SDL_SetWindowMouseGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowKeyboardGrab2(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowKeyboardGrab2(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowKeyboardGrab2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Int32)>>('SDL_SetWindowKeyboardGrab');
  late final _SDL_SetWindowKeyboardGrab2 = _SDL_SetWindowKeyboardGrab2Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's mouse grab mode.
  ///
  /// Mouse grab confines the mouse cursor to the window.
  ///
  /// \param window The window for which the mouse grab mode should be set.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowMouseGrab
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowMouseGrab2(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowMouseGrab2(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowMouseGrab2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowMouseGrab');
  late final _SDL_SetWindowMouseGrab2 = _SDL_SetWindowMouseGrab2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get a window's input grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGrab
  int SDL_GetWindowGrab2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab2(
      window,
    );
  }

  late final _SDL_GetWindowGrab2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab2 = _SDL_GetWindowGrab2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's keyboard grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowKeyboardGrab2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowKeyboardGrab2(
      window,
    );
  }

  late final _SDL_GetWindowKeyboardGrab2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowKeyboardGrab');
  late final _SDL_GetWindowKeyboardGrab2 = _SDL_GetWindowKeyboardGrab2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's mouse grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowMouseGrab2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseGrab2(
      window,
    );
  }

  late final _SDL_GetWindowMouseGrab2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowMouseGrab');
  late final _SDL_GetWindowMouseGrab2 = _SDL_GetWindowMouseGrab2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window that currently has an input grab enabled.
  ///
  /// \returns the window if input is grabbed or NULL otherwise.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetWindowGrab
  /// \sa SDL_SetWindowGrab
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow2() {
    return _SDL_GetGrabbedWindow2();
  }

  late final _SDL_GetGrabbedWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow2 = _SDL_GetGrabbedWindow2Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Confines the cursor to the specified area of a window.
  ///
  /// Note that this does NOT grab the cursor, it only defines the area a cursor
  /// is restricted to when the window has mouse focus.
  ///
  /// \param window The window that will be associated with the barrier.
  /// \param rect A rectangle area in window-relative coordinates. If NULL the
  /// barrier for the specified window will be destroyed.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetWindowMouseRect
  /// \sa SDL_SetWindowMouseGrab
  int SDL_SetWindowMouseRect2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetWindowMouseRect2(
      window,
      rect,
    );
  }

  late final _SDL_SetWindowMouseRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetWindowMouseRect');
  late final _SDL_SetWindowMouseRect2 = _SDL_SetWindowMouseRect2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>)>();

  /// Get the mouse confinement rectangle of a window.
  ///
  /// \param window The window to query
  /// \returns A pointer to the mouse confinement rectangle of a window, or NULL
  /// if there isn't one.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetWindowMouseRect
  ffi.Pointer<SDL_Rect> SDL_GetWindowMouseRect2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseRect2(
      window,
    );
  }

  late final _SDL_GetWindowMouseRect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Rect> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowMouseRect');
  late final _SDL_GetWindowMouseRect2 = _SDL_GetWindowMouseRect2Ptr.asFunction<
      ffi.Pointer<SDL_Rect> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method sets the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The
  /// brightness set will not follow the window if it is moved to another
  /// display.
  ///
  /// Many platforms will refuse to set the display brightness in modern times.
  /// You are better off using a shader to adjust gamma during rendering, or
  /// something similar.
  ///
  /// \param window the window used to select the display whose brightness will
  /// be changed
  /// \param brightness the brightness (gamma multiplier) value to set where 0.0
  /// is completely dark and 1.0 is normal brightness
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowBrightness
  /// \sa SDL_SetWindowGammaRamp
  int SDL_SetWindowBrightness2(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness2(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightness2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness2 = _SDL_SetWindowBrightness2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose brightness will
  /// be queried
  /// \returns the brightness for the display where 0.0 is completely dark and
  /// 1.0 is normal brightness.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowBrightness
  double SDL_GetWindowBrightness2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness2(
      window,
    );
  }

  late final _SDL_GetWindowBrightness2Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness2 = _SDL_GetWindowBrightness2Ptr
      .asFunction<double Function(ffi.Pointer<SDL_Window>)>();

  /// Set the opacity for a window.
  ///
  /// The parameter `opacity` will be clamped internally between 0.0f
  /// (transparent) and 1.0f (opaque).
  ///
  /// This function also returns -1 if setting the opacity isn't supported.
  ///
  /// \param window the window which will be made transparent or opaque
  /// \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowOpacity
  int SDL_SetWindowOpacity2(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity2(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacity2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity2 = _SDL_SetWindowOpacity2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// The parameter `opacity` is ignored if it is NULL.
  ///
  /// This function also returns -1 if an invalid window was provided.
  ///
  /// \param window the window to get the current opacity value from
  /// \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_SetWindowOpacity
  int SDL_GetWindowOpacity2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity2(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacity2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity2 = _SDL_GetWindowOpacity2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// Set the window as a modal for another window.
  ///
  /// \param modal_window the window that should be set modal
  /// \param parent_window the parent window for the modal window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  int SDL_SetWindowModalFor2(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor2(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalFor2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor2 = _SDL_SetWindowModalFor2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// Explicitly set input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that is completely
  /// obscured by other windows.
  ///
  /// \param window the window that should get the input focus
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RaiseWindow
  int SDL_SetWindowInputFocus2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus2(
      window,
    );
  }

  late final _SDL_SetWindowInputFocus2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus2 = _SDL_SetWindowInputFocus2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the gamma ramp for the display that owns a given window.
  ///
  /// Set the gamma translation table for the red, green, and blue channels of
  /// the video hardware. Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel. The
  /// input is the index into the array, and the output is the 16-bit gamma value
  /// at that index, scaled to the output color precision.
  ///
  /// Despite the name and signature, this method sets the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
  /// ramp set will not follow the window if it is moved to another display.
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be changed
  /// \param red a 256 element array of 16-bit quantities representing the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities representing the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities representing the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowGammaRamp
  int SDL_SetWindowGammaRamp2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp2(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRamp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp2 = _SDL_SetWindowGammaRamp2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Get the gamma ramp for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be queried
  /// \param red a 256 element array of 16-bit quantities filled in with the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities filled in with the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities filled in with the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  int SDL_GetWindowGammaRamp2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp2(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRamp2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp2 = _SDL_GetWindowGammaRamp2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable from
  /// any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of a
  /// given window as special. This callback is run during event processing if we
  /// need to tell the OS to treat a region of the window specially; the use of
  /// this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within a
  /// special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire when
  /// the OS is deciding whether to drag your window, but it fires for lots of
  /// other reasons, too, some unrelated to anything you probably care about _and
  /// when the mouse isn't actually at the location it is testing_). Since this
  /// can fire at any time, you should try to keep your callback efficient,
  /// devoid of allocations, etc.
  ///
  /// \param window the window to set hit-testing on
  /// \param callback the function to call when doing a hit-test
  /// \param callback_data an app-defined void pointer passed to **callback**
  /// \returns 0 on success or -1 on error (including unsupported); call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_SetWindowHitTest2(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest2(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTest2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest2 = _SDL_SetWindowHitTest2Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// Request a window to demand attention from the user.
  ///
  /// \param window the window to be flashed
  /// \param operation the flash operation
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_FlashWindow2(
    ffi.Pointer<SDL_Window> window,
    int operation,
  ) {
    return _SDL_FlashWindow2(
      window,
      operation,
    );
  }

  late final _SDL_FlashWindow2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_FlashWindow');
  late final _SDL_FlashWindow2 = _SDL_FlashWindow2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Destroy a window.
  ///
  /// If `window` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid window". See SDL_GetError().
  ///
  /// \param window the window to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_CreateWindowFrom
  void SDL_DestroyWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow2(
      window,
    );
  }

  late final _SDL_DestroyWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow2 = _SDL_DestroyWindow2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Check whether the screensaver is currently enabled.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
  ///
  /// \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
  /// disabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_EnableScreenSaver
  int SDL_IsScreenSaverEnabled2() {
    return _SDL_IsScreenSaverEnabled2();
  }

  late final _SDL_IsScreenSaverEnabled2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled2 =
      _SDL_IsScreenSaverEnabled2Ptr.asFunction<int Function()>();

  /// Allow the screen to be blanked by a screen saver.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_EnableScreenSaver2() {
    return _SDL_EnableScreenSaver2();
  }

  late final _SDL_EnableScreenSaver2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver2 =
      _SDL_EnableScreenSaver2Ptr.asFunction<void Function()>();

  /// Prevent the screen from being blanked by a screen saver.
  ///
  /// If you disable the screensaver, it is automatically re-enabled when SDL
  /// quits.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_EnableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_DisableScreenSaver2() {
    return _SDL_DisableScreenSaver2();
  }

  late final _SDL_DisableScreenSaver2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver2 =
      _SDL_DisableScreenSaver2Ptr.asFunction<void Function()>();

  /// Dynamically load an OpenGL library.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows. If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// If you do this, you need to retrieve all of the GL functions used in your
  /// program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \param path the platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetProcAddress
  /// \sa SDL_GL_UnloadLibrary
  int SDL_GL_LoadLibrary2(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _SDL_GL_LoadLibrary2(
      path,
    );
  }

  late final _SDL_GL_LoadLibrary2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary2 =
      _SDL_GL_LoadLibrary2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get an OpenGL function by name.
  ///
  /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
  /// GL functions must be retrieved this way. Usually this is used to retrieve
  /// function pointers to OpenGL extensions.
  ///
  /// There are some quirks to looking up OpenGL functions that require some
  /// extra care from the application. If you code carefully, you can handle
  /// these quirks without any platform-specific code, though:
  ///
  /// - On Windows, function pointers are specific to the current GL context;
  /// this means you need to have created a GL context and made it current
  /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
  /// create a second context, you should assume that any existing function
  /// pointers aren't valid to use with it. This is (currently) a
  /// Windows-specific limitation, and in practice lots of drivers don't suffer
  /// this limitation, but it is still the way the wgl API is documented to
  /// work and you should expect crashes if you don't respect it. Store a copy
  /// of the function pointers that comes and goes with context lifespan.
  /// - On X11, function pointers returned by this function are valid for any
  /// context, and can even be looked up before a context is created at all.
  /// This means that, for at least some common OpenGL implementations, if you
  /// look up a function that doesn't exist, you'll get a non-NULL result that
  /// is _NOT_ safe to call. You must always make sure the function is actually
  /// available for a given GL context before calling it, by checking for the
  /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
  /// or verifying that the version of OpenGL you're using offers the function
  /// as core functionality.
  /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
  /// isn't supported, but you can't count on this behavior. Check for
  /// extensions you use, and if you get a NULL anyway, act as if that
  /// extension wasn't available. This is probably a bug in the driver, but you
  /// can code defensively for this scenario anyhow.
  /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
  /// Next-gen display servers are waiting to replace it, and may or may not
  /// make the same promises about function pointers.
  /// - OpenGL function pointers must be declared `APIENTRY` as in the example
  /// code. This will ensure the proper calling convention is followed on
  /// platforms where this matters (Win32) thereby avoiding stack corruption.
  ///
  /// \param proc the name of an OpenGL function
  /// \returns a pointer to the named OpenGL function. The returned pointer
  /// should be cast to the appropriate function signature.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ExtensionSupported
  /// \sa SDL_GL_LoadLibrary
  /// \sa SDL_GL_UnloadLibrary
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress2(
    ffi.Pointer<ffi.Char> proc,
  ) {
    return _SDL_GL_GetProcAddress2(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddress2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress2 = _SDL_GL_GetProcAddress2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_LoadLibrary
  void SDL_GL_UnloadLibrary2() {
    return _SDL_GL_UnloadLibrary2();
  }

  late final _SDL_GL_UnloadLibrary2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary2 =
      _SDL_GL_UnloadLibrary2Ptr.asFunction<void Function()>();

  /// Check if an OpenGL extension is supported for the current context.
  ///
  /// This function operates on the current GL context; you must have created a
  /// context and it must be current before calling this function. Do not assume
  /// that all contexts you create will have the same set of extensions
  /// available, or that recreating an existing context will offer the same
  /// extensions again.
  ///
  /// While it's probably not a massive overhead, this function is not an O(1)
  /// operation. Check the extensions you care about after creating the GL
  /// context and save that information somewhere instead of calling the function
  /// every time you need to know.
  ///
  /// \param extension the name of the extension to check
  /// \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GL_ExtensionSupported2(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _SDL_GL_ExtensionSupported2(
      extension1,
    );
  }

  late final _SDL_GL_ExtensionSupported2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported2 = _SDL_GL_ExtensionSupported2Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Reset all previously set OpenGL context attributes to their default values.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_SetAttribute
  void SDL_GL_ResetAttributes2() {
    return _SDL_GL_ResetAttributes2();
  }

  late final _SDL_GL_ResetAttributes2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes2 =
      _SDL_GL_ResetAttributes2Ptr.asFunction<void Function()>();

  /// Set an OpenGL window attribute before window creation.
  ///
  /// This function sets the OpenGL attribute `attr` to `value`. The requested
  /// attributes should be set before creating an OpenGL window. You should use
  /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
  /// context, since the values obtained can differ from the requested ones.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
  /// \param value the desired value for the attribute
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_ResetAttributes
  int SDL_GL_SetAttribute2(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute2(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttribute2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32, ffi.Int)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute2 =
      _SDL_GL_SetAttribute2Ptr.asFunction<int Function(int, int)>();

  /// Get the actual value for an attribute from the current context.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
  /// \param value a pointer filled in with the current value of `attr`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ResetAttributes
  /// \sa SDL_GL_SetAttribute
  int SDL_GL_GetAttribute2(
    int attr,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _SDL_GL_GetAttribute2(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttribute2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, ffi.Pointer<ffi.Int>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute2 = _SDL_GL_GetAttribute2Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Create an OpenGL context for an OpenGL window, and make it current.
  ///
  /// Windows users new to OpenGL should note that, for historical reasons, GL
  /// functions added after OpenGL version 1.1 are not available by default.
  /// Those functions must be loaded at run-time, either with an OpenGL
  /// extension-handling library or with SDL_GL_GetProcAddress() and its related
  /// functions.
  ///
  /// SDL_GLContext is an alias for `void *`. It's opaque to the application.
  ///
  /// \param window the window to associate with the context
  /// \returns the OpenGL context associated with `window` or NULL on error; call
  /// SDL_GetError() for more details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_DeleteContext
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_CreateContext2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext2(
      window,
    );
  }

  late final _SDL_GL_CreateContext2Ptr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext2 = _SDL_GL_CreateContext2Ptr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// The context must have been created with a compatible window.
  ///
  /// \param window the window to associate with the context
  /// \param context the OpenGL context to associate with the window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  int SDL_GL_MakeCurrent2(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent2(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrent2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent2 = _SDL_GL_MakeCurrent2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// Get the currently active OpenGL window.
  ///
  /// \returns the currently active OpenGL window on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow2() {
    return _SDL_GL_GetCurrentWindow2();
  }

  late final _SDL_GL_GetCurrentWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow2 = _SDL_GL_GetCurrentWindow2Ptr
      .asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Get the currently active OpenGL context.
  ///
  /// \returns the currently active OpenGL context or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_GetCurrentContext2() {
    return _SDL_GL_GetCurrentContext2();
  }

  late final _SDL_GL_GetCurrentContext2Ptr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext2 =
      _SDL_GL_GetCurrentContext2Ptr.asFunction<SDL_GLContext Function()>();

  /// Get the size of a window's underlying drawable in pixels.
  ///
  /// This returns info useful for calling glViewport().
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GL_GetDrawableSize2(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GL_GetDrawableSize2(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize2 = _SDL_GL_GetDrawableSize2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the swap interval for the current OpenGL context.
  ///
  /// Some systems allow specifying -1 for the interval, to enable adaptive
  /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
  /// the vertical retrace for a given frame, it swaps buffers immediately, which
  /// might be less jarring for the user during occasional framerate drops. If an
  /// application requests adaptive vsync and the system does not support it,
  /// this function will fail and return -1. In such a case, you should probably
  /// retry the call with 1 for the interval.
  ///
  /// Adaptive vsync is implemented for some glX drivers with
  /// GLX_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/glx_swap_control_tear.txt
  ///
  /// and for some Windows drivers with WGL_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/wgl_swap_control_tear.txt
  ///
  /// Read more on the Khronos wiki:
  /// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with
  /// the vertical retrace, -1 for adaptive vsync
  /// \returns 0 on success or -1 if setting the swap interval is not supported;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetSwapInterval
  int SDL_GL_SetSwapInterval2(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval2(
      interval,
    );
  }

  late final _SDL_GL_SetSwapInterval2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval2 =
      _SDL_GL_SetSwapInterval2Ptr.asFunction<int Function(int)>();

  /// Get the swap interval for the current OpenGL context.
  ///
  /// If the system can't determine the swap interval, or there isn't a valid
  /// current context, this function will return 0 as a safe default.
  ///
  /// \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_SetSwapInterval
  int SDL_GL_GetSwapInterval2() {
    return _SDL_GL_GetSwapInterval2();
  }

  late final _SDL_GL_GetSwapInterval2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval2 =
      _SDL_GL_GetSwapInterval2Ptr.asFunction<int Function()>();

  /// Update a window with OpenGL rendering.
  ///
  /// This is used with double-buffered OpenGL contexts, which are the default.
  ///
  /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
  /// window, otherwise nothing will happen. If you aren't using
  /// glBindFramebuffer(), this is the default and you won't have to do anything
  /// extra.
  ///
  /// \param window the window to change
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GL_SwapWindow2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow2(
      window,
    );
  }

  late final _SDL_GL_SwapWindow2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow2 = _SDL_GL_SwapWindow2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Delete an OpenGL context.
  ///
  /// \param context the OpenGL context to be deleted
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  void SDL_GL_DeleteContext2(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext2(
      context,
    );
  }

  late final _SDL_GL_DeleteContext2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext2 =
      _SDL_GL_DeleteContext2Ptr.asFunction<void Function(SDL_GLContext)>();

  /// Query the window which currently has keyboard focus.
  ///
  /// \returns the window with keyboard focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetKeyboardFocus1() {
    return _SDL_GetKeyboardFocus1();
  }

  late final _SDL_GetKeyboardFocus1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetKeyboardFocus');
  late final _SDL_GetKeyboardFocus1 = _SDL_GetKeyboardFocus1Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Get a snapshot of the current state of the keyboard.
  ///
  /// The pointer returned is a pointer to an internal SDL array. It will be
  /// valid for the whole lifetime of the application and should not be freed by
  /// the caller.
  ///
  /// A array element with a value of 1 means that the key is pressed and a value
  /// of 0 means that it is not. Indexes into this array are obtained by using
  /// SDL_Scancode values.
  ///
  /// Use SDL_PumpEvents() to update the state array.
  ///
  /// This function gives you the current state after all events have been
  /// processed, so if a key or button has been pressed and released before you
  /// process events, then the pressed state will never show up in the
  /// SDL_GetKeyboardState() calls.
  ///
  /// Note: This function doesn't take into account whether shift has been
  /// pressed or not.
  ///
  /// \param numkeys if non-NULL, receives the length of the returned array
  /// \returns a pointer to an array of key states.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PumpEvents
  ffi.Pointer<Uint8> SDL_GetKeyboardState1(
    ffi.Pointer<ffi.Int> numkeys,
  ) {
    return _SDL_GetKeyboardState1(
      numkeys,
    );
  }

  late final _SDL_GetKeyboardState1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Uint8> Function(
              ffi.Pointer<ffi.Int>)>>('SDL_GetKeyboardState');
  late final _SDL_GetKeyboardState1 = _SDL_GetKeyboardState1Ptr.asFunction<
      ffi.Pointer<Uint8> Function(ffi.Pointer<ffi.Int>)>();

  /// Get the current key modifier state for the keyboard.
  ///
  /// \returns an OR'd combination of the modifier keys for the keyboard. See
  /// SDL_Keymod for details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyboardState
  /// \sa SDL_SetModState
  int SDL_GetModState1() {
    return _SDL_GetModState1();
  }

  late final _SDL_GetModState1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetModState');
  late final _SDL_GetModState1 =
      _SDL_GetModState1Ptr.asFunction<int Function()>();

  /// Set the current key modifier state for the keyboard.
  ///
  /// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
  /// modifier key states on your application. Simply pass your desired modifier
  /// states into `modstate`. This value may be a bitwise, OR'd combination of
  /// SDL_Keymod values.
  ///
  /// This does not change the keyboard state, only the key modifier flags that
  /// SDL reports.
  ///
  /// \param modstate the desired SDL_Keymod for the keyboard
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetModState
  void SDL_SetModState1(
    int modstate,
  ) {
    return _SDL_SetModState1(
      modstate,
    );
  }

  late final _SDL_SetModState1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetModState');
  late final _SDL_SetModState1 =
      _SDL_SetModState1Ptr.asFunction<void Function(int)>();

  /// Get the key code corresponding to the given scancode according to the
  /// current keyboard layout.
  ///
  /// See SDL_Keycode for details.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns the SDL_Keycode that corresponds to the given SDL_Scancode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromKey
  int SDL_GetKeyFromScancode1(
    int scancode,
  ) {
    return _SDL_GetKeyFromScancode1(
      scancode,
    );
  }

  late final _SDL_GetKeyFromScancode1Ptr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Int32)>>(
          'SDL_GetKeyFromScancode');
  late final _SDL_GetKeyFromScancode1 =
      _SDL_GetKeyFromScancode1Ptr.asFunction<int Function(int)>();

  /// Get the scancode corresponding to the given key code according to the
  /// current keyboard layout.
  ///
  /// See SDL_Scancode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns the SDL_Scancode that corresponds to the given SDL_Keycode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromKey1(
    int key,
  ) {
    return _SDL_GetScancodeFromKey1(
      key,
    );
  }

  late final _SDL_GetScancodeFromKey1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_Keycode)>>(
          'SDL_GetScancodeFromKey');
  late final _SDL_GetScancodeFromKey1 =
      _SDL_GetScancodeFromKey1Ptr.asFunction<int Function(int)>();

  /// Get a human-readable name for a scancode.
  ///
  /// See SDL_Scancode for details.
  ///
  /// **Warning**: The returned name is by design not stable across platforms,
  /// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
  /// Windows" under Microsoft Windows, and some scancodes like
  /// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
  /// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
  /// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
  /// unsuitable for creating a stable cross-platform two-way mapping between
  /// strings and scancodes.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns a pointer to the name for the scancode. If the scancode doesn't
  /// have a name this function returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeFromName
  ffi.Pointer<ffi.Char> SDL_GetScancodeName1(
    int scancode,
  ) {
    return _SDL_GetScancodeName1(
      scancode,
    );
  }

  late final _SDL_GetScancodeName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GetScancodeName');
  late final _SDL_GetScancodeName1 = _SDL_GetScancodeName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a scancode from a human-readable name.
  ///
  /// \param name the human-readable scancode name
  /// \returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
  /// recognized; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromName1(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetScancodeFromName1(
      name,
    );
  }

  late final _SDL_GetScancodeFromName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetScancodeFromName');
  late final _SDL_GetScancodeFromName1 = _SDL_GetScancodeFromName1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a human-readable name for a key.
  ///
  /// See SDL_Scancode and SDL_Keycode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns a pointer to a UTF-8 string that stays valid at least until the
  /// next call to this function. If you need it around any longer, you
  /// must copy it. If the key doesn't have a name, this function
  /// returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeFromKey
  ffi.Pointer<ffi.Char> SDL_GetKeyName1(
    int key,
  ) {
    return _SDL_GetKeyName1(
      key,
    );
  }

  late final _SDL_GetKeyName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SDL_Keycode)>>(
          'SDL_GetKeyName');
  late final _SDL_GetKeyName1 =
      _SDL_GetKeyName1Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a key code from a human-readable name.
  ///
  /// \param name the human-readable key name
  /// \returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromName
  int SDL_GetKeyFromName1(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetKeyFromName1(
      name,
    );
  }

  late final _SDL_GetKeyFromName1Ptr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetKeyFromName');
  late final _SDL_GetKeyFromName1 =
      _SDL_GetKeyFromName1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Start accepting Unicode text input events.
  ///
  /// This function will start accepting Unicode text input events in the focused
  /// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and
  /// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in
  /// pair with SDL_StopTextInput().
  ///
  /// On some platforms using this function activates the screen keyboard.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextInputRect
  /// \sa SDL_StopTextInput
  void SDL_StartTextInput1() {
    return _SDL_StartTextInput1();
  }

  late final _SDL_StartTextInput1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StartTextInput');
  late final _SDL_StartTextInput1 =
      _SDL_StartTextInput1Ptr.asFunction<void Function()>();

  /// Check whether or not Unicode text input events are enabled.
  ///
  /// \returns SDL_TRUE if text input events are enabled else SDL_FALSE.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  int SDL_IsTextInputActive1() {
    return _SDL_IsTextInputActive1();
  }

  late final _SDL_IsTextInputActive1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsTextInputActive');
  late final _SDL_IsTextInputActive1 =
      _SDL_IsTextInputActive1Ptr.asFunction<int Function()>();

  /// Stop receiving any text input events.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_StopTextInput1() {
    return _SDL_StopTextInput1();
  }

  late final _SDL_StopTextInput1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StopTextInput');
  late final _SDL_StopTextInput1 =
      _SDL_StopTextInput1Ptr.asFunction<void Function()>();

  /// Set the rectangle used to type Unicode text inputs.
  ///
  /// \param rect the SDL_Rect structure representing the rectangle to receive
  /// text (ignored if NULL)
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_SetTextInputRect1(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetTextInputRect1(
      rect,
    );
  }

  late final _SDL_SetTextInputRect1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Rect>)>>(
          'SDL_SetTextInputRect');
  late final _SDL_SetTextInputRect1 = _SDL_SetTextInputRect1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>)>();

  /// Check whether the platform has screen keyboard support.
  ///
  /// \returns SDL_TRUE if the platform has some screen keyboard support or
  /// SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  /// \sa SDL_IsScreenKeyboardShown
  int SDL_HasScreenKeyboardSupport1() {
    return _SDL_HasScreenKeyboardSupport1();
  }

  late final _SDL_HasScreenKeyboardSupport1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_HasScreenKeyboardSupport');
  late final _SDL_HasScreenKeyboardSupport1 =
      _SDL_HasScreenKeyboardSupport1Ptr.asFunction<int Function()>();

  /// Check whether the screen keyboard is shown for given window.
  ///
  /// \param window the window for which screen keyboard should be queried
  /// \returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasScreenKeyboardSupport
  int SDL_IsScreenKeyboardShown1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsScreenKeyboardShown1(
      window,
    );
  }

  late final _SDL_IsScreenKeyboardShown1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsScreenKeyboardShown');
  late final _SDL_IsScreenKeyboardShown1 = _SDL_IsScreenKeyboardShown1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window which currently has mouse focus.
  ///
  /// \returns the window with mouse focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetMouseFocus1() {
    return _SDL_GetMouseFocus1();
  }

  late final _SDL_GetMouseFocus1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetMouseFocus');
  late final _SDL_GetMouseFocus1 =
      _SDL_GetMouseFocus1Ptr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Retrieve the current state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can be
  /// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
  /// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
  /// mouse cursor position relative to the focus window. You can pass NULL for
  /// either `x` or `y`.
  ///
  /// \param x the x coordinate of the mouse cursor position relative to the
  /// focus window
  /// \param y the y coordinate of the mouse cursor position relative to the
  /// focus window
  /// \returns a 32-bit button bitmask of the current button state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGlobalMouseState
  /// \sa SDL_GetRelativeMouseState
  /// \sa SDL_PumpEvents
  int SDL_GetMouseState1(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetMouseState1(
      x,
      y,
    );
  }

  late final _SDL_GetMouseState1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetMouseState');
  late final _SDL_GetMouseState1 = _SDL_GetMouseState1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Get the current state of the mouse in relation to the desktop.
  ///
  /// This works similarly to SDL_GetMouseState(), but the coordinates will be
  /// reported relative to the top-left of the desktop. This can be useful if you
  /// need to track the mouse outside of a specific window and SDL_CaptureMouse()
  /// doesn't fit your needs. For example, it could be useful if you need to
  /// track the mouse while dragging a window, where coordinates relative to a
  /// window might not be in sync at all times.
  ///
  /// Note: SDL_GetMouseState() returns the mouse position as SDL understands it
  /// from the last pump of the event queue. This function, however, queries the
  /// OS for the current mouse position, and as such, might be a slightly less
  /// efficient function. Unless you know what you're doing and have a good
  /// reason to use this function, you probably want SDL_GetMouseState() instead.
  ///
  /// \param x filled in with the current X coord relative to the desktop; can be
  /// NULL
  /// \param y filled in with the current Y coord relative to the desktop; can be
  /// NULL
  /// \returns the current button state as a bitmask which can be tested using
  /// the SDL_BUTTON(X) macros.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_CaptureMouse
  int SDL_GetGlobalMouseState1(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetGlobalMouseState1(
      x,
      y,
    );
  }

  late final _SDL_GetGlobalMouseState1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetGlobalMouseState');
  late final _SDL_GetGlobalMouseState1 = _SDL_GetGlobalMouseState1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Retrieve the relative state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can be
  /// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
  /// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
  /// mouse deltas since the last call to SDL_GetRelativeMouseState() or since
  /// event initialization. You can pass NULL for either `x` or `y`.
  ///
  /// \param x a pointer filled with the last recorded x coordinate of the mouse
  /// \param y a pointer filled with the last recorded y coordinate of the mouse
  /// \returns a 32-bit button bitmask of the relative button state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetMouseState
  int SDL_GetRelativeMouseState1(
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetRelativeMouseState1(
      x,
      y,
    );
  }

  late final _SDL_GetRelativeMouseState1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetRelativeMouseState');
  late final _SDL_GetRelativeMouseState1 = _SDL_GetRelativeMouseState1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Move the mouse cursor to the given position within the window.
  ///
  /// This function generates a mouse motion event.
  ///
  /// Note that this function will appear to succeed, but not actually move the
  /// mouse when used over Microsoft Remote Desktop.
  ///
  /// \param window the window to move the mouse into, or NULL for the current
  /// mouse focus
  /// \param x the x coordinate within the window
  /// \param y the y coordinate within the window
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WarpMouseGlobal
  void SDL_WarpMouseInWindow1(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_WarpMouseInWindow1(
      window,
      x,
      y,
    );
  }

  late final _SDL_WarpMouseInWindow1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_WarpMouseInWindow');
  late final _SDL_WarpMouseInWindow1 = _SDL_WarpMouseInWindow1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Move the mouse to the given position in global screen space.
  ///
  /// This function generates a mouse motion event.
  ///
  /// A failure of this function usually means that it is unsupported by a
  /// platform.
  ///
  /// Note that this function will appear to succeed, but not actually move the
  /// mouse when used over Microsoft Remote Desktop.
  ///
  /// \param x the x coordinate
  /// \param y the y coordinate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_WarpMouseInWindow
  int SDL_WarpMouseGlobal1(
    int x,
    int y,
  ) {
    return _SDL_WarpMouseGlobal1(
      x,
      y,
    );
  }

  late final _SDL_WarpMouseGlobal1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'SDL_WarpMouseGlobal');
  late final _SDL_WarpMouseGlobal1 =
      _SDL_WarpMouseGlobal1Ptr.asFunction<int Function(int, int)>();

  /// Set relative mouse mode.
  ///
  /// While the mouse is in relative mode, the cursor is hidden, and the driver
  /// will try to report continuous motion in the current window. Only relative
  /// motion events will be delivered, the mouse position will not change.
  ///
  /// Note that this function will not be able to provide continuous relative
  /// motion when used over Microsoft Remote Desktop, instead motion is limited
  /// to the bounds of the screen.
  ///
  /// This function will flush any pending mouse motion.
  ///
  /// \param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// If relative mode is not supported, this returns -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRelativeMouseMode
  int SDL_SetRelativeMouseMode1(
    int enabled,
  ) {
    return _SDL_SetRelativeMouseMode1(
      enabled,
    );
  }

  late final _SDL_SetRelativeMouseMode1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_SetRelativeMouseMode');
  late final _SDL_SetRelativeMouseMode1 =
      _SDL_SetRelativeMouseMode1Ptr.asFunction<int Function(int)>();

  /// Capture the mouse and to track input outside an SDL window.
  ///
  /// Capturing enables your app to obtain mouse events globally, instead of just
  /// within your window. Not all video targets support this function. When
  /// capturing is enabled, the current window will get all mouse events, but
  /// unlike relative mode, no change is made to the cursor and it is not
  /// restrained to your window.
  ///
  /// This function may also deny mouse input to other windows--both those in
  /// your application and others on the system--so you should use this function
  /// sparingly, and in small bursts. For example, you might want to track the
  /// mouse while the user is dragging something, until the user releases a mouse
  /// button. It is not recommended that you capture the mouse for long periods
  /// of time, such as the entire time your app is running. For that, you should
  /// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending
  /// on your goals.
  ///
  /// While captured, mouse events still report coordinates relative to the
  /// current (foreground) window, but those coordinates may be outside the
  /// bounds of the window (including negative values). Capturing is only allowed
  /// for the foreground window. If the window loses focus while capturing, the
  /// capture will be disabled automatically.
  ///
  /// While capturing is enabled, the current window will have the
  /// `SDL_WINDOW_MOUSE_CAPTURE` flag set.
  ///
  /// \param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable.
  /// \returns 0 on success or -1 if not supported; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetGlobalMouseState
  int SDL_CaptureMouse1(
    int enabled,
  ) {
    return _SDL_CaptureMouse1(
      enabled,
    );
  }

  late final _SDL_CaptureMouse1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_CaptureMouse');
  late final _SDL_CaptureMouse1 =
      _SDL_CaptureMouse1Ptr.asFunction<int Function(int)>();

  /// Query whether relative mouse mode is enabled.
  ///
  /// \returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRelativeMouseMode
  int SDL_GetRelativeMouseMode1() {
    return _SDL_GetRelativeMouseMode1();
  }

  late final _SDL_GetRelativeMouseMode1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetRelativeMouseMode');
  late final _SDL_GetRelativeMouseMode1 =
      _SDL_GetRelativeMouseMode1Ptr.asFunction<int Function()>();

  /// Create a cursor using the specified bitmap data and mask (in MSB format).
  ///
  /// `mask` has to be in MSB (Most Significant Bit) format.
  ///
  /// The cursor width (`w`) must be a multiple of 8 bits.
  ///
  /// The cursor is created in black and white according to the following:
  ///
  /// - data=0, mask=1: white
  /// - data=1, mask=1: black
  /// - data=0, mask=0: transparent
  /// - data=1, mask=0: inverted color if possible, black if not.
  ///
  /// Cursors created with this function must be freed with SDL_FreeCursor().
  ///
  /// If you want to have a color cursor, or create your cursor from an
  /// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
  /// hide the cursor and draw your own as part of your game's rendering, but it
  /// will be bound to the framerate.
  ///
  /// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which
  /// provides twelve readily available system cursors to pick from.
  ///
  /// \param data the color value for each pixel of the cursor
  /// \param mask the mask value for each pixel of the cursor
  /// \param w the width of the cursor
  /// \param h the height of the cursor
  /// \param hot_x the X-axis location of the upper left corner of the cursor
  /// relative to the actual mouse position
  /// \param hot_y the Y-axis location of the upper left corner of the cursor
  /// relative to the actual mouse position
  /// \returns a new cursor with the specified parameters on success or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeCursor
  /// \sa SDL_SetCursor
  /// \sa SDL_ShowCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateCursor1(
    ffi.Pointer<Uint8> data,
    ffi.Pointer<Uint8> mask,
    int w,
    int h,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateCursor1(
      data,
      mask,
      w,
      h,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateCursor1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('SDL_CreateCursor');
  late final _SDL_CreateCursor1 = _SDL_CreateCursor1Ptr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int, int)>();

  /// Create a color cursor.
  ///
  /// \param surface an SDL_Surface structure representing the cursor image
  /// \param hot_x the x position of the cursor hot spot
  /// \param hot_y the y position of the cursor hot spot
  /// \returns the new cursor on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_FreeCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateColorCursor1(
    ffi.Pointer<SDL_Surface> surface,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateColorCursor1(
      surface,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateColorCursor1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, ffi.Int,
              ffi.Int)>>('SDL_CreateColorCursor');
  late final _SDL_CreateColorCursor1 = _SDL_CreateColorCursor1Ptr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Create a system cursor.
  ///
  /// \param id an SDL_SystemCursor enum value
  /// \returns a cursor on success or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeCursor
  ffi.Pointer<SDL_Cursor> SDL_CreateSystemCursor1(
    int id,
  ) {
    return _SDL_CreateSystemCursor1(
      id,
    );
  }

  late final _SDL_CreateSystemCursor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function(ffi.Int32)>>(
          'SDL_CreateSystemCursor');
  late final _SDL_CreateSystemCursor1 = _SDL_CreateSystemCursor1Ptr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(int)>();

  /// Set the active cursor.
  ///
  /// This function sets the currently active cursor to the specified one. If the
  /// cursor is currently visible, the change will be immediately represented on
  /// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
  /// this is desired for any reason.
  ///
  /// \param cursor a cursor to make active
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_GetCursor
  /// \sa SDL_ShowCursor
  void SDL_SetCursor1(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_SetCursor1(
      cursor,
    );
  }

  late final _SDL_SetCursor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_SetCursor');
  late final _SDL_SetCursor1 =
      _SDL_SetCursor1Ptr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// Get the active cursor.
  ///
  /// This function returns a pointer to the current cursor which is owned by the
  /// library. It is not necessary to free the cursor with SDL_FreeCursor().
  ///
  /// \returns the active cursor or NULL if there is no mouse.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetCursor
  ffi.Pointer<SDL_Cursor> SDL_GetCursor1() {
    return _SDL_GetCursor1();
  }

  late final _SDL_GetCursor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetCursor');
  late final _SDL_GetCursor1 =
      _SDL_GetCursor1Ptr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// Get the default cursor.
  ///
  /// \returns the default cursor on success or NULL on failure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSystemCursor
  ffi.Pointer<SDL_Cursor> SDL_GetDefaultCursor1() {
    return _SDL_GetDefaultCursor1();
  }

  late final _SDL_GetDefaultCursor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetDefaultCursor');
  late final _SDL_GetDefaultCursor1 = _SDL_GetDefaultCursor1Ptr.asFunction<
      ffi.Pointer<SDL_Cursor> Function()>();

  /// Free a previously-created cursor.
  ///
  /// Use this function to free cursor resources created with SDL_CreateCursor(),
  /// SDL_CreateColorCursor() or SDL_CreateSystemCursor().
  ///
  /// \param cursor the cursor to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateColorCursor
  /// \sa SDL_CreateCursor
  /// \sa SDL_CreateSystemCursor
  void SDL_FreeCursor1(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_FreeCursor1(
      cursor,
    );
  }

  late final _SDL_FreeCursor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_FreeCursor');
  late final _SDL_FreeCursor1 =
      _SDL_FreeCursor1Ptr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// Toggle whether or not the cursor is shown.
  ///
  /// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`
  /// displays the cursor and passing `SDL_DISABLE` hides it.
  ///
  /// The current state of the mouse cursor can be queried by passing
  /// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.
  ///
  /// \param toggle `SDL_ENABLE` to show the cursor, `SDL_DISABLE` to hide it,
  /// `SDL_QUERY` to query the current state without changing it.
  /// \returns `SDL_ENABLE` if the cursor is shown, or `SDL_DISABLE` if the
  /// cursor is hidden, or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateCursor
  /// \sa SDL_SetCursor
  int SDL_ShowCursor1(
    int toggle,
  ) {
    return _SDL_ShowCursor1(
      toggle,
    );
  }

  late final _SDL_ShowCursor1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ShowCursor');
  late final _SDL_ShowCursor1 =
      _SDL_ShowCursor1Ptr.asFunction<int Function(int)>();

  /// Locking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_LockJoysticks1() {
    return _SDL_LockJoysticks1();
  }

  late final _SDL_LockJoysticks1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockJoysticks');
  late final _SDL_LockJoysticks1 =
      _SDL_LockJoysticks1Ptr.asFunction<void Function()>();

  /// Unlocking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_UnlockJoysticks1() {
    return _SDL_UnlockJoysticks1();
  }

  late final _SDL_UnlockJoysticks1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockJoysticks');
  late final _SDL_UnlockJoysticks1 =
      _SDL_UnlockJoysticks1Ptr.asFunction<void Function()>();

  /// Count the number of joysticks attached to the system.
  ///
  /// \returns the number of attached joysticks on success or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  int SDL_NumJoysticks1() {
    return _SDL_NumJoysticks1();
  }

  late final _SDL_NumJoysticks1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumJoysticks');
  late final _SDL_NumJoysticks1 =
      _SDL_NumJoysticks1Ptr.asFunction<int Function()>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system)
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickNameForIndex1(
    int device_index,
  ) {
    return _SDL_JoystickNameForIndex1(
      device_index,
    );
  }

  late final _SDL_JoystickNameForIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_JoystickNameForIndex');
  late final _SDL_JoystickNameForIndex1 = _SDL_JoystickNameForIndex1Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the player index of a joystick, or -1 if it's not available This can be
  /// called before any joysticks are opened.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetDevicePlayerIndex1(
    int device_index,
  ) {
    return _SDL_JoystickGetDevicePlayerIndex1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDevicePlayerIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickGetDevicePlayerIndex');
  late final _SDL_JoystickGetDevicePlayerIndex1 =
      _SDL_JoystickGetDevicePlayerIndex1Ptr.asFunction<int Function(int)>();

  /// Get the implementation-dependent GUID for the joystick at a given device
  /// index.
  ///
  /// This function can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the GUID of the selected joystick. If called on an invalid index,
  /// this function returns a zero GUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetDeviceGUID1(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceGUID1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceGUID1Ptr =
      _lookup<ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceGUID');
  late final _SDL_JoystickGetDeviceGUID1 = _SDL_JoystickGetDeviceGUID1Ptr
      .asFunction<SDL_JoystickGUID Function(int)>();

  /// Get the USB vendor ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the vendor ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB vendor ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceVendor1(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceVendor1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceVendor1Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceVendor');
  late final _SDL_JoystickGetDeviceVendor1 =
      _SDL_JoystickGetDeviceVendor1Ptr.asFunction<int Function(int)>();

  /// Get the USB product ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB product ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProduct1(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProduct1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProduct1Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProduct');
  late final _SDL_JoystickGetDeviceProduct1 =
      _SDL_JoystickGetDeviceProduct1Ptr.asFunction<int Function(int)>();

  /// Get the product version of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product version
  /// isn't available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the product version of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProductVersion1(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProductVersion1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductVersion1Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProductVersion');
  late final _SDL_JoystickGetDeviceProductVersion1 =
      _SDL_JoystickGetDeviceProductVersion1Ptr.asFunction<int Function(int)>();

  /// Get the type of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the SDL_JoystickType of the selected joystick. If called on an
  /// invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceType1(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceType1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceType1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceType');
  late final _SDL_JoystickGetDeviceType1 =
      _SDL_JoystickGetDeviceType1Ptr.asFunction<int Function(int)>();

  /// Get the instance ID of a joystick.
  ///
  /// This can be called before any joysticks are opened. If the index is out of
  /// range, this function will return -1.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the instance id of the selected joystick. If called on an invalid
  /// index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceInstanceID1(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceInstanceID1(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceInstanceID1Ptr =
      _lookup<ffi.NativeFunction<SDL_JoystickID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceInstanceID');
  late final _SDL_JoystickGetDeviceInstanceID1 =
      _SDL_JoystickGetDeviceInstanceID1Ptr.asFunction<int Function(int)>();

  /// Open a joystick for use.
  ///
  /// The `device_index` argument refers to the N'th joystick presently
  /// recognized by SDL on the system. It is **NOT** the same as the instance ID
  /// used to identify the joystick in future events. See
  /// SDL_JoystickInstanceID() for more details about instance IDs.
  ///
  /// The joystick subsystem must be initialized before a joystick can be opened
  /// for use.
  ///
  /// \param device_index the index of the joystick to query
  /// \returns a joystick identifier or NULL if an error occurred; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickInstanceID
  ffi.Pointer<SDL_Joystick> SDL_JoystickOpen1(
    int device_index,
  ) {
    return _SDL_JoystickOpen1(
      device_index,
    );
  }

  late final _SDL_JoystickOpen1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickOpen');
  late final _SDL_JoystickOpen1 = _SDL_JoystickOpen1Ptr.asFunction<
      ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with an instance id.
  ///
  /// \param instance_id the instance id to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromInstanceID1(
    int instance_id,
  ) {
    return _SDL_JoystickFromInstanceID1(
      instance_id,
    );
  }

  late final _SDL_JoystickFromInstanceID1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Joystick> Function(
              SDL_JoystickID)>>('SDL_JoystickFromInstanceID');
  late final _SDL_JoystickFromInstanceID1 = _SDL_JoystickFromInstanceID1Ptr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with a player index.
  ///
  /// \param player_index the player index to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.12.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromPlayerIndex1(
    int player_index,
  ) {
    return _SDL_JoystickFromPlayerIndex1(
      player_index,
    );
  }

  late final _SDL_JoystickFromPlayerIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickFromPlayerIndex');
  late final _SDL_JoystickFromPlayerIndex1 = _SDL_JoystickFromPlayerIndex1Ptr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Attach a new virtual joystick.
  ///
  /// \returns the joystick's device index, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickAttachVirtual1(
    int type,
    int naxes,
    int nbuttons,
    int nhats,
  ) {
    return _SDL_JoystickAttachVirtual1(
      type,
      naxes,
      nbuttons,
      nhats,
    );
  }

  late final _SDL_JoystickAttachVirtual1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int32, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_JoystickAttachVirtual');
  late final _SDL_JoystickAttachVirtual1 = _SDL_JoystickAttachVirtual1Ptr
      .asFunction<int Function(int, int, int, int)>();

  /// Detach a virtual joystick.
  ///
  /// \param device_index a value previously returned from
  /// SDL_JoystickAttachVirtual()
  /// \returns 0 on success, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickDetachVirtual1(
    int device_index,
  ) {
    return _SDL_JoystickDetachVirtual1(
      device_index,
    );
  }

  late final _SDL_JoystickDetachVirtual1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickDetachVirtual');
  late final _SDL_JoystickDetachVirtual1 =
      _SDL_JoystickDetachVirtual1Ptr.asFunction<int Function(int)>();

  /// Query whether or not the joystick at a given device index is virtual.
  ///
  /// \param device_index a joystick device index.
  /// \returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickIsVirtual1(
    int device_index,
  ) {
    return _SDL_JoystickIsVirtual1(
      device_index,
    );
  }

  late final _SDL_JoystickIsVirtual1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickIsVirtual');
  late final _SDL_JoystickIsVirtual1 =
      _SDL_JoystickIsVirtual1Ptr.asFunction<int Function(int)>();

  /// Set values on an opened, virtual-joystick's axis.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param axis the specific axis on the virtual joystick to set.
  /// \param value the new value for the specified axis.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualAxis1(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    int value,
  ) {
    return _SDL_JoystickSetVirtualAxis1(
      joystick,
      axis,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualAxis1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Sint16)>>('SDL_JoystickSetVirtualAxis');
  late final _SDL_JoystickSetVirtualAxis1 = _SDL_JoystickSetVirtualAxis1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's button.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param button the specific button on the virtual joystick to set.
  /// \param value the new value for the specified button.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualButton1(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
    int value,
  ) {
    return _SDL_JoystickSetVirtualButton1(
      joystick,
      button,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualButton1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualButton');
  late final _SDL_JoystickSetVirtualButton1 = _SDL_JoystickSetVirtualButton1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's hat.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param hat the specific hat on the virtual joystick to set.
  /// \param value the new value for the specified hat.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualHat1(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
    int value,
  ) {
    return _SDL_JoystickSetVirtualHat1(
      joystick,
      hat,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualHat1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualHat');
  late final _SDL_JoystickSetVirtualHat1 = _SDL_JoystickSetVirtualHat1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNameForIndex
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickName1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickName1(
      joystick,
    );
  }

  late final _SDL_JoystickName1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickName');
  late final _SDL_JoystickName1 = _SDL_JoystickName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the player index of an opened joystick.
  ///
  /// For XInput controllers this returns the XInput user index. Many joysticks
  /// will not be able to supply this information.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the player index, or -1 if it's not available.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetPlayerIndex1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetPlayerIndex1(
      joystick,
    );
  }

  late final _SDL_JoystickGetPlayerIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetPlayerIndex');
  late final _SDL_JoystickGetPlayerIndex1 = _SDL_JoystickGetPlayerIndex1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Set the player index of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \param player_index the player index to set.
  ///
  /// \since This function is available since SDL 2.0.12.
  void SDL_JoystickSetPlayerIndex1(
    ffi.Pointer<SDL_Joystick> joystick,
    int player_index,
  ) {
    return _SDL_JoystickSetPlayerIndex1(
      joystick,
      player_index,
    );
  }

  late final _SDL_JoystickSetPlayerIndex1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Joystick>,
              ffi.Int)>>('SDL_JoystickSetPlayerIndex');
  late final _SDL_JoystickSetPlayerIndex1 = _SDL_JoystickSetPlayerIndex1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the implementation-dependent GUID for the joystick.
  ///
  /// This function requires an open joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the GUID of the given joystick. If called on an invalid index,
  /// this function returns a zero GUID; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUID1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetGUID1(
      joystick,
    );
  }

  late final _SDL_JoystickGetGUID1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickGUID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetGUID');
  late final _SDL_JoystickGetGUID1 = _SDL_JoystickGetGUID1Ptr.asFunction<
      SDL_JoystickGUID Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB vendor ID of an opened joystick, if available.
  ///
  /// If the vendor ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB vendor ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetVendor1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetVendor1(
      joystick,
    );
  }

  late final _SDL_JoystickGetVendor1Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetVendor');
  late final _SDL_JoystickGetVendor1 = _SDL_JoystickGetVendor1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB product ID of an opened joystick, if available.
  ///
  /// If the product ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB product ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProduct1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProduct1(
      joystick,
    );
  }

  late final _SDL_JoystickGetProduct1Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProduct');
  late final _SDL_JoystickGetProduct1 = _SDL_JoystickGetProduct1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the product version of an opened joystick, if available.
  ///
  /// If the product version isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the product version of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProductVersion1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProductVersion1(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductVersion1Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProductVersion');
  late final _SDL_JoystickGetProductVersion1 =
      _SDL_JoystickGetProductVersion1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the serial number of an opened joystick, if available.
  ///
  /// Returns the serial number of the joystick, or NULL if it is not available.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the serial number of the selected joystick, or NULL if
  /// unavailable.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<ffi.Char> SDL_JoystickGetSerial1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetSerial1(
      joystick,
    );
  }

  late final _SDL_JoystickGetSerial1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetSerial');
  late final _SDL_JoystickGetSerial1 = _SDL_JoystickGetSerial1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the type of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the SDL_JoystickType of the selected joystick.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetType1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetType1(
      joystick,
    );
  }

  late final _SDL_JoystickGetType1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetType');
  late final _SDL_JoystickGetType1 = _SDL_JoystickGetType1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get an ASCII string representation for a given SDL_JoystickGUID.
  ///
  /// You should supply at least 33 bytes for pszGUID.
  ///
  /// \param guid the SDL_JoystickGUID you wish to convert to string
  /// \param pszGUID buffer in which to write the ASCII string
  /// \param cbGUID the size of pszGUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDFromString
  void SDL_JoystickGetGUIDString1(
    SDL_JoystickGUID guid,
    ffi.Pointer<ffi.Char> pszGUID,
    int cbGUID,
  ) {
    return _SDL_JoystickGetGUIDString1(
      guid,
      pszGUID,
      cbGUID,
    );
  }

  late final _SDL_JoystickGetGUIDString1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_JoystickGetGUIDString');
  late final _SDL_JoystickGetGUIDString1 =
      _SDL_JoystickGetGUIDString1Ptr.asFunction<
          void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>, int)>();

  /// Convert a GUID string into a SDL_JoystickGUID structure.
  ///
  /// Performs no error checking. If this function is given a string containing
  /// an invalid GUID, the function will silently succeed, but the GUID generated
  /// will not be useful.
  ///
  /// \param pchGUID string containing an ASCII representation of a GUID
  /// \returns a SDL_JoystickGUID structure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUIDFromString1(
    ffi.Pointer<ffi.Char> pchGUID,
  ) {
    return _SDL_JoystickGetGUIDFromString1(
      pchGUID,
    );
  }

  late final _SDL_JoystickGetGUIDFromString1Ptr = _lookup<
          ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>>(
      'SDL_JoystickGetGUIDFromString');
  late final _SDL_JoystickGetGUIDFromString1 =
      _SDL_JoystickGetGUIDFromString1Ptr.asFunction<
          SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>();

  /// Get the status of a specified joystick.
  ///
  /// \param joystick the joystick to query
  /// \returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickOpen
  int SDL_JoystickGetAttached1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetAttached1(
      joystick,
    );
  }

  late final _SDL_JoystickGetAttached1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetAttached');
  late final _SDL_JoystickGetAttached1 = _SDL_JoystickGetAttached1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the instance ID of an opened joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the instance ID of the specified joystick on success or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  int SDL_JoystickInstanceID1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickInstanceID1(
      joystick,
    );
  }

  late final _SDL_JoystickInstanceID1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickInstanceID');
  late final _SDL_JoystickInstanceID1 = _SDL_JoystickInstanceID1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of general axis controls on a joystick.
  ///
  /// Often, the directional pad on a game controller will either look like 4
  /// separate buttons or a POV hat, and not axes, but all of this is up to the
  /// device and platform.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of axis controls/number of axes on success or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetAxis
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumAxes1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumAxes1(
      joystick,
    );
  }

  late final _SDL_JoystickNumAxes1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumAxes');
  late final _SDL_JoystickNumAxes1 = _SDL_JoystickNumAxes1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of trackballs on a joystick.
  ///
  /// Joystick trackballs have only relative motion events associated with them
  /// and their state cannot be polled.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of trackballs on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetBall
  int SDL_JoystickNumBalls1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumBalls1(
      joystick,
    );
  }

  late final _SDL_JoystickNumBalls1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumBalls');
  late final _SDL_JoystickNumBalls1 = _SDL_JoystickNumBalls1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of POV hats on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of POV hats on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetHat
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumHats1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumHats1(
      joystick,
    );
  }

  late final _SDL_JoystickNumHats1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumHats');
  late final _SDL_JoystickNumHats1 = _SDL_JoystickNumHats1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of buttons on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of buttons on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetButton
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumButtons1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumButtons1(
      joystick,
    );
  }

  late final _SDL_JoystickNumButtons1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumButtons');
  late final _SDL_JoystickNumButtons1 = _SDL_JoystickNumButtons1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update the current state of the open joysticks.
  ///
  /// This is called automatically by the event loop if any joystick events are
  /// enabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickEventState
  void SDL_JoystickUpdate1() {
    return _SDL_JoystickUpdate1();
  }

  late final _SDL_JoystickUpdate1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_JoystickUpdate');
  late final _SDL_JoystickUpdate1 =
      _SDL_JoystickUpdate1Ptr.asFunction<void Function()>();

  /// Enable/disable joystick event polling.
  ///
  /// If joystick events are disabled, you must call SDL_JoystickUpdate()
  /// yourself and manually check the state of the joystick when you want
  /// joystick information.
  ///
  /// It is recommended that you leave joystick event handling enabled.
  ///
  /// **WARNING**: Calling this function may delete all events currently in SDL's
  /// event queue.
  ///
  /// \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
  /// \returns 1 if enabled, 0 if disabled, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// If `state` is `SDL_QUERY` then the current state is returned,
  /// otherwise the new processing state is returned.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerEventState
  int SDL_JoystickEventState1(
    int state,
  ) {
    return _SDL_JoystickEventState1(
      state,
    );
  }

  late final _SDL_JoystickEventState1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickEventState');
  late final _SDL_JoystickEventState1 =
      _SDL_JoystickEventState1Ptr.asFunction<int Function(int)>();

  /// Get the current state of an axis control on a joystick.
  ///
  /// SDL makes no promises about what part of the joystick any given axis refers
  /// to. Your game should have some sort of configuration UI to let users
  /// specify what each axis should be bound to. Alternately, SDL's higher-level
  /// Game Controller API makes a great effort to apply order to this lower-level
  /// interface, so you know that a specific axis is the "left thumb stick," etc.
  ///
  /// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to
  /// 32767) representing the current position of the axis. It may be necessary
  /// to impose certain tolerances on these values to account for jitter.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \returns a 16-bit signed integer representing the current position of the
  /// axis or 0 on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumAxes
  int SDL_JoystickGetAxis1(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
  ) {
    return _SDL_JoystickGetAxis1(
      joystick,
      axis,
    );
  }

  late final _SDL_JoystickGetAxis1Ptr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetAxis');
  late final _SDL_JoystickGetAxis1 = _SDL_JoystickGetAxis1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the initial state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \param state Upon return, the initial value is supplied here.
  /// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetAxisInitialState1(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    ffi.Pointer<Sint16> state,
  ) {
    return _SDL_JoystickGetAxisInitialState1(
      joystick,
      axis,
      state,
    );
  }

  late final _SDL_JoystickGetAxisInitialState1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              ffi.Pointer<Sint16>)>>('SDL_JoystickGetAxisInitialState');
  late final _SDL_JoystickGetAxisInitialState1 =
      _SDL_JoystickGetAxisInitialState1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<Sint16>)>();

  /// Get the current state of a POV hat on a joystick.
  ///
  /// The returned value will be one of the following positions:
  ///
  /// - `SDL_HAT_CENTERED`
  /// - `SDL_HAT_UP`
  /// - `SDL_HAT_RIGHT`
  /// - `SDL_HAT_DOWN`
  /// - `SDL_HAT_LEFT`
  /// - `SDL_HAT_RIGHTUP`
  /// - `SDL_HAT_RIGHTDOWN`
  /// - `SDL_HAT_LEFTUP`
  /// - `SDL_HAT_LEFTDOWN`
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param hat the hat index to get the state from; indices start at index 0
  /// \returns the current hat position.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumHats
  int SDL_JoystickGetHat1(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
  ) {
    return _SDL_JoystickGetHat1(
      joystick,
      hat,
    );
  }

  late final _SDL_JoystickGetHat1Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetHat');
  late final _SDL_JoystickGetHat1 = _SDL_JoystickGetHat1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the ball axis change since the last poll.
  ///
  /// Trackballs can only return relative motion since the last call to
  /// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \param ball the ball index to query; ball indices start at index 0
  /// \param dx stores the difference in the x axis position since the last poll
  /// \param dy stores the difference in the y axis position since the last poll
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumBalls
  int SDL_JoystickGetBall1(
    ffi.Pointer<SDL_Joystick> joystick,
    int ball,
    ffi.Pointer<ffi.Int> dx,
    ffi.Pointer<ffi.Int> dy,
  ) {
    return _SDL_JoystickGetBall1(
      joystick,
      ball,
      dx,
      dy,
    );
  }

  late final _SDL_JoystickGetBall1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Joystick>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_JoystickGetBall');
  late final _SDL_JoystickGetBall1 = _SDL_JoystickGetBall1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the current state of a button on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param button the button index to get the state from; indices start at
  /// index 0
  /// \returns 1 if the specified button is pressed, 0 otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumButtons
  int SDL_JoystickGetButton1(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
  ) {
    return _SDL_JoystickGetButton1(
      joystick,
      button,
    );
  }

  late final _SDL_JoystickGetButton1Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetButton');
  late final _SDL_JoystickGetButton1 = _SDL_JoystickGetButton1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Start a rumble effect.
  ///
  /// Each call to this function cancels any previous rumble effect, and calling
  /// it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left)
  /// rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right)
  /// rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_JoystickHasRumble
  int SDL_JoystickRumble1(
    ffi.Pointer<SDL_Joystick> joystick,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumble1(
      joystick,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumble1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumble');
  late final _SDL_JoystickRumble1 = _SDL_JoystickRumble1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Start a rumble effect in the joystick's triggers
  ///
  /// Each call to this function cancels any previous trigger rumble effect, and
  /// calling it with 0 intensity stops any rumbling.
  ///
  /// Note that this function is for _trigger_ rumble; the first joystick to
  /// support this was the PlayStation 5's DualShock 5 controller. If you want
  /// the (more common) whole-controller rumble, use SDL_JoystickRumble()
  /// instead.
  ///
  /// \param joystick The joystick to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if trigger rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_JoystickHasRumbleTriggers
  int SDL_JoystickRumbleTriggers1(
    ffi.Pointer<SDL_Joystick> joystick,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumbleTriggers1(
      joystick,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumbleTriggers1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumbleTriggers');
  late final _SDL_JoystickRumbleTriggers1 = _SDL_JoystickRumbleTriggers1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Query whether a joystick has an LED.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickHasLED1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasLED1(
      joystick,
    );
  }

  late final _SDL_JoystickHasLED1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasLED');
  late final _SDL_JoystickHasLED1 = _SDL_JoystickHasLED1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumble
  int SDL_JoystickHasRumble1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumble1(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumble1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumble');
  late final _SDL_JoystickHasRumble1 = _SDL_JoystickHasRumble1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support on triggers.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumbleTriggers
  int SDL_JoystickHasRumbleTriggers1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumbleTriggers1(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumbleTriggers1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumbleTriggers');
  late final _SDL_JoystickHasRumbleTriggers1 =
      _SDL_JoystickHasRumbleTriggers1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update a joystick's LED color.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  /// \returns 0 on success, -1 if this joystick does not have a modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetLED1(
    ffi.Pointer<SDL_Joystick> joystick,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_JoystickSetLED1(
      joystick,
      red,
      green,
      blue,
    );
  }

  late final _SDL_JoystickSetLED1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint8, Uint8,
              Uint8)>>('SDL_JoystickSetLED');
  late final _SDL_JoystickSetLED1 = _SDL_JoystickSetLED1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Send a joystick specific effect packet
  ///
  /// \param joystick The joystick to affect
  /// \param data The data to send to the joystick
  /// \param size The size of the data to send to the joystick
  /// \returns 0, or -1 if this joystick or driver doesn't support effect packets
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_JoystickSendEffect1(
    ffi.Pointer<SDL_Joystick> joystick,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _SDL_JoystickSendEffect1(
      joystick,
      data,
      size,
    );
  }

  late final _SDL_JoystickSendEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_JoystickSendEffect');
  late final _SDL_JoystickSendEffect1 = _SDL_JoystickSendEffect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>, int)>();

  /// Close a joystick previously opened with SDL_JoystickOpen().
  ///
  /// \param joystick The joystick device to close
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  void SDL_JoystickClose1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickClose1(
      joystick,
    );
  }

  late final _SDL_JoystickClose1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickClose');
  late final _SDL_JoystickClose1 = _SDL_JoystickClose1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the battery level of a joystick as SDL_JoystickPowerLevel.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \returns the current battery level as SDL_JoystickPowerLevel on success or
  /// `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_JoystickCurrentPowerLevel1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickCurrentPowerLevel1(
      joystick,
    );
  }

  late final _SDL_JoystickCurrentPowerLevel1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickCurrentPowerLevel');
  late final _SDL_JoystickCurrentPowerLevel1 =
      _SDL_JoystickCurrentPowerLevel1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Locking for multi-threaded access to the sensor API
  ///
  /// If you are using the sensor API or handling events from multiple threads
  /// you should use these locking functions to protect access to the sensors.
  ///
  /// In particular, you are guaranteed that the sensor list won't change, so the
  /// API functions that take a sensor index will be valid, and sensor events
  /// will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.14.
  void SDL_LockSensors1() {
    return _SDL_LockSensors1();
  }

  late final _SDL_LockSensors1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockSensors');
  late final _SDL_LockSensors1 =
      _SDL_LockSensors1Ptr.asFunction<void Function()>();

  void SDL_UnlockSensors1() {
    return _SDL_UnlockSensors1();
  }

  late final _SDL_UnlockSensors1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockSensors');
  late final _SDL_UnlockSensors1 =
      _SDL_UnlockSensors1Ptr.asFunction<void Function()>();

  /// Count the number of sensors attached to the system right now.
  ///
  /// \returns the number of sensors detected.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_NumSensors1() {
    return _SDL_NumSensors1();
  }

  late final _SDL_NumSensors1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumSensors');
  late final _SDL_NumSensors1 =
      _SDL_NumSensors1Ptr.asFunction<int Function()>();

  /// Get the implementation dependent name of a sensor.
  ///
  /// \param device_index The sensor to obtain name from
  /// \returns the sensor name, or NULL if `device_index` is out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_SensorGetDeviceName1(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceName1(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_SensorGetDeviceName');
  late final _SDL_SensorGetDeviceName1 = _SDL_SensorGetDeviceName1Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the type of a sensor.
  ///
  /// \param device_index The sensor to get the type from
  /// \returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `device_index` is
  /// out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceType1(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceType1(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceType1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_SensorGetDeviceType');
  late final _SDL_SensorGetDeviceType1 =
      _SDL_SensorGetDeviceType1Ptr.asFunction<int Function(int)>();

  /// Get the platform dependent type of a sensor.
  ///
  /// \param device_index The sensor to check
  /// \returns the sensor platform dependent type, or -1 if `device_index` is out
  /// of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceNonPortableType1(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceNonPortableType1(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNonPortableType1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_SensorGetDeviceNonPortableType');
  late final _SDL_SensorGetDeviceNonPortableType1 =
      _SDL_SensorGetDeviceNonPortableType1Ptr.asFunction<int Function(int)>();

  /// Get the instance ID of a sensor.
  ///
  /// \param device_index The sensor to get instance id from
  /// \returns the sensor instance ID, or -1 if `device_index` is out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceInstanceID1(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceInstanceID1(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceInstanceID1Ptr =
      _lookup<ffi.NativeFunction<SDL_SensorID Function(ffi.Int)>>(
          'SDL_SensorGetDeviceInstanceID');
  late final _SDL_SensorGetDeviceInstanceID1 =
      _SDL_SensorGetDeviceInstanceID1Ptr.asFunction<int Function(int)>();

  /// Open a sensor for use.
  ///
  /// \param device_index The sensor to open
  /// \returns an SDL_Sensor sensor object, or NULL if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<SDL_Sensor> SDL_SensorOpen1(
    int device_index,
  ) {
    return _SDL_SensorOpen1(
      device_index,
    );
  }

  late final _SDL_SensorOpen1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Sensor> Function(ffi.Int)>>(
          'SDL_SensorOpen');
  late final _SDL_SensorOpen1 =
      _SDL_SensorOpen1Ptr.asFunction<ffi.Pointer<SDL_Sensor> Function(int)>();

  /// Return the SDL_Sensor associated with an instance id.
  ///
  /// \param instance_id The sensor from instance id
  /// \returns an SDL_Sensor object.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<SDL_Sensor> SDL_SensorFromInstanceID1(
    int instance_id,
  ) {
    return _SDL_SensorFromInstanceID1(
      instance_id,
    );
  }

  late final _SDL_SensorFromInstanceID1Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_Sensor> Function(SDL_SensorID)>>(
      'SDL_SensorFromInstanceID');
  late final _SDL_SensorFromInstanceID1 = _SDL_SensorFromInstanceID1Ptr
      .asFunction<ffi.Pointer<SDL_Sensor> Function(int)>();

  /// Get the implementation dependent name of a sensor
  ///
  /// \param sensor The SDL_Sensor object
  /// \returns the sensor name, or NULL if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_SensorGetName1(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetName1(
      sensor,
    );
  }

  late final _SDL_SensorGetName1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Sensor>)>>('SDL_SensorGetName');
  late final _SDL_SensorGetName1 = _SDL_SensorGetName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the type of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
  /// NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetType1(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetType1(
      sensor,
    );
  }

  late final _SDL_SensorGetType1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorGetType');
  late final _SDL_SensorGetType1 = _SDL_SensorGetType1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the platform dependent type of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the sensor platform dependent type, or -1 if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetNonPortableType1(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetNonPortableType1(
      sensor,
    );
  }

  late final _SDL_SensorGetNonPortableType1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorGetNonPortableType');
  late final _SDL_SensorGetNonPortableType1 = _SDL_SensorGetNonPortableType1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the instance ID of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the sensor instance ID, or -1 if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetInstanceID1(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetInstanceID1(
      sensor,
    );
  }

  late final _SDL_SensorGetInstanceID1Ptr = _lookup<
          ffi.NativeFunction<SDL_SensorID Function(ffi.Pointer<SDL_Sensor>)>>(
      'SDL_SensorGetInstanceID');
  late final _SDL_SensorGetInstanceID1 = _SDL_SensorGetInstanceID1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the current state of an opened sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  ///
  /// \param sensor The SDL_Sensor object to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  /// \returns 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetData1(
    ffi.Pointer<SDL_Sensor> sensor,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_SensorGetData1(
      sensor,
      data,
      num_values,
    );
  }

  late final _SDL_SensorGetData1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Sensor>, ffi.Pointer<ffi.Float>,
              ffi.Int)>>('SDL_SensorGetData');
  late final _SDL_SensorGetData1 = _SDL_SensorGetData1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor>, ffi.Pointer<ffi.Float>, int)>();

  /// Close a sensor previously opened with SDL_SensorOpen().
  ///
  /// \param sensor The SDL_Sensor object to close
  ///
  /// \since This function is available since SDL 2.0.9.
  void SDL_SensorClose1(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorClose1(
      sensor,
    );
  }

  late final _SDL_SensorClose1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorClose');
  late final _SDL_SensorClose1 =
      _SDL_SensorClose1Ptr.asFunction<void Function(ffi.Pointer<SDL_Sensor>)>();

  /// Update the current state of the open sensors.
  ///
  /// This is called automatically by the event loop if sensor events are
  /// enabled.
  ///
  /// This needs to be called from the thread that initialized the sensor
  /// subsystem.
  ///
  /// \since This function is available since SDL 2.0.9.
  void SDL_SensorUpdate1() {
    return _SDL_SensorUpdate1();
  }

  late final _SDL_SensorUpdate1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_SensorUpdate');
  late final _SDL_SensorUpdate1 =
      _SDL_SensorUpdate1Ptr.asFunction<void Function()>();

  /// Load a set of Game Controller mappings from a seekable SDL data stream.
  ///
  /// You can call this function several times, if needed, to load different
  /// database files.
  ///
  /// If a new mapping is loaded for an already known controller GUID, the later
  /// version will overwrite the one currently loaded.
  ///
  /// Mappings not belonging to the current platform or with no platform field
  /// specified will be ignored (i.e. mappings for Linux will be ignored in
  /// Windows, etc).
  ///
  /// This function will load the text database entirely in memory before
  /// processing it, so take this into consideration if you are in a memory
  /// constrained environment.
  ///
  /// \param rw the data stream for the mappings to be added
  /// \param freerw non-zero to close the stream after being read
  /// \returns the number of mappings added or -1 on error; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GameControllerAddMapping
  /// \sa SDL_GameControllerAddMappingsFromFile
  /// \sa SDL_GameControllerMappingForGUID
  int SDL_GameControllerAddMappingsFromRW1(
    ffi.Pointer<SDL_RWops> rw,
    int freerw,
  ) {
    return _SDL_GameControllerAddMappingsFromRW1(
      rw,
      freerw,
    );
  }

  late final _SDL_GameControllerAddMappingsFromRW1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_GameControllerAddMappingsFromRW');
  late final _SDL_GameControllerAddMappingsFromRW1 =
      _SDL_GameControllerAddMappingsFromRW1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Add support for controllers that SDL is unaware of or to cause an existing
  /// controller to have a different binding.
  ///
  /// The mapping string has the format "GUID,name,mapping", where GUID is the
  /// string value from SDL_JoystickGetGUIDString(), name is the human readable
  /// string for the device and mappings are controller mappings to joystick
  /// ones. Under Windows there is a reserved GUID of "xinput" that covers all
  /// XInput devices. The mapping format for joystick is: {| |bX |a joystick
  /// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick
  /// |} Buttons can be used as a controller axes and vice versa.
  ///
  /// This string shows an example of a valid mapping for a controller:
  ///
  /// ```c
  /// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
  /// ```
  ///
  /// \param mappingString the mapping string
  /// \returns 1 if a new mapping is added, 0 if an existing mapping is updated,
  /// -1 on error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerMapping
  /// \sa SDL_GameControllerMappingForGUID
  int SDL_GameControllerAddMapping1(
    ffi.Pointer<ffi.Char> mappingString,
  ) {
    return _SDL_GameControllerAddMapping1(
      mappingString,
    );
  }

  late final _SDL_GameControllerAddMapping1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GameControllerAddMapping');
  late final _SDL_GameControllerAddMapping1 = _SDL_GameControllerAddMapping1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get the number of mappings installed.
  ///
  /// \returns the number of mappings.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerNumMappings1() {
    return _SDL_GameControllerNumMappings1();
  }

  late final _SDL_GameControllerNumMappings1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GameControllerNumMappings');
  late final _SDL_GameControllerNumMappings1 =
      _SDL_GameControllerNumMappings1Ptr.asFunction<int Function()>();

  /// Get the mapping at a particular index.
  ///
  /// \returns the mapping string. Must be freed with SDL_free(). Returns NULL if
  /// the index is out of range.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Char> SDL_GameControllerMappingForIndex1(
    int mapping_index,
  ) {
    return _SDL_GameControllerMappingForIndex1(
      mapping_index,
    );
  }

  late final _SDL_GameControllerMappingForIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GameControllerMappingForIndex');
  late final _SDL_GameControllerMappingForIndex1 =
      _SDL_GameControllerMappingForIndex1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the game controller mapping string for a given GUID.
  ///
  /// The returned string must be freed with SDL_free().
  ///
  /// \param guid a structure containing the GUID for which a mapping is desired
  /// \returns a mapping string or NULL on error; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUID
  ffi.Pointer<ffi.Char> SDL_GameControllerMappingForGUID1(
    SDL_JoystickGUID guid,
  ) {
    return _SDL_GameControllerMappingForGUID1(
      guid,
    );
  }

  late final _SDL_GameControllerMappingForGUID1Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SDL_JoystickGUID)>>(
      'SDL_GameControllerMappingForGUID');
  late final _SDL_GameControllerMappingForGUID1 =
      _SDL_GameControllerMappingForGUID1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(SDL_JoystickGUID)>();

  /// Get the current mapping of a Game Controller.
  ///
  /// The returned string must be freed with SDL_free().
  ///
  /// Details about mappings are discussed with SDL_GameControllerAddMapping().
  ///
  /// \param gamecontroller the game controller you want to get the current
  /// mapping for
  /// \returns a string that has the controller's mapping or NULL if no mapping
  /// is available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerAddMapping
  /// \sa SDL_GameControllerMappingForGUID
  ffi.Pointer<ffi.Char> SDL_GameControllerMapping1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerMapping1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerMapping1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerMapping');
  late final _SDL_GameControllerMapping1 =
      _SDL_GameControllerMapping1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>)>();

  /// Check if the given joystick is supported by the game controller interface.
  ///
  /// `joystick_index` is the same as the `device_index` passed to
  /// SDL_JoystickOpen().
  ///
  /// \param joystick_index the device_index of a device, up to
  /// SDL_NumJoysticks()
  /// \returns SDL_TRUE if the given joystick is supported by the game controller
  /// interface, SDL_FALSE if it isn't or it's an invalid index.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerNameForIndex
  /// \sa SDL_GameControllerOpen
  int SDL_IsGameController1(
    int joystick_index,
  ) {
    return _SDL_IsGameController1(
      joystick_index,
    );
  }

  late final _SDL_IsGameController1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_IsGameController');
  late final _SDL_IsGameController1 =
      _SDL_IsGameController1Ptr.asFunction<int Function(int)>();

  /// Get the implementation dependent name for the game controller.
  ///
  /// This function can be called before any controllers are opened.
  ///
  /// `joystick_index` is the same as the `device_index` passed to
  /// SDL_JoystickOpen().
  ///
  /// \param joystick_index the device_index of a device, from zero to
  /// SDL_NumJoysticks()-1
  /// \returns the implementation-dependent name for the game controller, or NULL
  /// if there is no name or the index is invalid.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerName
  /// \sa SDL_GameControllerOpen
  /// \sa SDL_IsGameController
  ffi.Pointer<ffi.Char> SDL_GameControllerNameForIndex1(
    int joystick_index,
  ) {
    return _SDL_GameControllerNameForIndex1(
      joystick_index,
    );
  }

  late final _SDL_GameControllerNameForIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GameControllerNameForIndex');
  late final _SDL_GameControllerNameForIndex1 =
      _SDL_GameControllerNameForIndex1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the type of a game controller.
  ///
  /// This can be called before any controllers are opened.
  ///
  /// \param joystick_index the device_index of a device, from zero to
  /// SDL_NumJoysticks()-1
  /// \returns the controller type.
  ///
  /// \since This function is available since SDL 2.0.12.
  int SDL_GameControllerTypeForIndex1(
    int joystick_index,
  ) {
    return _SDL_GameControllerTypeForIndex1(
      joystick_index,
    );
  }

  late final _SDL_GameControllerTypeForIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GameControllerTypeForIndex');
  late final _SDL_GameControllerTypeForIndex1 =
      _SDL_GameControllerTypeForIndex1Ptr.asFunction<int Function(int)>();

  /// Get the mapping of a game controller.
  ///
  /// This can be called before any controllers are opened.
  ///
  /// \param joystick_index the device_index of a device, from zero to
  /// SDL_NumJoysticks()-1
  /// \returns the mapping string. Must be freed with SDL_free(). Returns NULL if
  /// no mapping is available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_GameControllerMappingForDeviceIndex1(
    int joystick_index,
  ) {
    return _SDL_GameControllerMappingForDeviceIndex1(
      joystick_index,
    );
  }

  late final _SDL_GameControllerMappingForDeviceIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GameControllerMappingForDeviceIndex');
  late final _SDL_GameControllerMappingForDeviceIndex1 =
      _SDL_GameControllerMappingForDeviceIndex1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Open a game controller for use.
  ///
  /// `joystick_index` is the same as the `device_index` passed to
  /// SDL_JoystickOpen().
  ///
  /// The index passed as an argument refers to the N'th game controller on the
  /// system. This index is not the value which will identify this controller in
  /// future controller events. The joystick's instance id (SDL_JoystickID) will
  /// be used there instead.
  ///
  /// \param joystick_index the device_index of a device, up to
  /// SDL_NumJoysticks()
  /// \returns a gamecontroller identifier or NULL if an error occurred; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerClose
  /// \sa SDL_GameControllerNameForIndex
  /// \sa SDL_IsGameController
  ffi.Pointer<SDL_GameController> SDL_GameControllerOpen1(
    int joystick_index,
  ) {
    return _SDL_GameControllerOpen1(
      joystick_index,
    );
  }

  late final _SDL_GameControllerOpen1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController> Function(
              ffi.Int)>>('SDL_GameControllerOpen');
  late final _SDL_GameControllerOpen1 = _SDL_GameControllerOpen1Ptr.asFunction<
      ffi.Pointer<SDL_GameController> Function(int)>();

  /// Get the SDL_GameController associated with an instance id.
  ///
  /// \param joyid the instance id to get the SDL_GameController for
  /// \returns an SDL_GameController on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ffi.Pointer<SDL_GameController> SDL_GameControllerFromInstanceID1(
    int joyid,
  ) {
    return _SDL_GameControllerFromInstanceID1(
      joyid,
    );
  }

  late final _SDL_GameControllerFromInstanceID1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController> Function(
              SDL_JoystickID)>>('SDL_GameControllerFromInstanceID');
  late final _SDL_GameControllerFromInstanceID1 =
      _SDL_GameControllerFromInstanceID1Ptr.asFunction<
          ffi.Pointer<SDL_GameController> Function(int)>();

  /// Get the SDL_GameController associated with a player index.
  ///
  /// Please note that the player index is _not_ the device index, nor is it the
  /// instance id!
  ///
  /// \param player_index the player index, which is not the device index or the
  /// instance id!
  /// \returns the SDL_GameController associated with a player index.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_GameControllerGetPlayerIndex
  /// \sa SDL_GameControllerSetPlayerIndex
  ffi.Pointer<SDL_GameController> SDL_GameControllerFromPlayerIndex1(
    int player_index,
  ) {
    return _SDL_GameControllerFromPlayerIndex1(
      player_index,
    );
  }

  late final _SDL_GameControllerFromPlayerIndex1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController> Function(
              ffi.Int)>>('SDL_GameControllerFromPlayerIndex');
  late final _SDL_GameControllerFromPlayerIndex1 =
      _SDL_GameControllerFromPlayerIndex1Ptr.asFunction<
          ffi.Pointer<SDL_GameController> Function(int)>();

  /// Get the implementation-dependent name for an opened game controller.
  ///
  /// This is the same name as returned by SDL_GameControllerNameForIndex(), but
  /// it takes a controller identifier instead of the (unstable) device index.
  ///
  /// \param gamecontroller a game controller identifier previously returned by
  /// SDL_GameControllerOpen()
  /// \returns the implementation dependent name for the game controller, or NULL
  /// if there is no name or the identifier passed is invalid.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerNameForIndex
  /// \sa SDL_GameControllerOpen
  ffi.Pointer<ffi.Char> SDL_GameControllerName1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerName1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerName1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerName');
  late final _SDL_GameControllerName1 = _SDL_GameControllerName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the type of this currently opened controller
  ///
  /// This is the same name as returned by SDL_GameControllerTypeForIndex(), but
  /// it takes a controller identifier instead of the (unstable) device index.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \returns the controller type.
  ///
  /// \since This function is available since SDL 2.0.12.
  int SDL_GameControllerGetType1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetType1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetType1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerGetType');
  late final _SDL_GameControllerGetType1 = _SDL_GameControllerGetType1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the player index of an opened game controller.
  ///
  /// For XInput controllers this returns the XInput user index.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \returns the player index for controller, or -1 if it's not available.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_GameControllerGetPlayerIndex1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetPlayerIndex1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetPlayerIndex1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetPlayerIndex');
  late final _SDL_GameControllerGetPlayerIndex1 =
      _SDL_GameControllerGetPlayerIndex1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Set the player index of an opened game controller.
  ///
  /// \param gamecontroller the game controller object to adjust.
  /// \param player_index Player index to assign to this controller.
  ///
  /// \since This function is available since SDL 2.0.12.
  void SDL_GameControllerSetPlayerIndex1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int player_index,
  ) {
    return _SDL_GameControllerSetPlayerIndex1(
      gamecontroller,
      player_index,
    );
  }

  late final _SDL_GameControllerSetPlayerIndex1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_GameController>,
              ffi.Int)>>('SDL_GameControllerSetPlayerIndex');
  late final _SDL_GameControllerSetPlayerIndex1 =
      _SDL_GameControllerSetPlayerIndex1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the USB vendor ID of an opened controller, if available.
  ///
  /// If the vendor ID isn't available this function returns 0.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the USB vendor ID, or zero if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerGetVendor1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetVendor1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetVendor1Ptr = _lookup<
          ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetVendor');
  late final _SDL_GameControllerGetVendor1 = _SDL_GameControllerGetVendor1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the USB product ID of an opened controller, if available.
  ///
  /// If the product ID isn't available this function returns 0.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the USB product ID, or zero if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerGetProduct1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetProduct1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProduct1Ptr = _lookup<
          ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetProduct');
  late final _SDL_GameControllerGetProduct1 = _SDL_GameControllerGetProduct1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the product version of an opened controller, if available.
  ///
  /// If the product version isn't available this function returns 0.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the USB product version, or zero if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_GameControllerGetProductVersion1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetProductVersion1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProductVersion1Ptr = _lookup<
          ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetProductVersion');
  late final _SDL_GameControllerGetProductVersion1 =
      _SDL_GameControllerGetProductVersion1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the serial number of an opened controller, if available.
  ///
  /// Returns the serial number of the controller, or NULL if it is not
  /// available.
  ///
  /// \param gamecontroller the game controller object to query.
  /// \return the serial number, or NULL if unavailable.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<ffi.Char> SDL_GameControllerGetSerial1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetSerial1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetSerial1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerGetSerial');
  late final _SDL_GameControllerGetSerial1 =
      _SDL_GameControllerGetSerial1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>)>();

  /// Check if a controller has been opened and is currently connected.
  ///
  /// \param gamecontroller a game controller identifier previously returned by
  /// SDL_GameControllerOpen()
  /// \returns SDL_TRUE if the controller has been opened and is currently
  /// connected, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerClose
  /// \sa SDL_GameControllerOpen
  int SDL_GameControllerGetAttached1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetAttached1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetAttached1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetAttached');
  late final _SDL_GameControllerGetAttached1 =
      _SDL_GameControllerGetAttached1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the Joystick ID from a Game Controller.
  ///
  /// This function will give you a SDL_Joystick object, which allows you to use
  /// the SDL_Joystick functions with a SDL_GameController object. This would be
  /// useful for getting a joystick's position at any given time, even if it
  /// hasn't moved (moving it would produce an event, which would have the axis'
  /// value).
  ///
  /// The pointer returned is owned by the SDL_GameController. You should not
  /// call SDL_JoystickClose() on it, for example, since doing so will likely
  /// cause SDL to crash.
  ///
  /// \param gamecontroller the game controller object that you want to get a
  /// joystick from
  /// \returns a SDL_Joystick object; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Joystick> SDL_GameControllerGetJoystick1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetJoystick1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetJoystick1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SDL_Joystick> Function(
                  ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetJoystick');
  late final _SDL_GameControllerGetJoystick1 =
      _SDL_GameControllerGetJoystick1Ptr.asFunction<
          ffi.Pointer<SDL_Joystick> Function(
              ffi.Pointer<SDL_GameController>)>();

  /// Query or change current state of Game Controller events.
  ///
  /// If controller events are disabled, you must call SDL_GameControllerUpdate()
  /// yourself and check the state of the controller when you want controller
  /// information.
  ///
  /// Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,
  /// and 1 will have any effect. Other numbers will just be returned.
  ///
  /// \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
  /// \returns the same value passed to the function, with exception to -1
  /// (SDL_QUERY), which will return the current state.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickEventState
  int SDL_GameControllerEventState1(
    int state,
  ) {
    return _SDL_GameControllerEventState1(
      state,
    );
  }

  late final _SDL_GameControllerEventState1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GameControllerEventState');
  late final _SDL_GameControllerEventState1 =
      _SDL_GameControllerEventState1Ptr.asFunction<int Function(int)>();

  /// Manually pump game controller updates if not using the loop.
  ///
  /// This function is called automatically by the event loop if events are
  /// enabled. Under such circumstances, it will not be necessary to call this
  /// function.
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GameControllerUpdate1() {
    return _SDL_GameControllerUpdate1();
  }

  late final _SDL_GameControllerUpdate1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GameControllerUpdate');
  late final _SDL_GameControllerUpdate1 =
      _SDL_GameControllerUpdate1Ptr.asFunction<void Function()>();

  /// Convert a string into SDL_GameControllerAxis enum.
  ///
  /// This function is called internally to translate SDL_GameController mapping
  /// strings for the underlying joystick device into the consistent
  /// SDL_GameController mapping. You do not normally need to call this function
  /// unless you are parsing SDL_GameController mappings in your own code.
  ///
  /// Note specially that "righttrigger" and "lefttrigger" map to
  /// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,
  /// respectively.
  ///
  /// \param str string representing a SDL_GameController axis
  /// \returns the SDL_GameControllerAxis enum corresponding to the input string,
  /// or `SDL_CONTROLLER_AXIS_INVALID` if no match was found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetStringForAxis
  int SDL_GameControllerGetAxisFromString1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_GameControllerGetAxisFromString1(
      str,
    );
  }

  late final _SDL_GameControllerGetAxisFromString1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GameControllerGetAxisFromString');
  late final _SDL_GameControllerGetAxisFromString1 =
      _SDL_GameControllerGetAxisFromString1Ptr.asFunction<
          int Function(ffi.Pointer<ffi.Char>)>();

  /// Convert from an SDL_GameControllerAxis enum to a string.
  ///
  /// The caller should not SDL_free() the returned string.
  ///
  /// \param axis an enum value for a given SDL_GameControllerAxis
  /// \returns a string for the given axis, or NULL if an invalid axis is
  /// specified. The string returned is of the format used by
  /// SDL_GameController mapping strings.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetAxisFromString
  ffi.Pointer<ffi.Char> SDL_GameControllerGetStringForAxis1(
    int axis,
  ) {
    return _SDL_GameControllerGetStringForAxis1(
      axis,
    );
  }

  late final _SDL_GameControllerGetStringForAxis1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GameControllerGetStringForAxis');
  late final _SDL_GameControllerGetStringForAxis1 =
      _SDL_GameControllerGetStringForAxis1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the SDL joystick layer binding for a controller axis mapping.
  ///
  /// \param gamecontroller a game controller
  /// \param axis an axis enum value (one of the SDL_GameControllerAxis values)
  /// \returns a SDL_GameControllerButtonBind describing the bind. On failure
  /// (like the given Controller axis doesn't exist on the device), its
  /// `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetBindForButton
  SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetBindForAxis1(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetBindForAxis1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_GameControllerButtonBind Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetBindForAxis');
  late final _SDL_GameControllerGetBindForAxis1 =
      _SDL_GameControllerGetBindForAxis1Ptr.asFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Query whether a game controller has a given axis.
  ///
  /// This merely reports whether the controller's mapping defined this axis, as
  /// that is all the information SDL has about the physical device.
  ///
  /// \param gamecontroller a game controller
  /// \param axis an axis enum value (an SDL_GameControllerAxis value)
  /// \returns SDL_TRUE if the controller has this axis, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasAxis1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerHasAxis1(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerHasAxis1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerHasAxis');
  late final _SDL_GameControllerHasAxis1 = _SDL_GameControllerHasAxis1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of an axis control on a game controller.
  ///
  /// The axis indices start at index 0.
  ///
  /// The state is a value ranging from -32768 to 32767. Triggers, however, range
  /// from 0 to 32767 (they never return a negative value).
  ///
  /// \param gamecontroller a game controller
  /// \param axis an axis index (one of the SDL_GameControllerAxis values)
  /// \returns axis state (including 0) on success or 0 (also) on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetButton
  int SDL_GameControllerGetAxis1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetAxis1(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetAxis1Ptr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetAxis');
  late final _SDL_GameControllerGetAxis1 = _SDL_GameControllerGetAxis1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Convert a string into an SDL_GameControllerButton enum.
  ///
  /// This function is called internally to translate SDL_GameController mapping
  /// strings for the underlying joystick device into the consistent
  /// SDL_GameController mapping. You do not normally need to call this function
  /// unless you are parsing SDL_GameController mappings in your own code.
  ///
  /// \param str string representing a SDL_GameController axis
  /// \returns the SDL_GameControllerButton enum corresponding to the input
  /// string, or `SDL_CONTROLLER_AXIS_INVALID` if no match was found.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GameControllerGetButtonFromString1(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_GameControllerGetButtonFromString1(
      str,
    );
  }

  late final _SDL_GameControllerGetButtonFromString1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GameControllerGetButtonFromString');
  late final _SDL_GameControllerGetButtonFromString1 =
      _SDL_GameControllerGetButtonFromString1Ptr.asFunction<
          int Function(ffi.Pointer<ffi.Char>)>();

  /// Convert from an SDL_GameControllerButton enum to a string.
  ///
  /// The caller should not SDL_free() the returned string.
  ///
  /// \param button an enum value for a given SDL_GameControllerButton
  /// \returns a string for the given button, or NULL if an invalid axis is
  /// specified. The string returned is of the format used by
  /// SDL_GameController mapping strings.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetButtonFromString
  ffi.Pointer<ffi.Char> SDL_GameControllerGetStringForButton1(
    int button,
  ) {
    return _SDL_GameControllerGetStringForButton1(
      button,
    );
  }

  late final _SDL_GameControllerGetStringForButton1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GameControllerGetStringForButton');
  late final _SDL_GameControllerGetStringForButton1 =
      _SDL_GameControllerGetStringForButton1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the SDL joystick layer binding for a controller button mapping.
  ///
  /// \param gamecontroller a game controller
  /// \param button an button enum value (an SDL_GameControllerButton value)
  /// \returns a SDL_GameControllerButtonBind describing the bind. On failure
  /// (like the given Controller button doesn't exist on the device),
  /// its `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetBindForAxis
  SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetBindForButton1(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetBindForButton1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_GameControllerButtonBind Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetBindForButton');
  late final _SDL_GameControllerGetBindForButton1 =
      _SDL_GameControllerGetBindForButton1Ptr.asFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Query whether a game controller has a given button.
  ///
  /// This merely reports whether the controller's mapping defined this button,
  /// as that is all the information SDL has about the physical device.
  ///
  /// \param gamecontroller a game controller
  /// \param button a button enum value (an SDL_GameControllerButton value)
  /// \returns SDL_TRUE if the controller has this button, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasButton1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerHasButton1(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerHasButton1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerHasButton');
  late final _SDL_GameControllerHasButton1 = _SDL_GameControllerHasButton1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of a button on a game controller.
  ///
  /// \param gamecontroller a game controller
  /// \param button a button index (one of the SDL_GameControllerButton values)
  /// \returns 1 for pressed state or 0 for not pressed state or error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerGetAxis
  int SDL_GameControllerGetButton1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetButton1(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetButton1Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetButton');
  late final _SDL_GameControllerGetButton1 = _SDL_GameControllerGetButton1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the number of touchpads on a game controller.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetNumTouchpads1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetNumTouchpads1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetNumTouchpads1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerGetNumTouchpads');
  late final _SDL_GameControllerGetNumTouchpads1 =
      _SDL_GameControllerGetNumTouchpads1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Get the number of supported simultaneous fingers on a touchpad on a game
  /// controller.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetNumTouchpadFingers1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int touchpad,
  ) {
    return _SDL_GameControllerGetNumTouchpadFingers1(
      gamecontroller,
      touchpad,
    );
  }

  late final _SDL_GameControllerGetNumTouchpadFingers1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>,
              ffi.Int)>>('SDL_GameControllerGetNumTouchpadFingers');
  late final _SDL_GameControllerGetNumTouchpadFingers1 =
      _SDL_GameControllerGetNumTouchpadFingers1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of a finger on a touchpad on a game controller.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetTouchpadFinger1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int touchpad,
    int finger,
    ffi.Pointer<Uint8> state,
    ffi.Pointer<ffi.Float> x,
    ffi.Pointer<ffi.Float> y,
    ffi.Pointer<ffi.Float> pressure,
  ) {
    return _SDL_GameControllerGetTouchpadFinger1(
      gamecontroller,
      touchpad,
      finger,
      state,
      x,
      y,
      pressure,
    );
  }

  late final _SDL_GameControllerGetTouchpadFinger1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_GameController>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GameControllerGetTouchpadFinger');
  late final _SDL_GameControllerGetTouchpadFinger1 =
      _SDL_GameControllerGetTouchpadFinger1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_GameController>,
              int,
              int,
              ffi.Pointer<Uint8>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>();

  /// Return whether a game controller has a particular sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \returns SDL_TRUE if the sensor exists, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasSensor1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerHasSensor1(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerHasSensor1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerHasSensor');
  late final _SDL_GameControllerHasSensor1 = _SDL_GameControllerHasSensor1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Set whether data reporting for a game controller sensor is enabled.
  ///
  /// \param gamecontroller The controller to update
  /// \param type The type of sensor to enable/disable
  /// \param enabled Whether data reporting should be enabled
  /// \returns 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerSetSensorEnabled1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
    int enabled,
  ) {
    return _SDL_GameControllerSetSensorEnabled1(
      gamecontroller,
      type,
      enabled,
    );
  }

  late final _SDL_GameControllerSetSensorEnabled1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, ffi.Int32,
              ffi.Int32)>>('SDL_GameControllerSetSensorEnabled');
  late final _SDL_GameControllerSetSensorEnabled1 =
      _SDL_GameControllerSetSensorEnabled1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int)>();

  /// Query whether sensor data reporting is enabled for a game controller.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \returns SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerIsSensorEnabled1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerIsSensorEnabled1(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerIsSensorEnabled1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerIsSensorEnabled');
  late final _SDL_GameControllerIsSensorEnabled1 =
      _SDL_GameControllerIsSensorEnabled1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the data rate (number of events per second) of a game controller
  /// sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \return the data rate, or 0.0f if the data rate is not available.
  ///
  /// \since This function is available since SDL 2.0.16.
  double SDL_GameControllerGetSensorDataRate1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerGetSensorDataRate1(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerGetSensorDataRate1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetSensorDataRate');
  late final _SDL_GameControllerGetSensorDataRate1 =
      _SDL_GameControllerGetSensorDataRate1Ptr.asFunction<
          double Function(ffi.Pointer<SDL_GameController>, int)>();

  /// Get the current state of a game controller sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  /// See SDL_sensor.h for the details for each type of sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  /// \return 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerGetSensorData1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int type,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_GameControllerGetSensorData1(
      gamecontroller,
      type,
      data,
      num_values,
    );
  }

  late final _SDL_GameControllerGetSensorData1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_GameController>,
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Int)>>('SDL_GameControllerGetSensorData');
  late final _SDL_GameControllerGetSensorData1 =
      _SDL_GameControllerGetSensorData1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int,
              ffi.Pointer<ffi.Float>, int)>();

  /// Start a rumble effect on a game controller.
  ///
  /// Each call to this function cancels any previous rumble effect, and calling
  /// it with 0 intensity stops any rumbling.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left)
  /// rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right)
  /// rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if rumble isn't supported on this controller
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GameControllerHasRumble
  int SDL_GameControllerRumble1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumble1(
      gamecontroller,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumble1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, Uint16, Uint16,
              Uint32)>>('SDL_GameControllerRumble');
  late final _SDL_GameControllerRumble1 =
      _SDL_GameControllerRumble1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int, int)>();

  /// Start a rumble effect in the game controller's triggers.
  ///
  /// Each call to this function cancels any previous trigger rumble effect, and
  /// calling it with 0 intensity stops any rumbling.
  ///
  /// Note that this is rumbling of the _triggers_ and not the game controller as
  /// a whole. The first controller to offer this feature was the PlayStation 5's
  /// DualShock 5.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if trigger rumble isn't supported on this controller
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GameControllerHasRumbleTriggers
  int SDL_GameControllerRumbleTriggers1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumbleTriggers1(
      gamecontroller,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumbleTriggers1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, Uint16, Uint16,
              Uint32)>>('SDL_GameControllerRumbleTriggers');
  late final _SDL_GameControllerRumbleTriggers1 =
      _SDL_GameControllerRumbleTriggers1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int, int)>();

  /// Query whether a game controller has an LED.
  ///
  /// \param gamecontroller The controller to query
  /// \returns SDL_TRUE, or SDL_FALSE if this controller does not have a
  /// modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerHasLED1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasLED1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasLED1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerHasLED');
  late final _SDL_GameControllerHasLED1 = _SDL_GameControllerHasLED1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Query whether a game controller has rumble support.
  ///
  /// \param gamecontroller The controller to query
  /// \returns SDL_TRUE, or SDL_FALSE if this controller does not have rumble
  /// support
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerRumble
  int SDL_GameControllerHasRumble1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasRumble1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasRumble1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerHasRumble');
  late final _SDL_GameControllerHasRumble1 = _SDL_GameControllerHasRumble1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_GameController>)>();

  /// Query whether a game controller has rumble support on triggers.
  ///
  /// \param gamecontroller The controller to query
  /// \returns SDL_TRUE, or SDL_FALSE if this controller does not have trigger
  /// rumble support
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerRumbleTriggers
  int SDL_GameControllerHasRumbleTriggers1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasRumbleTriggers1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasRumbleTriggers1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController>)>>(
      'SDL_GameControllerHasRumbleTriggers');
  late final _SDL_GameControllerHasRumbleTriggers1 =
      _SDL_GameControllerHasRumbleTriggers1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>)>();

  /// Update a game controller's LED color.
  ///
  /// \param gamecontroller The controller to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  /// \returns 0, or -1 if this controller does not have a modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_GameControllerSetLED1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_GameControllerSetLED1(
      gamecontroller,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GameControllerSetLED1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>, Uint8, Uint8,
              Uint8)>>('SDL_GameControllerSetLED');
  late final _SDL_GameControllerSetLED1 =
      _SDL_GameControllerSetLED1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_GameController>, int, int, int)>();

  /// Send a controller specific effect packet
  ///
  /// \param gamecontroller The controller to affect
  /// \param data The data to send to the controller
  /// \param size The size of the data to send to the controller
  /// \returns 0, or -1 if this controller or driver doesn't support effect
  /// packets
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_GameControllerSendEffect1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _SDL_GameControllerSendEffect1(
      gamecontroller,
      data,
      size,
    );
  }

  late final _SDL_GameControllerSendEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_GameController>,
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_GameControllerSendEffect');
  late final _SDL_GameControllerSendEffect1 =
      _SDL_GameControllerSendEffect1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_GameController>, ffi.Pointer<ffi.Void>, int)>();

  /// Close a game controller previously opened with SDL_GameControllerOpen().
  ///
  /// \param gamecontroller a game controller identifier previously returned by
  /// SDL_GameControllerOpen()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerOpen
  void SDL_GameControllerClose1(
    ffi.Pointer<SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerClose1(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerClose1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_GameController>)>>('SDL_GameControllerClose');
  late final _SDL_GameControllerClose1 = _SDL_GameControllerClose1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_GameController>)>();

  /// Return the sfSymbolsName for a given button on a game controller on Apple
  /// platforms.
  ///
  /// \param gamecontroller the controller to query
  /// \param button a button on the game controller
  /// \returns the sfSymbolsName or NULL if the name can't be found
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerGetAppleSFSymbolsNameForAxis
  ffi.Pointer<ffi.Char> SDL_GameControllerGetAppleSFSymbolsNameForButton1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetAppleSFSymbolsNameForButton1(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetAppleSFSymbolsNameForButton1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetAppleSFSymbolsNameForButton');
  late final _SDL_GameControllerGetAppleSFSymbolsNameForButton1 =
      _SDL_GameControllerGetAppleSFSymbolsNameForButton1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Return the sfSymbolsName for a given axis on a game controller on Apple
  /// platforms.
  ///
  /// \param gamecontroller the controller to query
  /// \param axis an axis on the game controller
  /// \returns the sfSymbolsName or NULL if the name can't be found
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GameControllerGetAppleSFSymbolsNameForButton
  ffi.Pointer<ffi.Char> SDL_GameControllerGetAppleSFSymbolsNameForAxis1(
    ffi.Pointer<SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetAppleSFSymbolsNameForAxis1(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetAppleSFSymbolsNameForAxis1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_GameController>,
              ffi.Int32)>>('SDL_GameControllerGetAppleSFSymbolsNameForAxis');
  late final _SDL_GameControllerGetAppleSFSymbolsNameForAxis1 =
      _SDL_GameControllerGetAppleSFSymbolsNameForAxis1Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_GameController>, int)>();

  /// Get the number of registered touch devices.
  ///
  /// On some platforms SDL first sees the touch device if it was actually used.
  /// Therefore SDL_GetNumTouchDevices() may return 0 although devices are
  /// available. After using all devices at least once the number will be
  /// correct.
  ///
  /// This was fixed for Android in SDL 2.0.1.
  ///
  /// \returns the number of registered touch devices.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTouchDevice
  int SDL_GetNumTouchDevices1() {
    return _SDL_GetNumTouchDevices1();
  }

  late final _SDL_GetNumTouchDevices1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumTouchDevices');
  late final _SDL_GetNumTouchDevices1 =
      _SDL_GetNumTouchDevices1Ptr.asFunction<int Function()>();

  /// Get the touch ID with the given index.
  ///
  /// \param index the touch device index
  /// \returns the touch ID with the given index on success or 0 if the index is
  /// invalid; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumTouchDevices
  int SDL_GetTouchDevice1(
    int index,
  ) {
    return _SDL_GetTouchDevice1(
      index,
    );
  }

  late final _SDL_GetTouchDevice1Ptr =
      _lookup<ffi.NativeFunction<SDL_TouchID Function(ffi.Int)>>(
          'SDL_GetTouchDevice');
  late final _SDL_GetTouchDevice1 =
      _SDL_GetTouchDevice1Ptr.asFunction<int Function(int)>();

  /// Get the type of the given touch device.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_GetTouchDeviceType1(
    int touchID,
  ) {
    return _SDL_GetTouchDeviceType1(
      touchID,
    );
  }

  late final _SDL_GetTouchDeviceType1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TouchID)>>(
          'SDL_GetTouchDeviceType');
  late final _SDL_GetTouchDeviceType1 =
      _SDL_GetTouchDeviceType1Ptr.asFunction<int Function(int)>();

  /// Get the number of active fingers for a given touch device.
  ///
  /// \param touchID the ID of a touch device
  /// \returns the number of active fingers for a given touch device on success
  /// or 0 on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTouchFinger
  int SDL_GetNumTouchFingers1(
    int touchID,
  ) {
    return _SDL_GetNumTouchFingers1(
      touchID,
    );
  }

  late final _SDL_GetNumTouchFingers1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_TouchID)>>(
          'SDL_GetNumTouchFingers');
  late final _SDL_GetNumTouchFingers1 =
      _SDL_GetNumTouchFingers1Ptr.asFunction<int Function(int)>();

  /// Get the finger object for specified touch device ID and finger index.
  ///
  /// The returned resource is owned by SDL and should not be deallocated.
  ///
  /// \param touchID the ID of the requested touch device
  /// \param index the index of the requested finger
  /// \returns a pointer to the SDL_Finger object or NULL if no object at the
  /// given ID and index could be found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RecordGesture
  ffi.Pointer<SDL_Finger> SDL_GetTouchFinger1(
    int touchID,
    int index,
  ) {
    return _SDL_GetTouchFinger1(
      touchID,
      index,
    );
  }

  late final _SDL_GetTouchFinger1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Finger> Function(
              SDL_TouchID, ffi.Int)>>('SDL_GetTouchFinger');
  late final _SDL_GetTouchFinger1 = _SDL_GetTouchFinger1Ptr.asFunction<
      ffi.Pointer<SDL_Finger> Function(int, int)>();

  /// Begin recording a gesture on a specified touch device or all touch devices.
  ///
  /// If the parameter `touchId` is -1 (i.e., all devices), this function will
  /// always return 1, regardless of whether there actually are any devices.
  ///
  /// \param touchId the touch device id, or -1 for all touch devices
  /// \returns 1 on success or 0 if the specified device could not be found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTouchDevice
  int SDL_RecordGesture1(
    int touchId,
  ) {
    return _SDL_RecordGesture1(
      touchId,
    );
  }

  late final _SDL_RecordGesture1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_TouchID)>>(
          'SDL_RecordGesture');
  late final _SDL_RecordGesture1 =
      _SDL_RecordGesture1Ptr.asFunction<int Function(int)>();

  /// Save all currently loaded Dollar Gesture templates.
  ///
  /// \param dst a SDL_RWops to save to
  /// \returns the number of saved templates on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadDollarTemplates
  /// \sa SDL_SaveDollarTemplate
  int SDL_SaveAllDollarTemplates1(
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveAllDollarTemplates1(
      dst,
    );
  }

  late final _SDL_SaveAllDollarTemplates1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_SaveAllDollarTemplates');
  late final _SDL_SaveAllDollarTemplates1 = _SDL_SaveAllDollarTemplates1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Save a currently loaded Dollar Gesture template.
  ///
  /// \param gestureId a gesture id
  /// \param dst a SDL_RWops to save to
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadDollarTemplates
  /// \sa SDL_SaveAllDollarTemplates
  int SDL_SaveDollarTemplate1(
    int gestureId,
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveDollarTemplate1(
      gestureId,
      dst,
    );
  }

  late final _SDL_SaveDollarTemplate1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_GestureID,
              ffi.Pointer<SDL_RWops>)>>('SDL_SaveDollarTemplate');
  late final _SDL_SaveDollarTemplate1 = _SDL_SaveDollarTemplate1Ptr.asFunction<
      int Function(int, ffi.Pointer<SDL_RWops>)>();

  /// Load Dollar Gesture templates from a file.
  ///
  /// \param touchId a touch id
  /// \param src a SDL_RWops to load from
  /// \returns the number of loaded templates on success or a negative error code
  /// (or 0) on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SaveAllDollarTemplates
  /// \sa SDL_SaveDollarTemplate
  int SDL_LoadDollarTemplates1(
    int touchId,
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_LoadDollarTemplates1(
      touchId,
      src,
    );
  }

  late final _SDL_LoadDollarTemplates1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              SDL_TouchID, ffi.Pointer<SDL_RWops>)>>('SDL_LoadDollarTemplates');
  late final _SDL_LoadDollarTemplates1 = _SDL_LoadDollarTemplates1Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_RWops>)>();

  /// Pump the event loop, gathering events from the input devices.
  ///
  /// This function updates the event queue and internal input device state.
  ///
  /// **WARNING**: This should only be run in the thread that initialized the
  /// video subsystem, and for extra safety, you should consider only doing those
  /// things on the main thread in any case.
  ///
  /// SDL_PumpEvents() gathers all the pending input information from devices and
  /// places it in the event queue. Without calls to SDL_PumpEvents() no events
  /// would ever be placed on the queue. Often the need for calls to
  /// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
  /// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
  /// polling or waiting for events (e.g. you are filtering them), then you must
  /// call SDL_PumpEvents() to force an event queue update.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_WaitEvent
  void SDL_PumpEvents1() {
    return _SDL_PumpEvents1();
  }

  late final _SDL_PumpEvents1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_PumpEvents');
  late final _SDL_PumpEvents1 =
      _SDL_PumpEvents1Ptr.asFunction<void Function()>();

  /// Check the event queue for messages and optionally return them.
  ///
  /// `action` may be any of the following:
  ///
  /// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
  /// event queue.
  /// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
  /// within the specified minimum and maximum type, will be returned to the
  /// caller and will _not_ be removed from the queue.
  /// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
  /// within the specified minimum and maximum type, will be returned to the
  /// caller and will be removed from the queue.
  ///
  /// You may have to call SDL_PumpEvents() before calling this function.
  /// Otherwise, the events may not be ready to be filtered when you call
  /// SDL_PeepEvents().
  ///
  /// This function is thread-safe.
  ///
  /// \param events destination buffer for the retrieved events
  /// \param numevents if action is SDL_ADDEVENT, the number of events to add
  /// back to the event queue; if action is SDL_PEEKEVENT or
  /// SDL_GETEVENT, the maximum number of events to retrieve
  /// \param action action to take; see [[#action|Remarks]] for details
  /// \param minType minimum value of the event type to be considered;
  /// SDL_FIRSTEVENT is a safe choice
  /// \param maxType maximum value of the event type to be considered;
  /// SDL_LASTEVENT is a safe choice
  /// \returns the number of events actually stored or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_PushEvent
  int SDL_PeepEvents1(
    ffi.Pointer<SDL_Event> events,
    int numevents,
    int action,
    int minType,
    int maxType,
  ) {
    return _SDL_PeepEvents1(
      events,
      numevents,
      action,
      minType,
      maxType,
    );
  }

  late final _SDL_PeepEvents1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Event>, ffi.Int, ffi.Int32, Uint32,
              Uint32)>>('SDL_PeepEvents');
  late final _SDL_PeepEvents1 = _SDL_PeepEvents1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int, int, int, int)>();

  /// Check for the existence of a certain event type in the event queue.
  ///
  /// If you need to check for a range of event types, use SDL_HasEvents()
  /// instead.
  ///
  /// \param type the type of event to be queried; see SDL_EventType for details
  /// \returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if
  /// events matching `type` are not present.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasEvents
  int SDL_HasEvent1(
    int type,
  ) {
    return _SDL_HasEvent1(
      type,
    );
  }

  late final _SDL_HasEvent1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32)>>('SDL_HasEvent');
  late final _SDL_HasEvent1 = _SDL_HasEvent1Ptr.asFunction<int Function(int)>();

  /// Check for the existence of certain event types in the event queue.
  ///
  /// If you need to check for a single event type, use SDL_HasEvent() instead.
  ///
  /// \param minType the low end of event type to be queried, inclusive; see
  /// SDL_EventType for details
  /// \param maxType the high end of event type to be queried, inclusive; see
  /// SDL_EventType for details
  /// \returns SDL_TRUE if events with type >= `minType` and <= `maxType` are
  /// present, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasEvents
  int SDL_HasEvents1(
    int minType,
    int maxType,
  ) {
    return _SDL_HasEvents1(
      minType,
      maxType,
    );
  }

  late final _SDL_HasEvents1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32, Uint32)>>(
          'SDL_HasEvents');
  late final _SDL_HasEvents1 =
      _SDL_HasEvents1Ptr.asFunction<int Function(int, int)>();

  /// Clear events of a specific type from the event queue.
  ///
  /// This will unconditionally remove any events from the queue that match
  /// `type`. If you need to remove a range of event types, use SDL_FlushEvents()
  /// instead.
  ///
  /// It's also normal to just ignore events you don't care about in your event
  /// loop without calling this function.
  ///
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  ///
  /// \param type the type of event to be cleared; see SDL_EventType for details
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FlushEvents
  void SDL_FlushEvent1(
    int type,
  ) {
    return _SDL_FlushEvent1(
      type,
    );
  }

  late final _SDL_FlushEvent1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_FlushEvent');
  late final _SDL_FlushEvent1 =
      _SDL_FlushEvent1Ptr.asFunction<void Function(int)>();

  /// Clear events of a range of types from the event queue.
  ///
  /// This will unconditionally remove any events from the queue that are in the
  /// range of `minType` to `maxType`, inclusive. If you need to remove a single
  /// event type, use SDL_FlushEvent() instead.
  ///
  /// It's also normal to just ignore events you don't care about in your event
  /// loop without calling this function.
  ///
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  ///
  /// \param minType the low end of event type to be cleared, inclusive; see
  /// SDL_EventType for details
  /// \param maxType the high end of event type to be cleared, inclusive; see
  /// SDL_EventType for details
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FlushEvent
  void SDL_FlushEvents1(
    int minType,
    int maxType,
  ) {
    return _SDL_FlushEvents1(
      minType,
      maxType,
    );
  }

  late final _SDL_FlushEvents1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32, Uint32)>>(
          'SDL_FlushEvents');
  late final _SDL_FlushEvents1 =
      _SDL_FlushEvents1Ptr.asFunction<void Function(int, int)>();

  /// Poll for currently pending events.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`. The 1 returned refers to
  /// this event, immediately stored in the SDL Event structure -- not an event
  /// to follow.
  ///
  /// If `event` is NULL, it simply returns 1 if there is an event in the queue,
  /// but will not remove it from the queue.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that set the video mode.
  ///
  /// SDL_PollEvent() is the favored way of receiving system events since it can
  /// be done from the main loop and does not suspend the main loop while waiting
  /// on an event to be posted.
  ///
  /// The common practice is to fully process the event queue once every frame,
  /// usually as a first step before updating the game's state:
  ///
  /// ```c
  /// while (game_is_still_running) {
  /// SDL_Event event;
  /// while (SDL_PollEvent(&event)) {  // poll until all events are handled!
  /// // decide what to do with this event.
  /// }
  ///
  /// // update game state, draw the current frame
  /// }
  /// ```
  ///
  /// \param event the SDL_Event structure to be filled with the next event from
  /// the queue, or NULL
  /// \returns 1 if there is a pending event or 0 if there are none available.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventFilter
  /// \sa SDL_PeepEvents
  /// \sa SDL_PushEvent
  /// \sa SDL_SetEventFilter
  /// \sa SDL_WaitEvent
  /// \sa SDL_WaitEventTimeout
  int SDL_PollEvent1(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PollEvent1(
      event,
    );
  }

  late final _SDL_PollEvent1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PollEvent');
  late final _SDL_PollEvent1 =
      _SDL_PollEvent1Ptr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Wait indefinitely for the next available event.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that initialized the video subsystem.
  ///
  /// \param event the SDL_Event structure to be filled in with the next event
  /// from the queue, or NULL
  /// \returns 1 on success or 0 if there was an error while waiting for events;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_WaitEventTimeout
  int SDL_WaitEvent1(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_WaitEvent1(
      event,
    );
  }

  late final _SDL_WaitEvent1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_WaitEvent');
  late final _SDL_WaitEvent1 =
      _SDL_WaitEvent1Ptr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Wait until the specified timeout (in milliseconds) for the next available
  /// event.
  ///
  /// If `event` is not NULL, the next event is removed from the queue and stored
  /// in the SDL_Event structure pointed to by `event`.
  ///
  /// As this function may implicitly call SDL_PumpEvents(), you can only call
  /// this function in the thread that initialized the video subsystem.
  ///
  /// \param event the SDL_Event structure to be filled in with the next event
  /// from the queue, or NULL
  /// \param timeout the maximum number of milliseconds to wait for the next
  /// available event
  /// \returns 1 on success or 0 if there was an error while waiting for events;
  /// call SDL_GetError() for more information. This also returns 0 if
  /// the timeout elapsed without an event arriving.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PollEvent
  /// \sa SDL_PumpEvents
  /// \sa SDL_WaitEvent
  int SDL_WaitEventTimeout1(
    ffi.Pointer<SDL_Event> event,
    int timeout,
  ) {
    return _SDL_WaitEventTimeout1(
      event,
      timeout,
    );
  }

  late final _SDL_WaitEventTimeout1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Event>, ffi.Int)>>('SDL_WaitEventTimeout');
  late final _SDL_WaitEventTimeout1 = _SDL_WaitEventTimeout1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int)>();

  /// Add an event to the event queue.
  ///
  /// The event queue can actually be used as a two way communication channel.
  /// Not only can events be read from the queue, but the user can also push
  /// their own events onto it. `event` is a pointer to the event structure you
  /// wish to push onto the queue. The event is copied into the queue, and the
  /// caller may dispose of the memory pointed to after SDL_PushEvent() returns.
  ///
  /// Note: Pushing device input events onto the queue doesn't modify the state
  /// of the device within SDL.
  ///
  /// This function is thread-safe, and can be called from other threads safely.
  ///
  /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
  /// the event filter but events added with SDL_PeepEvents() do not.
  ///
  /// For pushing application-specific events, please use SDL_RegisterEvents() to
  /// get an event type that does not conflict with other code that also wants
  /// its own custom event types.
  ///
  /// \param event the SDL_Event to be added to the queue
  /// \returns 1 on success, 0 if the event was filtered, or a negative error
  /// code on failure; call SDL_GetError() for more information. A
  /// common reason for error is the event queue being full.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PeepEvents
  /// \sa SDL_PollEvent
  /// \sa SDL_RegisterEvents
  int SDL_PushEvent1(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PushEvent1(
      event,
    );
  }

  late final _SDL_PushEvent1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PushEvent');
  late final _SDL_PushEvent1 =
      _SDL_PushEvent1Ptr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Set up a filter to process all events before they change internal state and
  /// are posted to the internal event queue.
  ///
  /// If the filter function returns 1 when called, then the event will be added
  /// to the internal queue. If it returns 0, then the event will be dropped from
  /// the queue, but the internal state will still be updated. This allows
  /// selective filtering of dynamically arriving events.
  ///
  /// **WARNING**: Be very careful of what you do in the event filter function,
  /// as it may run in a different thread!
  ///
  /// On platforms that support it, if the quit event is generated by an
  /// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
  /// application at the next event poll.
  ///
  /// There is one caveat when dealing with the ::SDL_QuitEvent event type. The
  /// event filter is only called when the window manager desires to close the
  /// application window. If the event filter returns 1, then the window will be
  /// closed, otherwise the window will remain open if possible.
  ///
  /// Note: Disabled events never make it to the event filter function; see
  /// SDL_EventState().
  ///
  /// Note: If you just want to inspect events without filtering, you should use
  /// SDL_AddEventWatch() instead.
  ///
  /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
  /// the event filter, but events pushed onto the queue with SDL_PeepEvents() do
  /// not.
  ///
  /// \param filter An SDL_EventFilter function to call when an event happens
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddEventWatch
  /// \sa SDL_EventState
  /// \sa SDL_GetEventFilter
  /// \sa SDL_PeepEvents
  /// \sa SDL_PushEvent
  void SDL_SetEventFilter1(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetEventFilter1(
      filter,
      userdata,
    );
  }

  late final _SDL_SetEventFilter1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_SetEventFilter');
  late final _SDL_SetEventFilter1 = _SDL_SetEventFilter1Ptr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Query the current event filter.
  ///
  /// This function can be used to "chain" filters, by saving the existing filter
  /// before replacing it with a function that will call that saved filter.
  ///
  /// \param filter the current callback function will be stored here
  /// \param userdata the pointer that is passed to the current event filter will
  /// be stored here
  /// \returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetEventFilter
  int SDL_GetEventFilter1(
    ffi.Pointer<SDL_EventFilter> filter,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_GetEventFilter1(
      filter,
      userdata,
    );
  }

  late final _SDL_GetEventFilter1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_EventFilter>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetEventFilter');
  late final _SDL_GetEventFilter1 = _SDL_GetEventFilter1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_EventFilter>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Add a callback to be triggered when an event is added to the event queue.
  ///
  /// `filter` will be called when an event happens, and its return value is
  /// ignored.
  ///
  /// **WARNING**: Be very careful of what you do in the event filter function,
  /// as it may run in a different thread!
  ///
  /// If the quit event is generated by a signal (e.g. SIGINT), it will bypass
  /// the internal queue and be delivered to the watch callback immediately, and
  /// arrive at the next event poll.
  ///
  /// Note: the callback is called for events posted by the user through
  /// SDL_PushEvent(), but not for disabled events, nor for events by a filter
  /// callback set with SDL_SetEventFilter(), nor for events posted by the user
  /// through SDL_PeepEvents().
  ///
  /// \param filter an SDL_EventFilter function to call when an event happens.
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DelEventWatch
  /// \sa SDL_SetEventFilter
  void SDL_AddEventWatch1(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddEventWatch1(
      filter,
      userdata,
    );
  }

  late final _SDL_AddEventWatch1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_AddEventWatch');
  late final _SDL_AddEventWatch1 = _SDL_AddEventWatch1Ptr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Remove an event watch callback added with SDL_AddEventWatch().
  ///
  /// This function takes the same input as SDL_AddEventWatch() to identify and
  /// delete the corresponding callback.
  ///
  /// \param filter the function originally passed to SDL_AddEventWatch()
  /// \param userdata the pointer originally passed to SDL_AddEventWatch()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddEventWatch
  void SDL_DelEventWatch1(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelEventWatch1(
      filter,
      userdata,
    );
  }

  late final _SDL_DelEventWatch1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_DelEventWatch');
  late final _SDL_DelEventWatch1 = _SDL_DelEventWatch1Ptr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Run a specific filter function on the current event queue, removing any
  /// events for which the filter returns 0.
  ///
  /// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
  /// this function does not change the filter permanently, it only uses the
  /// supplied filter until this function returns.
  ///
  /// \param filter the SDL_EventFilter function to call when an event happens
  /// \param userdata a pointer that is passed to `filter`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventFilter
  /// \sa SDL_SetEventFilter
  void SDL_FilterEvents1(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_FilterEvents1(
      filter,
      userdata,
    );
  }

  late final _SDL_FilterEvents1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_FilterEvents');
  late final _SDL_FilterEvents1 = _SDL_FilterEvents1Ptr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Set the state of processing events by type.
  ///
  /// `state` may be any of the following:
  ///
  /// - `SDL_QUERY`: returns the current processing state of the specified event
  /// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped
  /// from the event queue and will not be filtered
  /// - `SDL_ENABLE`: the event will be processed normally
  ///
  /// \param type the type of event; see SDL_EventType for details
  /// \param state how to process the event
  /// \returns `SDL_DISABLE` or `SDL_ENABLE`, representing the processing state
  /// of the event before this function makes any changes to it.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetEventState
  int SDL_EventState1(
    int type,
    int state,
  ) {
    return _SDL_EventState1(
      type,
      state,
    );
  }

  late final _SDL_EventState1Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(Uint32, ffi.Int)>>(
          'SDL_EventState');
  late final _SDL_EventState1 =
      _SDL_EventState1Ptr.asFunction<int Function(int, int)>();

  /// Allocate a set of user-defined events, and return the beginning event
  /// number for that set of events.
  ///
  /// Calling this function with `numevents` <= 0 is an error and will return
  /// (Uint32)-1.
  ///
  /// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or
  /// 0xFFFFFFFF), but is clearer to write.
  ///
  /// \param numevents the number of events to be allocated
  /// \returns the beginning event number, or (Uint32)-1 if there are not enough
  /// user-defined events left.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PushEvent
  int SDL_RegisterEvents1(
    int numevents,
  ) {
    return _SDL_RegisterEvents1(
      numevents,
    );
  }

  late final _SDL_RegisterEvents1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Int)>>(
          'SDL_RegisterEvents');
  late final _SDL_RegisterEvents1 =
      _SDL_RegisterEvents1Ptr.asFunction<int Function(int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform9() {
    return _SDL_GetPlatform9();
  }

  late final _SDL_GetPlatform9Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform9 =
      _SDL_GetPlatform9Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc8(
    int size,
  ) {
    return _SDL_malloc8(
      size,
    );
  }

  late final _SDL_malloc8Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc8 =
      _SDL_malloc8Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc8(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc8(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc8 =
      _SDL_calloc8Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc8(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc8(
      mem,
      size,
    );
  }

  late final _SDL_realloc8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc8 = _SDL_realloc8Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free8(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free8(
      mem,
    );
  }

  late final _SDL_free8Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free8 =
      _SDL_free8Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions8(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions8(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions8 = _SDL_GetMemoryFunctions8Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions8(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions8(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions8 = _SDL_SetMemoryFunctions8Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations8() {
    return _SDL_GetNumAllocations8();
  }

  late final _SDL_GetNumAllocations8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations8 =
      _SDL_GetNumAllocations8Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv8(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv8(
      name,
    );
  }

  late final _SDL_getenv8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv8 = _SDL_getenv8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv8(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv8(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv8 = _SDL_setenv8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort8(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort8(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort8 = _SDL_qsort8Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs8(
    int x,
  ) {
    return _SDL_abs8(
      x,
    );
  }

  late final _SDL_abs8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs8 = _SDL_abs8Ptr.asFunction<int Function(int)>();

  int SDL_isalpha8(
    int x,
  ) {
    return _SDL_isalpha8(
      x,
    );
  }

  late final _SDL_isalpha8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha8 = _SDL_isalpha8Ptr.asFunction<int Function(int)>();

  int SDL_isalnum8(
    int x,
  ) {
    return _SDL_isalnum8(
      x,
    );
  }

  late final _SDL_isalnum8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum8 = _SDL_isalnum8Ptr.asFunction<int Function(int)>();

  int SDL_isblank8(
    int x,
  ) {
    return _SDL_isblank8(
      x,
    );
  }

  late final _SDL_isblank8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank8 = _SDL_isblank8Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl8(
    int x,
  ) {
    return _SDL_iscntrl8(
      x,
    );
  }

  late final _SDL_iscntrl8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl8 = _SDL_iscntrl8Ptr.asFunction<int Function(int)>();

  int SDL_isdigit8(
    int x,
  ) {
    return _SDL_isdigit8(
      x,
    );
  }

  late final _SDL_isdigit8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit8 = _SDL_isdigit8Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit8(
    int x,
  ) {
    return _SDL_isxdigit8(
      x,
    );
  }

  late final _SDL_isxdigit8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit8 = _SDL_isxdigit8Ptr.asFunction<int Function(int)>();

  int SDL_ispunct8(
    int x,
  ) {
    return _SDL_ispunct8(
      x,
    );
  }

  late final _SDL_ispunct8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct8 = _SDL_ispunct8Ptr.asFunction<int Function(int)>();

  int SDL_isspace8(
    int x,
  ) {
    return _SDL_isspace8(
      x,
    );
  }

  late final _SDL_isspace8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace8 = _SDL_isspace8Ptr.asFunction<int Function(int)>();

  int SDL_isupper8(
    int x,
  ) {
    return _SDL_isupper8(
      x,
    );
  }

  late final _SDL_isupper8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper8 = _SDL_isupper8Ptr.asFunction<int Function(int)>();

  int SDL_islower8(
    int x,
  ) {
    return _SDL_islower8(
      x,
    );
  }

  late final _SDL_islower8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower8 = _SDL_islower8Ptr.asFunction<int Function(int)>();

  int SDL_isprint8(
    int x,
  ) {
    return _SDL_isprint8(
      x,
    );
  }

  late final _SDL_isprint8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint8 = _SDL_isprint8Ptr.asFunction<int Function(int)>();

  int SDL_isgraph8(
    int x,
  ) {
    return _SDL_isgraph8(
      x,
    );
  }

  late final _SDL_isgraph8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph8 = _SDL_isgraph8Ptr.asFunction<int Function(int)>();

  int SDL_toupper8(
    int x,
  ) {
    return _SDL_toupper8(
      x,
    );
  }

  late final _SDL_toupper8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper8 = _SDL_toupper8Ptr.asFunction<int Function(int)>();

  int SDL_tolower8(
    int x,
  ) {
    return _SDL_tolower8(
      x,
    );
  }

  late final _SDL_tolower8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower8 = _SDL_tolower8Ptr.asFunction<int Function(int)>();

  int SDL_crc328(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc328(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc328Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc328 = _SDL_crc328Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset8(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset8(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset8 = _SDL_memset8Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy8(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy8(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy8 = _SDL_memcpy8Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove8(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove8(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove8 = _SDL_memmove8Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp8(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp8(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp8 = _SDL_memcmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen8(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen8(
      wstr,
    );
  }

  late final _SDL_wcslen8Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen8 =
      _SDL_wcslen8Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy8(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy8(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy8 = _SDL_wcslcpy8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat8(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat8(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat8 = _SDL_wcslcat8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup8(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup8(
      wstr,
    );
  }

  late final _SDL_wcsdup8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup8 = _SDL_wcsdup8Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr8(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr8(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr8 = _SDL_wcsstr8Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp8(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp8(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp8 = _SDL_wcscmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp8(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp8(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp8 = _SDL_wcsncmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp8(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp8(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp8 = _SDL_wcscasecmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp8(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp8(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp8 = _SDL_wcsncasecmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen8(
      str,
    );
  }

  late final _SDL_strlen8Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen8 =
      _SDL_strlen8Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy8(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy8(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy8 = _SDL_strlcpy8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy8(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy8(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy8 = _SDL_utf8strlcpy8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat8(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat8(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat8 = _SDL_strlcat8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup8(
      str,
    );
  }

  late final _SDL_strdup8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup8 = _SDL_strdup8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev8(
      str,
    );
  }

  late final _SDL_strrev8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev8 = _SDL_strrev8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr8(
      str,
    );
  }

  late final _SDL_strupr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr8 = _SDL_strupr8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr8(
      str,
    );
  }

  late final _SDL_strlwr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr8 = _SDL_strlwr8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr8(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr8(
      str,
      c,
    );
  }

  late final _SDL_strchr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr8 = _SDL_strchr8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr8(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr8(
      str,
      c,
    );
  }

  late final _SDL_strrchr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr8 = _SDL_strrchr8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr8(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr8(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr8 = _SDL_strstr8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr8(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr8(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr8 = _SDL_strtokr8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen8(
      str,
    );
  }

  late final _SDL_utf8strlen8Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen8 =
      _SDL_utf8strlen8Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa8(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa8(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa8 = _SDL_itoa8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa8(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa8(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa8 = _SDL_uitoa8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa8(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa8(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa8 = _SDL_ltoa8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa8(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa8(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa8 = _SDL_ultoa8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa8(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa8(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa8 = _SDL_lltoa8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa8(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa8(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa8 = _SDL_ulltoa8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi8(
      str,
    );
  }

  late final _SDL_atoi8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi8 =
      _SDL_atoi8Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof8(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof8(
      str,
    );
  }

  late final _SDL_atof8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof8 =
      _SDL_atof8Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol8(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol8(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol8 = _SDL_strtol8Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul8(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul8(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul8 = _SDL_strtoul8Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll8(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll8(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll8Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll8 = _SDL_strtoll8Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull8(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull8(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull8Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull8 = _SDL_strtoull8Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod8(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod8(
      str,
      endp,
    );
  }

  late final _SDL_strtod8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod8 = _SDL_strtod8Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp8(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp8(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp8 = _SDL_strcmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp8(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp8(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp8 = _SDL_strncmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp8(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp8(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp8 = _SDL_strcasecmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp8(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp8(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp8 = _SDL_strncasecmp8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf8(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf8(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf8 = _SDL_sscanf8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf8(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf8(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf8 = _SDL_vsscanf8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf8(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf8(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf8 = _SDL_snprintf8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf8(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf8(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf8 = _SDL_vsnprintf8Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf8(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf8(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf8 = _SDL_asprintf8Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf8(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf8(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf8 = _SDL_vasprintf8Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos8(
    double x,
  ) {
    return _SDL_acos8(
      x,
    );
  }

  late final _SDL_acos8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos8 = _SDL_acos8Ptr.asFunction<double Function(double)>();

  double SDL_acosf8(
    double x,
  ) {
    return _SDL_acosf8(
      x,
    );
  }

  late final _SDL_acosf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf8 = _SDL_acosf8Ptr.asFunction<double Function(double)>();

  double SDL_asin8(
    double x,
  ) {
    return _SDL_asin8(
      x,
    );
  }

  late final _SDL_asin8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin8 = _SDL_asin8Ptr.asFunction<double Function(double)>();

  double SDL_asinf8(
    double x,
  ) {
    return _SDL_asinf8(
      x,
    );
  }

  late final _SDL_asinf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf8 = _SDL_asinf8Ptr.asFunction<double Function(double)>();

  double SDL_atan9(
    double x,
  ) {
    return _SDL_atan9(
      x,
    );
  }

  late final _SDL_atan9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan9 = _SDL_atan9Ptr.asFunction<double Function(double)>();

  double SDL_atanf8(
    double x,
  ) {
    return _SDL_atanf8(
      x,
    );
  }

  late final _SDL_atanf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf8 = _SDL_atanf8Ptr.asFunction<double Function(double)>();

  double SDL_atan28(
    double y,
    double x,
  ) {
    return _SDL_atan28(
      y,
      x,
    );
  }

  late final _SDL_atan28Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan28 =
      _SDL_atan28Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f8(
    double y,
    double x,
  ) {
    return _SDL_atan2f8(
      y,
      x,
    );
  }

  late final _SDL_atan2f8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f8 =
      _SDL_atan2f8Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil8(
    double x,
  ) {
    return _SDL_ceil8(
      x,
    );
  }

  late final _SDL_ceil8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil8 = _SDL_ceil8Ptr.asFunction<double Function(double)>();

  double SDL_ceilf8(
    double x,
  ) {
    return _SDL_ceilf8(
      x,
    );
  }

  late final _SDL_ceilf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf8 = _SDL_ceilf8Ptr.asFunction<double Function(double)>();

  double SDL_copysign8(
    double x,
    double y,
  ) {
    return _SDL_copysign8(
      x,
      y,
    );
  }

  late final _SDL_copysign8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign8 =
      _SDL_copysign8Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf8(
    double x,
    double y,
  ) {
    return _SDL_copysignf8(
      x,
      y,
    );
  }

  late final _SDL_copysignf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf8 =
      _SDL_copysignf8Ptr.asFunction<double Function(double, double)>();

  double SDL_cos8(
    double x,
  ) {
    return _SDL_cos8(
      x,
    );
  }

  late final _SDL_cos8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos8 = _SDL_cos8Ptr.asFunction<double Function(double)>();

  double SDL_cosf8(
    double x,
  ) {
    return _SDL_cosf8(
      x,
    );
  }

  late final _SDL_cosf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf8 = _SDL_cosf8Ptr.asFunction<double Function(double)>();

  double SDL_exp8(
    double x,
  ) {
    return _SDL_exp8(
      x,
    );
  }

  late final _SDL_exp8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp8 = _SDL_exp8Ptr.asFunction<double Function(double)>();

  double SDL_expf8(
    double x,
  ) {
    return _SDL_expf8(
      x,
    );
  }

  late final _SDL_expf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf8 = _SDL_expf8Ptr.asFunction<double Function(double)>();

  double SDL_fabs8(
    double x,
  ) {
    return _SDL_fabs8(
      x,
    );
  }

  late final _SDL_fabs8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs8 = _SDL_fabs8Ptr.asFunction<double Function(double)>();

  double SDL_fabsf8(
    double x,
  ) {
    return _SDL_fabsf8(
      x,
    );
  }

  late final _SDL_fabsf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf8 = _SDL_fabsf8Ptr.asFunction<double Function(double)>();

  double SDL_floor8(
    double x,
  ) {
    return _SDL_floor8(
      x,
    );
  }

  late final _SDL_floor8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor8 = _SDL_floor8Ptr.asFunction<double Function(double)>();

  double SDL_floorf8(
    double x,
  ) {
    return _SDL_floorf8(
      x,
    );
  }

  late final _SDL_floorf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf8 =
      _SDL_floorf8Ptr.asFunction<double Function(double)>();

  double SDL_trunc8(
    double x,
  ) {
    return _SDL_trunc8(
      x,
    );
  }

  late final _SDL_trunc8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc8 = _SDL_trunc8Ptr.asFunction<double Function(double)>();

  double SDL_truncf8(
    double x,
  ) {
    return _SDL_truncf8(
      x,
    );
  }

  late final _SDL_truncf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf8 =
      _SDL_truncf8Ptr.asFunction<double Function(double)>();

  double SDL_fmod8(
    double x,
    double y,
  ) {
    return _SDL_fmod8(
      x,
      y,
    );
  }

  late final _SDL_fmod8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod8 =
      _SDL_fmod8Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf8(
    double x,
    double y,
  ) {
    return _SDL_fmodf8(
      x,
      y,
    );
  }

  late final _SDL_fmodf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf8 =
      _SDL_fmodf8Ptr.asFunction<double Function(double, double)>();

  double SDL_log8(
    double x,
  ) {
    return _SDL_log8(
      x,
    );
  }

  late final _SDL_log8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log8 = _SDL_log8Ptr.asFunction<double Function(double)>();

  double SDL_logf8(
    double x,
  ) {
    return _SDL_logf8(
      x,
    );
  }

  late final _SDL_logf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf8 = _SDL_logf8Ptr.asFunction<double Function(double)>();

  double SDL_log108(
    double x,
  ) {
    return _SDL_log108(
      x,
    );
  }

  late final _SDL_log108Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log108 = _SDL_log108Ptr.asFunction<double Function(double)>();

  double SDL_log10f8(
    double x,
  ) {
    return _SDL_log10f8(
      x,
    );
  }

  late final _SDL_log10f8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f8 =
      _SDL_log10f8Ptr.asFunction<double Function(double)>();

  double SDL_pow8(
    double x,
    double y,
  ) {
    return _SDL_pow8(
      x,
      y,
    );
  }

  late final _SDL_pow8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow8 =
      _SDL_pow8Ptr.asFunction<double Function(double, double)>();

  double SDL_powf8(
    double x,
    double y,
  ) {
    return _SDL_powf8(
      x,
      y,
    );
  }

  late final _SDL_powf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf8 =
      _SDL_powf8Ptr.asFunction<double Function(double, double)>();

  double SDL_round8(
    double x,
  ) {
    return _SDL_round8(
      x,
    );
  }

  late final _SDL_round8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round8 = _SDL_round8Ptr.asFunction<double Function(double)>();

  double SDL_roundf8(
    double x,
  ) {
    return _SDL_roundf8(
      x,
    );
  }

  late final _SDL_roundf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf8 =
      _SDL_roundf8Ptr.asFunction<double Function(double)>();

  int SDL_lround8(
    double x,
  ) {
    return _SDL_lround8(
      x,
    );
  }

  late final _SDL_lround8Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround8 = _SDL_lround8Ptr.asFunction<int Function(double)>();

  int SDL_lroundf8(
    double x,
  ) {
    return _SDL_lroundf8(
      x,
    );
  }

  late final _SDL_lroundf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf8 =
      _SDL_lroundf8Ptr.asFunction<int Function(double)>();

  double SDL_scalbn8(
    double x,
    int n,
  ) {
    return _SDL_scalbn8(
      x,
      n,
    );
  }

  late final _SDL_scalbn8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn8 =
      _SDL_scalbn8Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf8(
    double x,
    int n,
  ) {
    return _SDL_scalbnf8(
      x,
      n,
    );
  }

  late final _SDL_scalbnf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf8 =
      _SDL_scalbnf8Ptr.asFunction<double Function(double, int)>();

  double SDL_sin8(
    double x,
  ) {
    return _SDL_sin8(
      x,
    );
  }

  late final _SDL_sin8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin8 = _SDL_sin8Ptr.asFunction<double Function(double)>();

  double SDL_sinf8(
    double x,
  ) {
    return _SDL_sinf8(
      x,
    );
  }

  late final _SDL_sinf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf8 = _SDL_sinf8Ptr.asFunction<double Function(double)>();

  double SDL_sqrt8(
    double x,
  ) {
    return _SDL_sqrt8(
      x,
    );
  }

  late final _SDL_sqrt8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt8 = _SDL_sqrt8Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf8(
    double x,
  ) {
    return _SDL_sqrtf8(
      x,
    );
  }

  late final _SDL_sqrtf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf8 = _SDL_sqrtf8Ptr.asFunction<double Function(double)>();

  double SDL_tan8(
    double x,
  ) {
    return _SDL_tan8(
      x,
    );
  }

  late final _SDL_tan8Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan8 = _SDL_tan8Ptr.asFunction<double Function(double)>();

  double SDL_tanf8(
    double x,
  ) {
    return _SDL_tanf8(
      x,
    );
  }

  late final _SDL_tanf8Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf8 = _SDL_tanf8Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open8(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open8(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open8Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open8 = _SDL_iconv_open8Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close8(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close8(
      cd,
    );
  }

  late final _SDL_iconv_close8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close8 =
      _SDL_iconv_close8Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv8(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv8(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv8 = _SDL_iconv8Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string8(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string8(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string8 = _SDL_iconv_string8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError4(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError4(
      fmt,
    );
  }

  late final _SDL_SetError4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError4 =
      _SDL_SetError4Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError4() {
    return _SDL_GetError4();
  }

  late final _SDL_GetError4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError4 =
      _SDL_GetError4Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg4(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg4(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg4 = _SDL_GetErrorMsg4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError4() {
    return _SDL_ClearError4();
  }

  late final _SDL_ClearError4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError4 =
      _SDL_ClearError4Ptr.asFunction<void Function()>();

  int SDL_Error4(
    int code,
  ) {
    return _SDL_Error4(
      code,
    );
  }

  late final _SDL_Error4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error4 = _SDL_Error4Ptr.asFunction<int Function(int)>();

  /// Get the human readable name of a pixel format.
  ///
  /// \param format the pixel format to query
  /// \returns the human readable name of the specified pixel format or
  /// `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPixelFormatName3(
    int format,
  ) {
    return _SDL_GetPixelFormatName3(
      format,
    );
  }

  late final _SDL_GetPixelFormatName3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Uint32)>>(
          'SDL_GetPixelFormatName');
  late final _SDL_GetPixelFormatName3 = _SDL_GetPixelFormatName3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
  ///
  /// \param format one of the SDL_PixelFormatEnum values
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask a pointer filled in with the red mask for the format
  /// \param Gmask a pointer filled in with the green mask for the format
  /// \param Bmask a pointer filled in with the blue mask for the format
  /// \param Amask a pointer filled in with the alpha mask for the format
  /// \returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't
  /// possible; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MasksToPixelFormatEnum
  int SDL_PixelFormatEnumToMasks3(
    int format,
    ffi.Pointer<ffi.Int> bpp,
    ffi.Pointer<Uint32> Rmask,
    ffi.Pointer<Uint32> Gmask,
    ffi.Pointer<Uint32> Bmask,
    ffi.Pointer<Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks3(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasks3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>)>>('SDL_PixelFormatEnumToMasks');
  late final _SDL_PixelFormatEnumToMasks3 =
      _SDL_PixelFormatEnumToMasks3Ptr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>, ffi.Pointer<Uint32>, ffi.Pointer<Uint32>)>();

  /// Convert a bpp value and RGBA masks to an enumerated pixel format.
  ///
  /// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
  /// possible.
  ///
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask the red mask for the format
  /// \param Gmask the green mask for the format
  /// \param Bmask the blue mask for the format
  /// \param Amask the alpha mask for the format
  /// \returns one of the SDL_PixelFormatEnum values
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PixelFormatEnumToMasks
  int SDL_MasksToPixelFormatEnum3(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum3(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnum3Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Int, Uint32, Uint32, Uint32,
              Uint32)>>('SDL_MasksToPixelFormatEnum');
  late final _SDL_MasksToPixelFormatEnum3 = _SDL_MasksToPixelFormatEnum3Ptr
      .asFunction<int Function(int, int, int, int, int)>();

  /// Create an SDL_PixelFormat structure corresponding to a pixel format.
  ///
  /// Returned structure may come from a shared global cache (i.e. not newly
  /// allocated), and hence should not be modified, especially the palette. Weird
  /// errors such as `Blit combination not supported` may occur.
  ///
  /// \param pixel_format one of the SDL_PixelFormatEnum values
  /// \returns the new SDL_PixelFormat structure or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeFormat
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat3(
    int pixel_format,
  ) {
    return _SDL_AllocFormat3(
      pixel_format,
    );
  }

  late final _SDL_AllocFormat3Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_PixelFormat> Function(Uint32)>>(
      'SDL_AllocFormat');
  late final _SDL_AllocFormat3 = _SDL_AllocFormat3Ptr.asFunction<
      ffi.Pointer<SDL_PixelFormat> Function(int)>();

  /// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().
  ///
  /// \param format the SDL_PixelFormat structure to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  void SDL_FreeFormat3(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat3(
      format,
    );
  }

  late final _SDL_FreeFormat3Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_PixelFormat>)>>(
      'SDL_FreeFormat');
  late final _SDL_FreeFormat3 = _SDL_FreeFormat3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_PixelFormat>)>();

  /// Create a palette structure with the specified number of color entries.
  ///
  /// The palette entries are initialized to white.
  ///
  /// \param ncolors represents the number of color entries in the color palette
  /// \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
  /// there wasn't enough memory); call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreePalette
  ffi.Pointer<SDL_Palette> SDL_AllocPalette3(
    int ncolors,
  ) {
    return _SDL_AllocPalette3(
      ncolors,
    );
  }

  late final _SDL_AllocPalette3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Palette> Function(ffi.Int)>>(
          'SDL_AllocPalette');
  late final _SDL_AllocPalette3 = _SDL_AllocPalette3Ptr.asFunction<
      ffi.Pointer<SDL_Palette> Function(int)>();

  /// Set the palette for a pixel format structure.
  ///
  /// \param format the SDL_PixelFormat structure that will use the palette
  /// \param palette the SDL_Palette structure that will be used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_FreePalette
  int SDL_SetPixelFormatPalette3(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette3(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalette3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetPixelFormatPalette');
  late final _SDL_SetPixelFormatPalette3 =
      _SDL_SetPixelFormatPalette3Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<SDL_Palette>)>();

  /// Set a range of colors in a palette.
  ///
  /// \param palette the SDL_Palette structure to modify
  /// \param colors an array of SDL_Color structures to copy into the palette
  /// \param firstcolor the index of the first palette entry to modify
  /// \param ncolors the number of entries to modify
  /// \returns 0 on success or a negative error code if not all of the colors
  /// could be set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_CreateRGBSurface
  int SDL_SetPaletteColors3(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors3(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColors3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>,
              ffi.Int, ffi.Int)>>('SDL_SetPaletteColors');
  late final _SDL_SetPaletteColors3 = _SDL_SetPaletteColors3Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>, int, int)>();

  /// Free a palette created with SDL_AllocPalette().
  ///
  /// \param palette the SDL_Palette structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  void SDL_FreePalette3(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette3(
      palette,
    );
  }

  late final _SDL_FreePalette3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Palette>)>>(
          'SDL_FreePalette');
  late final _SDL_FreePalette3 = _SDL_FreePalette3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Palette>)>();

  /// Map an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// This function maps the RGB color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGB color value for
  /// the given pixel format.
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the specified pixel format has an alpha component it will be returned as
  /// all 1 bits (fully opaque).
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the pixel format
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGBA
  int SDL_MapRGB3(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB3(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGB3Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8,
              Uint8)>>('SDL_MapRGB');
  late final _SDL_MapRGB3 = _SDL_MapRGB3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int)>();

  /// Map an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// This function maps the RGBA color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGBA color value for
  /// the given pixel format.
  ///
  /// If the specified pixel format has no alpha component the alpha value will
  /// be ignored (as it will be in formats with a palette).
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \param a the alpha component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  int SDL_MapRGBA3(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA3(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBA3Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_MapRGBA');
  late final _SDL_MapRGBA3 = _SDL_MapRGBA3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int, int)>();

  /// Get RGB values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGB3(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetRGB3(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGB3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGB');
  late final _SDL_GetRGB3 = _SDL_GetRGB3Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Get RGBA values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// If the surface has no alpha component, the alpha will be returned as 0xff
  /// (100% opaque).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  /// \param a a pointer filled in with the alpha component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGBA3(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRGBA3(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBA3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGBA');
  late final _SDL_GetRGBA3 = _SDL_GetRGBA3Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Calculate a 256 entry gamma ramp for a gamma value.
  ///
  /// \param gamma a gamma value where 0.0 is black and 1.0 is identity
  /// \param ramp an array of 256 values filled in with the gamma ramp
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  void SDL_CalculateGammaRamp3(
    double gamma,
    ffi.Pointer<Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp3(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRamp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Float, ffi.Pointer<Uint16>)>>('SDL_CalculateGammaRamp');
  late final _SDL_CalculateGammaRamp3 = _SDL_CalculateGammaRamp3Ptr.asFunction<
      void Function(double, ffi.Pointer<Uint16>)>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile3(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile3(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile3 = _SDL_RWFromFile3Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP3(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP3(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP3 = _SDL_RWFromFP3Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem3(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem3(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem3 = _SDL_RWFromMem3Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem3(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem3(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem3 = _SDL_RWFromConstMem3Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW3() {
    return _SDL_AllocRW3();
  }

  late final _SDL_AllocRW3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW3 =
      _SDL_AllocRW3Ptr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW3(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW3(
      area,
    );
  }

  late final _SDL_FreeRW3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW3 =
      _SDL_FreeRW3Ptr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize3(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize3(
      context,
    );
  }

  late final _SDL_RWsize3Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize3 =
      _SDL_RWsize3Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek3(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek3(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek3Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek3 = _SDL_RWseek3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell3(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell3(
      context,
    );
  }

  late final _SDL_RWtell3Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell3 =
      _SDL_RWtell3Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread3(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread3(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread3 = _SDL_RWread3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite3(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite3(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite3 = _SDL_RWwrite3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose3(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose3(
      context,
    );
  }

  late final _SDL_RWclose3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose3 =
      _SDL_RWclose3Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW3(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW3(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW3 = _SDL_LoadFile_RW3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile3(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile3(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile3 = _SDL_LoadFile3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU83(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU83(
      src,
    );
  }

  late final _SDL_ReadU83Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU83 =
      _SDL_ReadU83Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE163(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE163(
      src,
    );
  }

  late final _SDL_ReadLE163Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE163 =
      _SDL_ReadLE163Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE163(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE163(
      src,
    );
  }

  late final _SDL_ReadBE163Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE163 =
      _SDL_ReadBE163Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE323(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE323(
      src,
    );
  }

  late final _SDL_ReadLE323Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE323 =
      _SDL_ReadLE323Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE323(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE323(
      src,
    );
  }

  late final _SDL_ReadBE323Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE323 =
      _SDL_ReadBE323Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE643(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE643(
      src,
    );
  }

  late final _SDL_ReadLE643Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE643 =
      _SDL_ReadLE643Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE643(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE643(
      src,
    );
  }

  late final _SDL_ReadBE643Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE643 =
      _SDL_ReadBE643Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU83(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU83(
      dst,
      value,
    );
  }

  late final _SDL_WriteU83Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU83 =
      _SDL_WriteU83Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE163(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE163(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE163Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE163 = _SDL_WriteLE163Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE163(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE163(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE163Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE163 = _SDL_WriteBE163Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE323(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE323(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE323Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE323 = _SDL_WriteLE323Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE323(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE323(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE323Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE323 = _SDL_WriteBE323Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE643(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE643(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE643Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE643 = _SDL_WriteLE643Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE643(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE643(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE643Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE643 = _SDL_WriteBE643Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Determine whether two rectangles intersect.
  ///
  /// If either pointer is NULL the function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_IntersectRect
  int SDL_HasIntersection3(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection3(
      A,
      B,
    );
  }

  late final _SDL_HasIntersection3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_HasIntersection');
  late final _SDL_HasIntersection3 = _SDL_HasIntersection3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of two rectangles.
  ///
  /// If `result` is NULL then this function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the intersection of
  /// rectangles `A` and `B`
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasIntersection
  int SDL_IntersectRect3(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect3(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_IntersectRect');
  late final _SDL_IntersectRect3 = _SDL_IntersectRect3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the union of two rectangles.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the union of rectangles
  /// `A` and `B`
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_UnionRect3(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect3(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UnionRect');
  late final _SDL_UnionRect3 = _SDL_UnionRect3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate a minimal rectangle enclosing a set of points.
  ///
  /// If `clip` is not NULL then only points inside of the clipping rectangle are
  /// considered.
  ///
  /// \param points an array of SDL_Point structures representing points to be
  /// enclosed
  /// \param count the number of structures in the `points` array
  /// \param clip an SDL_Rect used for clipping or NULL to enclose all points
  /// \param result an SDL_Rect structure filled in with the minimal enclosing
  /// rectangle
  /// \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
  /// points were outside of the clipping rectangle.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_EnclosePoints3(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints3(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePoints3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Point>,
              ffi.Int,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_EnclosePoints');
  late final _SDL_EnclosePoints3 = _SDL_EnclosePoints3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Point>, int, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of a rectangle and line segment.
  ///
  /// This function is used to clip a line segment to a rectangle. A line segment
  /// contained entirely within the rectangle or that does not intersect will
  /// remain unchanged. A line segment that crosses the rectangle at either or
  /// both ends will be clipped to the boundary of the rectangle and the new
  /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
  ///
  /// \param rect an SDL_Rect structure representing the rectangle to intersect
  /// \param X1 a pointer to the starting X-coordinate of the line
  /// \param Y1 a pointer to the starting Y-coordinate of the line
  /// \param X2 a pointer to the ending X-coordinate of the line
  /// \param Y2 a pointer to the ending Y-coordinate of the line
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_IntersectRectAndLine3(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int> X1,
    ffi.Pointer<ffi.Int> Y1,
    ffi.Pointer<ffi.Int> X2,
    ffi.Pointer<ffi.Int> Y2,
  ) {
    return _SDL_IntersectRectAndLine3(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLine3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_IntersectRectAndLine');
  late final _SDL_IntersectRectAndLine3 =
      _SDL_IntersectRectAndLine3Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Compose a custom blend mode for renderers.
  ///
  /// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
  /// the SDL_BlendMode returned by this function if the renderer supports it.
  ///
  /// A blend mode controls how the pixels from a drawing operation (source) get
  /// combined with the pixels from the render target (destination). First, the
  /// components of the source and destination pixels get multiplied with their
  /// blend factors. Then, the blend operation takes the two products and
  /// calculates the result that will get stored in the render target.
  ///
  /// Expressed in pseudocode, it would look like this:
  ///
  /// ```c
  /// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
  /// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
  /// ```
  ///
  /// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
  /// dst)` can return one of the following:
  ///
  /// - `src + dst`
  /// - `src - dst`
  /// - `dst - src`
  /// - `min(src, dst)`
  /// - `max(src, dst)`
  ///
  /// The red, green, and blue components are always multiplied with the first,
  /// second, and third components of the SDL_BlendFactor, respectively. The
  /// fourth component is not used.
  ///
  /// The alpha component is always multiplied with the fourth component of the
  /// SDL_BlendFactor. The other components are not used in the alpha
  /// calculation.
  ///
  /// Support for these blend modes varies for each renderer. To check if a
  /// specific SDL_BlendMode is supported, create a renderer and pass it to
  /// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
  /// return with an error if the blend mode is not supported.
  ///
  /// This list describes the support of custom blend modes for each renderer in
  /// SDL 2.0.6. All renderers support the four blend modes listed in the
  /// SDL_BlendMode enumeration.
  ///
  /// - **direct3d**: Supports `SDL_BLENDOPERATION_ADD` with all factors.
  /// - **direct3d11**: Supports all operations with all factors. However, some
  /// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
  /// `SDL_BLENDOPERATION_MAXIMUM`.
  /// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL
  /// 2.0.6.
  /// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. Color and alpha factors need to be the same. OpenGL ES 1
  /// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`
  /// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha
  /// operations being different from each other. May support color and alpha
  /// factors being different from each other.
  /// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
  /// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
  /// operations with all factors.
  /// - **psp**: No custom blend mode support.
  /// - **software**: No custom blend mode support.
  ///
  /// Some renderers do not provide an alpha component for the default render
  /// target. The `SDL_BLENDFACTOR_DST_ALPHA` and
  /// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
  /// case.
  ///
  /// \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the source pixels
  /// \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the destination pixels
  /// \param colorOperation the SDL_BlendOperation used to combine the red,
  /// green, and blue components of the source and
  /// destination pixels
  /// \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the source pixels
  /// \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the destination pixels
  /// \param alphaOperation the SDL_BlendOperation used to combine the alpha
  /// component of the source and destination pixels
  /// \returns an SDL_BlendMode that represents the chosen factors and
  /// operations.
  ///
  /// \since This function is available since SDL 2.0.6.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_GetTextureBlendMode
  int SDL_ComposeCustomBlendMode3(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode3(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_ComposeCustomBlendMode');
  late final _SDL_ComposeCustomBlendMode3 = _SDL_ComposeCustomBlendMode3Ptr
      .asFunction<int Function(int, int, int, int, int, int)>();

  /// Allocate a new RGB surface.
  ///
  /// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If `depth` is greater than 8 bits, the pixel format is set using the
  /// [RGBA]mask parameters.
  ///
  /// The [RGBA]mask parameters are the bitmasks used to extract that color from
  /// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
  /// stored in the most significant byte. Using zeros for the RGB masks sets a
  /// default value, based on the depth. For example:
  ///
  /// ```c++
  /// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
  /// ```
  ///
  /// However, using zero for the Amask results in an Amask of 0.
  ///
  /// By default surfaces with an alpha mask are set up for blending as with:
  ///
  /// ```c++
  /// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
  /// ```
  ///
  /// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
  /// different `blendMode`.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface3(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface3(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurface3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32, Uint32, Uint32, Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface3 = _SDL_CreateRGBSurface3Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with a specific pixel format.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except instead
  /// of providing pixel color masks, you provide it with a predefined format
  /// from SDL_PixelFormatEnum.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat3(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat3(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormat3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat3 =
      _SDL_CreateRGBSurfaceWithFormat3Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  /// Allocate a new RGB surface with existing pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except it does
  /// not allocate memory for the pixel data, instead the caller provides an
  /// existing buffer of data for the surface to use.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom3(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom3(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFrom3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom3 =
      _SDL_CreateRGBSurfaceFrom3Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with with a specific pixel format and existing
  /// pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
  /// instead of providing pixel color masks, you provide it with a predefined
  /// format from SDL_PixelFormatEnum.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom3(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom3(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFrom3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom3 =
      _SDL_CreateRGBSurfaceWithFormatFrom3Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// Free an RGB surface.
  ///
  /// It is safe to pass NULL to this function.
  ///
  /// \param surface the SDL_Surface to free.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_LoadBMP
  /// \sa SDL_LoadBMP_RW
  void SDL_FreeSurface3(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface3(
      surface,
    );
  }

  late final _SDL_FreeSurface3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface3 = _SDL_FreeSurface3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the palette used by a surface.
  ///
  /// A single palette can be shared with many surfaces.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param palette the SDL_Palette structure to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetSurfacePalette3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette3(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalette3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette3 = _SDL_SetSurfacePalette3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// Set up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
  /// and read from `surface->pixels`, using the pixel format stored in
  /// `surface->format`. Once you are done accessing the surface, you should use
  /// SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
  /// 0, then you can read and write to the surface at any time, and the pixel
  /// format of the surface will not change.
  ///
  /// \param surface the SDL_Surface structure to be locked
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MUSTLOCK
  /// \sa SDL_UnlockSurface
  int SDL_LockSurface3(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface3(
      surface,
    );
  }

  late final _SDL_LockSurface3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface3 =
      _SDL_LockSurface3Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Release a surface after directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockSurface
  void SDL_UnlockSurface3(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface3(
      surface,
    );
  }

  late final _SDL_UnlockSurface3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface3 = _SDL_UnlockSurface3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a BMP image from a seekable SDL data stream.
  ///
  /// The new surface should be freed with SDL_FreeSurface(). Not doing so will
  /// result in a memory leak.
  ///
  /// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
  /// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
  /// from a file, convert it to an SDL_Surface and then close the file.
  ///
  /// \param src the data stream for the surface
  /// \param freesrc non-zero to close the stream after being read
  /// \returns a pointer to a new SDL_Surface structure or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeSurface
  /// \sa SDL_RWFromFile
  /// \sa SDL_LoadBMP
  /// \sa SDL_SaveBMP_RW
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW3(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW3(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RW3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW3 = _SDL_LoadBMP_RW3Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream in BMP format.
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// \param surface the SDL_Surface structure containing the image to be saved
  /// \param dst a data stream to save to
  /// \param freedst non-zero to close the stream after being written
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadBMP_RW
  /// \sa SDL_SaveBMP
  int SDL_SaveBMP_RW3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW3(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RW3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW3 = _SDL_SaveBMP_RW3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// Set the RLE acceleration hint for a surface.
  ///
  /// If RLE is enabled, color key and alpha blending blits are much faster, but
  /// the surface must be locked before directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to optimize
  /// \param flag 0 to disable, non-zero to enable RLE acceleration
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_LockSurface
  /// \sa SDL_UnlockSurface
  int SDL_SetSurfaceRLE3(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE3(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLE3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int)>>('SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE3 = _SDL_SetSurfaceRLE3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Returns whether the surface is RLE enabled
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SetSurfaceRLE
  int SDL_HasSurfaceRLE3(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE3(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLE3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE3 = _SDL_HasSurfaceRLE3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the color key (transparent pixel) in a surface.
  ///
  /// The color key defines a pixel value that will be treated as transparent in
  /// a blit. For example, one can use this to specify that cyan pixels should be
  /// considered transparent, and therefore not rendered.
  ///
  /// It is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// RLE acceleration can substantially speed up blitting of images with large
  /// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
  /// \param key the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetColorKey
  int SDL_SetColorKey3(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey3(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKey3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey3 = _SDL_SetColorKey3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Returns whether the surface has a color key
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_SetColorKey
  /// \sa SDL_GetColorKey
  int SDL_HasColorKey3(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey3(
      surface,
    );
  }

  late final _SDL_HasColorKey3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasColorKey');
  late final _SDL_HasColorKey3 =
      _SDL_HasColorKey3Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the color key (transparent pixel) for a surface.
  ///
  /// The color key is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// If the surface doesn't have color key enabled this function returns -1.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param key a pointer filled in with the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetColorKey
  int SDL_GetColorKey3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey3(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKey3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey3 = _SDL_GetColorKey3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// Set an additional color value multiplied into blit operations.
  ///
  /// When this surface is blitted, during the blit operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param r the red color value multiplied into blit operations
  /// \param g the green color value multiplied into blit operations
  /// \param b the blue color value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_SetSurfaceColorMod3(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod3(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorMod3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod3 = _SDL_SetSurfaceColorMod3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// Get the additional color value multiplied into blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_GetSurfaceColorMod3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod3(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorMod3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod3 = _SDL_GetSurfaceColorMod3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value used in blit operations.
  ///
  /// When this surface is blitted, during the blit operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param alpha the alpha value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_SetSurfaceAlphaMod3(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod3(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaMod3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, Uint8)>>('SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod3 = _SDL_SetSurfaceAlphaMod3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the additional alpha value used in blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_GetSurfaceAlphaMod3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod3(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaMod3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod3 = _SDL_GetSurfaceAlphaMod3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for blit operations.
  ///
  /// To copy a surface to another surface (or texture) without blending with the
  /// existing data, the blendmode of the SOURCE surface should be set to
  /// `SDL_BLENDMODE_NONE`.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param blendMode the SDL_BlendMode to use for blit blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceBlendMode
  int SDL_SetSurfaceBlendMode3(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode3(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode3 = _SDL_SetSurfaceBlendMode3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the blend mode used for blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetSurfaceBlendMode
  int SDL_GetSurfaceBlendMode3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode3(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode3 =
      _SDL_GetSurfaceBlendMode3Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.Int32>)>();

  /// Set the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// Note that blits are automatically clipped to the edges of the source and
  /// destination surfaces.
  ///
  /// \param surface the SDL_Surface structure to be clipped
  /// \param rect the SDL_Rect structure representing the clipping rectangle, or
  /// NULL to disable clipping
  /// \returns SDL_TRUE if the rectangle intersects the surface, otherwise
  /// SDL_FALSE and blits will be completely clipped.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetClipRect
  int SDL_SetClipRect3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect3(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect3 = _SDL_SetClipRect3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// \param surface the SDL_Surface structure representing the surface to be
  /// clipped
  /// \param rect an SDL_Rect structure filled in with the clipping rectangle for
  /// the surface
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetClipRect
  void SDL_GetClipRect3(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect3(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect3 = _SDL_GetClipRect3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface3(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface3(
      surface,
    );
  }

  late final _SDL_DuplicateSurface3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface3 = _SDL_DuplicateSurface3Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Copy an existing surface to a new surface of the specified format.
  ///
  /// This function is used to optimize images for faster *repeat* blitting. This
  /// is accomplished by converting the original and storing the result as a new
  /// surface. The new, optimized surface can then be used as the source for
  /// future blits, making them faster.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param fmt the SDL_PixelFormat structure that the new surface is optimized
  /// for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurfaceFormat
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface3(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurface3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface3 = _SDL_ConvertSurface3Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  /// Copy an existing surface to a new surface of the specified format enum.
  ///
  /// This function operates just like SDL_ConvertSurface(), but accepts an
  /// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
  /// it might be easier to call but it doesn't have access to palette
  /// information for the destination surface, in case that would be important.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param pixel_format the SDL_PixelFormatEnum that the new surface is
  /// optimized for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurface
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat3(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat3(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormat3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat3 =
      _SDL_ConvertSurfaceFormat3Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// Copy a block of pixels of one format to another format.
  ///
  /// \param width the width of the block to copy, in pixels
  /// \param height the height of the block to copy, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with new pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_ConvertPixels3(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels3(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixels3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels3 = _SDL_ConvertPixels3Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Premultiply the alpha on a block of pixels.
  ///
  /// This is safe to use with src == dst, but not for other overlapping areas.
  ///
  /// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
  ///
  /// \param width the width of the block to convert, in pixels
  /// \param height the height of the block to convert, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with premultiplied pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_PremultiplyAlpha3(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_PremultiplyAlpha3(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_PremultiplyAlpha3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_PremultiplyAlpha');
  late final _SDL_PremultiplyAlpha3 = _SDL_PremultiplyAlpha3Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Perform a fast fill of a rectangle with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL to fill the entire surface
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRects
  int SDL_FillRect3(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect3(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect3 = _SDL_FillRect3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  /// Perform a fast fill of a set of rectangles with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rects an array of SDL_Rects representing the rectangles to fill.
  /// \param count the number of rectangles in the array
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRect
  int SDL_FillRects3(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects3(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRects3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects3 = _SDL_FillRects3Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// Perform a fast blit from the source surface to the destination surface.
  ///
  /// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
  /// macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_UpperBlit3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit3(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlit3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit3 = _SDL_UpperBlit3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface blitting only.
  ///
  /// This is a semi-private blit function and it performs low-level surface
  /// blitting, assuming the input rectangles have already been clipped.
  ///
  /// Unless you know what you're doing, you should be using SDL_BlitSurface()
  /// instead.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied, or NULL to copy the entire surface
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_LowerBlit3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit3(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlit3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit3 = _SDL_LowerBlit3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a fast, low quality, stretch blit between two surfaces of the same
  /// format.
  ///
  /// Please use SDL_BlitScaled() instead.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SoftStretch3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch3(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretch3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch3 = _SDL_SoftStretch3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform bilinear scaling between two surfaces of the same format, 32BPP.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_SoftStretchLinear3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretchLinear3(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchLinear3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretchLinear');
  late final _SDL_SoftStretchLinear3 = _SDL_SoftStretchLinear3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a scaled surface copy to a destination surface.
  ///
  /// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
  /// merely a macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_UpperBlitScaled3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled3(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaled3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled3 = _SDL_UpperBlitScaled3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface scaled blitting only.
  ///
  /// This is a semi-private function and it performs low-level surface blitting,
  /// assuming the input rectangles have already been clipped.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_LowerBlitScaled3(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled3(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaled3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled3 = _SDL_LowerBlitScaled3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Set the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  void SDL_SetYUVConversionMode3(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode3(
      mode,
    );
  }

  late final _SDL_SetYUVConversionMode3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode3 =
      _SDL_SetYUVConversionMode3Ptr.asFunction<void Function(int)>();

  /// Get the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionMode3() {
    return _SDL_GetYUVConversionMode3();
  }

  late final _SDL_GetYUVConversionMode3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode3 =
      _SDL_GetYUVConversionMode3Ptr.asFunction<int Function()>();

  /// Get the YUV conversion mode, returning the correct mode for the resolution
  /// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionModeForResolution3(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution3(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolution3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int, ffi.Int)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution3 =
      _SDL_GetYUVConversionModeForResolution3Ptr.asFunction<
          int Function(int, int)>();

  /// Get the number of video drivers compiled into SDL.
  ///
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVideoDriver
  int SDL_GetNumVideoDrivers3() {
    return _SDL_GetNumVideoDrivers3();
  }

  late final _SDL_GetNumVideoDrivers3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers3 =
      _SDL_GetNumVideoDrivers3Ptr.asFunction<int Function()>();

  /// Get the name of a built in video driver.
  ///
  /// The video drivers are presented in the order in which they are normally
  /// checked during initialization.
  ///
  /// \param index the index of a video driver
  /// \returns the name of the video driver with the given **index**.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  ffi.Pointer<ffi.Char> SDL_GetVideoDriver3(
    int index,
  ) {
    return _SDL_GetVideoDriver3(
      index,
    );
  }

  late final _SDL_GetVideoDriver3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver3 =
      _SDL_GetVideoDriver3Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// This function initializes the video subsystem, setting up a connection to
  /// the window manager, etc, and determines the available display modes and
  /// pixel formats, but does not initialize a window or graphics mode.
  ///
  /// If you use this function and you haven't used the SDL_INIT_VIDEO flag with
  /// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
  /// before calling SDL_Quit().
  ///
  /// It is safe to call this function multiple times. SDL_VideoInit() will call
  /// SDL_VideoQuit() itself if the video subsystem has already been initialized.
  ///
  /// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
  /// specific `driver_name`.
  ///
  /// \param driver_name the name of a video driver to initialize, or NULL for
  /// the default driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  /// \sa SDL_InitSubSystem
  /// \sa SDL_VideoQuit
  int SDL_VideoInit3(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_VideoInit3(
      driver_name,
    );
  }

  late final _SDL_VideoInit3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit3 =
      _SDL_VideoInit3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Shut down the video subsystem, if initialized with SDL_VideoInit().
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_VideoInit
  void SDL_VideoQuit3() {
    return _SDL_VideoQuit3();
  }

  late final _SDL_VideoQuit3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit3 = _SDL_VideoQuit3Ptr.asFunction<void Function()>();

  /// Get the name of the currently initialized video driver.
  ///
  /// \returns the name of the current video driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  ffi.Pointer<ffi.Char> SDL_GetCurrentVideoDriver3() {
    return _SDL_GetCurrentVideoDriver3();
  }

  late final _SDL_GetCurrentVideoDriver3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver3 = _SDL_GetCurrentVideoDriver3Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the number of available video displays.
  ///
  /// \returns a number >= 1 or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  int SDL_GetNumVideoDisplays3() {
    return _SDL_GetNumVideoDisplays3();
  }

  late final _SDL_GetNumVideoDisplays3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays3 =
      _SDL_GetNumVideoDisplays3Ptr.asFunction<int Function()>();

  /// Get the name of a display in UTF-8 encoding.
  ///
  /// \param displayIndex the index of display from which the name should be
  /// queried
  /// \returns the name of a display or NULL for an invalid display index or
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  ffi.Pointer<ffi.Char> SDL_GetDisplayName3(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName3(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayName3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName3 =
      _SDL_GetDisplayName3Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// \param displayIndex the index of the display to query
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayBounds3(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds3(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBounds3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds3 = _SDL_GetDisplayBounds3Ptr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the usable desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Apple's macOS, this
  /// subtracts the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// The parameter `rect` is ignored if it is NULL.
  ///
  /// This function also returns -1 if the parameter `displayIndex` is out of
  /// range.
  ///
  /// \param displayIndex the index of the display to query the usable bounds
  /// from
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayUsableBounds3(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds3(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBounds3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds3 = _SDL_GetDisplayUsableBounds3Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the dots/pixels-per-inch for a display.
  ///
  /// Diagonal, horizontal and vertical DPI can all be optionally returned if the
  /// appropriate parameter is non-NULL.
  ///
  /// A failure of this function usually means that either no DPI information is
  /// available or the `displayIndex` is out of range.
  ///
  /// \param displayIndex the index of the display from which DPI information
  /// should be queried
  /// \param ddpi a pointer filled in with the diagonal DPI of the display; may
  /// be NULL
  /// \param hdpi a pointer filled in with the horizontal DPI of the display; may
  /// be NULL
  /// \param vdpi a pointer filled in with the vertical DPI of the display; may
  /// be NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayDPI3(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI3(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPI3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI3 = _SDL_GetDisplayDPI3Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get the orientation of a display.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns The SDL_DisplayOrientation enum value of the display, or
  /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayOrientation3(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation3(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientation3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation3 =
      _SDL_GetDisplayOrientation3Ptr.asFunction<int Function(int)>();

  /// Get the number of available display modes.
  ///
  /// The `displayIndex` needs to be in the range from 0 to
  /// SDL_GetNumVideoDisplays() - 1.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetNumDisplayModes3(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes3(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModes3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes3 =
      _SDL_GetNumDisplayModes3Ptr.asFunction<int Function(int)>();

  /// Get information about a specific display mode.
  ///
  /// The display modes are sorted in this priority:
  ///
  /// - width -> largest to smallest
  /// - height -> largest to smallest
  /// - bits per pixel -> more colors to fewer colors
  /// - packed pixel layout -> largest to smallest
  /// - refresh rate -> highest to lowest
  ///
  /// \param displayIndex the index of the display to query
  /// \param modeIndex the index of the display mode to query
  /// \param mode an SDL_DisplayMode structure filled in with the mode at
  /// `modeIndex`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumDisplayModes
  int SDL_GetDisplayMode3(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode3(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode3 = _SDL_GetDisplayMode3Ptr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the desktop's display mode.
  ///
  /// There's a difference between this function and SDL_GetCurrentDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the previous native display mode, and not the current
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetCurrentDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetDesktopDisplayMode3(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode3(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode3 = _SDL_GetDesktopDisplayMode3Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the current display mode.
  ///
  /// There's a difference between this function and SDL_GetDesktopDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the current display mode, and not the previous native
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDesktopDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetCurrentDisplayMode3(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode3(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode3 = _SDL_GetCurrentDisplayMode3Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the closest match to the requested display mode.
  ///
  /// The available display modes are scanned and `closest` is filled in with the
  /// closest mode matching the requested mode and returned. The mode format and
  /// refresh rate default to the desktop mode if they are set to 0. The modes
  /// are scanned with size being first priority, format being second priority,
  /// and finally checking the refresh rate. If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure containing the desired display
  /// mode
  /// \param closest an SDL_DisplayMode structure filled in with the closest
  /// match of the available display modes
  /// \returns the passed in value `closest` or NULL if no matching video mode
  /// was available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumDisplayModes
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode3(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode3(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode3 =
      _SDL_GetClosestDisplayMode3Ptr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the index of the display associated with a window.
  ///
  /// \param window the window to query
  /// \returns the index of the display containing the center of the window on
  /// success or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetWindowDisplayIndex3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex3(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex3 = _SDL_GetWindowDisplayIndex3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the display mode to use when a window is visible at fullscreen.
  ///
  /// This only affects the display mode used when the window is fullscreen. To
  /// change the window size when the window is not fullscreen, use
  /// SDL_SetWindowSize().
  ///
  /// \param window the window to affect
  /// \param mode the SDL_DisplayMode structure representing the mode to use, or
  /// NULL to use the window's dimensions and the desktop's format
  /// and refresh rate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_SetWindowDisplayMode3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode3(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode3 =
      _SDL_SetWindowDisplayMode3Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Query the display mode to use when a window is visible at fullscreen.
  ///
  /// \param window the window to query
  /// \param mode an SDL_DisplayMode structure filled in with the fullscreen
  /// display mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_GetWindowDisplayMode3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode3(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayMode3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode3 =
      _SDL_GetWindowDisplayMode3Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the raw ICC profile data for the screen the window is currently on.
  ///
  /// Data returned should be freed with SDL_free.
  ///
  /// \param window the window to query
  /// \param size the size of the ICC profile
  /// \returns the raw ICC profile data on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<ffi.Void> SDL_GetWindowICCProfile3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _SDL_GetWindowICCProfile3(
      window,
      size,
    );
  }

  late final _SDL_GetWindowICCProfile3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Size>)>>('SDL_GetWindowICCProfile');
  late final _SDL_GetWindowICCProfile3 =
      _SDL_GetWindowICCProfile3Ptr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Size>)>();

  /// Get the pixel format associated with the window.
  ///
  /// \param window the window to query
  /// \returns the pixel format of the window on success or
  /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetWindowPixelFormat3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat3(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormat3Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat3 = _SDL_GetWindowPixelFormat3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Create a window with the specified position, dimensions, and flags.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window
  /// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
  /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
  /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
  /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
  /// - `SDL_WINDOW_HIDDEN`: window is not visible
  /// - `SDL_WINDOW_BORDERLESS`: no window decoration
  /// - `SDL_WINDOW_RESIZABLE`: window can be resized
  /// - `SDL_WINDOW_MINIMIZED`: window is minimized
  /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
  /// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
  /// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
  /// supported (>= SDL 2.0.1)
  ///
  /// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
  /// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
  /// queried later using SDL_GetWindowFlags().
  ///
  /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
  /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
  ///
  /// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
  /// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to query the drawable size in pixels.
  ///
  /// If the window is set fullscreen, the width and height parameters `w` and
  /// `h` will not be used. However, invalid size parameters (e.g. too large) may
  /// still fail. Window size is actually limited to 16384 x 16384 for all
  /// platforms at window creation.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// On non-Apple devices, SDL requires you to either not link to the Vulkan
  /// loader or link to a dynamic library version. This limitation may be removed
  /// in a future version of SDL.
  ///
  /// \param title the title of the window, in UTF-8 encoding
  /// \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param w the width of the window, in screen coordinates
  /// \param h the height of the window, in screen coordinates
  /// \param flags 0, or one or more SDL_WindowFlags OR'd together
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindowFrom
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindow3(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow3(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindow3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow3 = _SDL_CreateWindow3Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Create an SDL window from an existing native window.
  ///
  /// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
  /// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
  /// before using SDL_CreateWindowFrom().
  ///
  /// \param data a pointer to driver-dependent window creation data, typically
  /// your native window cast to a void*
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom3(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom3(
      data,
    );
  }

  late final _SDL_CreateWindowFrom3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom3 = _SDL_CreateWindowFrom3Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// Get the numeric ID of a window.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param window the window to query
  /// \returns the ID of the window on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFromID
  int SDL_GetWindowID3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID3(
      window,
    );
  }

  late final _SDL_GetWindowID3Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID3 =
      _SDL_GetWindowID3Ptr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window from a stored ID.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param id the ID of the window
  /// \returns the window associated with `id` or NULL if it doesn't exist; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowID
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID3(
    int id,
  ) {
    return _SDL_GetWindowFromID3(
      id,
    );
  }

  late final _SDL_GetWindowFromID3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID3 = _SDL_GetWindowFromID3Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// Get the window flags.
  ///
  /// \param window the window to query
  /// \returns a mask of the SDL_WindowFlags associated with `window`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_HideWindow
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_SetWindowFullscreen
  /// \sa SDL_SetWindowGrab
  /// \sa SDL_ShowWindow
  int SDL_GetWindowFlags3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags3(
      window,
    );
  }

  late final _SDL_GetWindowFlags3Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags3 = _SDL_GetWindowFlags3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the title of a window.
  ///
  /// This string is expected to be in UTF-8 encoding.
  ///
  /// \param window the window to change
  /// \param title the desired window title in UTF-8 format
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowTitle
  void SDL_SetWindowTitle3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _SDL_SetWindowTitle3(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitle3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle3 = _SDL_SetWindowTitle3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Get the title of a window.
  ///
  /// \param window the window to query
  /// \returns the title of the window in UTF-8 format or "" if there is no
  /// title.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowTitle
  ffi.Pointer<ffi.Char> SDL_GetWindowTitle3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle3(
      window,
    );
  }

  late final _SDL_GetWindowTitle3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle3 = _SDL_GetWindowTitle3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the icon for a window.
  ///
  /// \param window the window to change
  /// \param icon an SDL_Surface structure containing the icon for the window
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_SetWindowIcon3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon3(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIcon3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon3 = _SDL_SetWindowIcon3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// Associate an arbitrary named pointer with a window.
  ///
  /// `name` is case-sensitive.
  ///
  /// \param window the window to associate with the pointer
  /// \param name the name of the pointer
  /// \param userdata the associated pointer
  /// \returns the previous value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowData
  ffi.Pointer<ffi.Void> SDL_SetWindowData3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData3(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowData3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData3 = _SDL_SetWindowData3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Retrieve the data pointer associated with a window.
  ///
  /// \param window the window to query
  /// \param name the name of the pointer
  /// \returns the value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowData
  ffi.Pointer<ffi.Void> SDL_GetWindowData3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetWindowData3(
      window,
      name,
    );
  }

  late final _SDL_GetWindowData3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData3 = _SDL_GetWindowData3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Set the position of a window.
  ///
  /// The window coordinate origin is the upper left of the display.
  ///
  /// \param window the window to reposition
  /// \param x the x coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowPosition
  void SDL_SetWindowPosition3(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition3(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPosition3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition3 = _SDL_SetWindowPosition3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the position of a window.
  ///
  /// If you do not need the value for one of the positions a NULL may be passed
  /// in the `x` or `y` parameter.
  ///
  /// \param window the window to query
  /// \param x a pointer filled in with the x position of the window, in screen
  /// coordinates, may be NULL
  /// \param y a pointer filled in with the y position of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowPosition
  void SDL_GetWindowPosition3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetWindowPosition3(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPosition3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition3 = _SDL_GetWindowPosition3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the size of a window's client area.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// Fullscreen windows automatically match the size of the display mode, and
  /// you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// \param window the window to change
  /// \param w the width of the window in pixels, in screen coordinates, must be
  /// > 0
  /// \param h the height of the window in pixels, in screen coordinates, must be
  /// > 0
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_SetWindowDisplayMode
  void SDL_SetWindowSize3(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize3(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int, ffi.Int)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize3 = _SDL_SetWindowSize3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the size of a window's client area.
  ///
  /// NULL can safely be passed as the `w` or `h` parameter if the width or
  /// height value is not desired.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
  /// real client area size in pixels.
  ///
  /// \param window the window to query the width and height from
  /// \param w a pointer filled in with the width of the window, in screen
  /// coordinates, may be NULL
  /// \param h a pointer filled in with the height of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetDrawableSize
  /// \sa SDL_Vulkan_GetDrawableSize
  /// \sa SDL_SetWindowSize
  void SDL_GetWindowSize3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSize3(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize3 = _SDL_GetWindowSize3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window's borders (decorations) around the client area.
  ///
  /// Note: If this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
  /// window in question was borderless.
  ///
  /// Note: This function may fail on systems where the window has not yet been
  /// decorated by the display server (for example, immediately after calling
  /// SDL_CreateWindow). It is recommended that you wait at least until the
  /// window has been presented and composited, so that the window system has a
  /// chance to decorate the window and provide the border dimensions to SDL.
  ///
  /// This function also returns -1 if getting the information is not supported.
  ///
  /// \param window the window to query the size values of the border
  /// (decorations) from
  /// \param top pointer to variable for storing the size of the top border; NULL
  /// is permitted
  /// \param left pointer to variable for storing the size of the left border;
  /// NULL is permitted
  /// \param bottom pointer to variable for storing the size of the bottom
  /// border; NULL is permitted
  /// \param right pointer to variable for storing the size of the right border;
  /// NULL is permitted
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowSize
  int SDL_GetWindowBordersSize3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> bottom,
    ffi.Pointer<ffi.Int> right,
  ) {
    return _SDL_GetWindowBordersSize3(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize3 =
      _SDL_GetWindowBordersSize3Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the minimum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param min_w the minimum width of the window in pixels
  /// \param min_h the minimum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_SetWindowMinimumSize3(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize3(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize3 = _SDL_SetWindowMinimumSize3Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the minimum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the minimum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the minimum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_GetWindowMinimumSize3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMinimumSize3(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize3 =
      _SDL_GetWindowMinimumSize3Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the maximum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param max_w the maximum width of the window in pixels
  /// \param max_h the maximum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_SetWindowMaximumSize3(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize3(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize3 = _SDL_SetWindowMaximumSize3Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the maximum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the maximum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the maximum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_GetWindowMaximumSize3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMaximumSize3(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize3 =
      _SDL_GetWindowMaximumSize3Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the border state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
  /// or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// You can't change the border state of a fullscreen window.
  ///
  /// \param window the window of which to change the border state
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowBordered3(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered3(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBordered3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered3 = _SDL_SetWindowBordered3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
  /// allow/disallow user resizing of the window. This is a no-op if the window's
  /// resizable state already matches the requested state.
  ///
  /// You can't change the resizable state of a fullscreen window.
  ///
  /// \param window the window of which to change the resizable state
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowResizable3(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable3(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizable3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable3 = _SDL_SetWindowResizable3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the window to always be above the others.
  ///
  /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
  /// will bring the window to the front and keep the window above the rest.
  ///
  /// \param window The window of which to change the always on top state
  /// \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
  /// disable
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowAlwaysOnTop3(
    ffi.Pointer<SDL_Window> window,
    int on_top,
  ) {
    return _SDL_SetWindowAlwaysOnTop3(
      window,
      on_top,
    );
  }

  late final _SDL_SetWindowAlwaysOnTop3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowAlwaysOnTop');
  late final _SDL_SetWindowAlwaysOnTop3 = _SDL_SetWindowAlwaysOnTop3Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Show a window.
  ///
  /// \param window the window to show
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HideWindow
  /// \sa SDL_RaiseWindow
  void SDL_ShowWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow3(
      window,
    );
  }

  late final _SDL_ShowWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow3 =
      _SDL_ShowWindow3Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Hide a window.
  ///
  /// \param window the window to hide
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowWindow
  void SDL_HideWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow3(
      window,
    );
  }

  late final _SDL_HideWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow3 =
      _SDL_HideWindow3Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Raise a window above other windows and set the input focus.
  ///
  /// \param window the window to raise
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_RaiseWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow3(
      window,
    );
  }

  late final _SDL_RaiseWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow3 =
      _SDL_RaiseWindow3Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Make a window as large as possible.
  ///
  /// \param window the window to maximize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MaximizeWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow3(
      window,
    );
  }

  late final _SDL_MaximizeWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow3 = _SDL_MaximizeWindow3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Minimize a window to an iconic representation.
  ///
  /// \param window the window to minimize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MinimizeWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow3(
      window,
    );
  }

  late final _SDL_MinimizeWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow3 = _SDL_MinimizeWindow3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Restore the size and position of a minimized or maximized window.
  ///
  /// \param window the window to restore
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  void SDL_RestoreWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow3(
      window,
    );
  }

  late final _SDL_RestoreWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow3 = _SDL_RestoreWindow3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's fullscreen state.
  ///
  /// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
  /// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
  /// that takes the size of the desktop; and 0 for windowed mode.
  ///
  /// \param window the window to change
  /// \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_SetWindowFullscreen3(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen3(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreen3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, Uint32)>>('SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen3 = _SDL_SetWindowFullscreen3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get the SDL surface associated with the window.
  ///
  /// A new surface will be created with the optimal format for the window, if
  /// necessary. This surface will be freed when the window is destroyed. Do not
  /// free this surface.
  ///
  /// This surface will be invalidated if the window is resized. After resizing a
  /// window this function must be called again to return a valid surface.
  ///
  /// You may not combine this with 3D or the rendering API on this window.
  ///
  /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
  ///
  /// \param window the window to query
  /// \returns the surface associated with the window, or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UpdateWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface3(
      window,
    );
  }

  late final _SDL_GetWindowSurface3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface3 = _SDL_GetWindowSurface3Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// Copy the window surface to the screen.
  ///
  /// This is the function you use to reflect any changes to the surface on the
  /// screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_Flip().
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  int SDL_UpdateWindowSurface3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface3(
      window,
    );
  }

  late final _SDL_UpdateWindowSurface3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface3 = _SDL_UpdateWindowSurface3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Copy areas of the window surface to the screen.
  ///
  /// This is the function you use to reflect changes to portions of the surface
  /// on the screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
  ///
  /// \param window the window to update
  /// \param rects an array of SDL_Rect structures representing areas of the
  /// surface to copy
  /// \param numrects the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurface
  int SDL_UpdateWindowSurfaceRects3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects3(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRects3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects3 =
      _SDL_UpdateWindowSurfaceRects3Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// Set a window's input grab mode.
  ///
  /// When input is grabbed, the mouse is confined to the window. This function
  /// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
  /// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window the window for which the input grab mode should be set
  /// \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGrabbedWindow
  /// \sa SDL_GetWindowGrab
  void SDL_SetWindowGrab3(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab3(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrab3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab3 = _SDL_SetWindowGrab3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's keyboard grab mode.
  ///
  /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
  /// the Meta/Super key. Note that not all system keyboard shortcuts can be
  /// captured by applications (one example is Ctrl+Alt+Del on Windows).
  ///
  /// This is primarily intended for specialized applications such as VNC clients
  /// or VM frontends. Normal games should not use keyboard grab.
  ///
  /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
  /// window is full-screen to ensure the user is not trapped in your
  /// application. If you have a custom keyboard shortcut to exit fullscreen
  /// mode, you may suppress this behavior with
  /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window The window for which the keyboard grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowKeyboardGrab
  /// \sa SDL_SetWindowMouseGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowKeyboardGrab3(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowKeyboardGrab3(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowKeyboardGrab3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Int32)>>('SDL_SetWindowKeyboardGrab');
  late final _SDL_SetWindowKeyboardGrab3 = _SDL_SetWindowKeyboardGrab3Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's mouse grab mode.
  ///
  /// Mouse grab confines the mouse cursor to the window.
  ///
  /// \param window The window for which the mouse grab mode should be set.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowMouseGrab
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowMouseGrab3(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowMouseGrab3(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowMouseGrab3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowMouseGrab');
  late final _SDL_SetWindowMouseGrab3 = _SDL_SetWindowMouseGrab3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get a window's input grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGrab
  int SDL_GetWindowGrab3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab3(
      window,
    );
  }

  late final _SDL_GetWindowGrab3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab3 = _SDL_GetWindowGrab3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's keyboard grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowKeyboardGrab3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowKeyboardGrab3(
      window,
    );
  }

  late final _SDL_GetWindowKeyboardGrab3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowKeyboardGrab');
  late final _SDL_GetWindowKeyboardGrab3 = _SDL_GetWindowKeyboardGrab3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's mouse grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowMouseGrab3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseGrab3(
      window,
    );
  }

  late final _SDL_GetWindowMouseGrab3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowMouseGrab');
  late final _SDL_GetWindowMouseGrab3 = _SDL_GetWindowMouseGrab3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window that currently has an input grab enabled.
  ///
  /// \returns the window if input is grabbed or NULL otherwise.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetWindowGrab
  /// \sa SDL_SetWindowGrab
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow3() {
    return _SDL_GetGrabbedWindow3();
  }

  late final _SDL_GetGrabbedWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow3 = _SDL_GetGrabbedWindow3Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Confines the cursor to the specified area of a window.
  ///
  /// Note that this does NOT grab the cursor, it only defines the area a cursor
  /// is restricted to when the window has mouse focus.
  ///
  /// \param window The window that will be associated with the barrier.
  /// \param rect A rectangle area in window-relative coordinates. If NULL the
  /// barrier for the specified window will be destroyed.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetWindowMouseRect
  /// \sa SDL_SetWindowMouseGrab
  int SDL_SetWindowMouseRect3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetWindowMouseRect3(
      window,
      rect,
    );
  }

  late final _SDL_SetWindowMouseRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetWindowMouseRect');
  late final _SDL_SetWindowMouseRect3 = _SDL_SetWindowMouseRect3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>)>();

  /// Get the mouse confinement rectangle of a window.
  ///
  /// \param window The window to query
  /// \returns A pointer to the mouse confinement rectangle of a window, or NULL
  /// if there isn't one.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetWindowMouseRect
  ffi.Pointer<SDL_Rect> SDL_GetWindowMouseRect3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseRect3(
      window,
    );
  }

  late final _SDL_GetWindowMouseRect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Rect> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowMouseRect');
  late final _SDL_GetWindowMouseRect3 = _SDL_GetWindowMouseRect3Ptr.asFunction<
      ffi.Pointer<SDL_Rect> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method sets the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The
  /// brightness set will not follow the window if it is moved to another
  /// display.
  ///
  /// Many platforms will refuse to set the display brightness in modern times.
  /// You are better off using a shader to adjust gamma during rendering, or
  /// something similar.
  ///
  /// \param window the window used to select the display whose brightness will
  /// be changed
  /// \param brightness the brightness (gamma multiplier) value to set where 0.0
  /// is completely dark and 1.0 is normal brightness
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowBrightness
  /// \sa SDL_SetWindowGammaRamp
  int SDL_SetWindowBrightness3(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness3(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightness3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness3 = _SDL_SetWindowBrightness3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose brightness will
  /// be queried
  /// \returns the brightness for the display where 0.0 is completely dark and
  /// 1.0 is normal brightness.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowBrightness
  double SDL_GetWindowBrightness3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness3(
      window,
    );
  }

  late final _SDL_GetWindowBrightness3Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness3 = _SDL_GetWindowBrightness3Ptr
      .asFunction<double Function(ffi.Pointer<SDL_Window>)>();

  /// Set the opacity for a window.
  ///
  /// The parameter `opacity` will be clamped internally between 0.0f
  /// (transparent) and 1.0f (opaque).
  ///
  /// This function also returns -1 if setting the opacity isn't supported.
  ///
  /// \param window the window which will be made transparent or opaque
  /// \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowOpacity
  int SDL_SetWindowOpacity3(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity3(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacity3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity3 = _SDL_SetWindowOpacity3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// The parameter `opacity` is ignored if it is NULL.
  ///
  /// This function also returns -1 if an invalid window was provided.
  ///
  /// \param window the window to get the current opacity value from
  /// \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_SetWindowOpacity
  int SDL_GetWindowOpacity3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity3(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacity3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity3 = _SDL_GetWindowOpacity3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// Set the window as a modal for another window.
  ///
  /// \param modal_window the window that should be set modal
  /// \param parent_window the parent window for the modal window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  int SDL_SetWindowModalFor3(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor3(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalFor3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor3 = _SDL_SetWindowModalFor3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// Explicitly set input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that is completely
  /// obscured by other windows.
  ///
  /// \param window the window that should get the input focus
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RaiseWindow
  int SDL_SetWindowInputFocus3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus3(
      window,
    );
  }

  late final _SDL_SetWindowInputFocus3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus3 = _SDL_SetWindowInputFocus3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the gamma ramp for the display that owns a given window.
  ///
  /// Set the gamma translation table for the red, green, and blue channels of
  /// the video hardware. Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel. The
  /// input is the index into the array, and the output is the 16-bit gamma value
  /// at that index, scaled to the output color precision.
  ///
  /// Despite the name and signature, this method sets the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
  /// ramp set will not follow the window if it is moved to another display.
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be changed
  /// \param red a 256 element array of 16-bit quantities representing the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities representing the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities representing the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowGammaRamp
  int SDL_SetWindowGammaRamp3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp3(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRamp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp3 = _SDL_SetWindowGammaRamp3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Get the gamma ramp for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be queried
  /// \param red a 256 element array of 16-bit quantities filled in with the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities filled in with the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities filled in with the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  int SDL_GetWindowGammaRamp3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp3(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRamp3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp3 = _SDL_GetWindowGammaRamp3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable from
  /// any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of a
  /// given window as special. This callback is run during event processing if we
  /// need to tell the OS to treat a region of the window specially; the use of
  /// this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within a
  /// special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire when
  /// the OS is deciding whether to drag your window, but it fires for lots of
  /// other reasons, too, some unrelated to anything you probably care about _and
  /// when the mouse isn't actually at the location it is testing_). Since this
  /// can fire at any time, you should try to keep your callback efficient,
  /// devoid of allocations, etc.
  ///
  /// \param window the window to set hit-testing on
  /// \param callback the function to call when doing a hit-test
  /// \param callback_data an app-defined void pointer passed to **callback**
  /// \returns 0 on success or -1 on error (including unsupported); call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_SetWindowHitTest3(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest3(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTest3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest3 = _SDL_SetWindowHitTest3Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// Request a window to demand attention from the user.
  ///
  /// \param window the window to be flashed
  /// \param operation the flash operation
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_FlashWindow3(
    ffi.Pointer<SDL_Window> window,
    int operation,
  ) {
    return _SDL_FlashWindow3(
      window,
      operation,
    );
  }

  late final _SDL_FlashWindow3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_FlashWindow');
  late final _SDL_FlashWindow3 = _SDL_FlashWindow3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Destroy a window.
  ///
  /// If `window` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid window". See SDL_GetError().
  ///
  /// \param window the window to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_CreateWindowFrom
  void SDL_DestroyWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow3(
      window,
    );
  }

  late final _SDL_DestroyWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow3 = _SDL_DestroyWindow3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Check whether the screensaver is currently enabled.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
  ///
  /// \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
  /// disabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_EnableScreenSaver
  int SDL_IsScreenSaverEnabled3() {
    return _SDL_IsScreenSaverEnabled3();
  }

  late final _SDL_IsScreenSaverEnabled3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled3 =
      _SDL_IsScreenSaverEnabled3Ptr.asFunction<int Function()>();

  /// Allow the screen to be blanked by a screen saver.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_EnableScreenSaver3() {
    return _SDL_EnableScreenSaver3();
  }

  late final _SDL_EnableScreenSaver3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver3 =
      _SDL_EnableScreenSaver3Ptr.asFunction<void Function()>();

  /// Prevent the screen from being blanked by a screen saver.
  ///
  /// If you disable the screensaver, it is automatically re-enabled when SDL
  /// quits.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_EnableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_DisableScreenSaver3() {
    return _SDL_DisableScreenSaver3();
  }

  late final _SDL_DisableScreenSaver3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver3 =
      _SDL_DisableScreenSaver3Ptr.asFunction<void Function()>();

  /// Dynamically load an OpenGL library.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows. If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// If you do this, you need to retrieve all of the GL functions used in your
  /// program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \param path the platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetProcAddress
  /// \sa SDL_GL_UnloadLibrary
  int SDL_GL_LoadLibrary3(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _SDL_GL_LoadLibrary3(
      path,
    );
  }

  late final _SDL_GL_LoadLibrary3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary3 =
      _SDL_GL_LoadLibrary3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get an OpenGL function by name.
  ///
  /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
  /// GL functions must be retrieved this way. Usually this is used to retrieve
  /// function pointers to OpenGL extensions.
  ///
  /// There are some quirks to looking up OpenGL functions that require some
  /// extra care from the application. If you code carefully, you can handle
  /// these quirks without any platform-specific code, though:
  ///
  /// - On Windows, function pointers are specific to the current GL context;
  /// this means you need to have created a GL context and made it current
  /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
  /// create a second context, you should assume that any existing function
  /// pointers aren't valid to use with it. This is (currently) a
  /// Windows-specific limitation, and in practice lots of drivers don't suffer
  /// this limitation, but it is still the way the wgl API is documented to
  /// work and you should expect crashes if you don't respect it. Store a copy
  /// of the function pointers that comes and goes with context lifespan.
  /// - On X11, function pointers returned by this function are valid for any
  /// context, and can even be looked up before a context is created at all.
  /// This means that, for at least some common OpenGL implementations, if you
  /// look up a function that doesn't exist, you'll get a non-NULL result that
  /// is _NOT_ safe to call. You must always make sure the function is actually
  /// available for a given GL context before calling it, by checking for the
  /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
  /// or verifying that the version of OpenGL you're using offers the function
  /// as core functionality.
  /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
  /// isn't supported, but you can't count on this behavior. Check for
  /// extensions you use, and if you get a NULL anyway, act as if that
  /// extension wasn't available. This is probably a bug in the driver, but you
  /// can code defensively for this scenario anyhow.
  /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
  /// Next-gen display servers are waiting to replace it, and may or may not
  /// make the same promises about function pointers.
  /// - OpenGL function pointers must be declared `APIENTRY` as in the example
  /// code. This will ensure the proper calling convention is followed on
  /// platforms where this matters (Win32) thereby avoiding stack corruption.
  ///
  /// \param proc the name of an OpenGL function
  /// \returns a pointer to the named OpenGL function. The returned pointer
  /// should be cast to the appropriate function signature.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ExtensionSupported
  /// \sa SDL_GL_LoadLibrary
  /// \sa SDL_GL_UnloadLibrary
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress3(
    ffi.Pointer<ffi.Char> proc,
  ) {
    return _SDL_GL_GetProcAddress3(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddress3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress3 = _SDL_GL_GetProcAddress3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_LoadLibrary
  void SDL_GL_UnloadLibrary3() {
    return _SDL_GL_UnloadLibrary3();
  }

  late final _SDL_GL_UnloadLibrary3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary3 =
      _SDL_GL_UnloadLibrary3Ptr.asFunction<void Function()>();

  /// Check if an OpenGL extension is supported for the current context.
  ///
  /// This function operates on the current GL context; you must have created a
  /// context and it must be current before calling this function. Do not assume
  /// that all contexts you create will have the same set of extensions
  /// available, or that recreating an existing context will offer the same
  /// extensions again.
  ///
  /// While it's probably not a massive overhead, this function is not an O(1)
  /// operation. Check the extensions you care about after creating the GL
  /// context and save that information somewhere instead of calling the function
  /// every time you need to know.
  ///
  /// \param extension the name of the extension to check
  /// \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GL_ExtensionSupported3(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _SDL_GL_ExtensionSupported3(
      extension1,
    );
  }

  late final _SDL_GL_ExtensionSupported3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported3 = _SDL_GL_ExtensionSupported3Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Reset all previously set OpenGL context attributes to their default values.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_SetAttribute
  void SDL_GL_ResetAttributes3() {
    return _SDL_GL_ResetAttributes3();
  }

  late final _SDL_GL_ResetAttributes3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes3 =
      _SDL_GL_ResetAttributes3Ptr.asFunction<void Function()>();

  /// Set an OpenGL window attribute before window creation.
  ///
  /// This function sets the OpenGL attribute `attr` to `value`. The requested
  /// attributes should be set before creating an OpenGL window. You should use
  /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
  /// context, since the values obtained can differ from the requested ones.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
  /// \param value the desired value for the attribute
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_ResetAttributes
  int SDL_GL_SetAttribute3(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute3(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttribute3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32, ffi.Int)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute3 =
      _SDL_GL_SetAttribute3Ptr.asFunction<int Function(int, int)>();

  /// Get the actual value for an attribute from the current context.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
  /// \param value a pointer filled in with the current value of `attr`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ResetAttributes
  /// \sa SDL_GL_SetAttribute
  int SDL_GL_GetAttribute3(
    int attr,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _SDL_GL_GetAttribute3(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttribute3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, ffi.Pointer<ffi.Int>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute3 = _SDL_GL_GetAttribute3Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Create an OpenGL context for an OpenGL window, and make it current.
  ///
  /// Windows users new to OpenGL should note that, for historical reasons, GL
  /// functions added after OpenGL version 1.1 are not available by default.
  /// Those functions must be loaded at run-time, either with an OpenGL
  /// extension-handling library or with SDL_GL_GetProcAddress() and its related
  /// functions.
  ///
  /// SDL_GLContext is an alias for `void *`. It's opaque to the application.
  ///
  /// \param window the window to associate with the context
  /// \returns the OpenGL context associated with `window` or NULL on error; call
  /// SDL_GetError() for more details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_DeleteContext
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_CreateContext3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext3(
      window,
    );
  }

  late final _SDL_GL_CreateContext3Ptr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext3 = _SDL_GL_CreateContext3Ptr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// The context must have been created with a compatible window.
  ///
  /// \param window the window to associate with the context
  /// \param context the OpenGL context to associate with the window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  int SDL_GL_MakeCurrent3(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent3(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrent3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent3 = _SDL_GL_MakeCurrent3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// Get the currently active OpenGL window.
  ///
  /// \returns the currently active OpenGL window on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow3() {
    return _SDL_GL_GetCurrentWindow3();
  }

  late final _SDL_GL_GetCurrentWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow3 = _SDL_GL_GetCurrentWindow3Ptr
      .asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Get the currently active OpenGL context.
  ///
  /// \returns the currently active OpenGL context or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_GetCurrentContext3() {
    return _SDL_GL_GetCurrentContext3();
  }

  late final _SDL_GL_GetCurrentContext3Ptr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext3 =
      _SDL_GL_GetCurrentContext3Ptr.asFunction<SDL_GLContext Function()>();

  /// Get the size of a window's underlying drawable in pixels.
  ///
  /// This returns info useful for calling glViewport().
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GL_GetDrawableSize3(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GL_GetDrawableSize3(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSize3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize3 = _SDL_GL_GetDrawableSize3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the swap interval for the current OpenGL context.
  ///
  /// Some systems allow specifying -1 for the interval, to enable adaptive
  /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
  /// the vertical retrace for a given frame, it swaps buffers immediately, which
  /// might be less jarring for the user during occasional framerate drops. If an
  /// application requests adaptive vsync and the system does not support it,
  /// this function will fail and return -1. In such a case, you should probably
  /// retry the call with 1 for the interval.
  ///
  /// Adaptive vsync is implemented for some glX drivers with
  /// GLX_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/glx_swap_control_tear.txt
  ///
  /// and for some Windows drivers with WGL_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/wgl_swap_control_tear.txt
  ///
  /// Read more on the Khronos wiki:
  /// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with
  /// the vertical retrace, -1 for adaptive vsync
  /// \returns 0 on success or -1 if setting the swap interval is not supported;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetSwapInterval
  int SDL_GL_SetSwapInterval3(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval3(
      interval,
    );
  }

  late final _SDL_GL_SetSwapInterval3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval3 =
      _SDL_GL_SetSwapInterval3Ptr.asFunction<int Function(int)>();

  /// Get the swap interval for the current OpenGL context.
  ///
  /// If the system can't determine the swap interval, or there isn't a valid
  /// current context, this function will return 0 as a safe default.
  ///
  /// \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_SetSwapInterval
  int SDL_GL_GetSwapInterval3() {
    return _SDL_GL_GetSwapInterval3();
  }

  late final _SDL_GL_GetSwapInterval3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval3 =
      _SDL_GL_GetSwapInterval3Ptr.asFunction<int Function()>();

  /// Update a window with OpenGL rendering.
  ///
  /// This is used with double-buffered OpenGL contexts, which are the default.
  ///
  /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
  /// window, otherwise nothing will happen. If you aren't using
  /// glBindFramebuffer(), this is the default and you won't have to do anything
  /// extra.
  ///
  /// \param window the window to change
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GL_SwapWindow3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow3(
      window,
    );
  }

  late final _SDL_GL_SwapWindow3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow3 = _SDL_GL_SwapWindow3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Delete an OpenGL context.
  ///
  /// \param context the OpenGL context to be deleted
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  void SDL_GL_DeleteContext3(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext3(
      context,
    );
  }

  late final _SDL_GL_DeleteContext3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext3 =
      _SDL_GL_DeleteContext3Ptr.asFunction<void Function(SDL_GLContext)>();

  /// Query the window which currently has keyboard focus.
  ///
  /// \returns the window with keyboard focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetKeyboardFocus2() {
    return _SDL_GetKeyboardFocus2();
  }

  late final _SDL_GetKeyboardFocus2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetKeyboardFocus');
  late final _SDL_GetKeyboardFocus2 = _SDL_GetKeyboardFocus2Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Get a snapshot of the current state of the keyboard.
  ///
  /// The pointer returned is a pointer to an internal SDL array. It will be
  /// valid for the whole lifetime of the application and should not be freed by
  /// the caller.
  ///
  /// A array element with a value of 1 means that the key is pressed and a value
  /// of 0 means that it is not. Indexes into this array are obtained by using
  /// SDL_Scancode values.
  ///
  /// Use SDL_PumpEvents() to update the state array.
  ///
  /// This function gives you the current state after all events have been
  /// processed, so if a key or button has been pressed and released before you
  /// process events, then the pressed state will never show up in the
  /// SDL_GetKeyboardState() calls.
  ///
  /// Note: This function doesn't take into account whether shift has been
  /// pressed or not.
  ///
  /// \param numkeys if non-NULL, receives the length of the returned array
  /// \returns a pointer to an array of key states.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PumpEvents
  ffi.Pointer<Uint8> SDL_GetKeyboardState2(
    ffi.Pointer<ffi.Int> numkeys,
  ) {
    return _SDL_GetKeyboardState2(
      numkeys,
    );
  }

  late final _SDL_GetKeyboardState2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Uint8> Function(
              ffi.Pointer<ffi.Int>)>>('SDL_GetKeyboardState');
  late final _SDL_GetKeyboardState2 = _SDL_GetKeyboardState2Ptr.asFunction<
      ffi.Pointer<Uint8> Function(ffi.Pointer<ffi.Int>)>();

  /// Get the current key modifier state for the keyboard.
  ///
  /// \returns an OR'd combination of the modifier keys for the keyboard. See
  /// SDL_Keymod for details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyboardState
  /// \sa SDL_SetModState
  int SDL_GetModState2() {
    return _SDL_GetModState2();
  }

  late final _SDL_GetModState2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetModState');
  late final _SDL_GetModState2 =
      _SDL_GetModState2Ptr.asFunction<int Function()>();

  /// Set the current key modifier state for the keyboard.
  ///
  /// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
  /// modifier key states on your application. Simply pass your desired modifier
  /// states into `modstate`. This value may be a bitwise, OR'd combination of
  /// SDL_Keymod values.
  ///
  /// This does not change the keyboard state, only the key modifier flags that
  /// SDL reports.
  ///
  /// \param modstate the desired SDL_Keymod for the keyboard
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetModState
  void SDL_SetModState2(
    int modstate,
  ) {
    return _SDL_SetModState2(
      modstate,
    );
  }

  late final _SDL_SetModState2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetModState');
  late final _SDL_SetModState2 =
      _SDL_SetModState2Ptr.asFunction<void Function(int)>();

  /// Get the key code corresponding to the given scancode according to the
  /// current keyboard layout.
  ///
  /// See SDL_Keycode for details.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns the SDL_Keycode that corresponds to the given SDL_Scancode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromKey
  int SDL_GetKeyFromScancode2(
    int scancode,
  ) {
    return _SDL_GetKeyFromScancode2(
      scancode,
    );
  }

  late final _SDL_GetKeyFromScancode2Ptr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Int32)>>(
          'SDL_GetKeyFromScancode');
  late final _SDL_GetKeyFromScancode2 =
      _SDL_GetKeyFromScancode2Ptr.asFunction<int Function(int)>();

  /// Get the scancode corresponding to the given key code according to the
  /// current keyboard layout.
  ///
  /// See SDL_Scancode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns the SDL_Scancode that corresponds to the given SDL_Keycode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromKey2(
    int key,
  ) {
    return _SDL_GetScancodeFromKey2(
      key,
    );
  }

  late final _SDL_GetScancodeFromKey2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_Keycode)>>(
          'SDL_GetScancodeFromKey');
  late final _SDL_GetScancodeFromKey2 =
      _SDL_GetScancodeFromKey2Ptr.asFunction<int Function(int)>();

  /// Get a human-readable name for a scancode.
  ///
  /// See SDL_Scancode for details.
  ///
  /// **Warning**: The returned name is by design not stable across platforms,
  /// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
  /// Windows" under Microsoft Windows, and some scancodes like
  /// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
  /// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
  /// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
  /// unsuitable for creating a stable cross-platform two-way mapping between
  /// strings and scancodes.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns a pointer to the name for the scancode. If the scancode doesn't
  /// have a name this function returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeFromName
  ffi.Pointer<ffi.Char> SDL_GetScancodeName2(
    int scancode,
  ) {
    return _SDL_GetScancodeName2(
      scancode,
    );
  }

  late final _SDL_GetScancodeName2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GetScancodeName');
  late final _SDL_GetScancodeName2 = _SDL_GetScancodeName2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a scancode from a human-readable name.
  ///
  /// \param name the human-readable scancode name
  /// \returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
  /// recognized; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromName2(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetScancodeFromName2(
      name,
    );
  }

  late final _SDL_GetScancodeFromName2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetScancodeFromName');
  late final _SDL_GetScancodeFromName2 = _SDL_GetScancodeFromName2Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a human-readable name for a key.
  ///
  /// See SDL_Scancode and SDL_Keycode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns a pointer to a UTF-8 string that stays valid at least until the
  /// next call to this function. If you need it around any longer, you
  /// must copy it. If the key doesn't have a name, this function
  /// returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeFromKey
  ffi.Pointer<ffi.Char> SDL_GetKeyName2(
    int key,
  ) {
    return _SDL_GetKeyName2(
      key,
    );
  }

  late final _SDL_GetKeyName2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SDL_Keycode)>>(
          'SDL_GetKeyName');
  late final _SDL_GetKeyName2 =
      _SDL_GetKeyName2Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a key code from a human-readable name.
  ///
  /// \param name the human-readable key name
  /// \returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromName
  int SDL_GetKeyFromName2(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetKeyFromName2(
      name,
    );
  }

  late final _SDL_GetKeyFromName2Ptr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetKeyFromName');
  late final _SDL_GetKeyFromName2 =
      _SDL_GetKeyFromName2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Start accepting Unicode text input events.
  ///
  /// This function will start accepting Unicode text input events in the focused
  /// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and
  /// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in
  /// pair with SDL_StopTextInput().
  ///
  /// On some platforms using this function activates the screen keyboard.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextInputRect
  /// \sa SDL_StopTextInput
  void SDL_StartTextInput2() {
    return _SDL_StartTextInput2();
  }

  late final _SDL_StartTextInput2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StartTextInput');
  late final _SDL_StartTextInput2 =
      _SDL_StartTextInput2Ptr.asFunction<void Function()>();

  /// Check whether or not Unicode text input events are enabled.
  ///
  /// \returns SDL_TRUE if text input events are enabled else SDL_FALSE.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  int SDL_IsTextInputActive2() {
    return _SDL_IsTextInputActive2();
  }

  late final _SDL_IsTextInputActive2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsTextInputActive');
  late final _SDL_IsTextInputActive2 =
      _SDL_IsTextInputActive2Ptr.asFunction<int Function()>();

  /// Stop receiving any text input events.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_StopTextInput2() {
    return _SDL_StopTextInput2();
  }

  late final _SDL_StopTextInput2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StopTextInput');
  late final _SDL_StopTextInput2 =
      _SDL_StopTextInput2Ptr.asFunction<void Function()>();

  /// Set the rectangle used to type Unicode text inputs.
  ///
  /// \param rect the SDL_Rect structure representing the rectangle to receive
  /// text (ignored if NULL)
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_SetTextInputRect2(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetTextInputRect2(
      rect,
    );
  }

  late final _SDL_SetTextInputRect2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Rect>)>>(
          'SDL_SetTextInputRect');
  late final _SDL_SetTextInputRect2 = _SDL_SetTextInputRect2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>)>();

  /// Check whether the platform has screen keyboard support.
  ///
  /// \returns SDL_TRUE if the platform has some screen keyboard support or
  /// SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  /// \sa SDL_IsScreenKeyboardShown
  int SDL_HasScreenKeyboardSupport2() {
    return _SDL_HasScreenKeyboardSupport2();
  }

  late final _SDL_HasScreenKeyboardSupport2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_HasScreenKeyboardSupport');
  late final _SDL_HasScreenKeyboardSupport2 =
      _SDL_HasScreenKeyboardSupport2Ptr.asFunction<int Function()>();

  /// Check whether the screen keyboard is shown for given window.
  ///
  /// \param window the window for which screen keyboard should be queried
  /// \returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasScreenKeyboardSupport
  int SDL_IsScreenKeyboardShown2(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsScreenKeyboardShown2(
      window,
    );
  }

  late final _SDL_IsScreenKeyboardShown2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsScreenKeyboardShown');
  late final _SDL_IsScreenKeyboardShown2 = _SDL_IsScreenKeyboardShown2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform10() {
    return _SDL_GetPlatform10();
  }

  late final _SDL_GetPlatform10Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform10 =
      _SDL_GetPlatform10Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc9(
    int size,
  ) {
    return _SDL_malloc9(
      size,
    );
  }

  late final _SDL_malloc9Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc9 =
      _SDL_malloc9Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc9(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc9(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc9 =
      _SDL_calloc9Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc9(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc9(
      mem,
      size,
    );
  }

  late final _SDL_realloc9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc9 = _SDL_realloc9Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free9(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free9(
      mem,
    );
  }

  late final _SDL_free9Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free9 =
      _SDL_free9Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions9(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions9(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions9 = _SDL_GetMemoryFunctions9Ptr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions9(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions9(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions9 = _SDL_SetMemoryFunctions9Ptr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations9() {
    return _SDL_GetNumAllocations9();
  }

  late final _SDL_GetNumAllocations9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations9 =
      _SDL_GetNumAllocations9Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv9(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv9(
      name,
    );
  }

  late final _SDL_getenv9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv9 = _SDL_getenv9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv9(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv9(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv9 = _SDL_setenv9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort9(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort9(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort9 = _SDL_qsort9Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs9(
    int x,
  ) {
    return _SDL_abs9(
      x,
    );
  }

  late final _SDL_abs9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs9 = _SDL_abs9Ptr.asFunction<int Function(int)>();

  int SDL_isalpha9(
    int x,
  ) {
    return _SDL_isalpha9(
      x,
    );
  }

  late final _SDL_isalpha9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha9 = _SDL_isalpha9Ptr.asFunction<int Function(int)>();

  int SDL_isalnum9(
    int x,
  ) {
    return _SDL_isalnum9(
      x,
    );
  }

  late final _SDL_isalnum9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum9 = _SDL_isalnum9Ptr.asFunction<int Function(int)>();

  int SDL_isblank9(
    int x,
  ) {
    return _SDL_isblank9(
      x,
    );
  }

  late final _SDL_isblank9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank9 = _SDL_isblank9Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl9(
    int x,
  ) {
    return _SDL_iscntrl9(
      x,
    );
  }

  late final _SDL_iscntrl9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl9 = _SDL_iscntrl9Ptr.asFunction<int Function(int)>();

  int SDL_isdigit9(
    int x,
  ) {
    return _SDL_isdigit9(
      x,
    );
  }

  late final _SDL_isdigit9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit9 = _SDL_isdigit9Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit9(
    int x,
  ) {
    return _SDL_isxdigit9(
      x,
    );
  }

  late final _SDL_isxdigit9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit9 = _SDL_isxdigit9Ptr.asFunction<int Function(int)>();

  int SDL_ispunct9(
    int x,
  ) {
    return _SDL_ispunct9(
      x,
    );
  }

  late final _SDL_ispunct9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct9 = _SDL_ispunct9Ptr.asFunction<int Function(int)>();

  int SDL_isspace9(
    int x,
  ) {
    return _SDL_isspace9(
      x,
    );
  }

  late final _SDL_isspace9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace9 = _SDL_isspace9Ptr.asFunction<int Function(int)>();

  int SDL_isupper9(
    int x,
  ) {
    return _SDL_isupper9(
      x,
    );
  }

  late final _SDL_isupper9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper9 = _SDL_isupper9Ptr.asFunction<int Function(int)>();

  int SDL_islower9(
    int x,
  ) {
    return _SDL_islower9(
      x,
    );
  }

  late final _SDL_islower9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower9 = _SDL_islower9Ptr.asFunction<int Function(int)>();

  int SDL_isprint9(
    int x,
  ) {
    return _SDL_isprint9(
      x,
    );
  }

  late final _SDL_isprint9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint9 = _SDL_isprint9Ptr.asFunction<int Function(int)>();

  int SDL_isgraph9(
    int x,
  ) {
    return _SDL_isgraph9(
      x,
    );
  }

  late final _SDL_isgraph9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph9 = _SDL_isgraph9Ptr.asFunction<int Function(int)>();

  int SDL_toupper9(
    int x,
  ) {
    return _SDL_toupper9(
      x,
    );
  }

  late final _SDL_toupper9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper9 = _SDL_toupper9Ptr.asFunction<int Function(int)>();

  int SDL_tolower9(
    int x,
  ) {
    return _SDL_tolower9(
      x,
    );
  }

  late final _SDL_tolower9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower9 = _SDL_tolower9Ptr.asFunction<int Function(int)>();

  int SDL_crc329(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc329(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc329Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc329 = _SDL_crc329Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset9(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset9(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset9 = _SDL_memset9Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy9(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy9(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy9 = _SDL_memcpy9Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove9(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove9(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove9 = _SDL_memmove9Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp9(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp9(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp9 = _SDL_memcmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen9(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen9(
      wstr,
    );
  }

  late final _SDL_wcslen9Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen9 =
      _SDL_wcslen9Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy9(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy9(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy9 = _SDL_wcslcpy9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat9(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat9(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat9 = _SDL_wcslcat9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup9(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup9(
      wstr,
    );
  }

  late final _SDL_wcsdup9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup9 = _SDL_wcsdup9Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr9(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr9(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr9 = _SDL_wcsstr9Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp9(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp9(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp9 = _SDL_wcscmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp9(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp9(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp9 = _SDL_wcsncmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp9(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp9(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp9 = _SDL_wcscasecmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp9(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp9(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp9 = _SDL_wcsncasecmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen9(
      str,
    );
  }

  late final _SDL_strlen9Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen9 =
      _SDL_strlen9Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy9(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy9(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy9 = _SDL_strlcpy9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy9(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy9(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy9 = _SDL_utf8strlcpy9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat9(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat9(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat9 = _SDL_strlcat9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup9(
      str,
    );
  }

  late final _SDL_strdup9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup9 = _SDL_strdup9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev9(
      str,
    );
  }

  late final _SDL_strrev9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev9 = _SDL_strrev9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr9(
      str,
    );
  }

  late final _SDL_strupr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr9 = _SDL_strupr9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr9(
      str,
    );
  }

  late final _SDL_strlwr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr9 = _SDL_strlwr9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr9(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr9(
      str,
      c,
    );
  }

  late final _SDL_strchr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr9 = _SDL_strchr9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr9(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr9(
      str,
      c,
    );
  }

  late final _SDL_strrchr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr9 = _SDL_strrchr9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr9(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr9(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr9 = _SDL_strstr9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr9(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr9(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr9 = _SDL_strtokr9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen9(
      str,
    );
  }

  late final _SDL_utf8strlen9Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen9 =
      _SDL_utf8strlen9Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa9(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa9(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa9 = _SDL_itoa9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa9(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa9(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa9 = _SDL_uitoa9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa9(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa9(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa9 = _SDL_ltoa9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa9(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa9(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa9 = _SDL_ultoa9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa9(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa9(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa9 = _SDL_lltoa9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa9(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa9(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa9 = _SDL_ulltoa9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi9(
      str,
    );
  }

  late final _SDL_atoi9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi9 =
      _SDL_atoi9Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof9(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof9(
      str,
    );
  }

  late final _SDL_atof9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof9 =
      _SDL_atof9Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol9(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol9(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol9 = _SDL_strtol9Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul9(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul9(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul9 = _SDL_strtoul9Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll9(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll9(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll9Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll9 = _SDL_strtoll9Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull9(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull9(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull9Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull9 = _SDL_strtoull9Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod9(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod9(
      str,
      endp,
    );
  }

  late final _SDL_strtod9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod9 = _SDL_strtod9Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp9(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp9(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp9 = _SDL_strcmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp9(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp9(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp9 = _SDL_strncmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp9(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp9(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp9 = _SDL_strcasecmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp9(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp9(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp9 = _SDL_strncasecmp9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf9(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf9(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf9 = _SDL_sscanf9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf9(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf9(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf9 = _SDL_vsscanf9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf9(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf9(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf9 = _SDL_snprintf9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf9(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf9(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf9 = _SDL_vsnprintf9Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf9(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf9(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf9 = _SDL_asprintf9Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf9(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf9(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf9 = _SDL_vasprintf9Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos9(
    double x,
  ) {
    return _SDL_acos9(
      x,
    );
  }

  late final _SDL_acos9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos9 = _SDL_acos9Ptr.asFunction<double Function(double)>();

  double SDL_acosf9(
    double x,
  ) {
    return _SDL_acosf9(
      x,
    );
  }

  late final _SDL_acosf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf9 = _SDL_acosf9Ptr.asFunction<double Function(double)>();

  double SDL_asin9(
    double x,
  ) {
    return _SDL_asin9(
      x,
    );
  }

  late final _SDL_asin9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin9 = _SDL_asin9Ptr.asFunction<double Function(double)>();

  double SDL_asinf9(
    double x,
  ) {
    return _SDL_asinf9(
      x,
    );
  }

  late final _SDL_asinf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf9 = _SDL_asinf9Ptr.asFunction<double Function(double)>();

  double SDL_atan10(
    double x,
  ) {
    return _SDL_atan10(
      x,
    );
  }

  late final _SDL_atan10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan10 = _SDL_atan10Ptr.asFunction<double Function(double)>();

  double SDL_atanf9(
    double x,
  ) {
    return _SDL_atanf9(
      x,
    );
  }

  late final _SDL_atanf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf9 = _SDL_atanf9Ptr.asFunction<double Function(double)>();

  double SDL_atan29(
    double y,
    double x,
  ) {
    return _SDL_atan29(
      y,
      x,
    );
  }

  late final _SDL_atan29Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan29 =
      _SDL_atan29Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f9(
    double y,
    double x,
  ) {
    return _SDL_atan2f9(
      y,
      x,
    );
  }

  late final _SDL_atan2f9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f9 =
      _SDL_atan2f9Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil9(
    double x,
  ) {
    return _SDL_ceil9(
      x,
    );
  }

  late final _SDL_ceil9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil9 = _SDL_ceil9Ptr.asFunction<double Function(double)>();

  double SDL_ceilf9(
    double x,
  ) {
    return _SDL_ceilf9(
      x,
    );
  }

  late final _SDL_ceilf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf9 = _SDL_ceilf9Ptr.asFunction<double Function(double)>();

  double SDL_copysign9(
    double x,
    double y,
  ) {
    return _SDL_copysign9(
      x,
      y,
    );
  }

  late final _SDL_copysign9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign9 =
      _SDL_copysign9Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf9(
    double x,
    double y,
  ) {
    return _SDL_copysignf9(
      x,
      y,
    );
  }

  late final _SDL_copysignf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf9 =
      _SDL_copysignf9Ptr.asFunction<double Function(double, double)>();

  double SDL_cos9(
    double x,
  ) {
    return _SDL_cos9(
      x,
    );
  }

  late final _SDL_cos9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos9 = _SDL_cos9Ptr.asFunction<double Function(double)>();

  double SDL_cosf9(
    double x,
  ) {
    return _SDL_cosf9(
      x,
    );
  }

  late final _SDL_cosf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf9 = _SDL_cosf9Ptr.asFunction<double Function(double)>();

  double SDL_exp9(
    double x,
  ) {
    return _SDL_exp9(
      x,
    );
  }

  late final _SDL_exp9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp9 = _SDL_exp9Ptr.asFunction<double Function(double)>();

  double SDL_expf9(
    double x,
  ) {
    return _SDL_expf9(
      x,
    );
  }

  late final _SDL_expf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf9 = _SDL_expf9Ptr.asFunction<double Function(double)>();

  double SDL_fabs9(
    double x,
  ) {
    return _SDL_fabs9(
      x,
    );
  }

  late final _SDL_fabs9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs9 = _SDL_fabs9Ptr.asFunction<double Function(double)>();

  double SDL_fabsf9(
    double x,
  ) {
    return _SDL_fabsf9(
      x,
    );
  }

  late final _SDL_fabsf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf9 = _SDL_fabsf9Ptr.asFunction<double Function(double)>();

  double SDL_floor9(
    double x,
  ) {
    return _SDL_floor9(
      x,
    );
  }

  late final _SDL_floor9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor9 = _SDL_floor9Ptr.asFunction<double Function(double)>();

  double SDL_floorf9(
    double x,
  ) {
    return _SDL_floorf9(
      x,
    );
  }

  late final _SDL_floorf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf9 =
      _SDL_floorf9Ptr.asFunction<double Function(double)>();

  double SDL_trunc9(
    double x,
  ) {
    return _SDL_trunc9(
      x,
    );
  }

  late final _SDL_trunc9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc9 = _SDL_trunc9Ptr.asFunction<double Function(double)>();

  double SDL_truncf9(
    double x,
  ) {
    return _SDL_truncf9(
      x,
    );
  }

  late final _SDL_truncf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf9 =
      _SDL_truncf9Ptr.asFunction<double Function(double)>();

  double SDL_fmod9(
    double x,
    double y,
  ) {
    return _SDL_fmod9(
      x,
      y,
    );
  }

  late final _SDL_fmod9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod9 =
      _SDL_fmod9Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf9(
    double x,
    double y,
  ) {
    return _SDL_fmodf9(
      x,
      y,
    );
  }

  late final _SDL_fmodf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf9 =
      _SDL_fmodf9Ptr.asFunction<double Function(double, double)>();

  double SDL_log9(
    double x,
  ) {
    return _SDL_log9(
      x,
    );
  }

  late final _SDL_log9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log9 = _SDL_log9Ptr.asFunction<double Function(double)>();

  double SDL_logf9(
    double x,
  ) {
    return _SDL_logf9(
      x,
    );
  }

  late final _SDL_logf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf9 = _SDL_logf9Ptr.asFunction<double Function(double)>();

  double SDL_log109(
    double x,
  ) {
    return _SDL_log109(
      x,
    );
  }

  late final _SDL_log109Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log109 = _SDL_log109Ptr.asFunction<double Function(double)>();

  double SDL_log10f9(
    double x,
  ) {
    return _SDL_log10f9(
      x,
    );
  }

  late final _SDL_log10f9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f9 =
      _SDL_log10f9Ptr.asFunction<double Function(double)>();

  double SDL_pow9(
    double x,
    double y,
  ) {
    return _SDL_pow9(
      x,
      y,
    );
  }

  late final _SDL_pow9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow9 =
      _SDL_pow9Ptr.asFunction<double Function(double, double)>();

  double SDL_powf9(
    double x,
    double y,
  ) {
    return _SDL_powf9(
      x,
      y,
    );
  }

  late final _SDL_powf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf9 =
      _SDL_powf9Ptr.asFunction<double Function(double, double)>();

  double SDL_round9(
    double x,
  ) {
    return _SDL_round9(
      x,
    );
  }

  late final _SDL_round9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round9 = _SDL_round9Ptr.asFunction<double Function(double)>();

  double SDL_roundf9(
    double x,
  ) {
    return _SDL_roundf9(
      x,
    );
  }

  late final _SDL_roundf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf9 =
      _SDL_roundf9Ptr.asFunction<double Function(double)>();

  int SDL_lround9(
    double x,
  ) {
    return _SDL_lround9(
      x,
    );
  }

  late final _SDL_lround9Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround9 = _SDL_lround9Ptr.asFunction<int Function(double)>();

  int SDL_lroundf9(
    double x,
  ) {
    return _SDL_lroundf9(
      x,
    );
  }

  late final _SDL_lroundf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf9 =
      _SDL_lroundf9Ptr.asFunction<int Function(double)>();

  double SDL_scalbn9(
    double x,
    int n,
  ) {
    return _SDL_scalbn9(
      x,
      n,
    );
  }

  late final _SDL_scalbn9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn9 =
      _SDL_scalbn9Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf9(
    double x,
    int n,
  ) {
    return _SDL_scalbnf9(
      x,
      n,
    );
  }

  late final _SDL_scalbnf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf9 =
      _SDL_scalbnf9Ptr.asFunction<double Function(double, int)>();

  double SDL_sin9(
    double x,
  ) {
    return _SDL_sin9(
      x,
    );
  }

  late final _SDL_sin9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin9 = _SDL_sin9Ptr.asFunction<double Function(double)>();

  double SDL_sinf9(
    double x,
  ) {
    return _SDL_sinf9(
      x,
    );
  }

  late final _SDL_sinf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf9 = _SDL_sinf9Ptr.asFunction<double Function(double)>();

  double SDL_sqrt9(
    double x,
  ) {
    return _SDL_sqrt9(
      x,
    );
  }

  late final _SDL_sqrt9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt9 = _SDL_sqrt9Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf9(
    double x,
  ) {
    return _SDL_sqrtf9(
      x,
    );
  }

  late final _SDL_sqrtf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf9 = _SDL_sqrtf9Ptr.asFunction<double Function(double)>();

  double SDL_tan9(
    double x,
  ) {
    return _SDL_tan9(
      x,
    );
  }

  late final _SDL_tan9Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan9 = _SDL_tan9Ptr.asFunction<double Function(double)>();

  double SDL_tanf9(
    double x,
  ) {
    return _SDL_tanf9(
      x,
    );
  }

  late final _SDL_tanf9Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf9 = _SDL_tanf9Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open9(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open9(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open9Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open9 = _SDL_iconv_open9Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close9(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close9(
      cd,
    );
  }

  late final _SDL_iconv_close9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close9 =
      _SDL_iconv_close9Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv9(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv9(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv9 = _SDL_iconv9Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string9(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string9(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string9 = _SDL_iconv_string9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform11() {
    return _SDL_GetPlatform11();
  }

  late final _SDL_GetPlatform11Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform11 =
      _SDL_GetPlatform11Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc10(
    int size,
  ) {
    return _SDL_malloc10(
      size,
    );
  }

  late final _SDL_malloc10Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc10 =
      _SDL_malloc10Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc10(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc10(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc10 =
      _SDL_calloc10Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc10(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc10(
      mem,
      size,
    );
  }

  late final _SDL_realloc10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc10 = _SDL_realloc10Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free10(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free10(
      mem,
    );
  }

  late final _SDL_free10Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free10 =
      _SDL_free10Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions10(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions10(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions10 =
      _SDL_GetMemoryFunctions10Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions10(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions10(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions10 =
      _SDL_SetMemoryFunctions10Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations10() {
    return _SDL_GetNumAllocations10();
  }

  late final _SDL_GetNumAllocations10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations10 =
      _SDL_GetNumAllocations10Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv10(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv10(
      name,
    );
  }

  late final _SDL_getenv10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv10 = _SDL_getenv10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv10(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv10(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv10 = _SDL_setenv10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort10(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort10(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort10 = _SDL_qsort10Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs10(
    int x,
  ) {
    return _SDL_abs10(
      x,
    );
  }

  late final _SDL_abs10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs10 = _SDL_abs10Ptr.asFunction<int Function(int)>();

  int SDL_isalpha10(
    int x,
  ) {
    return _SDL_isalpha10(
      x,
    );
  }

  late final _SDL_isalpha10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha10 = _SDL_isalpha10Ptr.asFunction<int Function(int)>();

  int SDL_isalnum10(
    int x,
  ) {
    return _SDL_isalnum10(
      x,
    );
  }

  late final _SDL_isalnum10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum10 = _SDL_isalnum10Ptr.asFunction<int Function(int)>();

  int SDL_isblank10(
    int x,
  ) {
    return _SDL_isblank10(
      x,
    );
  }

  late final _SDL_isblank10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank10 = _SDL_isblank10Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl10(
    int x,
  ) {
    return _SDL_iscntrl10(
      x,
    );
  }

  late final _SDL_iscntrl10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl10 = _SDL_iscntrl10Ptr.asFunction<int Function(int)>();

  int SDL_isdigit10(
    int x,
  ) {
    return _SDL_isdigit10(
      x,
    );
  }

  late final _SDL_isdigit10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit10 = _SDL_isdigit10Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit10(
    int x,
  ) {
    return _SDL_isxdigit10(
      x,
    );
  }

  late final _SDL_isxdigit10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit10 =
      _SDL_isxdigit10Ptr.asFunction<int Function(int)>();

  int SDL_ispunct10(
    int x,
  ) {
    return _SDL_ispunct10(
      x,
    );
  }

  late final _SDL_ispunct10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct10 = _SDL_ispunct10Ptr.asFunction<int Function(int)>();

  int SDL_isspace10(
    int x,
  ) {
    return _SDL_isspace10(
      x,
    );
  }

  late final _SDL_isspace10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace10 = _SDL_isspace10Ptr.asFunction<int Function(int)>();

  int SDL_isupper10(
    int x,
  ) {
    return _SDL_isupper10(
      x,
    );
  }

  late final _SDL_isupper10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper10 = _SDL_isupper10Ptr.asFunction<int Function(int)>();

  int SDL_islower10(
    int x,
  ) {
    return _SDL_islower10(
      x,
    );
  }

  late final _SDL_islower10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower10 = _SDL_islower10Ptr.asFunction<int Function(int)>();

  int SDL_isprint10(
    int x,
  ) {
    return _SDL_isprint10(
      x,
    );
  }

  late final _SDL_isprint10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint10 = _SDL_isprint10Ptr.asFunction<int Function(int)>();

  int SDL_isgraph10(
    int x,
  ) {
    return _SDL_isgraph10(
      x,
    );
  }

  late final _SDL_isgraph10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph10 = _SDL_isgraph10Ptr.asFunction<int Function(int)>();

  int SDL_toupper10(
    int x,
  ) {
    return _SDL_toupper10(
      x,
    );
  }

  late final _SDL_toupper10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper10 = _SDL_toupper10Ptr.asFunction<int Function(int)>();

  int SDL_tolower10(
    int x,
  ) {
    return _SDL_tolower10(
      x,
    );
  }

  late final _SDL_tolower10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower10 = _SDL_tolower10Ptr.asFunction<int Function(int)>();

  int SDL_crc3210(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3210(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3210Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3210 = _SDL_crc3210Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset10(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset10(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset10 = _SDL_memset10Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy10(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy10(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy10 = _SDL_memcpy10Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove10(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove10(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove10 = _SDL_memmove10Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp10(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp10(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp10 = _SDL_memcmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen10(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen10(
      wstr,
    );
  }

  late final _SDL_wcslen10Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen10 =
      _SDL_wcslen10Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy10(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy10(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy10 = _SDL_wcslcpy10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat10(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat10(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat10 = _SDL_wcslcat10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup10(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup10(
      wstr,
    );
  }

  late final _SDL_wcsdup10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup10 = _SDL_wcsdup10Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr10(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr10(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr10 = _SDL_wcsstr10Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp10(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp10(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp10 = _SDL_wcscmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp10(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp10(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp10 = _SDL_wcsncmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp10(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp10(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp10 = _SDL_wcscasecmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp10(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp10(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp10 = _SDL_wcsncasecmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen10(
      str,
    );
  }

  late final _SDL_strlen10Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen10 =
      _SDL_strlen10Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy10(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy10(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy10 = _SDL_strlcpy10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy10(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy10(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy10 = _SDL_utf8strlcpy10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat10(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat10(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat10 = _SDL_strlcat10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup10(
      str,
    );
  }

  late final _SDL_strdup10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup10 = _SDL_strdup10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev10(
      str,
    );
  }

  late final _SDL_strrev10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev10 = _SDL_strrev10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr10(
      str,
    );
  }

  late final _SDL_strupr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr10 = _SDL_strupr10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr10(
      str,
    );
  }

  late final _SDL_strlwr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr10 = _SDL_strlwr10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr10(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr10(
      str,
      c,
    );
  }

  late final _SDL_strchr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr10 = _SDL_strchr10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr10(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr10(
      str,
      c,
    );
  }

  late final _SDL_strrchr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr10 = _SDL_strrchr10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr10(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr10(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr10 = _SDL_strstr10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr10(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr10(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr10 = _SDL_strtokr10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen10(
      str,
    );
  }

  late final _SDL_utf8strlen10Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen10 =
      _SDL_utf8strlen10Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa10(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa10(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa10 = _SDL_itoa10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa10(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa10(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa10 = _SDL_uitoa10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa10(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa10(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa10 = _SDL_ltoa10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa10(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa10(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa10 = _SDL_ultoa10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa10(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa10(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa10 = _SDL_lltoa10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa10(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa10(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa10 = _SDL_ulltoa10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi10(
      str,
    );
  }

  late final _SDL_atoi10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi10 =
      _SDL_atoi10Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof10(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof10(
      str,
    );
  }

  late final _SDL_atof10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof10 =
      _SDL_atof10Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol10(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol10(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol10 = _SDL_strtol10Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul10(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul10(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul10 = _SDL_strtoul10Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll10(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll10(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll10Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll10 = _SDL_strtoll10Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull10(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull10(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull10Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull10 = _SDL_strtoull10Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod10(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod10(
      str,
      endp,
    );
  }

  late final _SDL_strtod10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod10 = _SDL_strtod10Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp10(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp10(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp10 = _SDL_strcmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp10(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp10(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp10 = _SDL_strncmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp10(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp10(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp10 = _SDL_strcasecmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp10(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp10(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp10 = _SDL_strncasecmp10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf10(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf10(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf10 = _SDL_sscanf10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf10(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf10(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf10 = _SDL_vsscanf10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf10(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf10(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf10 = _SDL_snprintf10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf10(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf10(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf10 = _SDL_vsnprintf10Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf10(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf10(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf10 = _SDL_asprintf10Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf10(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf10(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf10 = _SDL_vasprintf10Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos10(
    double x,
  ) {
    return _SDL_acos10(
      x,
    );
  }

  late final _SDL_acos10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos10 = _SDL_acos10Ptr.asFunction<double Function(double)>();

  double SDL_acosf10(
    double x,
  ) {
    return _SDL_acosf10(
      x,
    );
  }

  late final _SDL_acosf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf10 =
      _SDL_acosf10Ptr.asFunction<double Function(double)>();

  double SDL_asin10(
    double x,
  ) {
    return _SDL_asin10(
      x,
    );
  }

  late final _SDL_asin10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin10 = _SDL_asin10Ptr.asFunction<double Function(double)>();

  double SDL_asinf10(
    double x,
  ) {
    return _SDL_asinf10(
      x,
    );
  }

  late final _SDL_asinf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf10 =
      _SDL_asinf10Ptr.asFunction<double Function(double)>();

  double SDL_atan11(
    double x,
  ) {
    return _SDL_atan11(
      x,
    );
  }

  late final _SDL_atan11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan11 = _SDL_atan11Ptr.asFunction<double Function(double)>();

  double SDL_atanf10(
    double x,
  ) {
    return _SDL_atanf10(
      x,
    );
  }

  late final _SDL_atanf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf10 =
      _SDL_atanf10Ptr.asFunction<double Function(double)>();

  double SDL_atan210(
    double y,
    double x,
  ) {
    return _SDL_atan210(
      y,
      x,
    );
  }

  late final _SDL_atan210Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan210 =
      _SDL_atan210Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f10(
    double y,
    double x,
  ) {
    return _SDL_atan2f10(
      y,
      x,
    );
  }

  late final _SDL_atan2f10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f10 =
      _SDL_atan2f10Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil10(
    double x,
  ) {
    return _SDL_ceil10(
      x,
    );
  }

  late final _SDL_ceil10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil10 = _SDL_ceil10Ptr.asFunction<double Function(double)>();

  double SDL_ceilf10(
    double x,
  ) {
    return _SDL_ceilf10(
      x,
    );
  }

  late final _SDL_ceilf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf10 =
      _SDL_ceilf10Ptr.asFunction<double Function(double)>();

  double SDL_copysign10(
    double x,
    double y,
  ) {
    return _SDL_copysign10(
      x,
      y,
    );
  }

  late final _SDL_copysign10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign10 =
      _SDL_copysign10Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf10(
    double x,
    double y,
  ) {
    return _SDL_copysignf10(
      x,
      y,
    );
  }

  late final _SDL_copysignf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf10 =
      _SDL_copysignf10Ptr.asFunction<double Function(double, double)>();

  double SDL_cos10(
    double x,
  ) {
    return _SDL_cos10(
      x,
    );
  }

  late final _SDL_cos10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos10 = _SDL_cos10Ptr.asFunction<double Function(double)>();

  double SDL_cosf10(
    double x,
  ) {
    return _SDL_cosf10(
      x,
    );
  }

  late final _SDL_cosf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf10 = _SDL_cosf10Ptr.asFunction<double Function(double)>();

  double SDL_exp10(
    double x,
  ) {
    return _SDL_exp10(
      x,
    );
  }

  late final _SDL_exp10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp10 = _SDL_exp10Ptr.asFunction<double Function(double)>();

  double SDL_expf10(
    double x,
  ) {
    return _SDL_expf10(
      x,
    );
  }

  late final _SDL_expf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf10 = _SDL_expf10Ptr.asFunction<double Function(double)>();

  double SDL_fabs10(
    double x,
  ) {
    return _SDL_fabs10(
      x,
    );
  }

  late final _SDL_fabs10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs10 = _SDL_fabs10Ptr.asFunction<double Function(double)>();

  double SDL_fabsf10(
    double x,
  ) {
    return _SDL_fabsf10(
      x,
    );
  }

  late final _SDL_fabsf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf10 =
      _SDL_fabsf10Ptr.asFunction<double Function(double)>();

  double SDL_floor10(
    double x,
  ) {
    return _SDL_floor10(
      x,
    );
  }

  late final _SDL_floor10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor10 =
      _SDL_floor10Ptr.asFunction<double Function(double)>();

  double SDL_floorf10(
    double x,
  ) {
    return _SDL_floorf10(
      x,
    );
  }

  late final _SDL_floorf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf10 =
      _SDL_floorf10Ptr.asFunction<double Function(double)>();

  double SDL_trunc10(
    double x,
  ) {
    return _SDL_trunc10(
      x,
    );
  }

  late final _SDL_trunc10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc10 =
      _SDL_trunc10Ptr.asFunction<double Function(double)>();

  double SDL_truncf10(
    double x,
  ) {
    return _SDL_truncf10(
      x,
    );
  }

  late final _SDL_truncf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf10 =
      _SDL_truncf10Ptr.asFunction<double Function(double)>();

  double SDL_fmod10(
    double x,
    double y,
  ) {
    return _SDL_fmod10(
      x,
      y,
    );
  }

  late final _SDL_fmod10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod10 =
      _SDL_fmod10Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf10(
    double x,
    double y,
  ) {
    return _SDL_fmodf10(
      x,
      y,
    );
  }

  late final _SDL_fmodf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf10 =
      _SDL_fmodf10Ptr.asFunction<double Function(double, double)>();

  double SDL_log11(
    double x,
  ) {
    return _SDL_log11(
      x,
    );
  }

  late final _SDL_log11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log11 = _SDL_log11Ptr.asFunction<double Function(double)>();

  double SDL_logf10(
    double x,
  ) {
    return _SDL_logf10(
      x,
    );
  }

  late final _SDL_logf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf10 = _SDL_logf10Ptr.asFunction<double Function(double)>();

  double SDL_log1010(
    double x,
  ) {
    return _SDL_log1010(
      x,
    );
  }

  late final _SDL_log1010Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1010 =
      _SDL_log1010Ptr.asFunction<double Function(double)>();

  double SDL_log10f10(
    double x,
  ) {
    return _SDL_log10f10(
      x,
    );
  }

  late final _SDL_log10f10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f10 =
      _SDL_log10f10Ptr.asFunction<double Function(double)>();

  double SDL_pow10(
    double x,
    double y,
  ) {
    return _SDL_pow10(
      x,
      y,
    );
  }

  late final _SDL_pow10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow10 =
      _SDL_pow10Ptr.asFunction<double Function(double, double)>();

  double SDL_powf10(
    double x,
    double y,
  ) {
    return _SDL_powf10(
      x,
      y,
    );
  }

  late final _SDL_powf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf10 =
      _SDL_powf10Ptr.asFunction<double Function(double, double)>();

  double SDL_round10(
    double x,
  ) {
    return _SDL_round10(
      x,
    );
  }

  late final _SDL_round10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round10 =
      _SDL_round10Ptr.asFunction<double Function(double)>();

  double SDL_roundf10(
    double x,
  ) {
    return _SDL_roundf10(
      x,
    );
  }

  late final _SDL_roundf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf10 =
      _SDL_roundf10Ptr.asFunction<double Function(double)>();

  int SDL_lround10(
    double x,
  ) {
    return _SDL_lround10(
      x,
    );
  }

  late final _SDL_lround10Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround10 =
      _SDL_lround10Ptr.asFunction<int Function(double)>();

  int SDL_lroundf10(
    double x,
  ) {
    return _SDL_lroundf10(
      x,
    );
  }

  late final _SDL_lroundf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf10 =
      _SDL_lroundf10Ptr.asFunction<int Function(double)>();

  double SDL_scalbn10(
    double x,
    int n,
  ) {
    return _SDL_scalbn10(
      x,
      n,
    );
  }

  late final _SDL_scalbn10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn10 =
      _SDL_scalbn10Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf10(
    double x,
    int n,
  ) {
    return _SDL_scalbnf10(
      x,
      n,
    );
  }

  late final _SDL_scalbnf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf10 =
      _SDL_scalbnf10Ptr.asFunction<double Function(double, int)>();

  double SDL_sin10(
    double x,
  ) {
    return _SDL_sin10(
      x,
    );
  }

  late final _SDL_sin10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin10 = _SDL_sin10Ptr.asFunction<double Function(double)>();

  double SDL_sinf10(
    double x,
  ) {
    return _SDL_sinf10(
      x,
    );
  }

  late final _SDL_sinf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf10 = _SDL_sinf10Ptr.asFunction<double Function(double)>();

  double SDL_sqrt10(
    double x,
  ) {
    return _SDL_sqrt10(
      x,
    );
  }

  late final _SDL_sqrt10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt10 = _SDL_sqrt10Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf10(
    double x,
  ) {
    return _SDL_sqrtf10(
      x,
    );
  }

  late final _SDL_sqrtf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf10 =
      _SDL_sqrtf10Ptr.asFunction<double Function(double)>();

  double SDL_tan10(
    double x,
  ) {
    return _SDL_tan10(
      x,
    );
  }

  late final _SDL_tan10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan10 = _SDL_tan10Ptr.asFunction<double Function(double)>();

  double SDL_tanf10(
    double x,
  ) {
    return _SDL_tanf10(
      x,
    );
  }

  late final _SDL_tanf10Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf10 = _SDL_tanf10Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open10(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open10(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open10Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open10 = _SDL_iconv_open10Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close10(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close10(
      cd,
    );
  }

  late final _SDL_iconv_close10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close10 =
      _SDL_iconv_close10Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv10(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv10(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv10 = _SDL_iconv10Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string10(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string10(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string10 = _SDL_iconv_string10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform12() {
    return _SDL_GetPlatform12();
  }

  late final _SDL_GetPlatform12Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform12 =
      _SDL_GetPlatform12Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc11(
    int size,
  ) {
    return _SDL_malloc11(
      size,
    );
  }

  late final _SDL_malloc11Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc11 =
      _SDL_malloc11Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc11(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc11(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc11 =
      _SDL_calloc11Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc11(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc11(
      mem,
      size,
    );
  }

  late final _SDL_realloc11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc11 = _SDL_realloc11Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free11(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free11(
      mem,
    );
  }

  late final _SDL_free11Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free11 =
      _SDL_free11Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions11(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions11(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions11 =
      _SDL_GetMemoryFunctions11Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions11(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions11(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions11 =
      _SDL_SetMemoryFunctions11Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations11() {
    return _SDL_GetNumAllocations11();
  }

  late final _SDL_GetNumAllocations11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations11 =
      _SDL_GetNumAllocations11Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv11(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv11(
      name,
    );
  }

  late final _SDL_getenv11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv11 = _SDL_getenv11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv11(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv11(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv11 = _SDL_setenv11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort11(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort11(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort11 = _SDL_qsort11Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs11(
    int x,
  ) {
    return _SDL_abs11(
      x,
    );
  }

  late final _SDL_abs11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs11 = _SDL_abs11Ptr.asFunction<int Function(int)>();

  int SDL_isalpha11(
    int x,
  ) {
    return _SDL_isalpha11(
      x,
    );
  }

  late final _SDL_isalpha11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha11 = _SDL_isalpha11Ptr.asFunction<int Function(int)>();

  int SDL_isalnum11(
    int x,
  ) {
    return _SDL_isalnum11(
      x,
    );
  }

  late final _SDL_isalnum11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum11 = _SDL_isalnum11Ptr.asFunction<int Function(int)>();

  int SDL_isblank11(
    int x,
  ) {
    return _SDL_isblank11(
      x,
    );
  }

  late final _SDL_isblank11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank11 = _SDL_isblank11Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl11(
    int x,
  ) {
    return _SDL_iscntrl11(
      x,
    );
  }

  late final _SDL_iscntrl11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl11 = _SDL_iscntrl11Ptr.asFunction<int Function(int)>();

  int SDL_isdigit11(
    int x,
  ) {
    return _SDL_isdigit11(
      x,
    );
  }

  late final _SDL_isdigit11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit11 = _SDL_isdigit11Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit11(
    int x,
  ) {
    return _SDL_isxdigit11(
      x,
    );
  }

  late final _SDL_isxdigit11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit11 =
      _SDL_isxdigit11Ptr.asFunction<int Function(int)>();

  int SDL_ispunct11(
    int x,
  ) {
    return _SDL_ispunct11(
      x,
    );
  }

  late final _SDL_ispunct11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct11 = _SDL_ispunct11Ptr.asFunction<int Function(int)>();

  int SDL_isspace11(
    int x,
  ) {
    return _SDL_isspace11(
      x,
    );
  }

  late final _SDL_isspace11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace11 = _SDL_isspace11Ptr.asFunction<int Function(int)>();

  int SDL_isupper11(
    int x,
  ) {
    return _SDL_isupper11(
      x,
    );
  }

  late final _SDL_isupper11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper11 = _SDL_isupper11Ptr.asFunction<int Function(int)>();

  int SDL_islower11(
    int x,
  ) {
    return _SDL_islower11(
      x,
    );
  }

  late final _SDL_islower11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower11 = _SDL_islower11Ptr.asFunction<int Function(int)>();

  int SDL_isprint11(
    int x,
  ) {
    return _SDL_isprint11(
      x,
    );
  }

  late final _SDL_isprint11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint11 = _SDL_isprint11Ptr.asFunction<int Function(int)>();

  int SDL_isgraph11(
    int x,
  ) {
    return _SDL_isgraph11(
      x,
    );
  }

  late final _SDL_isgraph11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph11 = _SDL_isgraph11Ptr.asFunction<int Function(int)>();

  int SDL_toupper11(
    int x,
  ) {
    return _SDL_toupper11(
      x,
    );
  }

  late final _SDL_toupper11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper11 = _SDL_toupper11Ptr.asFunction<int Function(int)>();

  int SDL_tolower11(
    int x,
  ) {
    return _SDL_tolower11(
      x,
    );
  }

  late final _SDL_tolower11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower11 = _SDL_tolower11Ptr.asFunction<int Function(int)>();

  int SDL_crc3211(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3211(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3211Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3211 = _SDL_crc3211Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset11(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset11(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset11 = _SDL_memset11Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy11(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy11(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy11 = _SDL_memcpy11Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove11(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove11(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove11 = _SDL_memmove11Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp11(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp11(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp11 = _SDL_memcmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen11(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen11(
      wstr,
    );
  }

  late final _SDL_wcslen11Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen11 =
      _SDL_wcslen11Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy11(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy11(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy11 = _SDL_wcslcpy11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat11(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat11(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat11 = _SDL_wcslcat11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup11(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup11(
      wstr,
    );
  }

  late final _SDL_wcsdup11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup11 = _SDL_wcsdup11Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr11(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr11(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr11 = _SDL_wcsstr11Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp11(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp11(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp11 = _SDL_wcscmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp11(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp11(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp11 = _SDL_wcsncmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp11(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp11(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp11 = _SDL_wcscasecmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp11(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp11(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp11 = _SDL_wcsncasecmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen11(
      str,
    );
  }

  late final _SDL_strlen11Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen11 =
      _SDL_strlen11Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy11(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy11(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy11 = _SDL_strlcpy11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy11(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy11(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy11 = _SDL_utf8strlcpy11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat11(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat11(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat11 = _SDL_strlcat11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup11(
      str,
    );
  }

  late final _SDL_strdup11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup11 = _SDL_strdup11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev11(
      str,
    );
  }

  late final _SDL_strrev11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev11 = _SDL_strrev11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr11(
      str,
    );
  }

  late final _SDL_strupr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr11 = _SDL_strupr11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr11(
      str,
    );
  }

  late final _SDL_strlwr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr11 = _SDL_strlwr11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr11(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr11(
      str,
      c,
    );
  }

  late final _SDL_strchr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr11 = _SDL_strchr11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr11(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr11(
      str,
      c,
    );
  }

  late final _SDL_strrchr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr11 = _SDL_strrchr11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr11(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr11(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr11 = _SDL_strstr11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr11(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr11(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr11 = _SDL_strtokr11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen11(
      str,
    );
  }

  late final _SDL_utf8strlen11Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen11 =
      _SDL_utf8strlen11Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa11(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa11(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa11 = _SDL_itoa11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa11(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa11(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa11 = _SDL_uitoa11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa11(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa11(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa11 = _SDL_ltoa11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa11(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa11(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa11 = _SDL_ultoa11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa11(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa11(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa11 = _SDL_lltoa11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa11(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa11(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa11 = _SDL_ulltoa11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi11(
      str,
    );
  }

  late final _SDL_atoi11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi11 =
      _SDL_atoi11Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof11(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof11(
      str,
    );
  }

  late final _SDL_atof11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof11 =
      _SDL_atof11Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol11(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol11(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol11 = _SDL_strtol11Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul11(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul11(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul11 = _SDL_strtoul11Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll11(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll11(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll11Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll11 = _SDL_strtoll11Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull11(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull11(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull11Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull11 = _SDL_strtoull11Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod11(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod11(
      str,
      endp,
    );
  }

  late final _SDL_strtod11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod11 = _SDL_strtod11Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp11(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp11(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp11 = _SDL_strcmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp11(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp11(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp11 = _SDL_strncmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp11(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp11(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp11 = _SDL_strcasecmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp11(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp11(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp11 = _SDL_strncasecmp11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf11(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf11(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf11 = _SDL_sscanf11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf11(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf11(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf11 = _SDL_vsscanf11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf11(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf11(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf11 = _SDL_snprintf11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf11(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf11(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf11 = _SDL_vsnprintf11Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf11(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf11(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf11 = _SDL_asprintf11Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf11(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf11(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf11 = _SDL_vasprintf11Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos11(
    double x,
  ) {
    return _SDL_acos11(
      x,
    );
  }

  late final _SDL_acos11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos11 = _SDL_acos11Ptr.asFunction<double Function(double)>();

  double SDL_acosf11(
    double x,
  ) {
    return _SDL_acosf11(
      x,
    );
  }

  late final _SDL_acosf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf11 =
      _SDL_acosf11Ptr.asFunction<double Function(double)>();

  double SDL_asin11(
    double x,
  ) {
    return _SDL_asin11(
      x,
    );
  }

  late final _SDL_asin11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin11 = _SDL_asin11Ptr.asFunction<double Function(double)>();

  double SDL_asinf11(
    double x,
  ) {
    return _SDL_asinf11(
      x,
    );
  }

  late final _SDL_asinf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf11 =
      _SDL_asinf11Ptr.asFunction<double Function(double)>();

  double SDL_atan12(
    double x,
  ) {
    return _SDL_atan12(
      x,
    );
  }

  late final _SDL_atan12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan12 = _SDL_atan12Ptr.asFunction<double Function(double)>();

  double SDL_atanf11(
    double x,
  ) {
    return _SDL_atanf11(
      x,
    );
  }

  late final _SDL_atanf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf11 =
      _SDL_atanf11Ptr.asFunction<double Function(double)>();

  double SDL_atan211(
    double y,
    double x,
  ) {
    return _SDL_atan211(
      y,
      x,
    );
  }

  late final _SDL_atan211Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan211 =
      _SDL_atan211Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f11(
    double y,
    double x,
  ) {
    return _SDL_atan2f11(
      y,
      x,
    );
  }

  late final _SDL_atan2f11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f11 =
      _SDL_atan2f11Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil11(
    double x,
  ) {
    return _SDL_ceil11(
      x,
    );
  }

  late final _SDL_ceil11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil11 = _SDL_ceil11Ptr.asFunction<double Function(double)>();

  double SDL_ceilf11(
    double x,
  ) {
    return _SDL_ceilf11(
      x,
    );
  }

  late final _SDL_ceilf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf11 =
      _SDL_ceilf11Ptr.asFunction<double Function(double)>();

  double SDL_copysign11(
    double x,
    double y,
  ) {
    return _SDL_copysign11(
      x,
      y,
    );
  }

  late final _SDL_copysign11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign11 =
      _SDL_copysign11Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf11(
    double x,
    double y,
  ) {
    return _SDL_copysignf11(
      x,
      y,
    );
  }

  late final _SDL_copysignf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf11 =
      _SDL_copysignf11Ptr.asFunction<double Function(double, double)>();

  double SDL_cos11(
    double x,
  ) {
    return _SDL_cos11(
      x,
    );
  }

  late final _SDL_cos11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos11 = _SDL_cos11Ptr.asFunction<double Function(double)>();

  double SDL_cosf11(
    double x,
  ) {
    return _SDL_cosf11(
      x,
    );
  }

  late final _SDL_cosf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf11 = _SDL_cosf11Ptr.asFunction<double Function(double)>();

  double SDL_exp11(
    double x,
  ) {
    return _SDL_exp11(
      x,
    );
  }

  late final _SDL_exp11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp11 = _SDL_exp11Ptr.asFunction<double Function(double)>();

  double SDL_expf11(
    double x,
  ) {
    return _SDL_expf11(
      x,
    );
  }

  late final _SDL_expf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf11 = _SDL_expf11Ptr.asFunction<double Function(double)>();

  double SDL_fabs11(
    double x,
  ) {
    return _SDL_fabs11(
      x,
    );
  }

  late final _SDL_fabs11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs11 = _SDL_fabs11Ptr.asFunction<double Function(double)>();

  double SDL_fabsf11(
    double x,
  ) {
    return _SDL_fabsf11(
      x,
    );
  }

  late final _SDL_fabsf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf11 =
      _SDL_fabsf11Ptr.asFunction<double Function(double)>();

  double SDL_floor11(
    double x,
  ) {
    return _SDL_floor11(
      x,
    );
  }

  late final _SDL_floor11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor11 =
      _SDL_floor11Ptr.asFunction<double Function(double)>();

  double SDL_floorf11(
    double x,
  ) {
    return _SDL_floorf11(
      x,
    );
  }

  late final _SDL_floorf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf11 =
      _SDL_floorf11Ptr.asFunction<double Function(double)>();

  double SDL_trunc11(
    double x,
  ) {
    return _SDL_trunc11(
      x,
    );
  }

  late final _SDL_trunc11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc11 =
      _SDL_trunc11Ptr.asFunction<double Function(double)>();

  double SDL_truncf11(
    double x,
  ) {
    return _SDL_truncf11(
      x,
    );
  }

  late final _SDL_truncf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf11 =
      _SDL_truncf11Ptr.asFunction<double Function(double)>();

  double SDL_fmod11(
    double x,
    double y,
  ) {
    return _SDL_fmod11(
      x,
      y,
    );
  }

  late final _SDL_fmod11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod11 =
      _SDL_fmod11Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf11(
    double x,
    double y,
  ) {
    return _SDL_fmodf11(
      x,
      y,
    );
  }

  late final _SDL_fmodf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf11 =
      _SDL_fmodf11Ptr.asFunction<double Function(double, double)>();

  double SDL_log12(
    double x,
  ) {
    return _SDL_log12(
      x,
    );
  }

  late final _SDL_log12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log12 = _SDL_log12Ptr.asFunction<double Function(double)>();

  double SDL_logf11(
    double x,
  ) {
    return _SDL_logf11(
      x,
    );
  }

  late final _SDL_logf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf11 = _SDL_logf11Ptr.asFunction<double Function(double)>();

  double SDL_log1011(
    double x,
  ) {
    return _SDL_log1011(
      x,
    );
  }

  late final _SDL_log1011Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1011 =
      _SDL_log1011Ptr.asFunction<double Function(double)>();

  double SDL_log10f11(
    double x,
  ) {
    return _SDL_log10f11(
      x,
    );
  }

  late final _SDL_log10f11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f11 =
      _SDL_log10f11Ptr.asFunction<double Function(double)>();

  double SDL_pow11(
    double x,
    double y,
  ) {
    return _SDL_pow11(
      x,
      y,
    );
  }

  late final _SDL_pow11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow11 =
      _SDL_pow11Ptr.asFunction<double Function(double, double)>();

  double SDL_powf11(
    double x,
    double y,
  ) {
    return _SDL_powf11(
      x,
      y,
    );
  }

  late final _SDL_powf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf11 =
      _SDL_powf11Ptr.asFunction<double Function(double, double)>();

  double SDL_round11(
    double x,
  ) {
    return _SDL_round11(
      x,
    );
  }

  late final _SDL_round11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round11 =
      _SDL_round11Ptr.asFunction<double Function(double)>();

  double SDL_roundf11(
    double x,
  ) {
    return _SDL_roundf11(
      x,
    );
  }

  late final _SDL_roundf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf11 =
      _SDL_roundf11Ptr.asFunction<double Function(double)>();

  int SDL_lround11(
    double x,
  ) {
    return _SDL_lround11(
      x,
    );
  }

  late final _SDL_lround11Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround11 =
      _SDL_lround11Ptr.asFunction<int Function(double)>();

  int SDL_lroundf11(
    double x,
  ) {
    return _SDL_lroundf11(
      x,
    );
  }

  late final _SDL_lroundf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf11 =
      _SDL_lroundf11Ptr.asFunction<int Function(double)>();

  double SDL_scalbn11(
    double x,
    int n,
  ) {
    return _SDL_scalbn11(
      x,
      n,
    );
  }

  late final _SDL_scalbn11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn11 =
      _SDL_scalbn11Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf11(
    double x,
    int n,
  ) {
    return _SDL_scalbnf11(
      x,
      n,
    );
  }

  late final _SDL_scalbnf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf11 =
      _SDL_scalbnf11Ptr.asFunction<double Function(double, int)>();

  double SDL_sin11(
    double x,
  ) {
    return _SDL_sin11(
      x,
    );
  }

  late final _SDL_sin11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin11 = _SDL_sin11Ptr.asFunction<double Function(double)>();

  double SDL_sinf11(
    double x,
  ) {
    return _SDL_sinf11(
      x,
    );
  }

  late final _SDL_sinf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf11 = _SDL_sinf11Ptr.asFunction<double Function(double)>();

  double SDL_sqrt11(
    double x,
  ) {
    return _SDL_sqrt11(
      x,
    );
  }

  late final _SDL_sqrt11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt11 = _SDL_sqrt11Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf11(
    double x,
  ) {
    return _SDL_sqrtf11(
      x,
    );
  }

  late final _SDL_sqrtf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf11 =
      _SDL_sqrtf11Ptr.asFunction<double Function(double)>();

  double SDL_tan11(
    double x,
  ) {
    return _SDL_tan11(
      x,
    );
  }

  late final _SDL_tan11Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan11 = _SDL_tan11Ptr.asFunction<double Function(double)>();

  double SDL_tanf11(
    double x,
  ) {
    return _SDL_tanf11(
      x,
    );
  }

  late final _SDL_tanf11Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf11 = _SDL_tanf11Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open11(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open11(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open11Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open11 = _SDL_iconv_open11Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close11(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close11(
      cd,
    );
  }

  late final _SDL_iconv_close11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close11 =
      _SDL_iconv_close11Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv11(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv11(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv11 = _SDL_iconv11Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string11(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string11(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string11 = _SDL_iconv_string11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError5(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError5(
      fmt,
    );
  }

  late final _SDL_SetError5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError5 =
      _SDL_SetError5Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError5() {
    return _SDL_GetError5();
  }

  late final _SDL_GetError5Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError5 =
      _SDL_GetError5Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg5(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg5(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg5 = _SDL_GetErrorMsg5Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError5() {
    return _SDL_ClearError5();
  }

  late final _SDL_ClearError5Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError5 =
      _SDL_ClearError5Ptr.asFunction<void Function()>();

  int SDL_Error5(
    int code,
  ) {
    return _SDL_Error5(
      code,
    );
  }

  late final _SDL_Error5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error5 = _SDL_Error5Ptr.asFunction<int Function(int)>();

  /// Locking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_LockJoysticks2() {
    return _SDL_LockJoysticks2();
  }

  late final _SDL_LockJoysticks2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockJoysticks');
  late final _SDL_LockJoysticks2 =
      _SDL_LockJoysticks2Ptr.asFunction<void Function()>();

  /// Unlocking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_UnlockJoysticks2() {
    return _SDL_UnlockJoysticks2();
  }

  late final _SDL_UnlockJoysticks2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockJoysticks');
  late final _SDL_UnlockJoysticks2 =
      _SDL_UnlockJoysticks2Ptr.asFunction<void Function()>();

  /// Count the number of joysticks attached to the system.
  ///
  /// \returns the number of attached joysticks on success or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  int SDL_NumJoysticks2() {
    return _SDL_NumJoysticks2();
  }

  late final _SDL_NumJoysticks2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumJoysticks');
  late final _SDL_NumJoysticks2 =
      _SDL_NumJoysticks2Ptr.asFunction<int Function()>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system)
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickNameForIndex2(
    int device_index,
  ) {
    return _SDL_JoystickNameForIndex2(
      device_index,
    );
  }

  late final _SDL_JoystickNameForIndex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_JoystickNameForIndex');
  late final _SDL_JoystickNameForIndex2 = _SDL_JoystickNameForIndex2Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the player index of a joystick, or -1 if it's not available This can be
  /// called before any joysticks are opened.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetDevicePlayerIndex2(
    int device_index,
  ) {
    return _SDL_JoystickGetDevicePlayerIndex2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDevicePlayerIndex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickGetDevicePlayerIndex');
  late final _SDL_JoystickGetDevicePlayerIndex2 =
      _SDL_JoystickGetDevicePlayerIndex2Ptr.asFunction<int Function(int)>();

  /// Get the implementation-dependent GUID for the joystick at a given device
  /// index.
  ///
  /// This function can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the GUID of the selected joystick. If called on an invalid index,
  /// this function returns a zero GUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetDeviceGUID2(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceGUID2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceGUID2Ptr =
      _lookup<ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceGUID');
  late final _SDL_JoystickGetDeviceGUID2 = _SDL_JoystickGetDeviceGUID2Ptr
      .asFunction<SDL_JoystickGUID Function(int)>();

  /// Get the USB vendor ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the vendor ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB vendor ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceVendor2(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceVendor2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceVendor2Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceVendor');
  late final _SDL_JoystickGetDeviceVendor2 =
      _SDL_JoystickGetDeviceVendor2Ptr.asFunction<int Function(int)>();

  /// Get the USB product ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB product ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProduct2(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProduct2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProduct2Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProduct');
  late final _SDL_JoystickGetDeviceProduct2 =
      _SDL_JoystickGetDeviceProduct2Ptr.asFunction<int Function(int)>();

  /// Get the product version of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product version
  /// isn't available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the product version of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProductVersion2(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProductVersion2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductVersion2Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProductVersion');
  late final _SDL_JoystickGetDeviceProductVersion2 =
      _SDL_JoystickGetDeviceProductVersion2Ptr.asFunction<int Function(int)>();

  /// Get the type of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the SDL_JoystickType of the selected joystick. If called on an
  /// invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceType2(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceType2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceType2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceType');
  late final _SDL_JoystickGetDeviceType2 =
      _SDL_JoystickGetDeviceType2Ptr.asFunction<int Function(int)>();

  /// Get the instance ID of a joystick.
  ///
  /// This can be called before any joysticks are opened. If the index is out of
  /// range, this function will return -1.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the instance id of the selected joystick. If called on an invalid
  /// index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceInstanceID2(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceInstanceID2(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceInstanceID2Ptr =
      _lookup<ffi.NativeFunction<SDL_JoystickID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceInstanceID');
  late final _SDL_JoystickGetDeviceInstanceID2 =
      _SDL_JoystickGetDeviceInstanceID2Ptr.asFunction<int Function(int)>();

  /// Open a joystick for use.
  ///
  /// The `device_index` argument refers to the N'th joystick presently
  /// recognized by SDL on the system. It is **NOT** the same as the instance ID
  /// used to identify the joystick in future events. See
  /// SDL_JoystickInstanceID() for more details about instance IDs.
  ///
  /// The joystick subsystem must be initialized before a joystick can be opened
  /// for use.
  ///
  /// \param device_index the index of the joystick to query
  /// \returns a joystick identifier or NULL if an error occurred; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickInstanceID
  ffi.Pointer<SDL_Joystick> SDL_JoystickOpen2(
    int device_index,
  ) {
    return _SDL_JoystickOpen2(
      device_index,
    );
  }

  late final _SDL_JoystickOpen2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickOpen');
  late final _SDL_JoystickOpen2 = _SDL_JoystickOpen2Ptr.asFunction<
      ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with an instance id.
  ///
  /// \param instance_id the instance id to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromInstanceID2(
    int instance_id,
  ) {
    return _SDL_JoystickFromInstanceID2(
      instance_id,
    );
  }

  late final _SDL_JoystickFromInstanceID2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Joystick> Function(
              SDL_JoystickID)>>('SDL_JoystickFromInstanceID');
  late final _SDL_JoystickFromInstanceID2 = _SDL_JoystickFromInstanceID2Ptr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with a player index.
  ///
  /// \param player_index the player index to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.12.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromPlayerIndex2(
    int player_index,
  ) {
    return _SDL_JoystickFromPlayerIndex2(
      player_index,
    );
  }

  late final _SDL_JoystickFromPlayerIndex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickFromPlayerIndex');
  late final _SDL_JoystickFromPlayerIndex2 = _SDL_JoystickFromPlayerIndex2Ptr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Attach a new virtual joystick.
  ///
  /// \returns the joystick's device index, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickAttachVirtual2(
    int type,
    int naxes,
    int nbuttons,
    int nhats,
  ) {
    return _SDL_JoystickAttachVirtual2(
      type,
      naxes,
      nbuttons,
      nhats,
    );
  }

  late final _SDL_JoystickAttachVirtual2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int32, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_JoystickAttachVirtual');
  late final _SDL_JoystickAttachVirtual2 = _SDL_JoystickAttachVirtual2Ptr
      .asFunction<int Function(int, int, int, int)>();

  /// Detach a virtual joystick.
  ///
  /// \param device_index a value previously returned from
  /// SDL_JoystickAttachVirtual()
  /// \returns 0 on success, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickDetachVirtual2(
    int device_index,
  ) {
    return _SDL_JoystickDetachVirtual2(
      device_index,
    );
  }

  late final _SDL_JoystickDetachVirtual2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickDetachVirtual');
  late final _SDL_JoystickDetachVirtual2 =
      _SDL_JoystickDetachVirtual2Ptr.asFunction<int Function(int)>();

  /// Query whether or not the joystick at a given device index is virtual.
  ///
  /// \param device_index a joystick device index.
  /// \returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickIsVirtual2(
    int device_index,
  ) {
    return _SDL_JoystickIsVirtual2(
      device_index,
    );
  }

  late final _SDL_JoystickIsVirtual2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickIsVirtual');
  late final _SDL_JoystickIsVirtual2 =
      _SDL_JoystickIsVirtual2Ptr.asFunction<int Function(int)>();

  /// Set values on an opened, virtual-joystick's axis.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param axis the specific axis on the virtual joystick to set.
  /// \param value the new value for the specified axis.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualAxis2(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    int value,
  ) {
    return _SDL_JoystickSetVirtualAxis2(
      joystick,
      axis,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualAxis2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Sint16)>>('SDL_JoystickSetVirtualAxis');
  late final _SDL_JoystickSetVirtualAxis2 = _SDL_JoystickSetVirtualAxis2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's button.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param button the specific button on the virtual joystick to set.
  /// \param value the new value for the specified button.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualButton2(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
    int value,
  ) {
    return _SDL_JoystickSetVirtualButton2(
      joystick,
      button,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualButton2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualButton');
  late final _SDL_JoystickSetVirtualButton2 = _SDL_JoystickSetVirtualButton2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's hat.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param hat the specific hat on the virtual joystick to set.
  /// \param value the new value for the specified hat.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualHat2(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
    int value,
  ) {
    return _SDL_JoystickSetVirtualHat2(
      joystick,
      hat,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualHat2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualHat');
  late final _SDL_JoystickSetVirtualHat2 = _SDL_JoystickSetVirtualHat2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNameForIndex
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickName2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickName2(
      joystick,
    );
  }

  late final _SDL_JoystickName2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickName');
  late final _SDL_JoystickName2 = _SDL_JoystickName2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the player index of an opened joystick.
  ///
  /// For XInput controllers this returns the XInput user index. Many joysticks
  /// will not be able to supply this information.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the player index, or -1 if it's not available.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetPlayerIndex2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetPlayerIndex2(
      joystick,
    );
  }

  late final _SDL_JoystickGetPlayerIndex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetPlayerIndex');
  late final _SDL_JoystickGetPlayerIndex2 = _SDL_JoystickGetPlayerIndex2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Set the player index of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \param player_index the player index to set.
  ///
  /// \since This function is available since SDL 2.0.12.
  void SDL_JoystickSetPlayerIndex2(
    ffi.Pointer<SDL_Joystick> joystick,
    int player_index,
  ) {
    return _SDL_JoystickSetPlayerIndex2(
      joystick,
      player_index,
    );
  }

  late final _SDL_JoystickSetPlayerIndex2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Joystick>,
              ffi.Int)>>('SDL_JoystickSetPlayerIndex');
  late final _SDL_JoystickSetPlayerIndex2 = _SDL_JoystickSetPlayerIndex2Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the implementation-dependent GUID for the joystick.
  ///
  /// This function requires an open joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the GUID of the given joystick. If called on an invalid index,
  /// this function returns a zero GUID; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUID2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetGUID2(
      joystick,
    );
  }

  late final _SDL_JoystickGetGUID2Ptr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickGUID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetGUID');
  late final _SDL_JoystickGetGUID2 = _SDL_JoystickGetGUID2Ptr.asFunction<
      SDL_JoystickGUID Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB vendor ID of an opened joystick, if available.
  ///
  /// If the vendor ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB vendor ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetVendor2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetVendor2(
      joystick,
    );
  }

  late final _SDL_JoystickGetVendor2Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetVendor');
  late final _SDL_JoystickGetVendor2 = _SDL_JoystickGetVendor2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB product ID of an opened joystick, if available.
  ///
  /// If the product ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB product ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProduct2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProduct2(
      joystick,
    );
  }

  late final _SDL_JoystickGetProduct2Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProduct');
  late final _SDL_JoystickGetProduct2 = _SDL_JoystickGetProduct2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the product version of an opened joystick, if available.
  ///
  /// If the product version isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the product version of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProductVersion2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProductVersion2(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductVersion2Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProductVersion');
  late final _SDL_JoystickGetProductVersion2 =
      _SDL_JoystickGetProductVersion2Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the serial number of an opened joystick, if available.
  ///
  /// Returns the serial number of the joystick, or NULL if it is not available.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the serial number of the selected joystick, or NULL if
  /// unavailable.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<ffi.Char> SDL_JoystickGetSerial2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetSerial2(
      joystick,
    );
  }

  late final _SDL_JoystickGetSerial2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetSerial');
  late final _SDL_JoystickGetSerial2 = _SDL_JoystickGetSerial2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the type of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the SDL_JoystickType of the selected joystick.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetType2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetType2(
      joystick,
    );
  }

  late final _SDL_JoystickGetType2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetType');
  late final _SDL_JoystickGetType2 = _SDL_JoystickGetType2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get an ASCII string representation for a given SDL_JoystickGUID.
  ///
  /// You should supply at least 33 bytes for pszGUID.
  ///
  /// \param guid the SDL_JoystickGUID you wish to convert to string
  /// \param pszGUID buffer in which to write the ASCII string
  /// \param cbGUID the size of pszGUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDFromString
  void SDL_JoystickGetGUIDString2(
    SDL_JoystickGUID guid,
    ffi.Pointer<ffi.Char> pszGUID,
    int cbGUID,
  ) {
    return _SDL_JoystickGetGUIDString2(
      guid,
      pszGUID,
      cbGUID,
    );
  }

  late final _SDL_JoystickGetGUIDString2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_JoystickGetGUIDString');
  late final _SDL_JoystickGetGUIDString2 =
      _SDL_JoystickGetGUIDString2Ptr.asFunction<
          void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>, int)>();

  /// Convert a GUID string into a SDL_JoystickGUID structure.
  ///
  /// Performs no error checking. If this function is given a string containing
  /// an invalid GUID, the function will silently succeed, but the GUID generated
  /// will not be useful.
  ///
  /// \param pchGUID string containing an ASCII representation of a GUID
  /// \returns a SDL_JoystickGUID structure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUIDFromString2(
    ffi.Pointer<ffi.Char> pchGUID,
  ) {
    return _SDL_JoystickGetGUIDFromString2(
      pchGUID,
    );
  }

  late final _SDL_JoystickGetGUIDFromString2Ptr = _lookup<
          ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>>(
      'SDL_JoystickGetGUIDFromString');
  late final _SDL_JoystickGetGUIDFromString2 =
      _SDL_JoystickGetGUIDFromString2Ptr.asFunction<
          SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>();

  /// Get the status of a specified joystick.
  ///
  /// \param joystick the joystick to query
  /// \returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickOpen
  int SDL_JoystickGetAttached2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetAttached2(
      joystick,
    );
  }

  late final _SDL_JoystickGetAttached2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetAttached');
  late final _SDL_JoystickGetAttached2 = _SDL_JoystickGetAttached2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the instance ID of an opened joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the instance ID of the specified joystick on success or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  int SDL_JoystickInstanceID2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickInstanceID2(
      joystick,
    );
  }

  late final _SDL_JoystickInstanceID2Ptr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickInstanceID');
  late final _SDL_JoystickInstanceID2 = _SDL_JoystickInstanceID2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of general axis controls on a joystick.
  ///
  /// Often, the directional pad on a game controller will either look like 4
  /// separate buttons or a POV hat, and not axes, but all of this is up to the
  /// device and platform.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of axis controls/number of axes on success or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetAxis
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumAxes2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumAxes2(
      joystick,
    );
  }

  late final _SDL_JoystickNumAxes2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumAxes');
  late final _SDL_JoystickNumAxes2 = _SDL_JoystickNumAxes2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of trackballs on a joystick.
  ///
  /// Joystick trackballs have only relative motion events associated with them
  /// and their state cannot be polled.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of trackballs on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetBall
  int SDL_JoystickNumBalls2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumBalls2(
      joystick,
    );
  }

  late final _SDL_JoystickNumBalls2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumBalls');
  late final _SDL_JoystickNumBalls2 = _SDL_JoystickNumBalls2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of POV hats on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of POV hats on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetHat
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumHats2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumHats2(
      joystick,
    );
  }

  late final _SDL_JoystickNumHats2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumHats');
  late final _SDL_JoystickNumHats2 = _SDL_JoystickNumHats2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of buttons on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of buttons on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetButton
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumButtons2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumButtons2(
      joystick,
    );
  }

  late final _SDL_JoystickNumButtons2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumButtons');
  late final _SDL_JoystickNumButtons2 = _SDL_JoystickNumButtons2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update the current state of the open joysticks.
  ///
  /// This is called automatically by the event loop if any joystick events are
  /// enabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickEventState
  void SDL_JoystickUpdate2() {
    return _SDL_JoystickUpdate2();
  }

  late final _SDL_JoystickUpdate2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_JoystickUpdate');
  late final _SDL_JoystickUpdate2 =
      _SDL_JoystickUpdate2Ptr.asFunction<void Function()>();

  /// Enable/disable joystick event polling.
  ///
  /// If joystick events are disabled, you must call SDL_JoystickUpdate()
  /// yourself and manually check the state of the joystick when you want
  /// joystick information.
  ///
  /// It is recommended that you leave joystick event handling enabled.
  ///
  /// **WARNING**: Calling this function may delete all events currently in SDL's
  /// event queue.
  ///
  /// \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
  /// \returns 1 if enabled, 0 if disabled, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// If `state` is `SDL_QUERY` then the current state is returned,
  /// otherwise the new processing state is returned.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerEventState
  int SDL_JoystickEventState2(
    int state,
  ) {
    return _SDL_JoystickEventState2(
      state,
    );
  }

  late final _SDL_JoystickEventState2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickEventState');
  late final _SDL_JoystickEventState2 =
      _SDL_JoystickEventState2Ptr.asFunction<int Function(int)>();

  /// Get the current state of an axis control on a joystick.
  ///
  /// SDL makes no promises about what part of the joystick any given axis refers
  /// to. Your game should have some sort of configuration UI to let users
  /// specify what each axis should be bound to. Alternately, SDL's higher-level
  /// Game Controller API makes a great effort to apply order to this lower-level
  /// interface, so you know that a specific axis is the "left thumb stick," etc.
  ///
  /// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to
  /// 32767) representing the current position of the axis. It may be necessary
  /// to impose certain tolerances on these values to account for jitter.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \returns a 16-bit signed integer representing the current position of the
  /// axis or 0 on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumAxes
  int SDL_JoystickGetAxis2(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
  ) {
    return _SDL_JoystickGetAxis2(
      joystick,
      axis,
    );
  }

  late final _SDL_JoystickGetAxis2Ptr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetAxis');
  late final _SDL_JoystickGetAxis2 = _SDL_JoystickGetAxis2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the initial state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \param state Upon return, the initial value is supplied here.
  /// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetAxisInitialState2(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    ffi.Pointer<Sint16> state,
  ) {
    return _SDL_JoystickGetAxisInitialState2(
      joystick,
      axis,
      state,
    );
  }

  late final _SDL_JoystickGetAxisInitialState2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              ffi.Pointer<Sint16>)>>('SDL_JoystickGetAxisInitialState');
  late final _SDL_JoystickGetAxisInitialState2 =
      _SDL_JoystickGetAxisInitialState2Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<Sint16>)>();

  /// Get the current state of a POV hat on a joystick.
  ///
  /// The returned value will be one of the following positions:
  ///
  /// - `SDL_HAT_CENTERED`
  /// - `SDL_HAT_UP`
  /// - `SDL_HAT_RIGHT`
  /// - `SDL_HAT_DOWN`
  /// - `SDL_HAT_LEFT`
  /// - `SDL_HAT_RIGHTUP`
  /// - `SDL_HAT_RIGHTDOWN`
  /// - `SDL_HAT_LEFTUP`
  /// - `SDL_HAT_LEFTDOWN`
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param hat the hat index to get the state from; indices start at index 0
  /// \returns the current hat position.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumHats
  int SDL_JoystickGetHat2(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
  ) {
    return _SDL_JoystickGetHat2(
      joystick,
      hat,
    );
  }

  late final _SDL_JoystickGetHat2Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetHat');
  late final _SDL_JoystickGetHat2 = _SDL_JoystickGetHat2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the ball axis change since the last poll.
  ///
  /// Trackballs can only return relative motion since the last call to
  /// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \param ball the ball index to query; ball indices start at index 0
  /// \param dx stores the difference in the x axis position since the last poll
  /// \param dy stores the difference in the y axis position since the last poll
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumBalls
  int SDL_JoystickGetBall2(
    ffi.Pointer<SDL_Joystick> joystick,
    int ball,
    ffi.Pointer<ffi.Int> dx,
    ffi.Pointer<ffi.Int> dy,
  ) {
    return _SDL_JoystickGetBall2(
      joystick,
      ball,
      dx,
      dy,
    );
  }

  late final _SDL_JoystickGetBall2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Joystick>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_JoystickGetBall');
  late final _SDL_JoystickGetBall2 = _SDL_JoystickGetBall2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the current state of a button on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param button the button index to get the state from; indices start at
  /// index 0
  /// \returns 1 if the specified button is pressed, 0 otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumButtons
  int SDL_JoystickGetButton2(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
  ) {
    return _SDL_JoystickGetButton2(
      joystick,
      button,
    );
  }

  late final _SDL_JoystickGetButton2Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetButton');
  late final _SDL_JoystickGetButton2 = _SDL_JoystickGetButton2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Start a rumble effect.
  ///
  /// Each call to this function cancels any previous rumble effect, and calling
  /// it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left)
  /// rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right)
  /// rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_JoystickHasRumble
  int SDL_JoystickRumble2(
    ffi.Pointer<SDL_Joystick> joystick,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumble2(
      joystick,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumble2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumble');
  late final _SDL_JoystickRumble2 = _SDL_JoystickRumble2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Start a rumble effect in the joystick's triggers
  ///
  /// Each call to this function cancels any previous trigger rumble effect, and
  /// calling it with 0 intensity stops any rumbling.
  ///
  /// Note that this function is for _trigger_ rumble; the first joystick to
  /// support this was the PlayStation 5's DualShock 5 controller. If you want
  /// the (more common) whole-controller rumble, use SDL_JoystickRumble()
  /// instead.
  ///
  /// \param joystick The joystick to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if trigger rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_JoystickHasRumbleTriggers
  int SDL_JoystickRumbleTriggers2(
    ffi.Pointer<SDL_Joystick> joystick,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumbleTriggers2(
      joystick,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumbleTriggers2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumbleTriggers');
  late final _SDL_JoystickRumbleTriggers2 = _SDL_JoystickRumbleTriggers2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Query whether a joystick has an LED.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickHasLED2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasLED2(
      joystick,
    );
  }

  late final _SDL_JoystickHasLED2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasLED');
  late final _SDL_JoystickHasLED2 = _SDL_JoystickHasLED2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumble
  int SDL_JoystickHasRumble2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumble2(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumble2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumble');
  late final _SDL_JoystickHasRumble2 = _SDL_JoystickHasRumble2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support on triggers.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumbleTriggers
  int SDL_JoystickHasRumbleTriggers2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumbleTriggers2(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumbleTriggers2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumbleTriggers');
  late final _SDL_JoystickHasRumbleTriggers2 =
      _SDL_JoystickHasRumbleTriggers2Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update a joystick's LED color.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  /// \returns 0 on success, -1 if this joystick does not have a modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetLED2(
    ffi.Pointer<SDL_Joystick> joystick,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_JoystickSetLED2(
      joystick,
      red,
      green,
      blue,
    );
  }

  late final _SDL_JoystickSetLED2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint8, Uint8,
              Uint8)>>('SDL_JoystickSetLED');
  late final _SDL_JoystickSetLED2 = _SDL_JoystickSetLED2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Send a joystick specific effect packet
  ///
  /// \param joystick The joystick to affect
  /// \param data The data to send to the joystick
  /// \param size The size of the data to send to the joystick
  /// \returns 0, or -1 if this joystick or driver doesn't support effect packets
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_JoystickSendEffect2(
    ffi.Pointer<SDL_Joystick> joystick,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _SDL_JoystickSendEffect2(
      joystick,
      data,
      size,
    );
  }

  late final _SDL_JoystickSendEffect2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_JoystickSendEffect');
  late final _SDL_JoystickSendEffect2 = _SDL_JoystickSendEffect2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>, int)>();

  /// Close a joystick previously opened with SDL_JoystickOpen().
  ///
  /// \param joystick The joystick device to close
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  void SDL_JoystickClose2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickClose2(
      joystick,
    );
  }

  late final _SDL_JoystickClose2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickClose');
  late final _SDL_JoystickClose2 = _SDL_JoystickClose2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the battery level of a joystick as SDL_JoystickPowerLevel.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \returns the current battery level as SDL_JoystickPowerLevel on success or
  /// `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_JoystickCurrentPowerLevel2(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickCurrentPowerLevel2(
      joystick,
    );
  }

  late final _SDL_JoystickCurrentPowerLevel2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickCurrentPowerLevel');
  late final _SDL_JoystickCurrentPowerLevel2 =
      _SDL_JoystickCurrentPowerLevel2Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Count the number of haptic devices attached to the system.
  ///
  /// \returns the number of haptic devices detected on the system or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticName
  int SDL_NumHaptics1() {
    return _SDL_NumHaptics1();
  }

  late final _SDL_NumHaptics1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumHaptics');
  late final _SDL_NumHaptics1 =
      _SDL_NumHaptics1Ptr.asFunction<int Function()>();

  /// Get the implementation dependent name of a haptic device.
  ///
  /// This can be called before any joysticks are opened. If no name can be
  /// found, this function returns NULL.
  ///
  /// \param device_index index of the device to query.
  /// \returns the name of the device or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_NumHaptics
  ffi.Pointer<ffi.Char> SDL_HapticName1(
    int device_index,
  ) {
    return _SDL_HapticName1(
      device_index,
    );
  }

  late final _SDL_HapticName1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_HapticName');
  late final _SDL_HapticName1 =
      _SDL_HapticName1Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Open a haptic device for use.
  ///
  /// The index passed as an argument refers to the N'th haptic device on this
  /// system.
  ///
  /// When opening a haptic device, its gain will be set to maximum and
  /// autocenter will be disabled. To modify these values use SDL_HapticSetGain()
  /// and SDL_HapticSetAutocenter().
  ///
  /// \param device_index index of the device to open
  /// \returns the device identifier or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticClose
  /// \sa SDL_HapticIndex
  /// \sa SDL_HapticOpenFromJoystick
  /// \sa SDL_HapticOpenFromMouse
  /// \sa SDL_HapticPause
  /// \sa SDL_HapticSetAutocenter
  /// \sa SDL_HapticSetGain
  /// \sa SDL_HapticStopAll
  ffi.Pointer<SDL_Haptic> SDL_HapticOpen1(
    int device_index,
  ) {
    return _SDL_HapticOpen1(
      device_index,
    );
  }

  late final _SDL_HapticOpen1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Haptic> Function(ffi.Int)>>(
          'SDL_HapticOpen');
  late final _SDL_HapticOpen1 =
      _SDL_HapticOpen1Ptr.asFunction<ffi.Pointer<SDL_Haptic> Function(int)>();

  /// Check if the haptic device at the designated index has been opened.
  ///
  /// \param device_index the index of the device to query
  /// \returns 1 if it has been opened, 0 if it hasn't or on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticIndex
  /// \sa SDL_HapticOpen
  int SDL_HapticOpened1(
    int device_index,
  ) {
    return _SDL_HapticOpened1(
      device_index,
    );
  }

  late final _SDL_HapticOpened1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_HapticOpened');
  late final _SDL_HapticOpened1 =
      _SDL_HapticOpened1Ptr.asFunction<int Function(int)>();

  /// Get the index of a haptic device.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns the index of the specified haptic device or a negative error code
  /// on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticOpened
  int SDL_HapticIndex1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticIndex1(
      haptic,
    );
  }

  late final _SDL_HapticIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticIndex');
  late final _SDL_HapticIndex1 =
      _SDL_HapticIndex1Ptr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Query whether or not the current mouse has haptic capabilities.
  ///
  /// \returns SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpenFromMouse
  int SDL_MouseIsHaptic1() {
    return _SDL_MouseIsHaptic1();
  }

  late final _SDL_MouseIsHaptic1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_MouseIsHaptic');
  late final _SDL_MouseIsHaptic1 =
      _SDL_MouseIsHaptic1Ptr.asFunction<int Function()>();

  /// Try to open a haptic device from the current mouse.
  ///
  /// \returns the haptic device identifier or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_MouseIsHaptic
  ffi.Pointer<SDL_Haptic> SDL_HapticOpenFromMouse1() {
    return _SDL_HapticOpenFromMouse1();
  }

  late final _SDL_HapticOpenFromMouse1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Haptic> Function()>>(
          'SDL_HapticOpenFromMouse');
  late final _SDL_HapticOpenFromMouse1 = _SDL_HapticOpenFromMouse1Ptr
      .asFunction<ffi.Pointer<SDL_Haptic> Function()>();

  /// Query if a joystick has haptic features.
  ///
  /// \param joystick the SDL_Joystick to test for haptic capabilities
  /// \returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpenFromJoystick
  int SDL_JoystickIsHaptic1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickIsHaptic1(
      joystick,
    );
  }

  late final _SDL_JoystickIsHaptic1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickIsHaptic');
  late final _SDL_JoystickIsHaptic1 = _SDL_JoystickIsHaptic1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Open a haptic device for use from a joystick device.
  ///
  /// You must still close the haptic device separately. It will not be closed
  /// with the joystick.
  ///
  /// When opened from a joystick you should first close the haptic device before
  /// closing the joystick device. If not, on some implementations the haptic
  /// device will also get unallocated and you'll be unable to use force feedback
  /// on that device.
  ///
  /// \param joystick the SDL_Joystick to create a haptic device from
  /// \returns a valid haptic device identifier on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticClose
  /// \sa SDL_HapticOpen
  /// \sa SDL_JoystickIsHaptic
  ffi.Pointer<SDL_Haptic> SDL_HapticOpenFromJoystick1(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_HapticOpenFromJoystick1(
      joystick,
    );
  }

  late final _SDL_HapticOpenFromJoystick1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Haptic> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_HapticOpenFromJoystick');
  late final _SDL_HapticOpenFromJoystick1 =
      _SDL_HapticOpenFromJoystick1Ptr.asFunction<
          ffi.Pointer<SDL_Haptic> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Close a haptic device previously opened with SDL_HapticOpen().
  ///
  /// \param haptic the SDL_Haptic device to close
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  void SDL_HapticClose1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticClose1(
      haptic,
    );
  }

  late final _SDL_HapticClose1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticClose');
  late final _SDL_HapticClose1 =
      _SDL_HapticClose1Ptr.asFunction<void Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the number of effects a haptic device can store.
  ///
  /// On some platforms this isn't fully supported, and therefore is an
  /// approximation. Always check to see if your created effect was actually
  /// created and do not rely solely on SDL_HapticNumEffects().
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns the number of effects the haptic device can store or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNumEffectsPlaying
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffects1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumEffects1(
      haptic,
    );
  }

  late final _SDL_HapticNumEffects1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticNumEffects');
  late final _SDL_HapticNumEffects1 = _SDL_HapticNumEffects1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the number of effects a haptic device can play at the same time.
  ///
  /// This is not supported on all platforms, but will always return a value.
  ///
  /// \param haptic the SDL_Haptic device to query maximum playing effects
  /// \returns the number of effects the haptic device can play at the same time
  /// or a negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNumEffects
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffectsPlaying1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumEffectsPlaying1(
      haptic,
    );
  }

  late final _SDL_HapticNumEffectsPlaying1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticNumEffectsPlaying');
  late final _SDL_HapticNumEffectsPlaying1 = _SDL_HapticNumEffectsPlaying1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the haptic device's supported features in bitwise manner.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns a list of supported haptic features in bitwise manner (OR'd), or 0
  /// on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticEffectSupported
  /// \sa SDL_HapticNumEffects
  int SDL_HapticQuery1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticQuery1(
      haptic,
    );
  }

  late final _SDL_HapticQuery1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<SDL_Haptic>)>>('SDL_HapticQuery');
  late final _SDL_HapticQuery1 =
      _SDL_HapticQuery1Ptr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the number of haptic axes the device has.
  ///
  /// The number of haptic axes might be useful if working with the
  /// SDL_HapticDirection effect.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \returns the number of axes on success or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_HapticNumAxes1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumAxes1(
      haptic,
    );
  }

  late final _SDL_HapticNumAxes1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticNumAxes');
  late final _SDL_HapticNumAxes1 = _SDL_HapticNumAxes1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Check to see if an effect is supported by a haptic device.
  ///
  /// \param haptic the SDL_Haptic device to query
  /// \param effect the desired effect to query
  /// \returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNewEffect
  /// \sa SDL_HapticQuery
  int SDL_HapticEffectSupported1(
    ffi.Pointer<SDL_Haptic> haptic,
    ffi.Pointer<SDL_HapticEffect> effect,
  ) {
    return _SDL_HapticEffectSupported1(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticEffectSupported1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticEffectSupported');
  late final _SDL_HapticEffectSupported1 =
      _SDL_HapticEffectSupported1Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Pointer<SDL_HapticEffect>)>();

  /// Create a new haptic effect on a specified device.
  ///
  /// \param haptic an SDL_Haptic device to create the effect on
  /// \param effect an SDL_HapticEffect structure containing the properties of
  /// the effect to create
  /// \returns the ID of the effect on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticUpdateEffect
  int SDL_HapticNewEffect1(
    ffi.Pointer<SDL_Haptic> haptic,
    ffi.Pointer<SDL_HapticEffect> effect,
  ) {
    return _SDL_HapticNewEffect1(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticNewEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticNewEffect');
  late final _SDL_HapticNewEffect1 = _SDL_HapticNewEffect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, ffi.Pointer<SDL_HapticEffect>)>();

  /// Update the properties of an effect.
  ///
  /// Can be used dynamically, although behavior when dynamically changing
  /// direction may be strange. Specifically the effect may re-upload itself and
  /// start playing from the start. You also cannot change the type either when
  /// running SDL_HapticUpdateEffect().
  ///
  /// \param haptic the SDL_Haptic device that has the effect
  /// \param effect the identifier of the effect to update
  /// \param data an SDL_HapticEffect structure containing the new effect
  /// properties to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticNewEffect
  /// \sa SDL_HapticRunEffect
  int SDL_HapticUpdateEffect1(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
    ffi.Pointer<SDL_HapticEffect> data,
  ) {
    return _SDL_HapticUpdateEffect1(
      haptic,
      effect,
      data,
    );
  }

  late final _SDL_HapticUpdateEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>, ffi.Int,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticUpdateEffect');
  late final _SDL_HapticUpdateEffect1 = _SDL_HapticUpdateEffect1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Haptic>, int, ffi.Pointer<SDL_HapticEffect>)>();

  /// Run the haptic effect on its associated haptic device.
  ///
  /// To repeat the effect over and over indefinitely, set `iterations` to
  /// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
  /// one instance of the effect last indefinitely (so the effect does not fade),
  /// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
  /// instead.
  ///
  /// \param haptic the SDL_Haptic device to run the effect on
  /// \param effect the ID of the haptic effect to run
  /// \param iterations the number of iterations to run the effect; use
  /// `SDL_HAPTIC_INFINITY` to repeat forever
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticGetEffectStatus
  /// \sa SDL_HapticStopEffect
  int SDL_HapticRunEffect1(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
    int iterations,
  ) {
    return _SDL_HapticRunEffect1(
      haptic,
      effect,
      iterations,
    );
  }

  late final _SDL_HapticRunEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>, ffi.Int,
              Uint32)>>('SDL_HapticRunEffect');
  late final _SDL_HapticRunEffect1 = _SDL_HapticRunEffect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int, int)>();

  /// Stop the haptic effect on its associated haptic device.
  ///
  /// *
  ///
  /// \param haptic the SDL_Haptic device to stop the effect on
  /// \param effect the ID of the haptic effect to stop
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticRunEffect
  int SDL_HapticStopEffect1(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticStopEffect1(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticStopEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticStopEffect');
  late final _SDL_HapticStopEffect1 = _SDL_HapticStopEffect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Destroy a haptic effect on the device.
  ///
  /// This will stop the effect if it's running. Effects are automatically
  /// destroyed when the device is closed.
  ///
  /// \param haptic the SDL_Haptic device to destroy the effect on
  /// \param effect the ID of the haptic effect to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticNewEffect
  void SDL_HapticDestroyEffect1(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticDestroyEffect1(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticDestroyEffect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticDestroyEffect');
  late final _SDL_HapticDestroyEffect1 = _SDL_HapticDestroyEffect1Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Get the status of the current effect on the specified haptic device.
  ///
  /// Device must support the SDL_HAPTIC_STATUS feature.
  ///
  /// \param haptic the SDL_Haptic device to query for the effect status on
  /// \param effect the ID of the haptic effect to query its status
  /// \returns 0 if it isn't playing, 1 if it is playing, or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticStopEffect
  int SDL_HapticGetEffectStatus1(
    ffi.Pointer<SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticGetEffectStatus1(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticGetEffectStatus1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticGetEffectStatus');
  late final _SDL_HapticGetEffectStatus1 = _SDL_HapticGetEffectStatus1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Set the global gain of the specified haptic device.
  ///
  /// Device must support the SDL_HAPTIC_GAIN feature.
  ///
  /// The user may specify the maximum gain by setting the environment variable
  /// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
  /// SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
  /// maximum.
  ///
  /// \param haptic the SDL_Haptic device to set the gain on
  /// \param gain value to set the gain to, should be between 0 and 100 (0 - 100)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetGain1(
    ffi.Pointer<SDL_Haptic> haptic,
    int gain,
  ) {
    return _SDL_HapticSetGain1(
      haptic,
      gain,
    );
  }

  late final _SDL_HapticSetGain1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticSetGain');
  late final _SDL_HapticSetGain1 = _SDL_HapticSetGain1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Set the global autocenter of the device.
  ///
  /// Autocenter should be between 0 and 100. Setting it to 0 will disable
  /// autocentering.
  ///
  /// Device must support the SDL_HAPTIC_AUTOCENTER feature.
  ///
  /// \param haptic the SDL_Haptic device to set autocentering on
  /// \param autocenter value to set autocenter to (0-100)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetAutocenter1(
    ffi.Pointer<SDL_Haptic> haptic,
    int autocenter,
  ) {
    return _SDL_HapticSetAutocenter1(
      haptic,
      autocenter,
    );
  }

  late final _SDL_HapticSetAutocenter1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Haptic>, ffi.Int)>>('SDL_HapticSetAutocenter');
  late final _SDL_HapticSetAutocenter1 = _SDL_HapticSetAutocenter1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>, int)>();

  /// Pause a haptic device.
  ///
  /// Device must support the `SDL_HAPTIC_PAUSE` feature. Call
  /// SDL_HapticUnpause() to resume playback.
  ///
  /// Do not modify the effects nor add new ones while the device is paused. That
  /// can cause all sorts of weird errors.
  ///
  /// \param haptic the SDL_Haptic device to pause
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticUnpause
  int SDL_HapticPause1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticPause1(
      haptic,
    );
  }

  late final _SDL_HapticPause1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticPause');
  late final _SDL_HapticPause1 =
      _SDL_HapticPause1Ptr.asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Unpause a haptic device.
  ///
  /// Call to unpause after SDL_HapticPause().
  ///
  /// \param haptic the SDL_Haptic device to unpause
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticPause
  int SDL_HapticUnpause1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticUnpause1(
      haptic,
    );
  }

  late final _SDL_HapticUnpause1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticUnpause');
  late final _SDL_HapticUnpause1 = _SDL_HapticUnpause1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Stop all the currently playing effects on a haptic device.
  ///
  /// \param haptic the SDL_Haptic device to stop
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_HapticStopAll1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticStopAll1(
      haptic,
    );
  }

  late final _SDL_HapticStopAll1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticStopAll');
  late final _SDL_HapticStopAll1 = _SDL_HapticStopAll1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Check whether rumble is supported on a haptic device.
  ///
  /// \param haptic haptic device to check for rumble support
  /// \returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumbleSupported1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleSupported1(
      haptic,
    );
  }

  late final _SDL_HapticRumbleSupported1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticRumbleSupported');
  late final _SDL_HapticRumbleSupported1 = _SDL_HapticRumbleSupported1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Initialize a haptic device for simple rumble playback.
  ///
  /// \param haptic the haptic device to initialize for simple rumble playback
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  /// \sa SDL_HapticRumbleSupported
  int SDL_HapticRumbleInit1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleInit1(
      haptic,
    );
  }

  late final _SDL_HapticRumbleInit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticRumbleInit');
  late final _SDL_HapticRumbleInit1 = _SDL_HapticRumbleInit1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Run a simple rumble effect on a haptic device.
  ///
  /// \param haptic the haptic device to play the rumble effect on
  /// \param strength strength of the rumble to play as a 0-1 float value
  /// \param length length of the rumble to play in milliseconds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumbleStop
  /// \sa SDL_HapticRumbleSupported
  int SDL_HapticRumblePlay1(
    ffi.Pointer<SDL_Haptic> haptic,
    double strength,
    int length,
  ) {
    return _SDL_HapticRumblePlay1(
      haptic,
      strength,
      length,
    );
  }

  late final _SDL_HapticRumblePlay1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Haptic>, ffi.Float,
              Uint32)>>('SDL_HapticRumblePlay');
  late final _SDL_HapticRumblePlay1 = _SDL_HapticRumblePlay1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>, double, int)>();

  /// Stop the simple rumble on a haptic device.
  ///
  /// \param haptic the haptic device to stop the rumble effect on
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleSupported
  int SDL_HapticRumbleStop1(
    ffi.Pointer<SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleStop1(
      haptic,
    );
  }

  late final _SDL_HapticRumbleStop1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Haptic>)>>(
          'SDL_HapticRumbleStop');
  late final _SDL_HapticRumbleStop1 = _SDL_HapticRumbleStop1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform13() {
    return _SDL_GetPlatform13();
  }

  late final _SDL_GetPlatform13Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform13 =
      _SDL_GetPlatform13Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc12(
    int size,
  ) {
    return _SDL_malloc12(
      size,
    );
  }

  late final _SDL_malloc12Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc12 =
      _SDL_malloc12Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc12(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc12(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc12 =
      _SDL_calloc12Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc12(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc12(
      mem,
      size,
    );
  }

  late final _SDL_realloc12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc12 = _SDL_realloc12Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free12(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free12(
      mem,
    );
  }

  late final _SDL_free12Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free12 =
      _SDL_free12Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions12(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions12(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions12 =
      _SDL_GetMemoryFunctions12Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions12(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions12(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions12 =
      _SDL_SetMemoryFunctions12Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations12() {
    return _SDL_GetNumAllocations12();
  }

  late final _SDL_GetNumAllocations12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations12 =
      _SDL_GetNumAllocations12Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv12(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv12(
      name,
    );
  }

  late final _SDL_getenv12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv12 = _SDL_getenv12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv12(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv12(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv12 = _SDL_setenv12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort12(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort12(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort12 = _SDL_qsort12Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs12(
    int x,
  ) {
    return _SDL_abs12(
      x,
    );
  }

  late final _SDL_abs12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs12 = _SDL_abs12Ptr.asFunction<int Function(int)>();

  int SDL_isalpha12(
    int x,
  ) {
    return _SDL_isalpha12(
      x,
    );
  }

  late final _SDL_isalpha12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha12 = _SDL_isalpha12Ptr.asFunction<int Function(int)>();

  int SDL_isalnum12(
    int x,
  ) {
    return _SDL_isalnum12(
      x,
    );
  }

  late final _SDL_isalnum12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum12 = _SDL_isalnum12Ptr.asFunction<int Function(int)>();

  int SDL_isblank12(
    int x,
  ) {
    return _SDL_isblank12(
      x,
    );
  }

  late final _SDL_isblank12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank12 = _SDL_isblank12Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl12(
    int x,
  ) {
    return _SDL_iscntrl12(
      x,
    );
  }

  late final _SDL_iscntrl12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl12 = _SDL_iscntrl12Ptr.asFunction<int Function(int)>();

  int SDL_isdigit12(
    int x,
  ) {
    return _SDL_isdigit12(
      x,
    );
  }

  late final _SDL_isdigit12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit12 = _SDL_isdigit12Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit12(
    int x,
  ) {
    return _SDL_isxdigit12(
      x,
    );
  }

  late final _SDL_isxdigit12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit12 =
      _SDL_isxdigit12Ptr.asFunction<int Function(int)>();

  int SDL_ispunct12(
    int x,
  ) {
    return _SDL_ispunct12(
      x,
    );
  }

  late final _SDL_ispunct12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct12 = _SDL_ispunct12Ptr.asFunction<int Function(int)>();

  int SDL_isspace12(
    int x,
  ) {
    return _SDL_isspace12(
      x,
    );
  }

  late final _SDL_isspace12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace12 = _SDL_isspace12Ptr.asFunction<int Function(int)>();

  int SDL_isupper12(
    int x,
  ) {
    return _SDL_isupper12(
      x,
    );
  }

  late final _SDL_isupper12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper12 = _SDL_isupper12Ptr.asFunction<int Function(int)>();

  int SDL_islower12(
    int x,
  ) {
    return _SDL_islower12(
      x,
    );
  }

  late final _SDL_islower12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower12 = _SDL_islower12Ptr.asFunction<int Function(int)>();

  int SDL_isprint12(
    int x,
  ) {
    return _SDL_isprint12(
      x,
    );
  }

  late final _SDL_isprint12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint12 = _SDL_isprint12Ptr.asFunction<int Function(int)>();

  int SDL_isgraph12(
    int x,
  ) {
    return _SDL_isgraph12(
      x,
    );
  }

  late final _SDL_isgraph12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph12 = _SDL_isgraph12Ptr.asFunction<int Function(int)>();

  int SDL_toupper12(
    int x,
  ) {
    return _SDL_toupper12(
      x,
    );
  }

  late final _SDL_toupper12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper12 = _SDL_toupper12Ptr.asFunction<int Function(int)>();

  int SDL_tolower12(
    int x,
  ) {
    return _SDL_tolower12(
      x,
    );
  }

  late final _SDL_tolower12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower12 = _SDL_tolower12Ptr.asFunction<int Function(int)>();

  int SDL_crc3212(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3212(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3212Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3212 = _SDL_crc3212Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset12(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset12(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset12 = _SDL_memset12Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy12(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy12(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy12 = _SDL_memcpy12Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove12(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove12(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove12 = _SDL_memmove12Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp12(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp12(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp12 = _SDL_memcmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen12(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen12(
      wstr,
    );
  }

  late final _SDL_wcslen12Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen12 =
      _SDL_wcslen12Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy12(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy12(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy12 = _SDL_wcslcpy12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat12(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat12(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat12 = _SDL_wcslcat12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup12(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup12(
      wstr,
    );
  }

  late final _SDL_wcsdup12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup12 = _SDL_wcsdup12Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr12(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr12(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr12 = _SDL_wcsstr12Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp12(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp12(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp12 = _SDL_wcscmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp12(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp12(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp12 = _SDL_wcsncmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp12(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp12(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp12 = _SDL_wcscasecmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp12(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp12(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp12 = _SDL_wcsncasecmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen12(
      str,
    );
  }

  late final _SDL_strlen12Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen12 =
      _SDL_strlen12Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy12(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy12(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy12 = _SDL_strlcpy12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy12(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy12(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy12 = _SDL_utf8strlcpy12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat12(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat12(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat12 = _SDL_strlcat12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup12(
      str,
    );
  }

  late final _SDL_strdup12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup12 = _SDL_strdup12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev12(
      str,
    );
  }

  late final _SDL_strrev12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev12 = _SDL_strrev12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr12(
      str,
    );
  }

  late final _SDL_strupr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr12 = _SDL_strupr12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr12(
      str,
    );
  }

  late final _SDL_strlwr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr12 = _SDL_strlwr12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr12(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr12(
      str,
      c,
    );
  }

  late final _SDL_strchr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr12 = _SDL_strchr12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr12(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr12(
      str,
      c,
    );
  }

  late final _SDL_strrchr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr12 = _SDL_strrchr12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr12(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr12(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr12 = _SDL_strstr12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr12(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr12(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr12 = _SDL_strtokr12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen12(
      str,
    );
  }

  late final _SDL_utf8strlen12Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen12 =
      _SDL_utf8strlen12Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa12(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa12(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa12 = _SDL_itoa12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa12(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa12(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa12 = _SDL_uitoa12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa12(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa12(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa12 = _SDL_ltoa12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa12(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa12(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa12 = _SDL_ultoa12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa12(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa12(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa12 = _SDL_lltoa12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa12(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa12(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa12 = _SDL_ulltoa12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi12(
      str,
    );
  }

  late final _SDL_atoi12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi12 =
      _SDL_atoi12Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof12(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof12(
      str,
    );
  }

  late final _SDL_atof12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof12 =
      _SDL_atof12Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol12(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol12(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol12 = _SDL_strtol12Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul12(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul12(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul12 = _SDL_strtoul12Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll12(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll12(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll12Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll12 = _SDL_strtoll12Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull12(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull12(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull12Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull12 = _SDL_strtoull12Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod12(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod12(
      str,
      endp,
    );
  }

  late final _SDL_strtod12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod12 = _SDL_strtod12Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp12(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp12(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp12 = _SDL_strcmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp12(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp12(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp12 = _SDL_strncmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp12(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp12(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp12 = _SDL_strcasecmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp12(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp12(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp12 = _SDL_strncasecmp12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf12(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf12(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf12 = _SDL_sscanf12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf12(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf12(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf12 = _SDL_vsscanf12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf12(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf12(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf12 = _SDL_snprintf12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf12(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf12(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf12 = _SDL_vsnprintf12Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf12(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf12(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf12 = _SDL_asprintf12Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf12(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf12(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf12 = _SDL_vasprintf12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos12(
    double x,
  ) {
    return _SDL_acos12(
      x,
    );
  }

  late final _SDL_acos12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos12 = _SDL_acos12Ptr.asFunction<double Function(double)>();

  double SDL_acosf12(
    double x,
  ) {
    return _SDL_acosf12(
      x,
    );
  }

  late final _SDL_acosf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf12 =
      _SDL_acosf12Ptr.asFunction<double Function(double)>();

  double SDL_asin12(
    double x,
  ) {
    return _SDL_asin12(
      x,
    );
  }

  late final _SDL_asin12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin12 = _SDL_asin12Ptr.asFunction<double Function(double)>();

  double SDL_asinf12(
    double x,
  ) {
    return _SDL_asinf12(
      x,
    );
  }

  late final _SDL_asinf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf12 =
      _SDL_asinf12Ptr.asFunction<double Function(double)>();

  double SDL_atan13(
    double x,
  ) {
    return _SDL_atan13(
      x,
    );
  }

  late final _SDL_atan13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan13 = _SDL_atan13Ptr.asFunction<double Function(double)>();

  double SDL_atanf12(
    double x,
  ) {
    return _SDL_atanf12(
      x,
    );
  }

  late final _SDL_atanf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf12 =
      _SDL_atanf12Ptr.asFunction<double Function(double)>();

  double SDL_atan212(
    double y,
    double x,
  ) {
    return _SDL_atan212(
      y,
      x,
    );
  }

  late final _SDL_atan212Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan212 =
      _SDL_atan212Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f12(
    double y,
    double x,
  ) {
    return _SDL_atan2f12(
      y,
      x,
    );
  }

  late final _SDL_atan2f12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f12 =
      _SDL_atan2f12Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil12(
    double x,
  ) {
    return _SDL_ceil12(
      x,
    );
  }

  late final _SDL_ceil12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil12 = _SDL_ceil12Ptr.asFunction<double Function(double)>();

  double SDL_ceilf12(
    double x,
  ) {
    return _SDL_ceilf12(
      x,
    );
  }

  late final _SDL_ceilf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf12 =
      _SDL_ceilf12Ptr.asFunction<double Function(double)>();

  double SDL_copysign12(
    double x,
    double y,
  ) {
    return _SDL_copysign12(
      x,
      y,
    );
  }

  late final _SDL_copysign12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign12 =
      _SDL_copysign12Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf12(
    double x,
    double y,
  ) {
    return _SDL_copysignf12(
      x,
      y,
    );
  }

  late final _SDL_copysignf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf12 =
      _SDL_copysignf12Ptr.asFunction<double Function(double, double)>();

  double SDL_cos12(
    double x,
  ) {
    return _SDL_cos12(
      x,
    );
  }

  late final _SDL_cos12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos12 = _SDL_cos12Ptr.asFunction<double Function(double)>();

  double SDL_cosf12(
    double x,
  ) {
    return _SDL_cosf12(
      x,
    );
  }

  late final _SDL_cosf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf12 = _SDL_cosf12Ptr.asFunction<double Function(double)>();

  double SDL_exp12(
    double x,
  ) {
    return _SDL_exp12(
      x,
    );
  }

  late final _SDL_exp12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp12 = _SDL_exp12Ptr.asFunction<double Function(double)>();

  double SDL_expf12(
    double x,
  ) {
    return _SDL_expf12(
      x,
    );
  }

  late final _SDL_expf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf12 = _SDL_expf12Ptr.asFunction<double Function(double)>();

  double SDL_fabs12(
    double x,
  ) {
    return _SDL_fabs12(
      x,
    );
  }

  late final _SDL_fabs12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs12 = _SDL_fabs12Ptr.asFunction<double Function(double)>();

  double SDL_fabsf12(
    double x,
  ) {
    return _SDL_fabsf12(
      x,
    );
  }

  late final _SDL_fabsf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf12 =
      _SDL_fabsf12Ptr.asFunction<double Function(double)>();

  double SDL_floor12(
    double x,
  ) {
    return _SDL_floor12(
      x,
    );
  }

  late final _SDL_floor12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor12 =
      _SDL_floor12Ptr.asFunction<double Function(double)>();

  double SDL_floorf12(
    double x,
  ) {
    return _SDL_floorf12(
      x,
    );
  }

  late final _SDL_floorf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf12 =
      _SDL_floorf12Ptr.asFunction<double Function(double)>();

  double SDL_trunc12(
    double x,
  ) {
    return _SDL_trunc12(
      x,
    );
  }

  late final _SDL_trunc12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc12 =
      _SDL_trunc12Ptr.asFunction<double Function(double)>();

  double SDL_truncf12(
    double x,
  ) {
    return _SDL_truncf12(
      x,
    );
  }

  late final _SDL_truncf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf12 =
      _SDL_truncf12Ptr.asFunction<double Function(double)>();

  double SDL_fmod12(
    double x,
    double y,
  ) {
    return _SDL_fmod12(
      x,
      y,
    );
  }

  late final _SDL_fmod12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod12 =
      _SDL_fmod12Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf12(
    double x,
    double y,
  ) {
    return _SDL_fmodf12(
      x,
      y,
    );
  }

  late final _SDL_fmodf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf12 =
      _SDL_fmodf12Ptr.asFunction<double Function(double, double)>();

  double SDL_log13(
    double x,
  ) {
    return _SDL_log13(
      x,
    );
  }

  late final _SDL_log13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log13 = _SDL_log13Ptr.asFunction<double Function(double)>();

  double SDL_logf12(
    double x,
  ) {
    return _SDL_logf12(
      x,
    );
  }

  late final _SDL_logf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf12 = _SDL_logf12Ptr.asFunction<double Function(double)>();

  double SDL_log1012(
    double x,
  ) {
    return _SDL_log1012(
      x,
    );
  }

  late final _SDL_log1012Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1012 =
      _SDL_log1012Ptr.asFunction<double Function(double)>();

  double SDL_log10f12(
    double x,
  ) {
    return _SDL_log10f12(
      x,
    );
  }

  late final _SDL_log10f12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f12 =
      _SDL_log10f12Ptr.asFunction<double Function(double)>();

  double SDL_pow12(
    double x,
    double y,
  ) {
    return _SDL_pow12(
      x,
      y,
    );
  }

  late final _SDL_pow12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow12 =
      _SDL_pow12Ptr.asFunction<double Function(double, double)>();

  double SDL_powf12(
    double x,
    double y,
  ) {
    return _SDL_powf12(
      x,
      y,
    );
  }

  late final _SDL_powf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf12 =
      _SDL_powf12Ptr.asFunction<double Function(double, double)>();

  double SDL_round12(
    double x,
  ) {
    return _SDL_round12(
      x,
    );
  }

  late final _SDL_round12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round12 =
      _SDL_round12Ptr.asFunction<double Function(double)>();

  double SDL_roundf12(
    double x,
  ) {
    return _SDL_roundf12(
      x,
    );
  }

  late final _SDL_roundf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf12 =
      _SDL_roundf12Ptr.asFunction<double Function(double)>();

  int SDL_lround12(
    double x,
  ) {
    return _SDL_lround12(
      x,
    );
  }

  late final _SDL_lround12Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround12 =
      _SDL_lround12Ptr.asFunction<int Function(double)>();

  int SDL_lroundf12(
    double x,
  ) {
    return _SDL_lroundf12(
      x,
    );
  }

  late final _SDL_lroundf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf12 =
      _SDL_lroundf12Ptr.asFunction<int Function(double)>();

  double SDL_scalbn12(
    double x,
    int n,
  ) {
    return _SDL_scalbn12(
      x,
      n,
    );
  }

  late final _SDL_scalbn12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn12 =
      _SDL_scalbn12Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf12(
    double x,
    int n,
  ) {
    return _SDL_scalbnf12(
      x,
      n,
    );
  }

  late final _SDL_scalbnf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf12 =
      _SDL_scalbnf12Ptr.asFunction<double Function(double, int)>();

  double SDL_sin12(
    double x,
  ) {
    return _SDL_sin12(
      x,
    );
  }

  late final _SDL_sin12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin12 = _SDL_sin12Ptr.asFunction<double Function(double)>();

  double SDL_sinf12(
    double x,
  ) {
    return _SDL_sinf12(
      x,
    );
  }

  late final _SDL_sinf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf12 = _SDL_sinf12Ptr.asFunction<double Function(double)>();

  double SDL_sqrt12(
    double x,
  ) {
    return _SDL_sqrt12(
      x,
    );
  }

  late final _SDL_sqrt12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt12 = _SDL_sqrt12Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf12(
    double x,
  ) {
    return _SDL_sqrtf12(
      x,
    );
  }

  late final _SDL_sqrtf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf12 =
      _SDL_sqrtf12Ptr.asFunction<double Function(double)>();

  double SDL_tan12(
    double x,
  ) {
    return _SDL_tan12(
      x,
    );
  }

  late final _SDL_tan12Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan12 = _SDL_tan12Ptr.asFunction<double Function(double)>();

  double SDL_tanf12(
    double x,
  ) {
    return _SDL_tanf12(
      x,
    );
  }

  late final _SDL_tanf12Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf12 = _SDL_tanf12Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open12(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open12(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open12Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open12 = _SDL_iconv_open12Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close12(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close12(
      cd,
    );
  }

  late final _SDL_iconv_close12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close12 =
      _SDL_iconv_close12Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv12(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv12(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv12 = _SDL_iconv12Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string12(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string12(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string12 = _SDL_iconv_string12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError6(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError6(
      fmt,
    );
  }

  late final _SDL_SetError6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError6 =
      _SDL_SetError6Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError6() {
    return _SDL_GetError6();
  }

  late final _SDL_GetError6Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError6 =
      _SDL_GetError6Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg6(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg6(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg6 = _SDL_GetErrorMsg6Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError6() {
    return _SDL_ClearError6();
  }

  late final _SDL_ClearError6Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError6 =
      _SDL_ClearError6Ptr.asFunction<void Function()>();

  int SDL_Error6(
    int code,
  ) {
    return _SDL_Error6(
      code,
    );
  }

  late final _SDL_Error6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error6 = _SDL_Error6Ptr.asFunction<int Function(int)>();

  /// Locking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_LockJoysticks3() {
    return _SDL_LockJoysticks3();
  }

  late final _SDL_LockJoysticks3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockJoysticks');
  late final _SDL_LockJoysticks3 =
      _SDL_LockJoysticks3Ptr.asFunction<void Function()>();

  /// Unlocking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_UnlockJoysticks3() {
    return _SDL_UnlockJoysticks3();
  }

  late final _SDL_UnlockJoysticks3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockJoysticks');
  late final _SDL_UnlockJoysticks3 =
      _SDL_UnlockJoysticks3Ptr.asFunction<void Function()>();

  /// Count the number of joysticks attached to the system.
  ///
  /// \returns the number of attached joysticks on success or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  int SDL_NumJoysticks3() {
    return _SDL_NumJoysticks3();
  }

  late final _SDL_NumJoysticks3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumJoysticks');
  late final _SDL_NumJoysticks3 =
      _SDL_NumJoysticks3Ptr.asFunction<int Function()>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system)
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickName
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickNameForIndex3(
    int device_index,
  ) {
    return _SDL_JoystickNameForIndex3(
      device_index,
    );
  }

  late final _SDL_JoystickNameForIndex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_JoystickNameForIndex');
  late final _SDL_JoystickNameForIndex3 = _SDL_JoystickNameForIndex3Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the player index of a joystick, or -1 if it's not available This can be
  /// called before any joysticks are opened.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetDevicePlayerIndex3(
    int device_index,
  ) {
    return _SDL_JoystickGetDevicePlayerIndex3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDevicePlayerIndex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickGetDevicePlayerIndex');
  late final _SDL_JoystickGetDevicePlayerIndex3 =
      _SDL_JoystickGetDevicePlayerIndex3Ptr.asFunction<int Function(int)>();

  /// Get the implementation-dependent GUID for the joystick at a given device
  /// index.
  ///
  /// This function can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the GUID of the selected joystick. If called on an invalid index,
  /// this function returns a zero GUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetDeviceGUID3(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceGUID3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceGUID3Ptr =
      _lookup<ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceGUID');
  late final _SDL_JoystickGetDeviceGUID3 = _SDL_JoystickGetDeviceGUID3Ptr
      .asFunction<SDL_JoystickGUID Function(int)>();

  /// Get the USB vendor ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the vendor ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB vendor ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceVendor3(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceVendor3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceVendor3Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceVendor');
  late final _SDL_JoystickGetDeviceVendor3 =
      _SDL_JoystickGetDeviceVendor3Ptr.asFunction<int Function(int)>();

  /// Get the USB product ID of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product ID isn't
  /// available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the USB product ID of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProduct3(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProduct3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProduct3Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProduct');
  late final _SDL_JoystickGetDeviceProduct3 =
      _SDL_JoystickGetDeviceProduct3Ptr.asFunction<int Function(int)>();

  /// Get the product version of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened. If the product version
  /// isn't available this function returns 0.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the product version of the selected joystick. If called on an
  /// invalid index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceProductVersion3(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProductVersion3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductVersion3Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceProductVersion');
  late final _SDL_JoystickGetDeviceProductVersion3 =
      _SDL_JoystickGetDeviceProductVersion3Ptr.asFunction<int Function(int)>();

  /// Get the type of a joystick, if available.
  ///
  /// This can be called before any joysticks are opened.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the SDL_JoystickType of the selected joystick. If called on an
  /// invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceType3(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceType3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceType3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceType');
  late final _SDL_JoystickGetDeviceType3 =
      _SDL_JoystickGetDeviceType3Ptr.asFunction<int Function(int)>();

  /// Get the instance ID of a joystick.
  ///
  /// This can be called before any joysticks are opened. If the index is out of
  /// range, this function will return -1.
  ///
  /// \param device_index the index of the joystick to query (the N'th joystick
  /// on the system
  /// \returns the instance id of the selected joystick. If called on an invalid
  /// index, this function returns zero
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetDeviceInstanceID3(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceInstanceID3(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceInstanceID3Ptr =
      _lookup<ffi.NativeFunction<SDL_JoystickID Function(ffi.Int)>>(
          'SDL_JoystickGetDeviceInstanceID');
  late final _SDL_JoystickGetDeviceInstanceID3 =
      _SDL_JoystickGetDeviceInstanceID3Ptr.asFunction<int Function(int)>();

  /// Open a joystick for use.
  ///
  /// The `device_index` argument refers to the N'th joystick presently
  /// recognized by SDL on the system. It is **NOT** the same as the instance ID
  /// used to identify the joystick in future events. See
  /// SDL_JoystickInstanceID() for more details about instance IDs.
  ///
  /// The joystick subsystem must be initialized before a joystick can be opened
  /// for use.
  ///
  /// \param device_index the index of the joystick to query
  /// \returns a joystick identifier or NULL if an error occurred; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickInstanceID
  ffi.Pointer<SDL_Joystick> SDL_JoystickOpen3(
    int device_index,
  ) {
    return _SDL_JoystickOpen3(
      device_index,
    );
  }

  late final _SDL_JoystickOpen3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickOpen');
  late final _SDL_JoystickOpen3 = _SDL_JoystickOpen3Ptr.asFunction<
      ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with an instance id.
  ///
  /// \param instance_id the instance id to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromInstanceID3(
    int instance_id,
  ) {
    return _SDL_JoystickFromInstanceID3(
      instance_id,
    );
  }

  late final _SDL_JoystickFromInstanceID3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Joystick> Function(
              SDL_JoystickID)>>('SDL_JoystickFromInstanceID');
  late final _SDL_JoystickFromInstanceID3 = _SDL_JoystickFromInstanceID3Ptr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Get the SDL_Joystick associated with a player index.
  ///
  /// \param player_index the player index to get the SDL_Joystick for
  /// \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.12.
  ffi.Pointer<SDL_Joystick> SDL_JoystickFromPlayerIndex3(
    int player_index,
  ) {
    return _SDL_JoystickFromPlayerIndex3(
      player_index,
    );
  }

  late final _SDL_JoystickFromPlayerIndex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Joystick> Function(ffi.Int)>>(
          'SDL_JoystickFromPlayerIndex');
  late final _SDL_JoystickFromPlayerIndex3 = _SDL_JoystickFromPlayerIndex3Ptr
      .asFunction<ffi.Pointer<SDL_Joystick> Function(int)>();

  /// Attach a new virtual joystick.
  ///
  /// \returns the joystick's device index, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickAttachVirtual3(
    int type,
    int naxes,
    int nbuttons,
    int nhats,
  ) {
    return _SDL_JoystickAttachVirtual3(
      type,
      naxes,
      nbuttons,
      nhats,
    );
  }

  late final _SDL_JoystickAttachVirtual3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int32, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_JoystickAttachVirtual');
  late final _SDL_JoystickAttachVirtual3 = _SDL_JoystickAttachVirtual3Ptr
      .asFunction<int Function(int, int, int, int)>();

  /// Detach a virtual joystick.
  ///
  /// \param device_index a value previously returned from
  /// SDL_JoystickAttachVirtual()
  /// \returns 0 on success, or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickDetachVirtual3(
    int device_index,
  ) {
    return _SDL_JoystickDetachVirtual3(
      device_index,
    );
  }

  late final _SDL_JoystickDetachVirtual3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickDetachVirtual');
  late final _SDL_JoystickDetachVirtual3 =
      _SDL_JoystickDetachVirtual3Ptr.asFunction<int Function(int)>();

  /// Query whether or not the joystick at a given device index is virtual.
  ///
  /// \param device_index a joystick device index.
  /// \returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickIsVirtual3(
    int device_index,
  ) {
    return _SDL_JoystickIsVirtual3(
      device_index,
    );
  }

  late final _SDL_JoystickIsVirtual3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_JoystickIsVirtual');
  late final _SDL_JoystickIsVirtual3 =
      _SDL_JoystickIsVirtual3Ptr.asFunction<int Function(int)>();

  /// Set values on an opened, virtual-joystick's axis.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param axis the specific axis on the virtual joystick to set.
  /// \param value the new value for the specified axis.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualAxis3(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    int value,
  ) {
    return _SDL_JoystickSetVirtualAxis3(
      joystick,
      axis,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualAxis3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Sint16)>>('SDL_JoystickSetVirtualAxis');
  late final _SDL_JoystickSetVirtualAxis3 = _SDL_JoystickSetVirtualAxis3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's button.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param button the specific button on the virtual joystick to set.
  /// \param value the new value for the specified button.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualButton3(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
    int value,
  ) {
    return _SDL_JoystickSetVirtualButton3(
      joystick,
      button,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualButton3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualButton');
  late final _SDL_JoystickSetVirtualButton3 = _SDL_JoystickSetVirtualButton3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Set values on an opened, virtual-joystick's hat.
  ///
  /// Please note that values set here will not be applied until the next call to
  /// SDL_JoystickUpdate, which can either be called directly, or can be called
  /// indirectly through various other SDL APIs, including, but not limited to
  /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
  /// SDL_WaitEvent.
  ///
  /// \param joystick the virtual joystick on which to set state.
  /// \param hat the specific hat on the virtual joystick to set.
  /// \param value the new value for the specified hat.
  /// \returns 0 on success, -1 on error.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetVirtualHat3(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
    int value,
  ) {
    return _SDL_JoystickSetVirtualHat3(
      joystick,
      hat,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualHat3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              Uint8)>>('SDL_JoystickSetVirtualHat');
  late final _SDL_JoystickSetVirtualHat3 = _SDL_JoystickSetVirtualHat3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int)>();

  /// Get the implementation dependent name of a joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the name of the selected joystick. If no name can be found, this
  /// function returns NULL; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNameForIndex
  /// \sa SDL_JoystickOpen
  ffi.Pointer<ffi.Char> SDL_JoystickName3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickName3(
      joystick,
    );
  }

  late final _SDL_JoystickName3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickName');
  late final _SDL_JoystickName3 = _SDL_JoystickName3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the player index of an opened joystick.
  ///
  /// For XInput controllers this returns the XInput user index. Many joysticks
  /// will not be able to supply this information.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the player index, or -1 if it's not available.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_JoystickGetPlayerIndex3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetPlayerIndex3(
      joystick,
    );
  }

  late final _SDL_JoystickGetPlayerIndex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetPlayerIndex');
  late final _SDL_JoystickGetPlayerIndex3 = _SDL_JoystickGetPlayerIndex3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Set the player index of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \param player_index the player index to set.
  ///
  /// \since This function is available since SDL 2.0.12.
  void SDL_JoystickSetPlayerIndex3(
    ffi.Pointer<SDL_Joystick> joystick,
    int player_index,
  ) {
    return _SDL_JoystickSetPlayerIndex3(
      joystick,
      player_index,
    );
  }

  late final _SDL_JoystickSetPlayerIndex3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Joystick>,
              ffi.Int)>>('SDL_JoystickSetPlayerIndex');
  late final _SDL_JoystickSetPlayerIndex3 = _SDL_JoystickSetPlayerIndex3Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the implementation-dependent GUID for the joystick.
  ///
  /// This function requires an open joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the GUID of the given joystick. If called on an invalid index,
  /// this function returns a zero GUID; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUID3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetGUID3(
      joystick,
    );
  }

  late final _SDL_JoystickGetGUID3Ptr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickGUID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetGUID');
  late final _SDL_JoystickGetGUID3 = _SDL_JoystickGetGUID3Ptr.asFunction<
      SDL_JoystickGUID Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB vendor ID of an opened joystick, if available.
  ///
  /// If the vendor ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB vendor ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetVendor3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetVendor3(
      joystick,
    );
  }

  late final _SDL_JoystickGetVendor3Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetVendor');
  late final _SDL_JoystickGetVendor3 = _SDL_JoystickGetVendor3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the USB product ID of an opened joystick, if available.
  ///
  /// If the product ID isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the USB product ID of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProduct3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProduct3(
      joystick,
    );
  }

  late final _SDL_JoystickGetProduct3Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProduct');
  late final _SDL_JoystickGetProduct3 = _SDL_JoystickGetProduct3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the product version of an opened joystick, if available.
  ///
  /// If the product version isn't available this function returns 0.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the product version of the selected joystick, or 0 if unavailable.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetProductVersion3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProductVersion3(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductVersion3Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickGetProductVersion');
  late final _SDL_JoystickGetProductVersion3 =
      _SDL_JoystickGetProductVersion3Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the serial number of an opened joystick, if available.
  ///
  /// Returns the serial number of the joystick, or NULL if it is not available.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the serial number of the selected joystick, or NULL if
  /// unavailable.
  ///
  /// \since This function is available since SDL 2.0.14.
  ffi.Pointer<ffi.Char> SDL_JoystickGetSerial3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetSerial3(
      joystick,
    );
  }

  late final _SDL_JoystickGetSerial3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickGetSerial');
  late final _SDL_JoystickGetSerial3 = _SDL_JoystickGetSerial3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the type of an opened joystick.
  ///
  /// \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
  /// \returns the SDL_JoystickType of the selected joystick.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetType3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetType3(
      joystick,
    );
  }

  late final _SDL_JoystickGetType3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetType');
  late final _SDL_JoystickGetType3 = _SDL_JoystickGetType3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get an ASCII string representation for a given SDL_JoystickGUID.
  ///
  /// You should supply at least 33 bytes for pszGUID.
  ///
  /// \param guid the SDL_JoystickGUID you wish to convert to string
  /// \param pszGUID buffer in which to write the ASCII string
  /// \param cbGUID the size of pszGUID
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetDeviceGUID
  /// \sa SDL_JoystickGetGUID
  /// \sa SDL_JoystickGetGUIDFromString
  void SDL_JoystickGetGUIDString3(
    SDL_JoystickGUID guid,
    ffi.Pointer<ffi.Char> pszGUID,
    int cbGUID,
  ) {
    return _SDL_JoystickGetGUIDString3(
      guid,
      pszGUID,
      cbGUID,
    );
  }

  late final _SDL_JoystickGetGUIDString3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_JoystickGetGUIDString');
  late final _SDL_JoystickGetGUIDString3 =
      _SDL_JoystickGetGUIDString3Ptr.asFunction<
          void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Char>, int)>();

  /// Convert a GUID string into a SDL_JoystickGUID structure.
  ///
  /// Performs no error checking. If this function is given a string containing
  /// an invalid GUID, the function will silently succeed, but the GUID generated
  /// will not be useful.
  ///
  /// \param pchGUID string containing an ASCII representation of a GUID
  /// \returns a SDL_JoystickGUID structure.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetGUIDString
  SDL_JoystickGUID SDL_JoystickGetGUIDFromString3(
    ffi.Pointer<ffi.Char> pchGUID,
  ) {
    return _SDL_JoystickGetGUIDFromString3(
      pchGUID,
    );
  }

  late final _SDL_JoystickGetGUIDFromString3Ptr = _lookup<
          ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>>(
      'SDL_JoystickGetGUIDFromString');
  late final _SDL_JoystickGetGUIDFromString3 =
      _SDL_JoystickGetGUIDFromString3Ptr.asFunction<
          SDL_JoystickGUID Function(ffi.Pointer<ffi.Char>)>();

  /// Get the status of a specified joystick.
  ///
  /// \param joystick the joystick to query
  /// \returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickClose
  /// \sa SDL_JoystickOpen
  int SDL_JoystickGetAttached3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetAttached3(
      joystick,
    );
  }

  late final _SDL_JoystickGetAttached3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickGetAttached');
  late final _SDL_JoystickGetAttached3 = _SDL_JoystickGetAttached3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the instance ID of an opened joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the instance ID of the specified joystick on success or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  int SDL_JoystickInstanceID3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickInstanceID3(
      joystick,
    );
  }

  late final _SDL_JoystickInstanceID3Ptr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickID Function(
              ffi.Pointer<SDL_Joystick>)>>('SDL_JoystickInstanceID');
  late final _SDL_JoystickInstanceID3 = _SDL_JoystickInstanceID3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of general axis controls on a joystick.
  ///
  /// Often, the directional pad on a game controller will either look like 4
  /// separate buttons or a POV hat, and not axes, but all of this is up to the
  /// device and platform.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of axis controls/number of axes on success or a
  /// negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetAxis
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumAxes3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumAxes3(
      joystick,
    );
  }

  late final _SDL_JoystickNumAxes3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumAxes');
  late final _SDL_JoystickNumAxes3 = _SDL_JoystickNumAxes3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of trackballs on a joystick.
  ///
  /// Joystick trackballs have only relative motion events associated with them
  /// and their state cannot be polled.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of trackballs on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetBall
  int SDL_JoystickNumBalls3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumBalls3(
      joystick,
    );
  }

  late final _SDL_JoystickNumBalls3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumBalls');
  late final _SDL_JoystickNumBalls3 = _SDL_JoystickNumBalls3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of POV hats on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of POV hats on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetHat
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumHats3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumHats3(
      joystick,
    );
  }

  late final _SDL_JoystickNumHats3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumHats');
  late final _SDL_JoystickNumHats3 = _SDL_JoystickNumHats3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the number of buttons on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \returns the number of buttons on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickGetButton
  /// \sa SDL_JoystickOpen
  int SDL_JoystickNumButtons3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumButtons3(
      joystick,
    );
  }

  late final _SDL_JoystickNumButtons3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickNumButtons');
  late final _SDL_JoystickNumButtons3 = _SDL_JoystickNumButtons3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update the current state of the open joysticks.
  ///
  /// This is called automatically by the event loop if any joystick events are
  /// enabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickEventState
  void SDL_JoystickUpdate3() {
    return _SDL_JoystickUpdate3();
  }

  late final _SDL_JoystickUpdate3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_JoystickUpdate');
  late final _SDL_JoystickUpdate3 =
      _SDL_JoystickUpdate3Ptr.asFunction<void Function()>();

  /// Enable/disable joystick event polling.
  ///
  /// If joystick events are disabled, you must call SDL_JoystickUpdate()
  /// yourself and manually check the state of the joystick when you want
  /// joystick information.
  ///
  /// It is recommended that you leave joystick event handling enabled.
  ///
  /// **WARNING**: Calling this function may delete all events currently in SDL's
  /// event queue.
  ///
  /// \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
  /// \returns 1 if enabled, 0 if disabled, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// If `state` is `SDL_QUERY` then the current state is returned,
  /// otherwise the new processing state is returned.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GameControllerEventState
  int SDL_JoystickEventState3(
    int state,
  ) {
    return _SDL_JoystickEventState3(
      state,
    );
  }

  late final _SDL_JoystickEventState3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_JoystickEventState');
  late final _SDL_JoystickEventState3 =
      _SDL_JoystickEventState3Ptr.asFunction<int Function(int)>();

  /// Get the current state of an axis control on a joystick.
  ///
  /// SDL makes no promises about what part of the joystick any given axis refers
  /// to. Your game should have some sort of configuration UI to let users
  /// specify what each axis should be bound to. Alternately, SDL's higher-level
  /// Game Controller API makes a great effort to apply order to this lower-level
  /// interface, so you know that a specific axis is the "left thumb stick," etc.
  ///
  /// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to
  /// 32767) representing the current position of the axis. It may be necessary
  /// to impose certain tolerances on these values to account for jitter.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \returns a 16-bit signed integer representing the current position of the
  /// axis or 0 on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumAxes
  int SDL_JoystickGetAxis3(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
  ) {
    return _SDL_JoystickGetAxis3(
      joystick,
      axis,
    );
  }

  late final _SDL_JoystickGetAxis3Ptr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetAxis');
  late final _SDL_JoystickGetAxis3 = _SDL_JoystickGetAxis3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the initial state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param axis the axis to query; the axis indices start at index 0
  /// \param state Upon return, the initial value is supplied here.
  /// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_JoystickGetAxisInitialState3(
    ffi.Pointer<SDL_Joystick> joystick,
    int axis,
    ffi.Pointer<Sint16> state,
  ) {
    return _SDL_JoystickGetAxisInitialState3(
      joystick,
      axis,
      state,
    );
  }

  late final _SDL_JoystickGetAxisInitialState3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick>, ffi.Int,
              ffi.Pointer<Sint16>)>>('SDL_JoystickGetAxisInitialState');
  late final _SDL_JoystickGetAxisInitialState3 =
      _SDL_JoystickGetAxisInitialState3Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<Sint16>)>();

  /// Get the current state of a POV hat on a joystick.
  ///
  /// The returned value will be one of the following positions:
  ///
  /// - `SDL_HAT_CENTERED`
  /// - `SDL_HAT_UP`
  /// - `SDL_HAT_RIGHT`
  /// - `SDL_HAT_DOWN`
  /// - `SDL_HAT_LEFT`
  /// - `SDL_HAT_RIGHTUP`
  /// - `SDL_HAT_RIGHTDOWN`
  /// - `SDL_HAT_LEFTUP`
  /// - `SDL_HAT_LEFTDOWN`
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param hat the hat index to get the state from; indices start at index 0
  /// \returns the current hat position.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumHats
  int SDL_JoystickGetHat3(
    ffi.Pointer<SDL_Joystick> joystick,
    int hat,
  ) {
    return _SDL_JoystickGetHat3(
      joystick,
      hat,
    );
  }

  late final _SDL_JoystickGetHat3Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetHat');
  late final _SDL_JoystickGetHat3 = _SDL_JoystickGetHat3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Get the ball axis change since the last poll.
  ///
  /// Trackballs can only return relative motion since the last call to
  /// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.
  ///
  /// Most joysticks do not have trackballs.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \param ball the ball index to query; ball indices start at index 0
  /// \param dx stores the difference in the x axis position since the last poll
  /// \param dy stores the difference in the y axis position since the last poll
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumBalls
  int SDL_JoystickGetBall3(
    ffi.Pointer<SDL_Joystick> joystick,
    int ball,
    ffi.Pointer<ffi.Int> dx,
    ffi.Pointer<ffi.Int> dy,
  ) {
    return _SDL_JoystickGetBall3(
      joystick,
      ball,
      dx,
      dy,
    );
  }

  late final _SDL_JoystickGetBall3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Joystick>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_JoystickGetBall');
  late final _SDL_JoystickGetBall3 = _SDL_JoystickGetBall3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the current state of a button on a joystick.
  ///
  /// \param joystick an SDL_Joystick structure containing joystick information
  /// \param button the button index to get the state from; indices start at
  /// index 0
  /// \returns 1 if the specified button is pressed, 0 otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickNumButtons
  int SDL_JoystickGetButton3(
    ffi.Pointer<SDL_Joystick> joystick,
    int button,
  ) {
    return _SDL_JoystickGetButton3(
      joystick,
      button,
    );
  }

  late final _SDL_JoystickGetButton3Ptr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick>, ffi.Int)>>('SDL_JoystickGetButton');
  late final _SDL_JoystickGetButton3 = _SDL_JoystickGetButton3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int)>();

  /// Start a rumble effect.
  ///
  /// Each call to this function cancels any previous rumble effect, and calling
  /// it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left)
  /// rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right)
  /// rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_JoystickHasRumble
  int SDL_JoystickRumble3(
    ffi.Pointer<SDL_Joystick> joystick,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumble3(
      joystick,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumble3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumble');
  late final _SDL_JoystickRumble3 = _SDL_JoystickRumble3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Start a rumble effect in the joystick's triggers
  ///
  /// Each call to this function cancels any previous trigger rumble effect, and
  /// calling it with 0 intensity stops any rumbling.
  ///
  /// Note that this function is for _trigger_ rumble; the first joystick to
  /// support this was the PlayStation 5's DualShock 5 controller. If you want
  /// the (more common) whole-controller rumble, use SDL_JoystickRumble()
  /// instead.
  ///
  /// \param joystick The joystick to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0
  /// to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  /// \returns 0, or -1 if trigger rumble isn't supported on this joystick
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_JoystickHasRumbleTriggers
  int SDL_JoystickRumbleTriggers3(
    ffi.Pointer<SDL_Joystick> joystick,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumbleTriggers3(
      joystick,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumbleTriggers3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumbleTriggers');
  late final _SDL_JoystickRumbleTriggers3 = _SDL_JoystickRumbleTriggers3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Query whether a joystick has an LED.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickHasLED3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasLED3(
      joystick,
    );
  }

  late final _SDL_JoystickHasLED3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasLED');
  late final _SDL_JoystickHasLED3 = _SDL_JoystickHasLED3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumble
  int SDL_JoystickHasRumble3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumble3(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumble3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumble');
  late final _SDL_JoystickHasRumble3 = _SDL_JoystickHasRumble3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Query whether a joystick has rumble support on triggers.
  ///
  /// \param joystick The joystick to query
  /// \return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_JoystickRumbleTriggers
  int SDL_JoystickHasRumbleTriggers3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasRumbleTriggers3(
      joystick,
    );
  }

  late final _SDL_JoystickHasRumbleTriggers3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickHasRumbleTriggers');
  late final _SDL_JoystickHasRumbleTriggers3 =
      _SDL_JoystickHasRumbleTriggers3Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Update a joystick's LED color.
  ///
  /// An example of a joystick LED is the light on the back of a PlayStation 4's
  /// DualShock 4 controller.
  ///
  /// \param joystick The joystick to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  /// \returns 0 on success, -1 if this joystick does not have a modifiable LED
  ///
  /// \since This function is available since SDL 2.0.14.
  int SDL_JoystickSetLED3(
    ffi.Pointer<SDL_Joystick> joystick,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_JoystickSetLED3(
      joystick,
      red,
      green,
      blue,
    );
  }

  late final _SDL_JoystickSetLED3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, Uint8, Uint8,
              Uint8)>>('SDL_JoystickSetLED');
  late final _SDL_JoystickSetLED3 = _SDL_JoystickSetLED3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, int, int, int)>();

  /// Send a joystick specific effect packet
  ///
  /// \param joystick The joystick to affect
  /// \param data The data to send to the joystick
  /// \param size The size of the data to send to the joystick
  /// \returns 0, or -1 if this joystick or driver doesn't support effect packets
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_JoystickSendEffect3(
    ffi.Pointer<SDL_Joystick> joystick,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _SDL_JoystickSendEffect3(
      joystick,
      data,
      size,
    );
  }

  late final _SDL_JoystickSendEffect3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_JoystickSendEffect');
  late final _SDL_JoystickSendEffect3 = _SDL_JoystickSendEffect3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick>, ffi.Pointer<ffi.Void>, int)>();

  /// Close a joystick previously opened with SDL_JoystickOpen().
  ///
  /// \param joystick The joystick device to close
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_JoystickOpen
  void SDL_JoystickClose3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickClose3(
      joystick,
    );
  }

  late final _SDL_JoystickClose3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Joystick>)>>(
          'SDL_JoystickClose');
  late final _SDL_JoystickClose3 = _SDL_JoystickClose3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the battery level of a joystick as SDL_JoystickPowerLevel.
  ///
  /// \param joystick the SDL_Joystick to query
  /// \returns the current battery level as SDL_JoystickPowerLevel on success or
  /// `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_JoystickCurrentPowerLevel3(
    ffi.Pointer<SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickCurrentPowerLevel3(
      joystick,
    );
  }

  late final _SDL_JoystickCurrentPowerLevel3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick>)>>(
      'SDL_JoystickCurrentPowerLevel');
  late final _SDL_JoystickCurrentPowerLevel3 =
      _SDL_JoystickCurrentPowerLevel3Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform14() {
    return _SDL_GetPlatform14();
  }

  late final _SDL_GetPlatform14Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform14 =
      _SDL_GetPlatform14Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc13(
    int size,
  ) {
    return _SDL_malloc13(
      size,
    );
  }

  late final _SDL_malloc13Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc13 =
      _SDL_malloc13Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc13(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc13(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc13 =
      _SDL_calloc13Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc13(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc13(
      mem,
      size,
    );
  }

  late final _SDL_realloc13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc13 = _SDL_realloc13Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free13(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free13(
      mem,
    );
  }

  late final _SDL_free13Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free13 =
      _SDL_free13Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions13(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions13(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions13 =
      _SDL_GetMemoryFunctions13Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions13(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions13(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions13 =
      _SDL_SetMemoryFunctions13Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations13() {
    return _SDL_GetNumAllocations13();
  }

  late final _SDL_GetNumAllocations13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations13 =
      _SDL_GetNumAllocations13Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv13(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv13(
      name,
    );
  }

  late final _SDL_getenv13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv13 = _SDL_getenv13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv13(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv13(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv13 = _SDL_setenv13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort13(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort13(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort13 = _SDL_qsort13Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs13(
    int x,
  ) {
    return _SDL_abs13(
      x,
    );
  }

  late final _SDL_abs13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs13 = _SDL_abs13Ptr.asFunction<int Function(int)>();

  int SDL_isalpha13(
    int x,
  ) {
    return _SDL_isalpha13(
      x,
    );
  }

  late final _SDL_isalpha13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha13 = _SDL_isalpha13Ptr.asFunction<int Function(int)>();

  int SDL_isalnum13(
    int x,
  ) {
    return _SDL_isalnum13(
      x,
    );
  }

  late final _SDL_isalnum13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum13 = _SDL_isalnum13Ptr.asFunction<int Function(int)>();

  int SDL_isblank13(
    int x,
  ) {
    return _SDL_isblank13(
      x,
    );
  }

  late final _SDL_isblank13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank13 = _SDL_isblank13Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl13(
    int x,
  ) {
    return _SDL_iscntrl13(
      x,
    );
  }

  late final _SDL_iscntrl13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl13 = _SDL_iscntrl13Ptr.asFunction<int Function(int)>();

  int SDL_isdigit13(
    int x,
  ) {
    return _SDL_isdigit13(
      x,
    );
  }

  late final _SDL_isdigit13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit13 = _SDL_isdigit13Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit13(
    int x,
  ) {
    return _SDL_isxdigit13(
      x,
    );
  }

  late final _SDL_isxdigit13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit13 =
      _SDL_isxdigit13Ptr.asFunction<int Function(int)>();

  int SDL_ispunct13(
    int x,
  ) {
    return _SDL_ispunct13(
      x,
    );
  }

  late final _SDL_ispunct13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct13 = _SDL_ispunct13Ptr.asFunction<int Function(int)>();

  int SDL_isspace13(
    int x,
  ) {
    return _SDL_isspace13(
      x,
    );
  }

  late final _SDL_isspace13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace13 = _SDL_isspace13Ptr.asFunction<int Function(int)>();

  int SDL_isupper13(
    int x,
  ) {
    return _SDL_isupper13(
      x,
    );
  }

  late final _SDL_isupper13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper13 = _SDL_isupper13Ptr.asFunction<int Function(int)>();

  int SDL_islower13(
    int x,
  ) {
    return _SDL_islower13(
      x,
    );
  }

  late final _SDL_islower13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower13 = _SDL_islower13Ptr.asFunction<int Function(int)>();

  int SDL_isprint13(
    int x,
  ) {
    return _SDL_isprint13(
      x,
    );
  }

  late final _SDL_isprint13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint13 = _SDL_isprint13Ptr.asFunction<int Function(int)>();

  int SDL_isgraph13(
    int x,
  ) {
    return _SDL_isgraph13(
      x,
    );
  }

  late final _SDL_isgraph13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph13 = _SDL_isgraph13Ptr.asFunction<int Function(int)>();

  int SDL_toupper13(
    int x,
  ) {
    return _SDL_toupper13(
      x,
    );
  }

  late final _SDL_toupper13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper13 = _SDL_toupper13Ptr.asFunction<int Function(int)>();

  int SDL_tolower13(
    int x,
  ) {
    return _SDL_tolower13(
      x,
    );
  }

  late final _SDL_tolower13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower13 = _SDL_tolower13Ptr.asFunction<int Function(int)>();

  int SDL_crc3213(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3213(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3213Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3213 = _SDL_crc3213Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset13(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset13(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset13 = _SDL_memset13Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy13(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy13(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy13 = _SDL_memcpy13Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove13(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove13(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove13 = _SDL_memmove13Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp13(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp13(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp13 = _SDL_memcmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen13(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen13(
      wstr,
    );
  }

  late final _SDL_wcslen13Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen13 =
      _SDL_wcslen13Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy13(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy13(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy13 = _SDL_wcslcpy13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat13(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat13(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat13 = _SDL_wcslcat13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup13(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup13(
      wstr,
    );
  }

  late final _SDL_wcsdup13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup13 = _SDL_wcsdup13Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr13(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr13(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr13 = _SDL_wcsstr13Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp13(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp13(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp13 = _SDL_wcscmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp13(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp13(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp13 = _SDL_wcsncmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp13(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp13(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp13 = _SDL_wcscasecmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp13(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp13(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp13 = _SDL_wcsncasecmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen13(
      str,
    );
  }

  late final _SDL_strlen13Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen13 =
      _SDL_strlen13Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy13(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy13(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy13 = _SDL_strlcpy13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy13(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy13(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy13 = _SDL_utf8strlcpy13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat13(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat13(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat13 = _SDL_strlcat13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup13(
      str,
    );
  }

  late final _SDL_strdup13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup13 = _SDL_strdup13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev13(
      str,
    );
  }

  late final _SDL_strrev13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev13 = _SDL_strrev13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr13(
      str,
    );
  }

  late final _SDL_strupr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr13 = _SDL_strupr13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr13(
      str,
    );
  }

  late final _SDL_strlwr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr13 = _SDL_strlwr13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr13(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr13(
      str,
      c,
    );
  }

  late final _SDL_strchr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr13 = _SDL_strchr13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr13(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr13(
      str,
      c,
    );
  }

  late final _SDL_strrchr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr13 = _SDL_strrchr13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr13(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr13(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr13 = _SDL_strstr13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr13(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr13(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr13 = _SDL_strtokr13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen13(
      str,
    );
  }

  late final _SDL_utf8strlen13Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen13 =
      _SDL_utf8strlen13Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa13(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa13(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa13 = _SDL_itoa13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa13(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa13(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa13 = _SDL_uitoa13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa13(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa13(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa13 = _SDL_ltoa13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa13(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa13(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa13 = _SDL_ultoa13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa13(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa13(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa13 = _SDL_lltoa13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa13(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa13(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa13 = _SDL_ulltoa13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi13(
      str,
    );
  }

  late final _SDL_atoi13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi13 =
      _SDL_atoi13Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof13(
      str,
    );
  }

  late final _SDL_atof13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof13 =
      _SDL_atof13Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol13(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol13(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol13 = _SDL_strtol13Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul13(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul13(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul13 = _SDL_strtoul13Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll13(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll13(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll13Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll13 = _SDL_strtoll13Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull13(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull13(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull13Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull13 = _SDL_strtoull13Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod13(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod13(
      str,
      endp,
    );
  }

  late final _SDL_strtod13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod13 = _SDL_strtod13Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp13(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp13(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp13 = _SDL_strcmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp13(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp13(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp13 = _SDL_strncmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp13(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp13(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp13 = _SDL_strcasecmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp13(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp13(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp13 = _SDL_strncasecmp13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf13(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf13(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf13 = _SDL_sscanf13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf13(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf13(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf13 = _SDL_vsscanf13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf13(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf13(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf13 = _SDL_snprintf13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf13(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf13(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf13 = _SDL_vsnprintf13Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf13(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf13(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf13 = _SDL_asprintf13Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf13(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf13(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf13 = _SDL_vasprintf13Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos13(
    double x,
  ) {
    return _SDL_acos13(
      x,
    );
  }

  late final _SDL_acos13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos13 = _SDL_acos13Ptr.asFunction<double Function(double)>();

  double SDL_acosf13(
    double x,
  ) {
    return _SDL_acosf13(
      x,
    );
  }

  late final _SDL_acosf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf13 =
      _SDL_acosf13Ptr.asFunction<double Function(double)>();

  double SDL_asin13(
    double x,
  ) {
    return _SDL_asin13(
      x,
    );
  }

  late final _SDL_asin13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin13 = _SDL_asin13Ptr.asFunction<double Function(double)>();

  double SDL_asinf13(
    double x,
  ) {
    return _SDL_asinf13(
      x,
    );
  }

  late final _SDL_asinf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf13 =
      _SDL_asinf13Ptr.asFunction<double Function(double)>();

  double SDL_atan14(
    double x,
  ) {
    return _SDL_atan14(
      x,
    );
  }

  late final _SDL_atan14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan14 = _SDL_atan14Ptr.asFunction<double Function(double)>();

  double SDL_atanf13(
    double x,
  ) {
    return _SDL_atanf13(
      x,
    );
  }

  late final _SDL_atanf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf13 =
      _SDL_atanf13Ptr.asFunction<double Function(double)>();

  double SDL_atan213(
    double y,
    double x,
  ) {
    return _SDL_atan213(
      y,
      x,
    );
  }

  late final _SDL_atan213Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan213 =
      _SDL_atan213Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f13(
    double y,
    double x,
  ) {
    return _SDL_atan2f13(
      y,
      x,
    );
  }

  late final _SDL_atan2f13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f13 =
      _SDL_atan2f13Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil13(
    double x,
  ) {
    return _SDL_ceil13(
      x,
    );
  }

  late final _SDL_ceil13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil13 = _SDL_ceil13Ptr.asFunction<double Function(double)>();

  double SDL_ceilf13(
    double x,
  ) {
    return _SDL_ceilf13(
      x,
    );
  }

  late final _SDL_ceilf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf13 =
      _SDL_ceilf13Ptr.asFunction<double Function(double)>();

  double SDL_copysign13(
    double x,
    double y,
  ) {
    return _SDL_copysign13(
      x,
      y,
    );
  }

  late final _SDL_copysign13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign13 =
      _SDL_copysign13Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf13(
    double x,
    double y,
  ) {
    return _SDL_copysignf13(
      x,
      y,
    );
  }

  late final _SDL_copysignf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf13 =
      _SDL_copysignf13Ptr.asFunction<double Function(double, double)>();

  double SDL_cos13(
    double x,
  ) {
    return _SDL_cos13(
      x,
    );
  }

  late final _SDL_cos13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos13 = _SDL_cos13Ptr.asFunction<double Function(double)>();

  double SDL_cosf13(
    double x,
  ) {
    return _SDL_cosf13(
      x,
    );
  }

  late final _SDL_cosf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf13 = _SDL_cosf13Ptr.asFunction<double Function(double)>();

  double SDL_exp13(
    double x,
  ) {
    return _SDL_exp13(
      x,
    );
  }

  late final _SDL_exp13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp13 = _SDL_exp13Ptr.asFunction<double Function(double)>();

  double SDL_expf13(
    double x,
  ) {
    return _SDL_expf13(
      x,
    );
  }

  late final _SDL_expf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf13 = _SDL_expf13Ptr.asFunction<double Function(double)>();

  double SDL_fabs13(
    double x,
  ) {
    return _SDL_fabs13(
      x,
    );
  }

  late final _SDL_fabs13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs13 = _SDL_fabs13Ptr.asFunction<double Function(double)>();

  double SDL_fabsf13(
    double x,
  ) {
    return _SDL_fabsf13(
      x,
    );
  }

  late final _SDL_fabsf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf13 =
      _SDL_fabsf13Ptr.asFunction<double Function(double)>();

  double SDL_floor13(
    double x,
  ) {
    return _SDL_floor13(
      x,
    );
  }

  late final _SDL_floor13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor13 =
      _SDL_floor13Ptr.asFunction<double Function(double)>();

  double SDL_floorf13(
    double x,
  ) {
    return _SDL_floorf13(
      x,
    );
  }

  late final _SDL_floorf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf13 =
      _SDL_floorf13Ptr.asFunction<double Function(double)>();

  double SDL_trunc13(
    double x,
  ) {
    return _SDL_trunc13(
      x,
    );
  }

  late final _SDL_trunc13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc13 =
      _SDL_trunc13Ptr.asFunction<double Function(double)>();

  double SDL_truncf13(
    double x,
  ) {
    return _SDL_truncf13(
      x,
    );
  }

  late final _SDL_truncf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf13 =
      _SDL_truncf13Ptr.asFunction<double Function(double)>();

  double SDL_fmod13(
    double x,
    double y,
  ) {
    return _SDL_fmod13(
      x,
      y,
    );
  }

  late final _SDL_fmod13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod13 =
      _SDL_fmod13Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf13(
    double x,
    double y,
  ) {
    return _SDL_fmodf13(
      x,
      y,
    );
  }

  late final _SDL_fmodf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf13 =
      _SDL_fmodf13Ptr.asFunction<double Function(double, double)>();

  double SDL_log14(
    double x,
  ) {
    return _SDL_log14(
      x,
    );
  }

  late final _SDL_log14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log14 = _SDL_log14Ptr.asFunction<double Function(double)>();

  double SDL_logf13(
    double x,
  ) {
    return _SDL_logf13(
      x,
    );
  }

  late final _SDL_logf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf13 = _SDL_logf13Ptr.asFunction<double Function(double)>();

  double SDL_log1013(
    double x,
  ) {
    return _SDL_log1013(
      x,
    );
  }

  late final _SDL_log1013Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1013 =
      _SDL_log1013Ptr.asFunction<double Function(double)>();

  double SDL_log10f13(
    double x,
  ) {
    return _SDL_log10f13(
      x,
    );
  }

  late final _SDL_log10f13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f13 =
      _SDL_log10f13Ptr.asFunction<double Function(double)>();

  double SDL_pow13(
    double x,
    double y,
  ) {
    return _SDL_pow13(
      x,
      y,
    );
  }

  late final _SDL_pow13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow13 =
      _SDL_pow13Ptr.asFunction<double Function(double, double)>();

  double SDL_powf13(
    double x,
    double y,
  ) {
    return _SDL_powf13(
      x,
      y,
    );
  }

  late final _SDL_powf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf13 =
      _SDL_powf13Ptr.asFunction<double Function(double, double)>();

  double SDL_round13(
    double x,
  ) {
    return _SDL_round13(
      x,
    );
  }

  late final _SDL_round13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round13 =
      _SDL_round13Ptr.asFunction<double Function(double)>();

  double SDL_roundf13(
    double x,
  ) {
    return _SDL_roundf13(
      x,
    );
  }

  late final _SDL_roundf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf13 =
      _SDL_roundf13Ptr.asFunction<double Function(double)>();

  int SDL_lround13(
    double x,
  ) {
    return _SDL_lround13(
      x,
    );
  }

  late final _SDL_lround13Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround13 =
      _SDL_lround13Ptr.asFunction<int Function(double)>();

  int SDL_lroundf13(
    double x,
  ) {
    return _SDL_lroundf13(
      x,
    );
  }

  late final _SDL_lroundf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf13 =
      _SDL_lroundf13Ptr.asFunction<int Function(double)>();

  double SDL_scalbn13(
    double x,
    int n,
  ) {
    return _SDL_scalbn13(
      x,
      n,
    );
  }

  late final _SDL_scalbn13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn13 =
      _SDL_scalbn13Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf13(
    double x,
    int n,
  ) {
    return _SDL_scalbnf13(
      x,
      n,
    );
  }

  late final _SDL_scalbnf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf13 =
      _SDL_scalbnf13Ptr.asFunction<double Function(double, int)>();

  double SDL_sin13(
    double x,
  ) {
    return _SDL_sin13(
      x,
    );
  }

  late final _SDL_sin13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin13 = _SDL_sin13Ptr.asFunction<double Function(double)>();

  double SDL_sinf13(
    double x,
  ) {
    return _SDL_sinf13(
      x,
    );
  }

  late final _SDL_sinf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf13 = _SDL_sinf13Ptr.asFunction<double Function(double)>();

  double SDL_sqrt13(
    double x,
  ) {
    return _SDL_sqrt13(
      x,
    );
  }

  late final _SDL_sqrt13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt13 = _SDL_sqrt13Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf13(
    double x,
  ) {
    return _SDL_sqrtf13(
      x,
    );
  }

  late final _SDL_sqrtf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf13 =
      _SDL_sqrtf13Ptr.asFunction<double Function(double)>();

  double SDL_tan13(
    double x,
  ) {
    return _SDL_tan13(
      x,
    );
  }

  late final _SDL_tan13Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan13 = _SDL_tan13Ptr.asFunction<double Function(double)>();

  double SDL_tanf13(
    double x,
  ) {
    return _SDL_tanf13(
      x,
    );
  }

  late final _SDL_tanf13Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf13 = _SDL_tanf13Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open13(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open13(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open13Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open13 = _SDL_iconv_open13Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close13(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close13(
      cd,
    );
  }

  late final _SDL_iconv_close13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close13 =
      _SDL_iconv_close13Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv13(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv13(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv13 = _SDL_iconv13Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string13(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string13(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string13 = _SDL_iconv_string13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError7(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError7(
      fmt,
    );
  }

  late final _SDL_SetError7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError7 =
      _SDL_SetError7Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError7() {
    return _SDL_GetError7();
  }

  late final _SDL_GetError7Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError7 =
      _SDL_GetError7Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg7(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg7(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg7 = _SDL_GetErrorMsg7Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError7() {
    return _SDL_ClearError7();
  }

  late final _SDL_ClearError7Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError7 =
      _SDL_ClearError7Ptr.asFunction<void Function()>();

  int SDL_Error7(
    int code,
  ) {
    return _SDL_Error7(
      code,
    );
  }

  late final _SDL_Error7Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error7 = _SDL_Error7Ptr.asFunction<int Function(int)>();

  /// Locking for multi-threaded access to the sensor API
  ///
  /// If you are using the sensor API or handling events from multiple threads
  /// you should use these locking functions to protect access to the sensors.
  ///
  /// In particular, you are guaranteed that the sensor list won't change, so the
  /// API functions that take a sensor index will be valid, and sensor events
  /// will not be delivered.
  ///
  /// \since This function is available since SDL 2.0.14.
  void SDL_LockSensors2() {
    return _SDL_LockSensors2();
  }

  late final _SDL_LockSensors2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockSensors');
  late final _SDL_LockSensors2 =
      _SDL_LockSensors2Ptr.asFunction<void Function()>();

  void SDL_UnlockSensors2() {
    return _SDL_UnlockSensors2();
  }

  late final _SDL_UnlockSensors2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockSensors');
  late final _SDL_UnlockSensors2 =
      _SDL_UnlockSensors2Ptr.asFunction<void Function()>();

  /// Count the number of sensors attached to the system right now.
  ///
  /// \returns the number of sensors detected.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_NumSensors2() {
    return _SDL_NumSensors2();
  }

  late final _SDL_NumSensors2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_NumSensors');
  late final _SDL_NumSensors2 =
      _SDL_NumSensors2Ptr.asFunction<int Function()>();

  /// Get the implementation dependent name of a sensor.
  ///
  /// \param device_index The sensor to obtain name from
  /// \returns the sensor name, or NULL if `device_index` is out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_SensorGetDeviceName2(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceName2(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceName2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_SensorGetDeviceName');
  late final _SDL_SensorGetDeviceName2 = _SDL_SensorGetDeviceName2Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the type of a sensor.
  ///
  /// \param device_index The sensor to get the type from
  /// \returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `device_index` is
  /// out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceType2(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceType2(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceType2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_SensorGetDeviceType');
  late final _SDL_SensorGetDeviceType2 =
      _SDL_SensorGetDeviceType2Ptr.asFunction<int Function(int)>();

  /// Get the platform dependent type of a sensor.
  ///
  /// \param device_index The sensor to check
  /// \returns the sensor platform dependent type, or -1 if `device_index` is out
  /// of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceNonPortableType2(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceNonPortableType2(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNonPortableType2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_SensorGetDeviceNonPortableType');
  late final _SDL_SensorGetDeviceNonPortableType2 =
      _SDL_SensorGetDeviceNonPortableType2Ptr.asFunction<int Function(int)>();

  /// Get the instance ID of a sensor.
  ///
  /// \param device_index The sensor to get instance id from
  /// \returns the sensor instance ID, or -1 if `device_index` is out of range.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetDeviceInstanceID2(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceInstanceID2(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceInstanceID2Ptr =
      _lookup<ffi.NativeFunction<SDL_SensorID Function(ffi.Int)>>(
          'SDL_SensorGetDeviceInstanceID');
  late final _SDL_SensorGetDeviceInstanceID2 =
      _SDL_SensorGetDeviceInstanceID2Ptr.asFunction<int Function(int)>();

  /// Open a sensor for use.
  ///
  /// \param device_index The sensor to open
  /// \returns an SDL_Sensor sensor object, or NULL if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<SDL_Sensor> SDL_SensorOpen2(
    int device_index,
  ) {
    return _SDL_SensorOpen2(
      device_index,
    );
  }

  late final _SDL_SensorOpen2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Sensor> Function(ffi.Int)>>(
          'SDL_SensorOpen');
  late final _SDL_SensorOpen2 =
      _SDL_SensorOpen2Ptr.asFunction<ffi.Pointer<SDL_Sensor> Function(int)>();

  /// Return the SDL_Sensor associated with an instance id.
  ///
  /// \param instance_id The sensor from instance id
  /// \returns an SDL_Sensor object.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<SDL_Sensor> SDL_SensorFromInstanceID2(
    int instance_id,
  ) {
    return _SDL_SensorFromInstanceID2(
      instance_id,
    );
  }

  late final _SDL_SensorFromInstanceID2Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_Sensor> Function(SDL_SensorID)>>(
      'SDL_SensorFromInstanceID');
  late final _SDL_SensorFromInstanceID2 = _SDL_SensorFromInstanceID2Ptr
      .asFunction<ffi.Pointer<SDL_Sensor> Function(int)>();

  /// Get the implementation dependent name of a sensor
  ///
  /// \param sensor The SDL_Sensor object
  /// \returns the sensor name, or NULL if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  ffi.Pointer<ffi.Char> SDL_SensorGetName2(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetName2(
      sensor,
    );
  }

  late final _SDL_SensorGetName2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Sensor>)>>('SDL_SensorGetName');
  late final _SDL_SensorGetName2 = _SDL_SensorGetName2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the type of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
  /// NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetType2(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetType2(
      sensor,
    );
  }

  late final _SDL_SensorGetType2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorGetType');
  late final _SDL_SensorGetType2 = _SDL_SensorGetType2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the platform dependent type of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the sensor platform dependent type, or -1 if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetNonPortableType2(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetNonPortableType2(
      sensor,
    );
  }

  late final _SDL_SensorGetNonPortableType2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorGetNonPortableType');
  late final _SDL_SensorGetNonPortableType2 = _SDL_SensorGetNonPortableType2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the instance ID of a sensor.
  ///
  /// \param sensor The SDL_Sensor object to inspect
  /// \returns the sensor instance ID, or -1 if `sensor` is NULL.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetInstanceID2(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetInstanceID2(
      sensor,
    );
  }

  late final _SDL_SensorGetInstanceID2Ptr = _lookup<
          ffi.NativeFunction<SDL_SensorID Function(ffi.Pointer<SDL_Sensor>)>>(
      'SDL_SensorGetInstanceID');
  late final _SDL_SensorGetInstanceID2 = _SDL_SensorGetInstanceID2Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Sensor>)>();

  /// Get the current state of an opened sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  ///
  /// \param sensor The SDL_Sensor object to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  /// \returns 0 or -1 if an error occurred.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_SensorGetData2(
    ffi.Pointer<SDL_Sensor> sensor,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_SensorGetData2(
      sensor,
      data,
      num_values,
    );
  }

  late final _SDL_SensorGetData2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Sensor>, ffi.Pointer<ffi.Float>,
              ffi.Int)>>('SDL_SensorGetData');
  late final _SDL_SensorGetData2 = _SDL_SensorGetData2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor>, ffi.Pointer<ffi.Float>, int)>();

  /// Close a sensor previously opened with SDL_SensorOpen().
  ///
  /// \param sensor The SDL_Sensor object to close
  ///
  /// \since This function is available since SDL 2.0.9.
  void SDL_SensorClose2(
    ffi.Pointer<SDL_Sensor> sensor,
  ) {
    return _SDL_SensorClose2(
      sensor,
    );
  }

  late final _SDL_SensorClose2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Sensor>)>>(
          'SDL_SensorClose');
  late final _SDL_SensorClose2 =
      _SDL_SensorClose2Ptr.asFunction<void Function(ffi.Pointer<SDL_Sensor>)>();

  /// Update the current state of the open sensors.
  ///
  /// This is called automatically by the event loop if sensor events are
  /// enabled.
  ///
  /// This needs to be called from the thread that initialized the sensor
  /// subsystem.
  ///
  /// \since This function is available since SDL 2.0.9.
  void SDL_SensorUpdate2() {
    return _SDL_SensorUpdate2();
  }

  late final _SDL_SensorUpdate2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_SensorUpdate');
  late final _SDL_SensorUpdate2 =
      _SDL_SensorUpdate2Ptr.asFunction<void Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform15() {
    return _SDL_GetPlatform15();
  }

  late final _SDL_GetPlatform15Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform15 =
      _SDL_GetPlatform15Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc14(
    int size,
  ) {
    return _SDL_malloc14(
      size,
    );
  }

  late final _SDL_malloc14Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc14 =
      _SDL_malloc14Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc14(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc14(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc14 =
      _SDL_calloc14Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc14(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc14(
      mem,
      size,
    );
  }

  late final _SDL_realloc14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc14 = _SDL_realloc14Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free14(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free14(
      mem,
    );
  }

  late final _SDL_free14Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free14 =
      _SDL_free14Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions14(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions14(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions14 =
      _SDL_GetMemoryFunctions14Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions14(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions14(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions14 =
      _SDL_SetMemoryFunctions14Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations14() {
    return _SDL_GetNumAllocations14();
  }

  late final _SDL_GetNumAllocations14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations14 =
      _SDL_GetNumAllocations14Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv14(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv14(
      name,
    );
  }

  late final _SDL_getenv14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv14 = _SDL_getenv14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv14(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv14(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv14 = _SDL_setenv14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort14(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort14(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort14 = _SDL_qsort14Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs14(
    int x,
  ) {
    return _SDL_abs14(
      x,
    );
  }

  late final _SDL_abs14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs14 = _SDL_abs14Ptr.asFunction<int Function(int)>();

  int SDL_isalpha14(
    int x,
  ) {
    return _SDL_isalpha14(
      x,
    );
  }

  late final _SDL_isalpha14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha14 = _SDL_isalpha14Ptr.asFunction<int Function(int)>();

  int SDL_isalnum14(
    int x,
  ) {
    return _SDL_isalnum14(
      x,
    );
  }

  late final _SDL_isalnum14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum14 = _SDL_isalnum14Ptr.asFunction<int Function(int)>();

  int SDL_isblank14(
    int x,
  ) {
    return _SDL_isblank14(
      x,
    );
  }

  late final _SDL_isblank14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank14 = _SDL_isblank14Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl14(
    int x,
  ) {
    return _SDL_iscntrl14(
      x,
    );
  }

  late final _SDL_iscntrl14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl14 = _SDL_iscntrl14Ptr.asFunction<int Function(int)>();

  int SDL_isdigit14(
    int x,
  ) {
    return _SDL_isdigit14(
      x,
    );
  }

  late final _SDL_isdigit14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit14 = _SDL_isdigit14Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit14(
    int x,
  ) {
    return _SDL_isxdigit14(
      x,
    );
  }

  late final _SDL_isxdigit14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit14 =
      _SDL_isxdigit14Ptr.asFunction<int Function(int)>();

  int SDL_ispunct14(
    int x,
  ) {
    return _SDL_ispunct14(
      x,
    );
  }

  late final _SDL_ispunct14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct14 = _SDL_ispunct14Ptr.asFunction<int Function(int)>();

  int SDL_isspace14(
    int x,
  ) {
    return _SDL_isspace14(
      x,
    );
  }

  late final _SDL_isspace14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace14 = _SDL_isspace14Ptr.asFunction<int Function(int)>();

  int SDL_isupper14(
    int x,
  ) {
    return _SDL_isupper14(
      x,
    );
  }

  late final _SDL_isupper14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper14 = _SDL_isupper14Ptr.asFunction<int Function(int)>();

  int SDL_islower14(
    int x,
  ) {
    return _SDL_islower14(
      x,
    );
  }

  late final _SDL_islower14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower14 = _SDL_islower14Ptr.asFunction<int Function(int)>();

  int SDL_isprint14(
    int x,
  ) {
    return _SDL_isprint14(
      x,
    );
  }

  late final _SDL_isprint14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint14 = _SDL_isprint14Ptr.asFunction<int Function(int)>();

  int SDL_isgraph14(
    int x,
  ) {
    return _SDL_isgraph14(
      x,
    );
  }

  late final _SDL_isgraph14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph14 = _SDL_isgraph14Ptr.asFunction<int Function(int)>();

  int SDL_toupper14(
    int x,
  ) {
    return _SDL_toupper14(
      x,
    );
  }

  late final _SDL_toupper14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper14 = _SDL_toupper14Ptr.asFunction<int Function(int)>();

  int SDL_tolower14(
    int x,
  ) {
    return _SDL_tolower14(
      x,
    );
  }

  late final _SDL_tolower14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower14 = _SDL_tolower14Ptr.asFunction<int Function(int)>();

  int SDL_crc3214(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3214(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3214Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3214 = _SDL_crc3214Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset14(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset14(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset14 = _SDL_memset14Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy14(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy14(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy14 = _SDL_memcpy14Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove14(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove14(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove14 = _SDL_memmove14Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp14(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp14(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp14 = _SDL_memcmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen14(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen14(
      wstr,
    );
  }

  late final _SDL_wcslen14Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen14 =
      _SDL_wcslen14Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy14(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy14(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy14 = _SDL_wcslcpy14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat14(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat14(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat14 = _SDL_wcslcat14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup14(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup14(
      wstr,
    );
  }

  late final _SDL_wcsdup14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup14 = _SDL_wcsdup14Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr14(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr14(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr14 = _SDL_wcsstr14Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp14(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp14(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp14 = _SDL_wcscmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp14(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp14(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp14 = _SDL_wcsncmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp14(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp14(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp14 = _SDL_wcscasecmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp14(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp14(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp14 = _SDL_wcsncasecmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen14(
      str,
    );
  }

  late final _SDL_strlen14Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen14 =
      _SDL_strlen14Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy14(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy14(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy14 = _SDL_strlcpy14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy14(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy14(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy14 = _SDL_utf8strlcpy14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat14(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat14(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat14 = _SDL_strlcat14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup14(
      str,
    );
  }

  late final _SDL_strdup14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup14 = _SDL_strdup14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev14(
      str,
    );
  }

  late final _SDL_strrev14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev14 = _SDL_strrev14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr14(
      str,
    );
  }

  late final _SDL_strupr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr14 = _SDL_strupr14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr14(
      str,
    );
  }

  late final _SDL_strlwr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr14 = _SDL_strlwr14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr14(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr14(
      str,
      c,
    );
  }

  late final _SDL_strchr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr14 = _SDL_strchr14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr14(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr14(
      str,
      c,
    );
  }

  late final _SDL_strrchr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr14 = _SDL_strrchr14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr14(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr14(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr14 = _SDL_strstr14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr14(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr14(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr14 = _SDL_strtokr14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen14(
      str,
    );
  }

  late final _SDL_utf8strlen14Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen14 =
      _SDL_utf8strlen14Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa14(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa14(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa14 = _SDL_itoa14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa14(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa14(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa14 = _SDL_uitoa14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa14(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa14(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa14 = _SDL_ltoa14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa14(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa14(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa14 = _SDL_ultoa14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa14(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa14(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa14 = _SDL_lltoa14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa14(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa14(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa14 = _SDL_ulltoa14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi14(
      str,
    );
  }

  late final _SDL_atoi14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi14 =
      _SDL_atoi14Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof14(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof14(
      str,
    );
  }

  late final _SDL_atof14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof14 =
      _SDL_atof14Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol14(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol14(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol14 = _SDL_strtol14Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul14(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul14(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul14 = _SDL_strtoul14Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll14(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll14(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll14Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll14 = _SDL_strtoll14Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull14(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull14(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull14Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull14 = _SDL_strtoull14Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod14(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod14(
      str,
      endp,
    );
  }

  late final _SDL_strtod14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod14 = _SDL_strtod14Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp14(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp14(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp14 = _SDL_strcmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp14(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp14(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp14 = _SDL_strncmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp14(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp14(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp14 = _SDL_strcasecmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp14(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp14(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp14 = _SDL_strncasecmp14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf14(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf14(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf14 = _SDL_sscanf14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf14(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf14(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf14 = _SDL_vsscanf14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf14(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf14(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf14 = _SDL_snprintf14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf14(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf14(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf14 = _SDL_vsnprintf14Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf14(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf14(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf14 = _SDL_asprintf14Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf14(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf14(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf14 = _SDL_vasprintf14Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos14(
    double x,
  ) {
    return _SDL_acos14(
      x,
    );
  }

  late final _SDL_acos14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos14 = _SDL_acos14Ptr.asFunction<double Function(double)>();

  double SDL_acosf14(
    double x,
  ) {
    return _SDL_acosf14(
      x,
    );
  }

  late final _SDL_acosf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf14 =
      _SDL_acosf14Ptr.asFunction<double Function(double)>();

  double SDL_asin14(
    double x,
  ) {
    return _SDL_asin14(
      x,
    );
  }

  late final _SDL_asin14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin14 = _SDL_asin14Ptr.asFunction<double Function(double)>();

  double SDL_asinf14(
    double x,
  ) {
    return _SDL_asinf14(
      x,
    );
  }

  late final _SDL_asinf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf14 =
      _SDL_asinf14Ptr.asFunction<double Function(double)>();

  double SDL_atan15(
    double x,
  ) {
    return _SDL_atan15(
      x,
    );
  }

  late final _SDL_atan15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan15 = _SDL_atan15Ptr.asFunction<double Function(double)>();

  double SDL_atanf14(
    double x,
  ) {
    return _SDL_atanf14(
      x,
    );
  }

  late final _SDL_atanf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf14 =
      _SDL_atanf14Ptr.asFunction<double Function(double)>();

  double SDL_atan214(
    double y,
    double x,
  ) {
    return _SDL_atan214(
      y,
      x,
    );
  }

  late final _SDL_atan214Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan214 =
      _SDL_atan214Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f14(
    double y,
    double x,
  ) {
    return _SDL_atan2f14(
      y,
      x,
    );
  }

  late final _SDL_atan2f14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f14 =
      _SDL_atan2f14Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil14(
    double x,
  ) {
    return _SDL_ceil14(
      x,
    );
  }

  late final _SDL_ceil14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil14 = _SDL_ceil14Ptr.asFunction<double Function(double)>();

  double SDL_ceilf14(
    double x,
  ) {
    return _SDL_ceilf14(
      x,
    );
  }

  late final _SDL_ceilf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf14 =
      _SDL_ceilf14Ptr.asFunction<double Function(double)>();

  double SDL_copysign14(
    double x,
    double y,
  ) {
    return _SDL_copysign14(
      x,
      y,
    );
  }

  late final _SDL_copysign14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign14 =
      _SDL_copysign14Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf14(
    double x,
    double y,
  ) {
    return _SDL_copysignf14(
      x,
      y,
    );
  }

  late final _SDL_copysignf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf14 =
      _SDL_copysignf14Ptr.asFunction<double Function(double, double)>();

  double SDL_cos14(
    double x,
  ) {
    return _SDL_cos14(
      x,
    );
  }

  late final _SDL_cos14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos14 = _SDL_cos14Ptr.asFunction<double Function(double)>();

  double SDL_cosf14(
    double x,
  ) {
    return _SDL_cosf14(
      x,
    );
  }

  late final _SDL_cosf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf14 = _SDL_cosf14Ptr.asFunction<double Function(double)>();

  double SDL_exp14(
    double x,
  ) {
    return _SDL_exp14(
      x,
    );
  }

  late final _SDL_exp14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp14 = _SDL_exp14Ptr.asFunction<double Function(double)>();

  double SDL_expf14(
    double x,
  ) {
    return _SDL_expf14(
      x,
    );
  }

  late final _SDL_expf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf14 = _SDL_expf14Ptr.asFunction<double Function(double)>();

  double SDL_fabs14(
    double x,
  ) {
    return _SDL_fabs14(
      x,
    );
  }

  late final _SDL_fabs14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs14 = _SDL_fabs14Ptr.asFunction<double Function(double)>();

  double SDL_fabsf14(
    double x,
  ) {
    return _SDL_fabsf14(
      x,
    );
  }

  late final _SDL_fabsf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf14 =
      _SDL_fabsf14Ptr.asFunction<double Function(double)>();

  double SDL_floor14(
    double x,
  ) {
    return _SDL_floor14(
      x,
    );
  }

  late final _SDL_floor14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor14 =
      _SDL_floor14Ptr.asFunction<double Function(double)>();

  double SDL_floorf14(
    double x,
  ) {
    return _SDL_floorf14(
      x,
    );
  }

  late final _SDL_floorf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf14 =
      _SDL_floorf14Ptr.asFunction<double Function(double)>();

  double SDL_trunc14(
    double x,
  ) {
    return _SDL_trunc14(
      x,
    );
  }

  late final _SDL_trunc14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc14 =
      _SDL_trunc14Ptr.asFunction<double Function(double)>();

  double SDL_truncf14(
    double x,
  ) {
    return _SDL_truncf14(
      x,
    );
  }

  late final _SDL_truncf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf14 =
      _SDL_truncf14Ptr.asFunction<double Function(double)>();

  double SDL_fmod14(
    double x,
    double y,
  ) {
    return _SDL_fmod14(
      x,
      y,
    );
  }

  late final _SDL_fmod14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod14 =
      _SDL_fmod14Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf14(
    double x,
    double y,
  ) {
    return _SDL_fmodf14(
      x,
      y,
    );
  }

  late final _SDL_fmodf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf14 =
      _SDL_fmodf14Ptr.asFunction<double Function(double, double)>();

  double SDL_log15(
    double x,
  ) {
    return _SDL_log15(
      x,
    );
  }

  late final _SDL_log15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log15 = _SDL_log15Ptr.asFunction<double Function(double)>();

  double SDL_logf14(
    double x,
  ) {
    return _SDL_logf14(
      x,
    );
  }

  late final _SDL_logf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf14 = _SDL_logf14Ptr.asFunction<double Function(double)>();

  double SDL_log1014(
    double x,
  ) {
    return _SDL_log1014(
      x,
    );
  }

  late final _SDL_log1014Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1014 =
      _SDL_log1014Ptr.asFunction<double Function(double)>();

  double SDL_log10f14(
    double x,
  ) {
    return _SDL_log10f14(
      x,
    );
  }

  late final _SDL_log10f14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f14 =
      _SDL_log10f14Ptr.asFunction<double Function(double)>();

  double SDL_pow14(
    double x,
    double y,
  ) {
    return _SDL_pow14(
      x,
      y,
    );
  }

  late final _SDL_pow14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow14 =
      _SDL_pow14Ptr.asFunction<double Function(double, double)>();

  double SDL_powf14(
    double x,
    double y,
  ) {
    return _SDL_powf14(
      x,
      y,
    );
  }

  late final _SDL_powf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf14 =
      _SDL_powf14Ptr.asFunction<double Function(double, double)>();

  double SDL_round14(
    double x,
  ) {
    return _SDL_round14(
      x,
    );
  }

  late final _SDL_round14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round14 =
      _SDL_round14Ptr.asFunction<double Function(double)>();

  double SDL_roundf14(
    double x,
  ) {
    return _SDL_roundf14(
      x,
    );
  }

  late final _SDL_roundf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf14 =
      _SDL_roundf14Ptr.asFunction<double Function(double)>();

  int SDL_lround14(
    double x,
  ) {
    return _SDL_lround14(
      x,
    );
  }

  late final _SDL_lround14Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround14 =
      _SDL_lround14Ptr.asFunction<int Function(double)>();

  int SDL_lroundf14(
    double x,
  ) {
    return _SDL_lroundf14(
      x,
    );
  }

  late final _SDL_lroundf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf14 =
      _SDL_lroundf14Ptr.asFunction<int Function(double)>();

  double SDL_scalbn14(
    double x,
    int n,
  ) {
    return _SDL_scalbn14(
      x,
      n,
    );
  }

  late final _SDL_scalbn14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn14 =
      _SDL_scalbn14Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf14(
    double x,
    int n,
  ) {
    return _SDL_scalbnf14(
      x,
      n,
    );
  }

  late final _SDL_scalbnf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf14 =
      _SDL_scalbnf14Ptr.asFunction<double Function(double, int)>();

  double SDL_sin14(
    double x,
  ) {
    return _SDL_sin14(
      x,
    );
  }

  late final _SDL_sin14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin14 = _SDL_sin14Ptr.asFunction<double Function(double)>();

  double SDL_sinf14(
    double x,
  ) {
    return _SDL_sinf14(
      x,
    );
  }

  late final _SDL_sinf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf14 = _SDL_sinf14Ptr.asFunction<double Function(double)>();

  double SDL_sqrt14(
    double x,
  ) {
    return _SDL_sqrt14(
      x,
    );
  }

  late final _SDL_sqrt14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt14 = _SDL_sqrt14Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf14(
    double x,
  ) {
    return _SDL_sqrtf14(
      x,
    );
  }

  late final _SDL_sqrtf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf14 =
      _SDL_sqrtf14Ptr.asFunction<double Function(double)>();

  double SDL_tan14(
    double x,
  ) {
    return _SDL_tan14(
      x,
    );
  }

  late final _SDL_tan14Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan14 = _SDL_tan14Ptr.asFunction<double Function(double)>();

  double SDL_tanf14(
    double x,
  ) {
    return _SDL_tanf14(
      x,
    );
  }

  late final _SDL_tanf14Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf14 = _SDL_tanf14Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open14(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open14(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open14Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open14 = _SDL_iconv_open14Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close14(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close14(
      cd,
    );
  }

  late final _SDL_iconv_close14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close14 =
      _SDL_iconv_close14Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv14(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv14(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv14 = _SDL_iconv14Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string14(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string14(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string14 = _SDL_iconv_string14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError8(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError8(
      fmt,
    );
  }

  late final _SDL_SetError8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError8 =
      _SDL_SetError8Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError8() {
    return _SDL_GetError8();
  }

  late final _SDL_GetError8Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError8 =
      _SDL_GetError8Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg8(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg8(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg8 = _SDL_GetErrorMsg8Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError8() {
    return _SDL_ClearError8();
  }

  late final _SDL_ClearError8Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError8 =
      _SDL_ClearError8Ptr.asFunction<void Function()>();

  int SDL_Error8(
    int code,
  ) {
    return _SDL_Error8(
      code,
    );
  }

  late final _SDL_Error8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error8 = _SDL_Error8Ptr.asFunction<int Function(int)>();

  /// Create a new mutex.
  ///
  /// All newly-created mutexes begin in the _unlocked_ state.
  ///
  /// Calls to SDL_LockMutex() will not return while the mutex is locked by
  /// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
  ///
  /// SDL mutexes are reentrant.
  ///
  /// \returns the initialized and unlocked mutex or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  ffi.Pointer<SDL_mutex> SDL_CreateMutex1() {
    return _SDL_CreateMutex1();
  }

  late final _SDL_CreateMutex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_mutex> Function()>>(
          'SDL_CreateMutex');
  late final _SDL_CreateMutex1 =
      _SDL_CreateMutex1Ptr.asFunction<ffi.Pointer<SDL_mutex> Function()>();

  /// Lock the mutex.
  ///
  /// This will block until the mutex is available, which is to say it is in the
  /// unlocked state and the OS has chosen the caller as the next thread to lock
  /// it. Of all threads waiting to lock the mutex, only one may do so at a time.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// \param mutex the mutex to lock
  /// \return 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_LockMutex1(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_LockMutex1(
      mutex,
    );
  }

  late final _SDL_LockMutex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_LockMutex');
  late final _SDL_LockMutex1 =
      _SDL_LockMutex1Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Try to lock a mutex without blocking.
  ///
  /// This works just like SDL_LockMutex(), but if the mutex is not available,
  /// this function returns `SDL_MUTEX_TIMEOUT` immediately.
  ///
  /// This technique is useful if you need exclusive access to a resource but
  /// don't want to wait for it, and will return to it to try again later.
  ///
  /// \param mutex the mutex to try to lock
  /// \returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_UnlockMutex
  int SDL_TryLockMutex1(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_TryLockMutex1(
      mutex,
    );
  }

  late final _SDL_TryLockMutex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_TryLockMutex');
  late final _SDL_TryLockMutex1 =
      _SDL_TryLockMutex1Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Unlock the mutex.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// It is an error to unlock a mutex that has not been locked by the current
  /// thread, and doing so results in undefined behavior.
  ///
  /// It is also an error to unlock a mutex that isn't locked at all.
  ///
  /// \param mutex the mutex to unlock.
  /// \returns 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_UnlockMutex1(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_UnlockMutex1(
      mutex,
    );
  }

  late final _SDL_UnlockMutex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_UnlockMutex');
  late final _SDL_UnlockMutex1 =
      _SDL_UnlockMutex1Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Destroy a mutex created with SDL_CreateMutex().
  ///
  /// This function must be called on any mutex that is no longer needed. Failure
  /// to destroy a mutex will result in a system memory or resource leak. While
  /// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
  /// to destroy a locked mutex, and may result in undefined behavior depending
  /// on the platform.
  ///
  /// \param mutex the mutex to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  void SDL_DestroyMutex1(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_DestroyMutex1(
      mutex,
    );
  }

  late final _SDL_DestroyMutex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_DestroyMutex');
  late final _SDL_DestroyMutex1 =
      _SDL_DestroyMutex1Ptr.asFunction<void Function(ffi.Pointer<SDL_mutex>)>();

  /// Create a semaphore.
  ///
  /// This function creates a new semaphore and initializes it with the value
  /// `initial_value`. Each wait operation on the semaphore will atomically
  /// decrement the semaphore value and potentially block if the semaphore value
  /// is 0. Each post operation will atomically increment the semaphore value and
  /// wake waiting threads and allow them to retry the wait operation.
  ///
  /// \param initial_value the starting value of the semaphore
  /// \returns a new semaphore or NULL on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  ffi.Pointer<SDL_sem> SDL_CreateSemaphore1(
    int initial_value,
  ) {
    return _SDL_CreateSemaphore1(
      initial_value,
    );
  }

  late final _SDL_CreateSemaphore1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_sem> Function(Uint32)>>(
          'SDL_CreateSemaphore');
  late final _SDL_CreateSemaphore1 =
      _SDL_CreateSemaphore1Ptr.asFunction<ffi.Pointer<SDL_sem> Function(int)>();

  /// Destroy a semaphore.
  ///
  /// It is not safe to destroy a semaphore if there are threads currently
  /// waiting on it.
  ///
  /// \param sem the semaphore to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  void SDL_DestroySemaphore1(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_DestroySemaphore1(
      sem,
    );
  }

  late final _SDL_DestroySemaphore1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_DestroySemaphore');
  late final _SDL_DestroySemaphore1 = _SDL_DestroySemaphore1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value or the call is interrupted by a
  /// signal or error. If the call is successful it will atomically decrement the
  /// semaphore value.
  ///
  /// This function is the equivalent of calling SDL_SemWaitTimeout() with a time
  /// length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param sem the semaphore wait on
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemWait1(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemWait1(
      sem,
    );
  }

  late final _SDL_SemWait1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemWait');
  late final _SDL_SemWait1 =
      _SDL_SemWait1Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// See if a semaphore has a positive value and decrement it if it does.
  ///
  /// This function checks to see if the semaphore pointed to by `sem` has a
  /// positive value and atomically decrements the semaphore value if it does. If
  /// the semaphore doesn't have a positive value, the function immediately
  /// returns SDL_MUTEX_TIMEDOUT.
  ///
  /// \param sem the semaphore to wait on
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would
  /// block, or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemTryWait1(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemTryWait1(
      sem,
    );
  }

  late final _SDL_SemTryWait1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemTryWait');
  late final _SDL_SemTryWait1 =
      _SDL_SemTryWait1Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value, the call is interrupted by a
  /// signal or error, or the specified time has elapsed. If the call is
  /// successful it will atomically decrement the semaphore value.
  ///
  /// \param sem the semaphore to wait on
  /// \param ms the length of the timeout, in milliseconds
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not
  /// succeed in the allotted time, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  int SDL_SemWaitTimeout1(
    ffi.Pointer<SDL_sem> sem,
    int ms,
  ) {
    return _SDL_SemWaitTimeout1(
      sem,
      ms,
    );
  }

  late final _SDL_SemWaitTimeout1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>, Uint32)>>(
      'SDL_SemWaitTimeout');
  late final _SDL_SemWaitTimeout1 = _SDL_SemWaitTimeout1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_sem>, int)>();

  /// Atomically increment a semaphore's value and wake waiting threads.
  ///
  /// \param sem the semaphore to increment
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemPost1(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemPost1(
      sem,
    );
  }

  late final _SDL_SemPost1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemPost');
  late final _SDL_SemPost1 =
      _SDL_SemPost1Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Get the current value of a semaphore.
  ///
  /// \param sem the semaphore to query
  /// \returns the current value of the semaphore.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  int SDL_SemValue1(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemValue1(
      sem,
    );
  }

  late final _SDL_SemValue1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemValue');
  late final _SDL_SemValue1 =
      _SDL_SemValue1Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Create a condition variable.
  ///
  /// \returns a new condition variable or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_DestroyCond
  ffi.Pointer<SDL_cond> SDL_CreateCond1() {
    return _SDL_CreateCond1();
  }

  late final _SDL_CreateCond1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_cond> Function()>>(
          'SDL_CreateCond');
  late final _SDL_CreateCond1 =
      _SDL_CreateCond1Ptr.asFunction<ffi.Pointer<SDL_cond> Function()>();

  /// Destroy a condition variable.
  ///
  /// \param cond the condition variable to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  void SDL_DestroyCond1(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_DestroyCond1(
      cond,
    );
  }

  late final _SDL_DestroyCond1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_DestroyCond');
  late final _SDL_DestroyCond1 =
      _SDL_DestroyCond1Ptr.asFunction<void Function(ffi.Pointer<SDL_cond>)>();

  /// Restart one of the threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondSignal1(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondSignal1(
      cond,
    );
  }

  late final _SDL_CondSignal1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondSignal');
  late final _SDL_CondSignal1 =
      _SDL_CondSignal1Ptr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Restart all threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondBroadcast1(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondBroadcast1(
      cond,
    );
  }

  late final _SDL_CondBroadcast1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondBroadcast');
  late final _SDL_CondBroadcast1 =
      _SDL_CondBroadcast1Ptr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Wait until a condition variable is signaled.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`. Once the condition variable is signaled, the mutex is re-locked and
  /// the function returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// This function is the equivalent of calling SDL_CondWaitTimeout() with a
  /// time length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \returns 0 when it is signaled or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWait1(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_CondWait1(
      cond,
      mutex,
    );
  }

  late final _SDL_CondWait1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>>('SDL_CondWait');
  late final _SDL_CondWait1 = _SDL_CondWait1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>();

  /// Wait until a condition variable is signaled or a certain time has passed.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`, or for the specified time to elapse. Once the condition variable is
  /// signaled or the time elapsed, the mutex is re-locked and the function
  /// returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \param ms the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`
  /// to wait indefinitely
  /// \returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if
  /// the condition is not signaled in the allotted time, or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWaitTimeout1(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
    int ms,
  ) {
    return _SDL_CondWaitTimeout1(
      cond,
      mutex,
      ms,
    );
  }

  late final _SDL_CondWaitTimeout1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>,
              Uint32)>>('SDL_CondWaitTimeout');
  late final _SDL_CondWaitTimeout1 = _SDL_CondWaitTimeout1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>, int)>();

  /// Try to lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  /// \returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already
  /// held.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicUnlock
  int SDL_AtomicTryLock1(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicTryLock1(
      lock,
    );
  }

  late final _SDL_AtomicTryLock1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_SpinLock>)>>(
      'SDL_AtomicTryLock');
  late final _SDL_AtomicTryLock1 = _SDL_AtomicTryLock1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicTryLock
  /// \sa SDL_AtomicUnlock
  void SDL_AtomicLock1(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicLock1(
      lock,
    );
  }

  late final _SDL_AtomicLock1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicLock');
  late final _SDL_AtomicLock1 = _SDL_AtomicLock1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Unlock a spin lock by setting it to 0.
  ///
  /// Always returns immediately.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicTryLock
  void SDL_AtomicUnlock1(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicUnlock1(
      lock,
    );
  }

  late final _SDL_AtomicUnlock1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicUnlock');
  late final _SDL_AtomicUnlock1 = _SDL_AtomicUnlock1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Memory barriers are designed to prevent reads and writes from being
  /// reordered by the compiler and being seen out of order on multi-core CPUs.
  ///
  /// A typical pattern would be for thread A to write some data and a flag, and
  /// for thread B to read the flag and get the data. In this case you would
  /// insert a release barrier between writing the data and the flag,
  /// guaranteeing that the data write completes no later than the flag is
  /// written, and you would insert an acquire barrier between reading the flag
  /// and reading the data, to ensure that all the reads associated with the flag
  /// have completed.
  ///
  /// In this pattern you should always see a release barrier paired with an
  /// acquire barrier and you should gate the data reads/writes with a single
  /// flag variable.
  ///
  /// For more information on these semantics, take a look at the blog post:
  /// http://preshing.com/20120913/acquire-and-release-semantics
  ///
  /// \since This function is available since SDL 2.0.6.
  void SDL_MemoryBarrierReleaseFunction1() {
    return _SDL_MemoryBarrierReleaseFunction1();
  }

  late final _SDL_MemoryBarrierReleaseFunction1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierReleaseFunction');
  late final _SDL_MemoryBarrierReleaseFunction1 =
      _SDL_MemoryBarrierReleaseFunction1Ptr.asFunction<void Function()>();

  void SDL_MemoryBarrierAcquireFunction1() {
    return _SDL_MemoryBarrierAcquireFunction1();
  }

  late final _SDL_MemoryBarrierAcquireFunction1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierAcquireFunction');
  late final _SDL_MemoryBarrierAcquireFunction1 =
      _SDL_MemoryBarrierAcquireFunction1Ptr.asFunction<void Function()>();

  /// Set an atomic variable to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param oldval the old value
  /// \param newval the new value
  /// \returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGet
  /// \sa SDL_AtomicSet
  int SDL_AtomicCAS1(
    ffi.Pointer<SDL_atomic_t> a,
    int oldval,
    int newval,
  ) {
    return _SDL_AtomicCAS1(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCAS1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int, ffi.Int)>>('SDL_AtomicCAS');
  late final _SDL_AtomicCAS1 = _SDL_AtomicCAS1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int, int)>();

  /// Set an atomic variable to a value.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicGet
  int SDL_AtomicSet1(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicSet1(
      a,
      v,
    );
  }

  late final _SDL_AtomicSet1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicSet');
  late final _SDL_AtomicSet1 = _SDL_AtomicSet1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Get the value of an atomic variable.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable
  /// \returns the current value of an atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicSet
  int SDL_AtomicGet1(
    ffi.Pointer<SDL_atomic_t> a,
  ) {
    return _SDL_AtomicGet1(
      a,
    );
  }

  late final _SDL_AtomicGet1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_atomic_t>)>>(
          'SDL_AtomicGet');
  late final _SDL_AtomicGet1 =
      _SDL_AtomicGet1Ptr.asFunction<int Function(ffi.Pointer<SDL_atomic_t>)>();

  /// Add to an atomic variable.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value to add
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicDecRef
  /// \sa SDL_AtomicIncRef
  int SDL_AtomicAdd1(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicAdd1(
      a,
      v,
    );
  }

  late final _SDL_AtomicAdd1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicAdd');
  late final _SDL_AtomicAdd1 = _SDL_AtomicAdd1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Set a pointer to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param oldval the old pointer value
  /// \param newval the new pointer value
  /// \returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCAS
  /// \sa SDL_AtomicGetPtr
  /// \sa SDL_AtomicSetPtr
  int SDL_AtomicCASPtr1(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> oldval,
    ffi.Pointer<ffi.Void> newval,
  ) {
    return _SDL_AtomicCASPtr11(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicCASPtr');
  late final _SDL_AtomicCASPtr11 = _SDL_AtomicCASPtr1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// Set a pointer to a value atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param v the desired pointer value
  /// \returns the previous value of the pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicSetPtr1(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> v,
  ) {
    return _SDL_AtomicSetPtr11(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicSetPtr');
  late final _SDL_AtomicSetPtr11 = _SDL_AtomicSetPtr1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>)>();

  /// Get the value of a pointer atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \returns the current value of a pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicSetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicGetPtr1(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ) {
    return _SDL_AtomicGetPtr11(
      a,
    );
  }

  late final _SDL_AtomicGetPtr1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_AtomicGetPtr');
  late final _SDL_AtomicGetPtr11 = _SDL_AtomicGetPtr1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  ffi.Pointer<SDL_Thread> SDL_CreateThread1(
    SDL_ThreadFunction fn,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThread1(
      fn,
      name,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThread1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              SDL_ThreadFunction,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThread');
  late final _SDL_CreateThread1 = _SDL_CreateThread1Ptr.asFunction<
      ffi.Pointer<SDL_Thread> Function(
          SDL_ThreadFunction,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          pfnSDL_CurrentBeginThread,
          pfnSDL_CurrentEndThread)>();

  ffi.Pointer<SDL_Thread> SDL_CreateThreadWithStackSize1(
    ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>> fn,
    ffi.Pointer<ffi.Char> name,
    int stacksize,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThreadWithStackSize1(
      fn,
      name,
      stacksize,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadWithStackSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThreadWithStackSize');
  late final _SDL_CreateThreadWithStackSize1 =
      _SDL_CreateThreadWithStackSize1Ptr.asFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>();

  /// Get the thread name as it was specified in SDL_CreateThread().
  ///
  /// This is internal memory, not to be freed by the caller, and remains valid
  /// until the specified thread is cleaned up by SDL_WaitThread().
  ///
  /// \param thread the thread to query
  /// \returns a pointer to a UTF-8 string that names the specified thread, or
  /// NULL if it doesn't have a name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateThread
  ffi.Pointer<ffi.Char> SDL_GetThreadName1(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadName1(
      thread,
    );
  }

  late final _SDL_GetThreadName1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Thread>)>>('SDL_GetThreadName');
  late final _SDL_GetThreadName1 = _SDL_GetThreadName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Thread>)>();

  /// Get the thread identifier for the current thread.
  ///
  /// This thread identifier is as reported by the underlying operating system.
  /// If SDL is running on a platform that does not support threads the return
  /// value will always be zero.
  ///
  /// This function also returns a valid thread ID when called from the main
  /// thread.
  ///
  /// \returns the ID of the current thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetThreadID
  int SDL_ThreadID1() {
    return _SDL_ThreadID1();
  }

  late final _SDL_ThreadID1Ptr =
      _lookup<ffi.NativeFunction<SDL_threadID Function()>>('SDL_ThreadID');
  late final _SDL_ThreadID1 = _SDL_ThreadID1Ptr.asFunction<int Function()>();

  /// Get the thread identifier for the specified thread.
  ///
  /// This thread identifier is as reported by the underlying operating system.
  /// If SDL is running on a platform that does not support threads the return
  /// value will always be zero.
  ///
  /// \param thread the thread to query
  /// \returns the ID of the specified thread, or the ID of the current thread if
  /// `thread` is NULL.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ThreadID
  int SDL_GetThreadID1(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadID1(
      thread,
    );
  }

  late final _SDL_GetThreadID1Ptr = _lookup<
          ffi.NativeFunction<SDL_threadID Function(ffi.Pointer<SDL_Thread>)>>(
      'SDL_GetThreadID');
  late final _SDL_GetThreadID1 =
      _SDL_GetThreadID1Ptr.asFunction<int Function(ffi.Pointer<SDL_Thread>)>();

  /// Set the priority for the current thread.
  ///
  /// Note that some platforms will not let you alter the priority (or at least,
  /// promote the thread to a higher priority) at all, and some require you to be
  /// an administrator account. Be prepared for this to fail.
  ///
  /// \param priority the SDL_ThreadPriority to set
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetThreadPriority1(
    int priority,
  ) {
    return _SDL_SetThreadPriority1(
      priority,
    );
  }

  late final _SDL_SetThreadPriority1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_SetThreadPriority');
  late final _SDL_SetThreadPriority1 =
      _SDL_SetThreadPriority1Ptr.asFunction<int Function(int)>();

  /// Wait for a thread to finish.
  ///
  /// Threads that haven't been detached will remain (as a "zombie") until this
  /// function cleans them up. Not doing so is a resource leak.
  ///
  /// Once a thread has been cleaned up through this function, the SDL_Thread
  /// that references it becomes invalid and should not be referenced again. As
  /// such, only one thread may call SDL_WaitThread() on another.
  ///
  /// The return code for the thread function is placed in the area pointed to by
  /// `status`, if `status` is not NULL.
  ///
  /// You may not wait on a thread that has been used in a call to
  /// SDL_DetachThread(). Use either that function or this one, but not both, or
  /// behavior is undefined.
  ///
  /// It is safe to pass a NULL thread to this function; it is a no-op.
  ///
  /// Note that the thread pointer is freed by this function and is not valid
  /// afterward.
  ///
  /// \param thread the SDL_Thread pointer that was returned from the
  /// SDL_CreateThread() call that started this thread
  /// \param status pointer to an integer that will receive the value returned
  /// from the thread function by its 'return', or NULL to not
  /// receive such value back.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateThread
  /// \sa SDL_DetachThread
  void SDL_WaitThread1(
    ffi.Pointer<SDL_Thread> thread,
    ffi.Pointer<ffi.Int> status,
  ) {
    return _SDL_WaitThread1(
      thread,
      status,
    );
  }

  late final _SDL_WaitThread1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Thread>,
              ffi.Pointer<ffi.Int>)>>('SDL_WaitThread');
  late final _SDL_WaitThread1 = _SDL_WaitThread1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Thread>, ffi.Pointer<ffi.Int>)>();

  /// Let a thread clean up on exit without intervention.
  ///
  /// A thread may be "detached" to signify that it should not remain until
  /// another thread has called SDL_WaitThread() on it. Detaching a thread is
  /// useful for long-running threads that nothing needs to synchronize with or
  /// further manage. When a detached thread is done, it simply goes away.
  ///
  /// There is no way to recover the return code of a detached thread. If you
  /// need this, don't detach the thread and instead use SDL_WaitThread().
  ///
  /// Once a thread is detached, you should usually assume the SDL_Thread isn't
  /// safe to reference again, as it will become invalid immediately upon the
  /// detached thread's exit, instead of remaining until someone has called
  /// SDL_WaitThread() to finally clean it up. As such, don't detach the same
  /// thread more than once.
  ///
  /// If a thread has already exited when passed to SDL_DetachThread(), it will
  /// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
  /// not safe to detach a thread that might be used with SDL_WaitThread().
  ///
  /// You may not call SDL_WaitThread() on a thread that has been detached. Use
  /// either that function or this one, but not both, or behavior is undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  ///
  /// \param thread the SDL_Thread pointer that was returned from the
  /// SDL_CreateThread() call that started this thread
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_CreateThread
  /// \sa SDL_WaitThread
  void SDL_DetachThread1(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_DetachThread1(
      thread,
    );
  }

  late final _SDL_DetachThread1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Thread>)>>(
          'SDL_DetachThread');
  late final _SDL_DetachThread1 = _SDL_DetachThread1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Thread>)>();

  /// Create a piece of thread-local storage.
  ///
  /// This creates an identifier that is globally visible to all threads but
  /// refers to data that is thread-specific.
  ///
  /// \returns the newly created thread local storage identifier or 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSGet
  /// \sa SDL_TLSSet
  int SDL_TLSCreate1() {
    return _SDL_TLSCreate1();
  }

  late final _SDL_TLSCreate1Ptr =
      _lookup<ffi.NativeFunction<SDL_TLSID Function()>>('SDL_TLSCreate');
  late final _SDL_TLSCreate1 = _SDL_TLSCreate1Ptr.asFunction<int Function()>();

  /// Get the current thread's value associated with a thread local storage ID.
  ///
  /// \param id the thread local storage ID
  /// \returns the value associated with the ID for the current thread or NULL if
  /// no value has been set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSCreate
  /// \sa SDL_TLSSet
  ffi.Pointer<ffi.Void> SDL_TLSGet1(
    int id,
  ) {
    return _SDL_TLSGet1(
      id,
    );
  }

  late final _SDL_TLSGet1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(SDL_TLSID)>>(
          'SDL_TLSGet');
  late final _SDL_TLSGet1 =
      _SDL_TLSGet1Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Set the current thread's value associated with a thread local storage ID.
  ///
  /// The function prototype for `destructor` is:
  ///
  /// ```c
  /// void destructor(void *value)
  /// ```
  ///
  /// where its parameter `value` is what was passed as `value` to SDL_TLSSet().
  ///
  /// \param id the thread local storage ID
  /// \param value the value to associate with the ID for the current thread
  /// \param destructor a function called when the thread exits, to free the
  /// value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSCreate
  /// \sa SDL_TLSGet
  int SDL_TLSSet1(
    int id,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        destructor,
  ) {
    return _SDL_TLSSet1(
      id,
      value,
      destructor,
    );
  }

  late final _SDL_TLSSet1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              SDL_TLSID,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_TLSSet');
  late final _SDL_TLSSet1 = _SDL_TLSSet1Ptr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// Cleanup all TLS data for this thread.
  ///
  /// \since This function is available since SDL 2.0.16.
  void SDL_TLSCleanup1() {
    return _SDL_TLSCleanup1();
  }

  late final _SDL_TLSCleanup1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_TLSCleanup');
  late final _SDL_TLSCleanup1 =
      _SDL_TLSCleanup1Ptr.asFunction<void Function()>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile4(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile4(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile4 = _SDL_RWFromFile4Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP4(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP4(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP4 = _SDL_RWFromFP4Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem4(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem4(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem4 = _SDL_RWFromMem4Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem4(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem4(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem4 = _SDL_RWFromConstMem4Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW4() {
    return _SDL_AllocRW4();
  }

  late final _SDL_AllocRW4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW4 =
      _SDL_AllocRW4Ptr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW4(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW4(
      area,
    );
  }

  late final _SDL_FreeRW4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW4 =
      _SDL_FreeRW4Ptr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize4(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize4(
      context,
    );
  }

  late final _SDL_RWsize4Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize4 =
      _SDL_RWsize4Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek4(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek4(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek4Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek4 = _SDL_RWseek4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell4(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell4(
      context,
    );
  }

  late final _SDL_RWtell4Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell4 =
      _SDL_RWtell4Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread4(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread4(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread4 = _SDL_RWread4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite4(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite4(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite4 = _SDL_RWwrite4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose4(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose4(
      context,
    );
  }

  late final _SDL_RWclose4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose4 =
      _SDL_RWclose4Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW4(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW4(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW4 = _SDL_LoadFile_RW4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile4(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile4(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile4 = _SDL_LoadFile4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU84(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU84(
      src,
    );
  }

  late final _SDL_ReadU84Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU84 =
      _SDL_ReadU84Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE164(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE164(
      src,
    );
  }

  late final _SDL_ReadLE164Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE164 =
      _SDL_ReadLE164Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE164(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE164(
      src,
    );
  }

  late final _SDL_ReadBE164Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE164 =
      _SDL_ReadBE164Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE324(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE324(
      src,
    );
  }

  late final _SDL_ReadLE324Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE324 =
      _SDL_ReadLE324Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE324(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE324(
      src,
    );
  }

  late final _SDL_ReadBE324Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE324 =
      _SDL_ReadBE324Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE644(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE644(
      src,
    );
  }

  late final _SDL_ReadLE644Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE644 =
      _SDL_ReadLE644Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE644(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE644(
      src,
    );
  }

  late final _SDL_ReadBE644Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE644 =
      _SDL_ReadBE644Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU84(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU84(
      dst,
      value,
    );
  }

  late final _SDL_WriteU84Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU84 =
      _SDL_WriteU84Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE164(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE164(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE164Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE164 = _SDL_WriteLE164Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE164(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE164(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE164Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE164 = _SDL_WriteBE164Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE324(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE324(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE324Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE324 = _SDL_WriteLE324Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE324(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE324(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE324Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE324 = _SDL_WriteBE324Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE644(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE644(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE644Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE644 = _SDL_WriteLE644Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE644(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE644(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE644Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE644 = _SDL_WriteBE644Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to get the number of built-in audio drivers.
  ///
  /// This function returns a hardcoded number. This never returns a negative
  /// value; if there are no drivers compiled into this build of SDL, this
  /// function returns zero. The presence of a driver in this list does not mean
  /// it will function, it just means SDL is capable of interacting with that
  /// interface. For example, a build of SDL might have esound support, but if
  /// there's no esound server available, SDL's esound driver would fail if used.
  ///
  /// By default, SDL tries all drivers, in its preferred order, until one is
  /// found to be usable.
  ///
  /// \returns the number of built-in audio drivers.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioDriver
  int SDL_GetNumAudioDrivers1() {
    return _SDL_GetNumAudioDrivers1();
  }

  late final _SDL_GetNumAudioDrivers1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAudioDrivers');
  late final _SDL_GetNumAudioDrivers1 =
      _SDL_GetNumAudioDrivers1Ptr.asFunction<int Function()>();

  /// Use this function to get the name of a built in audio driver.
  ///
  /// The list of audio drivers is given in the order that they are normally
  /// initialized by default; the drivers that seem more reasonable to choose
  /// first (as far as the SDL developers believe) are earlier in the list.
  ///
  /// The names of drivers are all simple, low-ASCII identifiers, like "alsa",
  /// "coreaudio" or "xaudio2". These never have Unicode characters, and are not
  /// meant to be proper names.
  ///
  /// \param index the index of the audio driver; the value ranges from 0 to
  /// SDL_GetNumAudioDrivers() - 1
  /// \returns the name of the audio driver at the requested index, or NULL if an
  /// invalid index was specified.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumAudioDrivers
  ffi.Pointer<ffi.Char> SDL_GetAudioDriver1(
    int index,
  ) {
    return _SDL_GetAudioDriver1(
      index,
    );
  }

  late final _SDL_GetAudioDriver1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetAudioDriver');
  late final _SDL_GetAudioDriver1 =
      _SDL_GetAudioDriver1Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Use this function to initialize a particular audio driver.
  ///
  /// This function is used internally, and should not be used unless you have a
  /// specific need to designate the audio driver you want to use. You should
  /// normally use SDL_Init() or SDL_InitSubSystem().
  ///
  /// \param driver_name the name of the desired audio driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AudioQuit
  int SDL_AudioInit1(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_AudioInit1(
      driver_name,
    );
  }

  late final _SDL_AudioInit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_AudioInit');
  late final _SDL_AudioInit1 =
      _SDL_AudioInit1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Use this function to shut down audio if you initialized it with
  /// SDL_AudioInit().
  ///
  /// This function is used internally, and should not be used unless you have a
  /// specific need to specify the audio driver you want to use. You should
  /// normally use SDL_Quit() or SDL_QuitSubSystem().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AudioInit
  void SDL_AudioQuit1() {
    return _SDL_AudioQuit1();
  }

  late final _SDL_AudioQuit1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_AudioQuit');
  late final _SDL_AudioQuit1 = _SDL_AudioQuit1Ptr.asFunction<void Function()>();

  /// Get the name of the current audio driver.
  ///
  /// The returned string points to internal static memory and thus never becomes
  /// invalid, even if you quit the audio subsystem and initialize a new driver
  /// (although such a case would return a different static string from another
  /// call to this function, of course). As such, you should not modify or free
  /// the returned string.
  ///
  /// \returns the name of the current audio driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AudioInit
  ffi.Pointer<ffi.Char> SDL_GetCurrentAudioDriver1() {
    return _SDL_GetCurrentAudioDriver1();
  }

  late final _SDL_GetCurrentAudioDriver1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentAudioDriver');
  late final _SDL_GetCurrentAudioDriver1 = _SDL_GetCurrentAudioDriver1Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// This function is a legacy means of opening the audio device.
  ///
  /// This function remains for compatibility with SDL 1.2, but also because it's
  /// slightly easier to use than the new functions in SDL 2.0. The new, more
  /// powerful, and preferred way to do this is SDL_OpenAudioDevice().
  ///
  /// This function is roughly equivalent to:
  ///
  /// ```c
  /// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);
  /// ```
  ///
  /// With two notable exceptions:
  ///
  /// - If `obtained` is NULL, we use `desired` (and allow no changes), which
  /// means desired will be modified to have the correct values for silence,
  /// etc, and SDL will convert any differences between your app's specific
  /// request and the hardware behind the scenes.
  /// - The return value is always success or failure, and not a device ID, which
  /// means you can only have one device open at a time with this function.
  ///
  /// \param desired an SDL_AudioSpec structure representing the desired output
  /// format. Please refer to the SDL_OpenAudioDevice
  /// documentation for details on how to prepare this structure.
  /// \param obtained an SDL_AudioSpec structure filled in with the actual
  /// parameters, or NULL.
  /// \returns 0 if successful, placing the actual hardware parameters in the
  /// structure pointed to by `obtained`.
  ///
  /// If `obtained` is NULL, the audio data passed to the callback
  /// function will be guaranteed to be in the requested format, and
  /// will be automatically converted to the actual hardware audio
  /// format if necessary. If `obtained` is NULL, `desired` will have
  /// fields modified.
  ///
  /// This function returns a negative error code on failure to open the
  /// audio device or failure to set up the audio thread; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CloseAudio
  /// \sa SDL_LockAudio
  /// \sa SDL_PauseAudio
  /// \sa SDL_UnlockAudio
  int SDL_OpenAudio1(
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
  ) {
    return _SDL_OpenAudio1(
      desired,
      obtained,
    );
  }

  late final _SDL_OpenAudio1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<SDL_AudioSpec>)>>('SDL_OpenAudio');
  late final _SDL_OpenAudio1 = _SDL_OpenAudio1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AudioSpec>, ffi.Pointer<SDL_AudioSpec>)>();

  /// Get the number of built-in audio devices.
  ///
  /// This function is only valid after successfully initializing the audio
  /// subsystem.
  ///
  /// Note that audio capture support is not implemented as of SDL 2.0.4, so the
  /// `iscapture` parameter is for future expansion and should always be zero for
  /// now.
  ///
  /// This function will return -1 if an explicit list of devices can't be
  /// determined. Returning -1 is not an error. For example, if SDL is set up to
  /// talk to a remote audio server, it can't list every one available on the
  /// Internet, but it will still allow a specific host to be specified in
  /// SDL_OpenAudioDevice().
  ///
  /// In many common cases, when this function returns a value <= 0, it can still
  /// successfully open the default device (NULL for first argument of
  /// SDL_OpenAudioDevice()).
  ///
  /// This function may trigger a complete redetect of available hardware. It
  /// should not be called for each iteration of a loop, but rather once at the
  /// start of a loop:
  ///
  /// ```c
  /// // Don't do this:
  /// for (int i = 0; i < SDL_GetNumAudioDevices(0); i++)
  ///
  /// // do this instead:
  /// const int count = SDL_GetNumAudioDevices(0);
  /// for (int i = 0; i < count; ++i) { do_something_here(); }
  /// ```
  ///
  /// \param iscapture zero to request playback devices, non-zero to request
  /// recording devices
  /// \returns the number of available devices exposed by the current driver or
  /// -1 if an explicit list of devices can't be determined. A return
  /// value of -1 does not necessarily mean an error condition.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioDeviceName
  /// \sa SDL_OpenAudioDevice
  int SDL_GetNumAudioDevices1(
    int iscapture,
  ) {
    return _SDL_GetNumAudioDevices1(
      iscapture,
    );
  }

  late final _SDL_GetNumAudioDevices1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumAudioDevices');
  late final _SDL_GetNumAudioDevices1 =
      _SDL_GetNumAudioDevices1Ptr.asFunction<int Function(int)>();

  /// Get the human-readable name of a specific audio device.
  ///
  /// This function is only valid after successfully initializing the audio
  /// subsystem. The values returned by this function reflect the latest call to
  /// SDL_GetNumAudioDevices(); re-call that function to redetect available
  /// hardware.
  ///
  /// The string returned by this function is UTF-8 encoded, read-only, and
  /// managed internally. You are not to free it. If you need to keep the string
  /// for any length of time, you should make your own copy of it, as it will be
  /// invalid next time any of several other SDL functions are called.
  ///
  /// \param index the index of the audio device; valid values range from 0 to
  /// SDL_GetNumAudioDevices() - 1
  /// \param iscapture non-zero to query the list of recording devices, zero to
  /// query the list of output devices.
  /// \returns the name of the audio device at the requested index, or NULL on
  /// error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumAudioDevices
  ffi.Pointer<ffi.Char> SDL_GetAudioDeviceName1(
    int index,
    int iscapture,
  ) {
    return _SDL_GetAudioDeviceName1(
      index,
      iscapture,
    );
  }

  late final _SDL_GetAudioDeviceName1Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int, ffi.Int)>>(
      'SDL_GetAudioDeviceName');
  late final _SDL_GetAudioDeviceName1 = _SDL_GetAudioDeviceName1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int)>();

  /// Get the preferred audio format of a specific audio device.
  ///
  /// This function is only valid after a successfully initializing the audio
  /// subsystem. The values returned by this function reflect the latest call to
  /// SDL_GetNumAudioDevices(); re-call that function to redetect available
  /// hardware.
  ///
  /// `spec` will be filled with the sample rate, sample format, and channel
  /// count. All other values in the structure are filled with 0. When the
  /// supported struct members are 0, SDL was unable to get the property from the
  /// backend.
  ///
  /// \param index the index of the audio device; valid values range from 0 to
  /// SDL_GetNumAudioDevices() - 1
  /// \param iscapture non-zero to query the list of recording devices, zero to
  /// query the list of output devices.
  /// \param spec The SDL_AudioSpec to be initialized by this function.
  /// \returns 0 on success, nonzero on error
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetNumAudioDevices
  int SDL_GetAudioDeviceSpec1(
    int index,
    int iscapture,
    ffi.Pointer<SDL_AudioSpec> spec,
  ) {
    return _SDL_GetAudioDeviceSpec1(
      index,
      iscapture,
      spec,
    );
  }

  late final _SDL_GetAudioDeviceSpec1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_AudioSpec>)>>('SDL_GetAudioDeviceSpec');
  late final _SDL_GetAudioDeviceSpec1 = _SDL_GetAudioDeviceSpec1Ptr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_AudioSpec>)>();

  /// Open a specific audio device.
  ///
  /// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,
  /// this function will never return a 1 so as not to conflict with the legacy
  /// function.
  ///
  /// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,
  /// this function would fail if `iscapture` was not zero. Starting with SDL
  /// 2.0.5, recording is implemented and this value can be non-zero.
  ///
  /// Passing in a `device` name of NULL requests the most reasonable default
  /// (and is equivalent to what SDL_OpenAudio() does to choose a device). The
  /// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
  /// some drivers allow arbitrary and driver-specific strings, such as a
  /// hostname/IP address for a remote audio server, or a filename in the
  /// diskaudio driver.
  ///
  /// An opened audio device starts out paused, and should be enabled for playing
  /// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio
  /// callback function to be called. Since the audio driver may modify the
  /// requested size of the audio buffer, you should allocate any local mixing
  /// buffers after you open the audio device.
  ///
  /// The audio callback runs in a separate thread in most cases; you can prevent
  /// race conditions between your callback and other threads without fully
  /// pausing playback with SDL_LockAudioDevice(). For more information about the
  /// callback, see SDL_AudioSpec.
  ///
  /// Managing the audio spec via 'desired' and 'obtained':
  ///
  /// When filling in the desired audio spec structure:
  ///
  /// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).
  /// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).
  /// - `desired->samples` is the desired size of the audio buffer, in _sample
  /// frames_ (with stereo output, two samples--left and right--would make a
  /// single sample frame). This number should be a power of two, and may be
  /// adjusted by the audio driver to a value more suitable for the hardware.
  /// Good values seem to range between 512 and 8096 inclusive, depending on
  /// the application and CPU speed. Smaller values reduce latency, but can
  /// lead to underflow if the application is doing heavy processing and cannot
  /// fill the audio buffer in time. Note that the number of sample frames is
  /// directly related to time by the following formula: `ms =
  /// (sampleframes*1000)/freq`
  /// - `desired->size` is the size in _bytes_ of the audio buffer, and is
  /// calculated by SDL_OpenAudioDevice(). You don't initialize this.
  /// - `desired->silence` is the value used to set the buffer to silence, and is
  /// calculated by SDL_OpenAudioDevice(). You don't initialize this.
  /// - `desired->callback` should be set to a function that will be called when
  /// the audio device is ready for more data. It is passed a pointer to the
  /// audio buffer, and the length in bytes of the audio buffer. This function
  /// usually runs in a separate thread, and so you should protect data
  /// structures that it accesses by calling SDL_LockAudioDevice() and
  /// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL
  /// pointer here, and call SDL_QueueAudio() with some frequency, to queue
  /// more audio samples to be played (or for capture devices, call
  /// SDL_DequeueAudio() with some frequency, to obtain audio samples).
  /// - `desired->userdata` is passed as the first parameter to your callback
  /// function. If you passed a NULL callback, this value is ignored.
  ///
  /// `allowed_changes` can have the following flags OR'd together:
  ///
  /// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`
  /// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`
  /// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`
  /// - `SDL_AUDIO_ALLOW_ANY_CHANGE`
  ///
  /// These flags specify how SDL should behave when a device cannot offer a
  /// specific feature. If the application requests a feature that the hardware
  /// doesn't offer, SDL will always try to get the closest equivalent.
  ///
  /// For example, if you ask for float32 audio format, but the sound card only
  /// supports int16, SDL will set the hardware to int16. If you had set
  /// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`
  /// structure. If that flag was *not* set, SDL will prepare to convert your
  /// callback's float32 audio to int16 before feeding it to the hardware and
  /// will keep the originally requested format in the `obtained` structure.
  ///
  /// The resulting audio specs, varying depending on hardware and on what
  /// changes were allowed, will then be written back to `obtained`.
  ///
  /// If your application can only handle one specific data format, pass a zero
  /// for `allowed_changes` and let SDL transparently handle any differences.
  ///
  /// \param device a UTF-8 string reported by SDL_GetAudioDeviceName() or a
  /// driver-specific name as appropriate. NULL requests the most
  /// reasonable default device.
  /// \param iscapture non-zero to specify a device should be opened for
  /// recording, not playback
  /// \param desired an SDL_AudioSpec structure representing the desired output
  /// format; see SDL_OpenAudio() for more information
  /// \param obtained an SDL_AudioSpec structure filled in with the actual output
  /// format; see SDL_OpenAudio() for more information
  /// \param allowed_changes 0, or one or more flags OR'd together
  /// \returns a valid device ID that is > 0 on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// For compatibility with SDL 1.2, this will never return 1, since
  /// SDL reserves that ID for the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CloseAudioDevice
  /// \sa SDL_GetAudioDeviceName
  /// \sa SDL_LockAudioDevice
  /// \sa SDL_OpenAudio
  /// \sa SDL_PauseAudioDevice
  /// \sa SDL_UnlockAudioDevice
  int SDL_OpenAudioDevice1(
    ffi.Pointer<ffi.Char> device,
    int iscapture,
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
    int allowed_changes,
  ) {
    return _SDL_OpenAudioDevice1(
      device,
      iscapture,
      desired,
      obtained,
      allowed_changes,
    );
  }

  late final _SDL_OpenAudioDevice1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_AudioDeviceID Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Int)>>('SDL_OpenAudioDevice');
  late final _SDL_OpenAudioDevice1 = _SDL_OpenAudioDevice1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<SDL_AudioSpec>,
          ffi.Pointer<SDL_AudioSpec>, int)>();

  /// This function is a legacy means of querying the audio device.
  ///
  /// New programs might want to use SDL_GetAudioDeviceStatus() instead. This
  /// function is equivalent to calling...
  ///
  /// ```c
  /// SDL_GetAudioDeviceStatus(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \returns the SDL_AudioStatus of the audio device opened by SDL_OpenAudio().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioDeviceStatus
  int SDL_GetAudioStatus1() {
    return _SDL_GetAudioStatus1();
  }

  late final _SDL_GetAudioStatus1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetAudioStatus');
  late final _SDL_GetAudioStatus1 =
      _SDL_GetAudioStatus1Ptr.asFunction<int Function()>();

  /// Use this function to get the current audio state of an audio device.
  ///
  /// \param dev the ID of an audio device previously opened with
  /// SDL_OpenAudioDevice()
  /// \returns the SDL_AudioStatus of the specified audio device.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PauseAudioDevice
  int SDL_GetAudioDeviceStatus1(
    int dev,
  ) {
    return _SDL_GetAudioDeviceStatus1(
      dev,
    );
  }

  late final _SDL_GetAudioDeviceStatus1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_AudioDeviceID)>>(
          'SDL_GetAudioDeviceStatus');
  late final _SDL_GetAudioDeviceStatus1 =
      _SDL_GetAudioDeviceStatus1Ptr.asFunction<int Function(int)>();

  /// This function is a legacy means of pausing the audio device.
  ///
  /// New programs might want to use SDL_PauseAudioDevice() instead. This
  /// function is equivalent to calling...
  ///
  /// ```c
  /// SDL_PauseAudioDevice(1, pause_on);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \param pause_on non-zero to pause, 0 to unpause
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetAudioStatus
  /// \sa SDL_PauseAudioDevice
  void SDL_PauseAudio1(
    int pause_on,
  ) {
    return _SDL_PauseAudio1(
      pause_on,
    );
  }

  late final _SDL_PauseAudio1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('SDL_PauseAudio');
  late final _SDL_PauseAudio1 =
      _SDL_PauseAudio1Ptr.asFunction<void Function(int)>();

  /// Use this function to pause and unpause audio playback on a specified
  /// device.
  ///
  /// This function pauses and unpauses the audio callback processing for a given
  /// device. Newly-opened audio devices start in the paused state, so you must
  /// call this function with **pause_on**=0 after opening the specified audio
  /// device to start playing sound. This allows you to safely initialize data
  /// for your callback function after opening the audio device. Silence will be
  /// written to the audio device while paused, and the audio callback is
  /// guaranteed to not be called. Pausing one device does not prevent other
  /// unpaused devices from running their callbacks.
  ///
  /// Pausing state does not stack; even if you pause a device several times, a
  /// single unpause will start the device playing again, and vice versa. This is
  /// different from how SDL_LockAudioDevice() works.
  ///
  /// If you just need to protect a few variables from race conditions vs your
  /// callback, you shouldn't pause the audio device, as it will lead to dropouts
  /// in the audio playback. Instead, you should use SDL_LockAudioDevice().
  ///
  /// \param dev a device opened by SDL_OpenAudioDevice()
  /// \param pause_on non-zero to pause, 0 to unpause
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudioDevice
  void SDL_PauseAudioDevice1(
    int dev,
    int pause_on,
  ) {
    return _SDL_PauseAudioDevice1(
      dev,
      pause_on,
    );
  }

  late final _SDL_PauseAudioDevice1Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID, ffi.Int)>>(
      'SDL_PauseAudioDevice');
  late final _SDL_PauseAudioDevice1 =
      _SDL_PauseAudioDevice1Ptr.asFunction<void Function(int, int)>();

  /// Load the audio data of a WAVE file into memory.
  ///
  /// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
  /// be valid pointers. The entire data portion of the file is then loaded into
  /// memory and decoded if necessary.
  ///
  /// If `freesrc` is non-zero, the data source gets automatically closed and
  /// freed before the function returns.
  ///
  /// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
  /// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
  /// A-law and mu-law (8 bits). Other formats are currently unsupported and
  /// cause an error.
  ///
  /// If this function succeeds, the pointer returned by it is equal to `spec`
  /// and the pointer to the audio data allocated by the function is written to
  /// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec
  /// members `freq`, `channels`, and `format` are set to the values of the audio
  /// data in the buffer. The `samples` member is set to a sane default and all
  /// others are set to zero.
  ///
  /// It's necessary to use SDL_FreeWAV() to free the audio data returned in
  /// `audio_buf` when it is no longer used.
  ///
  /// Because of the underspecification of the .WAV format, there are many
  /// problematic files in the wild that cause issues with strict decoders. To
  /// provide compatibility with these files, this decoder is lenient in regards
  /// to the truncation of the file, the fact chunk, and the size of the RIFF
  /// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
  /// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
  /// tune the behavior of the loading process.
  ///
  /// Any file that is invalid (due to truncation, corruption, or wrong values in
  /// the headers), too big, or unsupported causes an error. Additionally, any
  /// critical I/O error from the data source will terminate the loading process
  /// with an error. The function returns NULL on error and in all cases (with
  /// the exception of `src` being NULL), an appropriate error message will be
  /// set.
  ///
  /// It is required that the data source supports seeking.
  ///
  /// Example:
  ///
  /// ```c
  /// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, &spec, &buf, &len);
  /// ```
  ///
  /// Note that the SDL_LoadWAV macro does this same thing for you, but in a less
  /// messy way:
  ///
  /// ```c
  /// SDL_LoadWAV("sample.wav", &spec, &buf, &len);
  /// ```
  ///
  /// \param src The data source for the WAVE data
  /// \param freesrc If non-zero, SDL will _always_ free the data source
  /// \param spec An SDL_AudioSpec that will be filled in with the wave file's
  /// format details
  /// \param audio_buf A pointer filled with the audio data, allocated by the
  /// function.
  /// \param audio_len A pointer filled with the length of the audio data buffer
  /// in bytes
  /// \returns This function, if successfully called, returns `spec`, which will
  /// be filled with the audio data format of the wave source data.
  /// `audio_buf` will be filled with a pointer to an allocated buffer
  /// containing the audio data, and `audio_len` is filled with the
  /// length of that audio buffer in bytes.
  ///
  /// This function returns NULL if the .WAV file cannot be opened, uses
  /// an unknown data format, or is corrupt; call SDL_GetError() for
  /// more information.
  ///
  /// When the application is done with the data returned in
  /// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeWAV
  /// \sa SDL_LoadWAV
  ffi.Pointer<SDL_AudioSpec> SDL_LoadWAV_RW1(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
    ffi.Pointer<SDL_AudioSpec> spec,
    ffi.Pointer<ffi.Pointer<Uint8>> audio_buf,
    ffi.Pointer<Uint32> audio_len,
  ) {
    return _SDL_LoadWAV_RW1(
      src,
      freesrc,
      spec,
      audio_buf,
      audio_len,
    );
  }

  late final _SDL_LoadWAV_RW1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_AudioSpec> Function(
              ffi.Pointer<SDL_RWops>,
              ffi.Int,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<ffi.Pointer<Uint8>>,
              ffi.Pointer<Uint32>)>>('SDL_LoadWAV_RW');
  late final _SDL_LoadWAV_RW1 = _SDL_LoadWAV_RW1Ptr.asFunction<
      ffi.Pointer<SDL_AudioSpec> Function(
          ffi.Pointer<SDL_RWops>,
          int,
          ffi.Pointer<SDL_AudioSpec>,
          ffi.Pointer<ffi.Pointer<Uint8>>,
          ffi.Pointer<Uint32>)>();

  /// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().
  ///
  /// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()
  /// its data can eventually be freed with SDL_FreeWAV(). It is safe to call
  /// this function with a NULL pointer.
  ///
  /// \param audio_buf a pointer to the buffer created by SDL_LoadWAV() or
  /// SDL_LoadWAV_RW()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadWAV
  /// \sa SDL_LoadWAV_RW
  void SDL_FreeWAV1(
    ffi.Pointer<Uint8> audio_buf,
  ) {
    return _SDL_FreeWAV1(
      audio_buf,
    );
  }

  late final _SDL_FreeWAV1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Uint8>)>>(
          'SDL_FreeWAV');
  late final _SDL_FreeWAV1 =
      _SDL_FreeWAV1Ptr.asFunction<void Function(ffi.Pointer<Uint8>)>();

  /// Initialize an SDL_AudioCVT structure for conversion.
  ///
  /// Before an SDL_AudioCVT structure can be used to convert audio data it must
  /// be initialized with source and destination information.
  ///
  /// This function will zero out every field of the SDL_AudioCVT, so it must be
  /// called before the application fills in the final buffer information.
  ///
  /// Once this function has returned successfully, and reported that a
  /// conversion is necessary, the application fills in the rest of the fields in
  /// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,
  /// and then can call SDL_ConvertAudio() to complete the conversion.
  ///
  /// \param cvt an SDL_AudioCVT structure filled in with audio conversion
  /// information
  /// \param src_format the source format of the audio data; for more info see
  /// SDL_AudioFormat
  /// \param src_channels the number of channels in the source
  /// \param src_rate the frequency (sample-frames-per-second) of the source
  /// \param dst_format the destination format of the audio data; for more info
  /// see SDL_AudioFormat
  /// \param dst_channels the number of channels in the destination
  /// \param dst_rate the frequency (sample-frames-per-second) of the destination
  /// \returns 1 if the audio filter is prepared, 0 if no conversion is needed,
  /// or a negative error code on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ConvertAudio
  int SDL_BuildAudioCVT1(
    ffi.Pointer<SDL_AudioCVT> cvt,
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_BuildAudioCVT1(
      cvt,
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_BuildAudioCVT1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioCVT>, SDL_AudioFormat, Uint8,
              ffi.Int, SDL_AudioFormat, Uint8, ffi.Int)>>('SDL_BuildAudioCVT');
  late final _SDL_BuildAudioCVT1 = _SDL_BuildAudioCVT1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AudioCVT>, int, int, int, int, int, int)>();

  /// Convert audio data to a desired audio format.
  ///
  /// This function does the actual audio data conversion, after the application
  /// has called SDL_BuildAudioCVT() to prepare the conversion information and
  /// then filled in the buffer details.
  ///
  /// Once the application has initialized the `cvt` structure using
  /// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio
  /// data in the source format, this function will convert the buffer, in-place,
  /// to the desired format.
  ///
  /// The data conversion may go through several passes; any given pass may
  /// possibly temporarily increase the size of the data. For example, SDL might
  /// expand 16-bit data to 32 bits before resampling to a lower frequency,
  /// shrinking the data size after having grown it briefly. Since the supplied
  /// buffer will be both the source and destination, converting as necessary
  /// in-place, the application must allocate a buffer that will fully contain
  /// the data during its largest conversion pass. After SDL_BuildAudioCVT()
  /// returns, the application should set the `cvt->len` field to the size, in
  /// bytes, of the source data, and allocate a buffer that is `cvt->len *
  /// cvt->len_mult` bytes long for the `buf` field.
  ///
  /// The source data should be copied into this buffer before the call to
  /// SDL_ConvertAudio(). Upon successful return, this buffer will contain the
  /// converted audio, and `cvt->len_cvt` will be the size of the converted data,
  /// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once
  /// this function returns.
  ///
  /// \param cvt an SDL_AudioCVT structure that was previously set up by
  /// SDL_BuildAudioCVT().
  /// \returns 0 if the conversion was completed successfully or a negative error
  /// code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BuildAudioCVT
  int SDL_ConvertAudio1(
    ffi.Pointer<SDL_AudioCVT> cvt,
  ) {
    return _SDL_ConvertAudio1(
      cvt,
    );
  }

  late final _SDL_ConvertAudio1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_AudioCVT>)>>(
          'SDL_ConvertAudio');
  late final _SDL_ConvertAudio1 = _SDL_ConvertAudio1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AudioCVT>)>();

  /// Create a new audio stream.
  ///
  /// \param src_format The format of the source audio
  /// \param src_channels The number of channels of the source audio
  /// \param src_rate The sampling rate of the source audio
  /// \param dst_format The format of the desired audio output
  /// \param dst_channels The number of channels of the desired audio output
  /// \param dst_rate The sampling rate of the desired audio output
  /// \returns 0 on success, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  ffi.Pointer<SDL_AudioStream> SDL_NewAudioStream1(
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_NewAudioStream1(
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_NewAudioStream1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_AudioStream> Function(SDL_AudioFormat, Uint8, ffi.Int,
              SDL_AudioFormat, Uint8, ffi.Int)>>('SDL_NewAudioStream');
  late final _SDL_NewAudioStream1 = _SDL_NewAudioStream1Ptr.asFunction<
      ffi.Pointer<SDL_AudioStream> Function(int, int, int, int, int, int)>();

  /// Add data to be converted/resampled to the stream.
  ///
  /// \param stream The stream the audio data is being added to
  /// \param buf A pointer to the audio data to add
  /// \param len The number of bytes to write to the stream
  /// \returns 0 on success, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamPut1(
    ffi.Pointer<SDL_AudioStream> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamPut1(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamPut1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_AudioStreamPut');
  late final _SDL_AudioStreamPut1 = _SDL_AudioStreamPut1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>, int)>();

  /// Get converted/resampled data from the stream
  ///
  /// \param stream The stream the audio is being requested from
  /// \param buf A buffer to fill with audio data
  /// \param len The maximum number of bytes to fill
  /// \returns the number of bytes read from the stream, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamGet1(
    ffi.Pointer<SDL_AudioStream> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamGet1(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamGet1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_AudioStreamGet');
  late final _SDL_AudioStreamGet1 = _SDL_AudioStreamGet1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream>, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of converted/resampled bytes available.
  ///
  /// The stream may be buffering data behind the scenes until it has enough to
  /// resample correctly, so this number might be lower than what you expect, or
  /// even be zero. Add more data or flush the stream if you need the data now.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamAvailable1(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamAvailable1(
      stream,
    );
  }

  late final _SDL_AudioStreamAvailable1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_AudioStreamAvailable');
  late final _SDL_AudioStreamAvailable1 = _SDL_AudioStreamAvailable1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_AudioStream>)>();

  /// Tell the stream that you're done sending data, and anything being buffered
  /// should be converted/resampled and made available immediately.
  ///
  /// It is legal to add more data to a stream after flushing, but there will be
  /// audio gaps in the output. Generally this is intended to signal the end of
  /// input, so the complete output becomes available.
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamFlush1(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamFlush1(
      stream,
    );
  }

  late final _SDL_AudioStreamFlush1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_AudioStreamFlush');
  late final _SDL_AudioStreamFlush1 = _SDL_AudioStreamFlush1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream>)>();

  /// Clear any pending data in the stream without converting it
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_FreeAudioStream
  void SDL_AudioStreamClear1(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamClear1(
      stream,
    );
  }

  late final _SDL_AudioStreamClear1Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_AudioStreamClear');
  late final _SDL_AudioStreamClear1 = _SDL_AudioStreamClear1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_AudioStream>)>();

  /// Free an audio stream
  ///
  /// \since This function is available since SDL 2.0.7.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  void SDL_FreeAudioStream1(
    ffi.Pointer<SDL_AudioStream> stream,
  ) {
    return _SDL_FreeAudioStream1(
      stream,
    );
  }

  late final _SDL_FreeAudioStream1Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_AudioStream>)>>(
      'SDL_FreeAudioStream');
  late final _SDL_FreeAudioStream1 = _SDL_FreeAudioStream1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_AudioStream>)>();

  /// This function is a legacy means of mixing audio.
  ///
  /// This function is equivalent to calling...
  ///
  /// ```c
  /// SDL_MixAudioFormat(dst, src, format, len, volume);
  /// ```
  ///
  /// ...where `format` is the obtained format of the audio device from the
  /// legacy SDL_OpenAudio() function.
  ///
  /// \param dst the destination for the mixed audio
  /// \param src the source audio buffer to be mixed
  /// \param len the length of the audio buffer in bytes
  /// \param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
  /// for full audio volume
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MixAudioFormat
  void SDL_MixAudio1(
    ffi.Pointer<Uint8> dst,
    ffi.Pointer<Uint8> src,
    int len,
    int volume,
  ) {
    return _SDL_MixAudio1(
      dst,
      src,
      len,
      volume,
    );
  }

  late final _SDL_MixAudio1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, Uint32,
              ffi.Int)>>('SDL_MixAudio');
  late final _SDL_MixAudio1 = _SDL_MixAudio1Ptr.asFunction<
      void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int)>();

  /// Mix audio data in a specified format.
  ///
  /// This takes an audio buffer `src` of `len` bytes of `format` data and mixes
  /// it into `dst`, performing addition, volume adjustment, and overflow
  /// clipping. The buffer pointed to by `dst` must also be `len` bytes of
  /// `format` data.
  ///
  /// This is provided for convenience -- you can mix your own audio data.
  ///
  /// Do not use this function for mixing together more than two streams of
  /// sample data. The output from repeated application of this function may be
  /// distorted by clipping, because there is no accumulator with greater range
  /// than the input (not to mention this being an inefficient way of doing it).
  ///
  /// It is a common misconception that this function is required to write audio
  /// data to an output stream in an audio callback. While you can do that,
  /// SDL_MixAudioFormat() is really only needed when you're mixing a single
  /// audio stream with a volume adjustment.
  ///
  /// \param dst the destination for the mixed audio
  /// \param src the source audio buffer to be mixed
  /// \param format the SDL_AudioFormat structure representing the desired audio
  /// format
  /// \param len the length of the audio buffer in bytes
  /// \param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
  /// for full audio volume
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_MixAudioFormat1(
    ffi.Pointer<Uint8> dst,
    ffi.Pointer<Uint8> src,
    int format,
    int len,
    int volume,
  ) {
    return _SDL_MixAudioFormat1(
      dst,
      src,
      format,
      len,
      volume,
    );
  }

  late final _SDL_MixAudioFormat1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>,
              SDL_AudioFormat, Uint32, ffi.Int)>>('SDL_MixAudioFormat');
  late final _SDL_MixAudioFormat1 = _SDL_MixAudioFormat1Ptr.asFunction<
      void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int)>();

  /// Queue more audio on non-callback devices.
  ///
  /// If you are looking to retrieve queued audio from a non-callback capture
  /// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return
  /// -1 to signify an error if you use it with capture devices.
  ///
  /// SDL offers two ways to feed audio to the device: you can either supply a
  /// callback that SDL triggers with some frequency to obtain more audio (pull
  /// method), or you can supply no callback, and then SDL will expect you to
  /// supply data at regular intervals (push method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Queued data will drain to the device as
  /// necessary without further intervention from you. If the device needs audio
  /// but there is not enough queued, it will play silence to make up the
  /// difference. This means you will have skips in your audio playback if you
  /// aren't routinely queueing sufficient data.
  ///
  /// This function copies the supplied data, so you are safe to free it when the
  /// function returns. This function is thread-safe, but queueing to the same
  /// device from two threads at once does not promise which buffer will be
  /// queued first.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; doing so returns an error. You have to use the audio callback or
  /// queue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before queueing; SDL
  /// handles locking internally for this function.
  ///
  /// Note that SDL2 does not support planar audio. You will need to resample
  /// from planar audio formats into a non-planar one (see SDL_AudioFormat)
  /// before queuing audio.
  ///
  /// \param dev the device ID to which we will queue audio
  /// \param data the data to queue to the device for later playback
  /// \param len the number of bytes (not samples!) to which `data` points
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_ClearQueuedAudio
  /// \sa SDL_GetQueuedAudioSize
  int SDL_QueueAudio1(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_QueueAudio1(
      dev,
      data,
      len,
    );
  }

  late final _SDL_QueueAudio1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_AudioDeviceID, ffi.Pointer<ffi.Void>,
              Uint32)>>('SDL_QueueAudio');
  late final _SDL_QueueAudio1 = _SDL_QueueAudio1Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Dequeue more audio on non-callback devices.
  ///
  /// If you are looking to queue audio for output on a non-callback playback
  /// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always
  /// return 0 if you use it with playback devices.
  ///
  /// SDL offers two ways to retrieve audio from a capture device: you can either
  /// supply a callback that SDL triggers with some frequency as the device
  /// records more audio data, (push method), or you can supply no callback, and
  /// then SDL will expect you to retrieve data at regular intervals (pull
  /// method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Data from the device will keep queuing as
  /// necessary without further intervention from you. This means you will
  /// eventually run out of memory if you aren't routinely dequeueing data.
  ///
  /// Capture devices will not queue data when paused; if you are expecting to
  /// not need captured audio for some length of time, use SDL_PauseAudioDevice()
  /// to stop the capture device from queueing more data. This can be useful
  /// during, say, level loading times. When unpaused, capture devices will start
  /// queueing data from that point, having flushed any capturable data available
  /// while paused.
  ///
  /// This function is thread-safe, but dequeueing from the same device from two
  /// threads at once does not promise which thread will dequeue data first.
  ///
  /// You may not dequeue audio from a device that is using an
  /// application-supplied callback; doing so returns an error. You have to use
  /// the audio callback, or dequeue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before dequeueing; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev the device ID from which we will dequeue audio
  /// \param data a pointer into where audio data should be copied
  /// \param len the number of bytes (not samples!) to which (data) points
  /// \returns the number of bytes dequeued, which could be less than requested;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_ClearQueuedAudio
  /// \sa SDL_GetQueuedAudioSize
  int SDL_DequeueAudio1(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_DequeueAudio1(
      dev,
      data,
      len,
    );
  }

  late final _SDL_DequeueAudio1Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(SDL_AudioDeviceID, ffi.Pointer<ffi.Void>,
              Uint32)>>('SDL_DequeueAudio');
  late final _SDL_DequeueAudio1 = _SDL_DequeueAudio1Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of bytes of still-queued audio.
  ///
  /// For playback devices: this is the number of bytes that have been queued for
  /// playback with SDL_QueueAudio(), but have not yet been sent to the hardware.
  ///
  /// Once we've sent it to the hardware, this function can not decide the exact
  /// byte boundary of what has been played. It's possible that we just gave the
  /// hardware several kilobytes right before you called this function, but it
  /// hasn't played any of it yet, or maybe half of it, etc.
  ///
  /// For capture devices, this is the number of bytes that have been captured by
  /// the device and are waiting for you to dequeue. This number may grow at any
  /// time, so this only informs of the lower-bound of available data.
  ///
  /// You may not queue or dequeue audio on a device that is using an
  /// application-supplied callback; calling this function on such a device
  /// always returns 0. You have to use the audio callback or queue audio, but
  /// not both.
  ///
  /// You should not call SDL_LockAudio() on the device before querying; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev the device ID of which we will query queued audio size
  /// \returns the number of bytes (not samples!) of queued audio.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_ClearQueuedAudio
  /// \sa SDL_QueueAudio
  /// \sa SDL_DequeueAudio
  int SDL_GetQueuedAudioSize1(
    int dev,
  ) {
    return _SDL_GetQueuedAudioSize1(
      dev,
    );
  }

  late final _SDL_GetQueuedAudioSize1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(SDL_AudioDeviceID)>>(
          'SDL_GetQueuedAudioSize');
  late final _SDL_GetQueuedAudioSize1 =
      _SDL_GetQueuedAudioSize1Ptr.asFunction<int Function(int)>();

  /// Drop any queued audio data waiting to be sent to the hardware.
  ///
  /// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
  /// output devices, the hardware will start playing silence if more audio isn't
  /// queued. For capture devices, the hardware will start filling the empty
  /// queue with new data if the capture device isn't paused.
  ///
  /// This will not prevent playback of queued audio that's already been sent to
  /// the hardware, as we can not undo that, so expect there to be some fraction
  /// of a second of audio that might still be heard. This can be useful if you
  /// want to, say, drop any pending music or any unprocessed microphone input
  /// during a level change in your game.
  ///
  /// You may not queue or dequeue audio on a device that is using an
  /// application-supplied callback; calling this function on such a device
  /// always returns 0. You have to use the audio callback or queue audio, but
  /// not both.
  ///
  /// You should not call SDL_LockAudio() on the device before clearing the
  /// queue; SDL handles locking internally for this function.
  ///
  /// This function always succeeds and thus returns void.
  ///
  /// \param dev the device ID of which to clear the audio queue
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetQueuedAudioSize
  /// \sa SDL_QueueAudio
  /// \sa SDL_DequeueAudio
  void SDL_ClearQueuedAudio1(
    int dev,
  ) {
    return _SDL_ClearQueuedAudio1(
      dev,
    );
  }

  late final _SDL_ClearQueuedAudio1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_ClearQueuedAudio');
  late final _SDL_ClearQueuedAudio1 =
      _SDL_ClearQueuedAudio1Ptr.asFunction<void Function(int)>();

  /// This function is a legacy means of locking the audio device.
  ///
  /// New programs might want to use SDL_LockAudioDevice() instead. This function
  /// is equivalent to calling...
  ///
  /// ```c
  /// SDL_LockAudioDevice(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudioDevice
  /// \sa SDL_UnlockAudio
  /// \sa SDL_UnlockAudioDevice
  void SDL_LockAudio1() {
    return _SDL_LockAudio1();
  }

  late final _SDL_LockAudio1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockAudio');
  late final _SDL_LockAudio1 = _SDL_LockAudio1Ptr.asFunction<void Function()>();

  /// Use this function to lock out the audio callback function for a specified
  /// device.
  ///
  /// The lock manipulated by these functions protects the audio callback
  /// function specified in SDL_OpenAudioDevice(). During a
  /// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed
  /// that the callback function for that device is not running, even if the
  /// device is not paused. While a device is locked, any other unpaused,
  /// unlocked devices may still run their callbacks.
  ///
  /// Calling this function from inside your audio callback is unnecessary. SDL
  /// obtains this lock before calling your function, and releases it when the
  /// function returns.
  ///
  /// You should not hold the lock longer than absolutely necessary. If you hold
  /// it too long, you'll experience dropouts in your audio playback. Ideally,
  /// your application locks the device, sets a few variables and unlocks again.
  /// Do not do heavy work while holding the lock for a device.
  ///
  /// It is safe to lock the audio device multiple times, as long as you unlock
  /// it an equivalent number of times. The callback will not run until the
  /// device has been unlocked completely in this way. If your application fails
  /// to unlock the device appropriately, your callback will never run, you might
  /// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably
  /// deadlock.
  ///
  /// Internally, the audio device lock is a mutex; if you lock from two threads
  /// at once, not only will you block the audio callback, you'll block the other
  /// thread.
  ///
  /// \param dev the ID of the device to be locked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UnlockAudioDevice
  void SDL_LockAudioDevice1(
    int dev,
  ) {
    return _SDL_LockAudioDevice1(
      dev,
    );
  }

  late final _SDL_LockAudioDevice1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_LockAudioDevice');
  late final _SDL_LockAudioDevice1 =
      _SDL_LockAudioDevice1Ptr.asFunction<void Function(int)>();

  /// This function is a legacy means of unlocking the audio device.
  ///
  /// New programs might want to use SDL_UnlockAudioDevice() instead. This
  /// function is equivalent to calling...
  ///
  /// ```c
  /// SDL_UnlockAudioDevice(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudio
  /// \sa SDL_UnlockAudioDevice
  void SDL_UnlockAudio1() {
    return _SDL_UnlockAudio1();
  }

  late final _SDL_UnlockAudio1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockAudio');
  late final _SDL_UnlockAudio1 =
      _SDL_UnlockAudio1Ptr.asFunction<void Function()>();

  /// Use this function to unlock the audio callback function for a specified
  /// device.
  ///
  /// This function should be paired with a previous SDL_LockAudioDevice() call.
  ///
  /// \param dev the ID of the device to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockAudioDevice
  void SDL_UnlockAudioDevice1(
    int dev,
  ) {
    return _SDL_UnlockAudioDevice1(
      dev,
    );
  }

  late final _SDL_UnlockAudioDevice1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_UnlockAudioDevice');
  late final _SDL_UnlockAudioDevice1 =
      _SDL_UnlockAudioDevice1Ptr.asFunction<void Function(int)>();

  /// This function is a legacy means of closing the audio device.
  ///
  /// This function is equivalent to calling...
  ///
  /// ```c
  /// SDL_CloseAudioDevice(1);
  /// ```
  ///
  /// ...and is only useful if you used the legacy SDL_OpenAudio() function.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_OpenAudio
  void SDL_CloseAudio1() {
    return _SDL_CloseAudio1();
  }

  late final _SDL_CloseAudio1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_CloseAudio');
  late final _SDL_CloseAudio1 =
      _SDL_CloseAudio1Ptr.asFunction<void Function()>();

  /// Use this function to shut down audio processing and close the audio device.
  ///
  /// The application should close open audio devices once they are no longer
  /// needed. Calling this function will wait until the device's audio callback
  /// is not running, release the audio hardware and then clean up internal
  /// state. No further audio will play from this device once this function
  /// returns.
  ///
  /// This function may block briefly while pending audio data is played by the
  /// hardware, so that applications don't drop the last buffer of data they
  /// supplied.
  ///
  /// The device ID is invalid as soon as the device is closed, and is eligible
  /// for reuse in a new SDL_OpenAudioDevice() call immediately.
  ///
  /// \param dev an audio device previously opened with SDL_OpenAudioDevice()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_OpenAudioDevice
  void SDL_CloseAudioDevice1(
    int dev,
  ) {
    return _SDL_CloseAudioDevice1(
      dev,
    );
  }

  late final _SDL_CloseAudioDevice1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_CloseAudioDevice');
  late final _SDL_CloseAudioDevice1 =
      _SDL_CloseAudioDevice1Ptr.asFunction<void Function(int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform16() {
    return _SDL_GetPlatform16();
  }

  late final _SDL_GetPlatform16Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform16 =
      _SDL_GetPlatform16Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc15(
    int size,
  ) {
    return _SDL_malloc15(
      size,
    );
  }

  late final _SDL_malloc15Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc15 =
      _SDL_malloc15Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc15(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc15(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc15 =
      _SDL_calloc15Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc15(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc15(
      mem,
      size,
    );
  }

  late final _SDL_realloc15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc15 = _SDL_realloc15Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free15(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free15(
      mem,
    );
  }

  late final _SDL_free15Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free15 =
      _SDL_free15Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions15(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions15(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions15 =
      _SDL_GetMemoryFunctions15Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions15(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions15(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions15 =
      _SDL_SetMemoryFunctions15Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations15() {
    return _SDL_GetNumAllocations15();
  }

  late final _SDL_GetNumAllocations15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations15 =
      _SDL_GetNumAllocations15Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv15(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv15(
      name,
    );
  }

  late final _SDL_getenv15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv15 = _SDL_getenv15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv15(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv15(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv15 = _SDL_setenv15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort15(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort15(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort15 = _SDL_qsort15Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs15(
    int x,
  ) {
    return _SDL_abs15(
      x,
    );
  }

  late final _SDL_abs15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs15 = _SDL_abs15Ptr.asFunction<int Function(int)>();

  int SDL_isalpha15(
    int x,
  ) {
    return _SDL_isalpha15(
      x,
    );
  }

  late final _SDL_isalpha15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha15 = _SDL_isalpha15Ptr.asFunction<int Function(int)>();

  int SDL_isalnum15(
    int x,
  ) {
    return _SDL_isalnum15(
      x,
    );
  }

  late final _SDL_isalnum15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum15 = _SDL_isalnum15Ptr.asFunction<int Function(int)>();

  int SDL_isblank15(
    int x,
  ) {
    return _SDL_isblank15(
      x,
    );
  }

  late final _SDL_isblank15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank15 = _SDL_isblank15Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl15(
    int x,
  ) {
    return _SDL_iscntrl15(
      x,
    );
  }

  late final _SDL_iscntrl15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl15 = _SDL_iscntrl15Ptr.asFunction<int Function(int)>();

  int SDL_isdigit15(
    int x,
  ) {
    return _SDL_isdigit15(
      x,
    );
  }

  late final _SDL_isdigit15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit15 = _SDL_isdigit15Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit15(
    int x,
  ) {
    return _SDL_isxdigit15(
      x,
    );
  }

  late final _SDL_isxdigit15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit15 =
      _SDL_isxdigit15Ptr.asFunction<int Function(int)>();

  int SDL_ispunct15(
    int x,
  ) {
    return _SDL_ispunct15(
      x,
    );
  }

  late final _SDL_ispunct15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct15 = _SDL_ispunct15Ptr.asFunction<int Function(int)>();

  int SDL_isspace15(
    int x,
  ) {
    return _SDL_isspace15(
      x,
    );
  }

  late final _SDL_isspace15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace15 = _SDL_isspace15Ptr.asFunction<int Function(int)>();

  int SDL_isupper15(
    int x,
  ) {
    return _SDL_isupper15(
      x,
    );
  }

  late final _SDL_isupper15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper15 = _SDL_isupper15Ptr.asFunction<int Function(int)>();

  int SDL_islower15(
    int x,
  ) {
    return _SDL_islower15(
      x,
    );
  }

  late final _SDL_islower15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower15 = _SDL_islower15Ptr.asFunction<int Function(int)>();

  int SDL_isprint15(
    int x,
  ) {
    return _SDL_isprint15(
      x,
    );
  }

  late final _SDL_isprint15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint15 = _SDL_isprint15Ptr.asFunction<int Function(int)>();

  int SDL_isgraph15(
    int x,
  ) {
    return _SDL_isgraph15(
      x,
    );
  }

  late final _SDL_isgraph15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph15 = _SDL_isgraph15Ptr.asFunction<int Function(int)>();

  int SDL_toupper15(
    int x,
  ) {
    return _SDL_toupper15(
      x,
    );
  }

  late final _SDL_toupper15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper15 = _SDL_toupper15Ptr.asFunction<int Function(int)>();

  int SDL_tolower15(
    int x,
  ) {
    return _SDL_tolower15(
      x,
    );
  }

  late final _SDL_tolower15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower15 = _SDL_tolower15Ptr.asFunction<int Function(int)>();

  int SDL_crc3215(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3215(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3215Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3215 = _SDL_crc3215Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset15(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset15(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset15 = _SDL_memset15Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy15(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy15(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy15 = _SDL_memcpy15Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove15(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove15(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove15 = _SDL_memmove15Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp15(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp15(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp15 = _SDL_memcmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen15(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen15(
      wstr,
    );
  }

  late final _SDL_wcslen15Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen15 =
      _SDL_wcslen15Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy15(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy15(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy15 = _SDL_wcslcpy15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat15(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat15(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat15 = _SDL_wcslcat15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup15(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup15(
      wstr,
    );
  }

  late final _SDL_wcsdup15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup15 = _SDL_wcsdup15Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr15(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr15(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr15 = _SDL_wcsstr15Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp15(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp15(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp15 = _SDL_wcscmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp15(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp15(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp15 = _SDL_wcsncmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp15(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp15(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp15 = _SDL_wcscasecmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp15(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp15(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp15 = _SDL_wcsncasecmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen15(
      str,
    );
  }

  late final _SDL_strlen15Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen15 =
      _SDL_strlen15Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy15(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy15(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy15 = _SDL_strlcpy15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy15(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy15(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy15 = _SDL_utf8strlcpy15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat15(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat15(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat15 = _SDL_strlcat15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup15(
      str,
    );
  }

  late final _SDL_strdup15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup15 = _SDL_strdup15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev15(
      str,
    );
  }

  late final _SDL_strrev15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev15 = _SDL_strrev15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr15(
      str,
    );
  }

  late final _SDL_strupr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr15 = _SDL_strupr15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr15(
      str,
    );
  }

  late final _SDL_strlwr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr15 = _SDL_strlwr15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr15(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr15(
      str,
      c,
    );
  }

  late final _SDL_strchr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr15 = _SDL_strchr15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr15(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr15(
      str,
      c,
    );
  }

  late final _SDL_strrchr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr15 = _SDL_strrchr15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr15(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr15(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr15 = _SDL_strstr15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr15(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr15(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr15 = _SDL_strtokr15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen15(
      str,
    );
  }

  late final _SDL_utf8strlen15Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen15 =
      _SDL_utf8strlen15Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa15(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa15(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa15 = _SDL_itoa15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa15(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa15(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa15 = _SDL_uitoa15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa15(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa15(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa15 = _SDL_ltoa15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa15(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa15(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa15 = _SDL_ultoa15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa15(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa15(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa15 = _SDL_lltoa15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa15(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa15(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa15 = _SDL_ulltoa15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi15(
      str,
    );
  }

  late final _SDL_atoi15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi15 =
      _SDL_atoi15Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof15(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof15(
      str,
    );
  }

  late final _SDL_atof15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof15 =
      _SDL_atof15Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol15(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol15(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol15 = _SDL_strtol15Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul15(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul15(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul15 = _SDL_strtoul15Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll15(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll15(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll15Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll15 = _SDL_strtoll15Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull15(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull15(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull15Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull15 = _SDL_strtoull15Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod15(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod15(
      str,
      endp,
    );
  }

  late final _SDL_strtod15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod15 = _SDL_strtod15Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp15(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp15(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp15 = _SDL_strcmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp15(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp15(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp15 = _SDL_strncmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp15(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp15(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp15 = _SDL_strcasecmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp15(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp15(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp15 = _SDL_strncasecmp15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf15(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf15(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf15 = _SDL_sscanf15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf15(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf15(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf15 = _SDL_vsscanf15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf15(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf15(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf15 = _SDL_snprintf15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf15(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf15(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf15 = _SDL_vsnprintf15Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf15(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf15(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf15 = _SDL_asprintf15Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf15(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf15(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf15 = _SDL_vasprintf15Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos15(
    double x,
  ) {
    return _SDL_acos15(
      x,
    );
  }

  late final _SDL_acos15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos15 = _SDL_acos15Ptr.asFunction<double Function(double)>();

  double SDL_acosf15(
    double x,
  ) {
    return _SDL_acosf15(
      x,
    );
  }

  late final _SDL_acosf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf15 =
      _SDL_acosf15Ptr.asFunction<double Function(double)>();

  double SDL_asin15(
    double x,
  ) {
    return _SDL_asin15(
      x,
    );
  }

  late final _SDL_asin15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin15 = _SDL_asin15Ptr.asFunction<double Function(double)>();

  double SDL_asinf15(
    double x,
  ) {
    return _SDL_asinf15(
      x,
    );
  }

  late final _SDL_asinf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf15 =
      _SDL_asinf15Ptr.asFunction<double Function(double)>();

  double SDL_atan16(
    double x,
  ) {
    return _SDL_atan16(
      x,
    );
  }

  late final _SDL_atan16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan16 = _SDL_atan16Ptr.asFunction<double Function(double)>();

  double SDL_atanf15(
    double x,
  ) {
    return _SDL_atanf15(
      x,
    );
  }

  late final _SDL_atanf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf15 =
      _SDL_atanf15Ptr.asFunction<double Function(double)>();

  double SDL_atan215(
    double y,
    double x,
  ) {
    return _SDL_atan215(
      y,
      x,
    );
  }

  late final _SDL_atan215Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan215 =
      _SDL_atan215Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f15(
    double y,
    double x,
  ) {
    return _SDL_atan2f15(
      y,
      x,
    );
  }

  late final _SDL_atan2f15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f15 =
      _SDL_atan2f15Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil15(
    double x,
  ) {
    return _SDL_ceil15(
      x,
    );
  }

  late final _SDL_ceil15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil15 = _SDL_ceil15Ptr.asFunction<double Function(double)>();

  double SDL_ceilf15(
    double x,
  ) {
    return _SDL_ceilf15(
      x,
    );
  }

  late final _SDL_ceilf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf15 =
      _SDL_ceilf15Ptr.asFunction<double Function(double)>();

  double SDL_copysign15(
    double x,
    double y,
  ) {
    return _SDL_copysign15(
      x,
      y,
    );
  }

  late final _SDL_copysign15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign15 =
      _SDL_copysign15Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf15(
    double x,
    double y,
  ) {
    return _SDL_copysignf15(
      x,
      y,
    );
  }

  late final _SDL_copysignf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf15 =
      _SDL_copysignf15Ptr.asFunction<double Function(double, double)>();

  double SDL_cos15(
    double x,
  ) {
    return _SDL_cos15(
      x,
    );
  }

  late final _SDL_cos15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos15 = _SDL_cos15Ptr.asFunction<double Function(double)>();

  double SDL_cosf15(
    double x,
  ) {
    return _SDL_cosf15(
      x,
    );
  }

  late final _SDL_cosf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf15 = _SDL_cosf15Ptr.asFunction<double Function(double)>();

  double SDL_exp15(
    double x,
  ) {
    return _SDL_exp15(
      x,
    );
  }

  late final _SDL_exp15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp15 = _SDL_exp15Ptr.asFunction<double Function(double)>();

  double SDL_expf15(
    double x,
  ) {
    return _SDL_expf15(
      x,
    );
  }

  late final _SDL_expf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf15 = _SDL_expf15Ptr.asFunction<double Function(double)>();

  double SDL_fabs15(
    double x,
  ) {
    return _SDL_fabs15(
      x,
    );
  }

  late final _SDL_fabs15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs15 = _SDL_fabs15Ptr.asFunction<double Function(double)>();

  double SDL_fabsf15(
    double x,
  ) {
    return _SDL_fabsf15(
      x,
    );
  }

  late final _SDL_fabsf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf15 =
      _SDL_fabsf15Ptr.asFunction<double Function(double)>();

  double SDL_floor15(
    double x,
  ) {
    return _SDL_floor15(
      x,
    );
  }

  late final _SDL_floor15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor15 =
      _SDL_floor15Ptr.asFunction<double Function(double)>();

  double SDL_floorf15(
    double x,
  ) {
    return _SDL_floorf15(
      x,
    );
  }

  late final _SDL_floorf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf15 =
      _SDL_floorf15Ptr.asFunction<double Function(double)>();

  double SDL_trunc15(
    double x,
  ) {
    return _SDL_trunc15(
      x,
    );
  }

  late final _SDL_trunc15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc15 =
      _SDL_trunc15Ptr.asFunction<double Function(double)>();

  double SDL_truncf15(
    double x,
  ) {
    return _SDL_truncf15(
      x,
    );
  }

  late final _SDL_truncf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf15 =
      _SDL_truncf15Ptr.asFunction<double Function(double)>();

  double SDL_fmod15(
    double x,
    double y,
  ) {
    return _SDL_fmod15(
      x,
      y,
    );
  }

  late final _SDL_fmod15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod15 =
      _SDL_fmod15Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf15(
    double x,
    double y,
  ) {
    return _SDL_fmodf15(
      x,
      y,
    );
  }

  late final _SDL_fmodf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf15 =
      _SDL_fmodf15Ptr.asFunction<double Function(double, double)>();

  double SDL_log16(
    double x,
  ) {
    return _SDL_log16(
      x,
    );
  }

  late final _SDL_log16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log16 = _SDL_log16Ptr.asFunction<double Function(double)>();

  double SDL_logf15(
    double x,
  ) {
    return _SDL_logf15(
      x,
    );
  }

  late final _SDL_logf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf15 = _SDL_logf15Ptr.asFunction<double Function(double)>();

  double SDL_log1015(
    double x,
  ) {
    return _SDL_log1015(
      x,
    );
  }

  late final _SDL_log1015Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1015 =
      _SDL_log1015Ptr.asFunction<double Function(double)>();

  double SDL_log10f15(
    double x,
  ) {
    return _SDL_log10f15(
      x,
    );
  }

  late final _SDL_log10f15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f15 =
      _SDL_log10f15Ptr.asFunction<double Function(double)>();

  double SDL_pow15(
    double x,
    double y,
  ) {
    return _SDL_pow15(
      x,
      y,
    );
  }

  late final _SDL_pow15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow15 =
      _SDL_pow15Ptr.asFunction<double Function(double, double)>();

  double SDL_powf15(
    double x,
    double y,
  ) {
    return _SDL_powf15(
      x,
      y,
    );
  }

  late final _SDL_powf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf15 =
      _SDL_powf15Ptr.asFunction<double Function(double, double)>();

  double SDL_round15(
    double x,
  ) {
    return _SDL_round15(
      x,
    );
  }

  late final _SDL_round15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round15 =
      _SDL_round15Ptr.asFunction<double Function(double)>();

  double SDL_roundf15(
    double x,
  ) {
    return _SDL_roundf15(
      x,
    );
  }

  late final _SDL_roundf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf15 =
      _SDL_roundf15Ptr.asFunction<double Function(double)>();

  int SDL_lround15(
    double x,
  ) {
    return _SDL_lround15(
      x,
    );
  }

  late final _SDL_lround15Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround15 =
      _SDL_lround15Ptr.asFunction<int Function(double)>();

  int SDL_lroundf15(
    double x,
  ) {
    return _SDL_lroundf15(
      x,
    );
  }

  late final _SDL_lroundf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf15 =
      _SDL_lroundf15Ptr.asFunction<int Function(double)>();

  double SDL_scalbn15(
    double x,
    int n,
  ) {
    return _SDL_scalbn15(
      x,
      n,
    );
  }

  late final _SDL_scalbn15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn15 =
      _SDL_scalbn15Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf15(
    double x,
    int n,
  ) {
    return _SDL_scalbnf15(
      x,
      n,
    );
  }

  late final _SDL_scalbnf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf15 =
      _SDL_scalbnf15Ptr.asFunction<double Function(double, int)>();

  double SDL_sin15(
    double x,
  ) {
    return _SDL_sin15(
      x,
    );
  }

  late final _SDL_sin15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin15 = _SDL_sin15Ptr.asFunction<double Function(double)>();

  double SDL_sinf15(
    double x,
  ) {
    return _SDL_sinf15(
      x,
    );
  }

  late final _SDL_sinf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf15 = _SDL_sinf15Ptr.asFunction<double Function(double)>();

  double SDL_sqrt15(
    double x,
  ) {
    return _SDL_sqrt15(
      x,
    );
  }

  late final _SDL_sqrt15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt15 = _SDL_sqrt15Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf15(
    double x,
  ) {
    return _SDL_sqrtf15(
      x,
    );
  }

  late final _SDL_sqrtf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf15 =
      _SDL_sqrtf15Ptr.asFunction<double Function(double)>();

  double SDL_tan15(
    double x,
  ) {
    return _SDL_tan15(
      x,
    );
  }

  late final _SDL_tan15Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan15 = _SDL_tan15Ptr.asFunction<double Function(double)>();

  double SDL_tanf15(
    double x,
  ) {
    return _SDL_tanf15(
      x,
    );
  }

  late final _SDL_tanf15Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf15 = _SDL_tanf15Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open15(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open15(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open15Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open15 = _SDL_iconv_open15Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close15(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close15(
      cd,
    );
  }

  late final _SDL_iconv_close15Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close15 =
      _SDL_iconv_close15Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv15(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv15(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv15 = _SDL_iconv15Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string15(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string15(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string15 = _SDL_iconv_string15Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError9(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError9(
      fmt,
    );
  }

  late final _SDL_SetError9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError9 =
      _SDL_SetError9Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError9() {
    return _SDL_GetError9();
  }

  late final _SDL_GetError9Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError9 =
      _SDL_GetError9Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg9(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg9(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg9 = _SDL_GetErrorMsg9Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError9() {
    return _SDL_ClearError9();
  }

  late final _SDL_ClearError9Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError9 =
      _SDL_ClearError9Ptr.asFunction<void Function()>();

  int SDL_Error9(
    int code,
  ) {
    return _SDL_Error9(
      code,
    );
  }

  late final _SDL_Error9Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error9 = _SDL_Error9Ptr.asFunction<int Function(int)>();

  /// Try to lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  /// \returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already
  /// held.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicUnlock
  int SDL_AtomicTryLock2(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicTryLock2(
      lock,
    );
  }

  late final _SDL_AtomicTryLock2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_SpinLock>)>>(
      'SDL_AtomicTryLock');
  late final _SDL_AtomicTryLock2 = _SDL_AtomicTryLock2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicTryLock
  /// \sa SDL_AtomicUnlock
  void SDL_AtomicLock2(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicLock2(
      lock,
    );
  }

  late final _SDL_AtomicLock2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicLock');
  late final _SDL_AtomicLock2 = _SDL_AtomicLock2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Unlock a spin lock by setting it to 0.
  ///
  /// Always returns immediately.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicTryLock
  void SDL_AtomicUnlock2(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicUnlock2(
      lock,
    );
  }

  late final _SDL_AtomicUnlock2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicUnlock');
  late final _SDL_AtomicUnlock2 = _SDL_AtomicUnlock2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Memory barriers are designed to prevent reads and writes from being
  /// reordered by the compiler and being seen out of order on multi-core CPUs.
  ///
  /// A typical pattern would be for thread A to write some data and a flag, and
  /// for thread B to read the flag and get the data. In this case you would
  /// insert a release barrier between writing the data and the flag,
  /// guaranteeing that the data write completes no later than the flag is
  /// written, and you would insert an acquire barrier between reading the flag
  /// and reading the data, to ensure that all the reads associated with the flag
  /// have completed.
  ///
  /// In this pattern you should always see a release barrier paired with an
  /// acquire barrier and you should gate the data reads/writes with a single
  /// flag variable.
  ///
  /// For more information on these semantics, take a look at the blog post:
  /// http://preshing.com/20120913/acquire-and-release-semantics
  ///
  /// \since This function is available since SDL 2.0.6.
  void SDL_MemoryBarrierReleaseFunction2() {
    return _SDL_MemoryBarrierReleaseFunction2();
  }

  late final _SDL_MemoryBarrierReleaseFunction2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierReleaseFunction');
  late final _SDL_MemoryBarrierReleaseFunction2 =
      _SDL_MemoryBarrierReleaseFunction2Ptr.asFunction<void Function()>();

  void SDL_MemoryBarrierAcquireFunction2() {
    return _SDL_MemoryBarrierAcquireFunction2();
  }

  late final _SDL_MemoryBarrierAcquireFunction2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierAcquireFunction');
  late final _SDL_MemoryBarrierAcquireFunction2 =
      _SDL_MemoryBarrierAcquireFunction2Ptr.asFunction<void Function()>();

  /// Set an atomic variable to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param oldval the old value
  /// \param newval the new value
  /// \returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGet
  /// \sa SDL_AtomicSet
  int SDL_AtomicCAS2(
    ffi.Pointer<SDL_atomic_t> a,
    int oldval,
    int newval,
  ) {
    return _SDL_AtomicCAS2(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCAS2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int, ffi.Int)>>('SDL_AtomicCAS');
  late final _SDL_AtomicCAS2 = _SDL_AtomicCAS2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int, int)>();

  /// Set an atomic variable to a value.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicGet
  int SDL_AtomicSet2(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicSet2(
      a,
      v,
    );
  }

  late final _SDL_AtomicSet2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicSet');
  late final _SDL_AtomicSet2 = _SDL_AtomicSet2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Get the value of an atomic variable.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable
  /// \returns the current value of an atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicSet
  int SDL_AtomicGet2(
    ffi.Pointer<SDL_atomic_t> a,
  ) {
    return _SDL_AtomicGet2(
      a,
    );
  }

  late final _SDL_AtomicGet2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_atomic_t>)>>(
          'SDL_AtomicGet');
  late final _SDL_AtomicGet2 =
      _SDL_AtomicGet2Ptr.asFunction<int Function(ffi.Pointer<SDL_atomic_t>)>();

  /// Add to an atomic variable.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value to add
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicDecRef
  /// \sa SDL_AtomicIncRef
  int SDL_AtomicAdd2(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicAdd2(
      a,
      v,
    );
  }

  late final _SDL_AtomicAdd2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicAdd');
  late final _SDL_AtomicAdd2 = _SDL_AtomicAdd2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Set a pointer to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param oldval the old pointer value
  /// \param newval the new pointer value
  /// \returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCAS
  /// \sa SDL_AtomicGetPtr
  /// \sa SDL_AtomicSetPtr
  int SDL_AtomicCASPtr2(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> oldval,
    ffi.Pointer<ffi.Void> newval,
  ) {
    return _SDL_AtomicCASPtr2(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicCASPtr');
  late final _SDL_AtomicCASPtr2 = _SDL_AtomicCASPtr2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// Set a pointer to a value atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param v the desired pointer value
  /// \returns the previous value of the pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicSetPtr2(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> v,
  ) {
    return _SDL_AtomicSetPtr2(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicSetPtr');
  late final _SDL_AtomicSetPtr2 = _SDL_AtomicSetPtr2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>)>();

  /// Get the value of a pointer atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \returns the current value of a pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicSetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicGetPtr2(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ) {
    return _SDL_AtomicGetPtr2(
      a,
    );
  }

  late final _SDL_AtomicGetPtr2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_AtomicGetPtr');
  late final _SDL_AtomicGetPtr2 = _SDL_AtomicGetPtr2Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Create a new mutex.
  ///
  /// All newly-created mutexes begin in the _unlocked_ state.
  ///
  /// Calls to SDL_LockMutex() will not return while the mutex is locked by
  /// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
  ///
  /// SDL mutexes are reentrant.
  ///
  /// \returns the initialized and unlocked mutex or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  ffi.Pointer<SDL_mutex> SDL_CreateMutex2() {
    return _SDL_CreateMutex2();
  }

  late final _SDL_CreateMutex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_mutex> Function()>>(
          'SDL_CreateMutex');
  late final _SDL_CreateMutex2 =
      _SDL_CreateMutex2Ptr.asFunction<ffi.Pointer<SDL_mutex> Function()>();

  /// Lock the mutex.
  ///
  /// This will block until the mutex is available, which is to say it is in the
  /// unlocked state and the OS has chosen the caller as the next thread to lock
  /// it. Of all threads waiting to lock the mutex, only one may do so at a time.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// \param mutex the mutex to lock
  /// \return 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_LockMutex2(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_LockMutex2(
      mutex,
    );
  }

  late final _SDL_LockMutex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_LockMutex');
  late final _SDL_LockMutex2 =
      _SDL_LockMutex2Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Try to lock a mutex without blocking.
  ///
  /// This works just like SDL_LockMutex(), but if the mutex is not available,
  /// this function returns `SDL_MUTEX_TIMEOUT` immediately.
  ///
  /// This technique is useful if you need exclusive access to a resource but
  /// don't want to wait for it, and will return to it to try again later.
  ///
  /// \param mutex the mutex to try to lock
  /// \returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_UnlockMutex
  int SDL_TryLockMutex2(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_TryLockMutex2(
      mutex,
    );
  }

  late final _SDL_TryLockMutex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_TryLockMutex');
  late final _SDL_TryLockMutex2 =
      _SDL_TryLockMutex2Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Unlock the mutex.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// It is an error to unlock a mutex that has not been locked by the current
  /// thread, and doing so results in undefined behavior.
  ///
  /// It is also an error to unlock a mutex that isn't locked at all.
  ///
  /// \param mutex the mutex to unlock.
  /// \returns 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_UnlockMutex2(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_UnlockMutex2(
      mutex,
    );
  }

  late final _SDL_UnlockMutex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_UnlockMutex');
  late final _SDL_UnlockMutex2 =
      _SDL_UnlockMutex2Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Destroy a mutex created with SDL_CreateMutex().
  ///
  /// This function must be called on any mutex that is no longer needed. Failure
  /// to destroy a mutex will result in a system memory or resource leak. While
  /// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
  /// to destroy a locked mutex, and may result in undefined behavior depending
  /// on the platform.
  ///
  /// \param mutex the mutex to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  void SDL_DestroyMutex2(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_DestroyMutex2(
      mutex,
    );
  }

  late final _SDL_DestroyMutex2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_DestroyMutex');
  late final _SDL_DestroyMutex2 =
      _SDL_DestroyMutex2Ptr.asFunction<void Function(ffi.Pointer<SDL_mutex>)>();

  /// Create a semaphore.
  ///
  /// This function creates a new semaphore and initializes it with the value
  /// `initial_value`. Each wait operation on the semaphore will atomically
  /// decrement the semaphore value and potentially block if the semaphore value
  /// is 0. Each post operation will atomically increment the semaphore value and
  /// wake waiting threads and allow them to retry the wait operation.
  ///
  /// \param initial_value the starting value of the semaphore
  /// \returns a new semaphore or NULL on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  ffi.Pointer<SDL_sem> SDL_CreateSemaphore2(
    int initial_value,
  ) {
    return _SDL_CreateSemaphore2(
      initial_value,
    );
  }

  late final _SDL_CreateSemaphore2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_sem> Function(Uint32)>>(
          'SDL_CreateSemaphore');
  late final _SDL_CreateSemaphore2 =
      _SDL_CreateSemaphore2Ptr.asFunction<ffi.Pointer<SDL_sem> Function(int)>();

  /// Destroy a semaphore.
  ///
  /// It is not safe to destroy a semaphore if there are threads currently
  /// waiting on it.
  ///
  /// \param sem the semaphore to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  void SDL_DestroySemaphore2(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_DestroySemaphore2(
      sem,
    );
  }

  late final _SDL_DestroySemaphore2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_DestroySemaphore');
  late final _SDL_DestroySemaphore2 = _SDL_DestroySemaphore2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value or the call is interrupted by a
  /// signal or error. If the call is successful it will atomically decrement the
  /// semaphore value.
  ///
  /// This function is the equivalent of calling SDL_SemWaitTimeout() with a time
  /// length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param sem the semaphore wait on
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemWait2(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemWait2(
      sem,
    );
  }

  late final _SDL_SemWait2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemWait');
  late final _SDL_SemWait2 =
      _SDL_SemWait2Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// See if a semaphore has a positive value and decrement it if it does.
  ///
  /// This function checks to see if the semaphore pointed to by `sem` has a
  /// positive value and atomically decrements the semaphore value if it does. If
  /// the semaphore doesn't have a positive value, the function immediately
  /// returns SDL_MUTEX_TIMEDOUT.
  ///
  /// \param sem the semaphore to wait on
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would
  /// block, or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemTryWait2(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemTryWait2(
      sem,
    );
  }

  late final _SDL_SemTryWait2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemTryWait');
  late final _SDL_SemTryWait2 =
      _SDL_SemTryWait2Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value, the call is interrupted by a
  /// signal or error, or the specified time has elapsed. If the call is
  /// successful it will atomically decrement the semaphore value.
  ///
  /// \param sem the semaphore to wait on
  /// \param ms the length of the timeout, in milliseconds
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not
  /// succeed in the allotted time, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  int SDL_SemWaitTimeout2(
    ffi.Pointer<SDL_sem> sem,
    int ms,
  ) {
    return _SDL_SemWaitTimeout2(
      sem,
      ms,
    );
  }

  late final _SDL_SemWaitTimeout2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>, Uint32)>>(
      'SDL_SemWaitTimeout');
  late final _SDL_SemWaitTimeout2 = _SDL_SemWaitTimeout2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_sem>, int)>();

  /// Atomically increment a semaphore's value and wake waiting threads.
  ///
  /// \param sem the semaphore to increment
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemPost2(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemPost2(
      sem,
    );
  }

  late final _SDL_SemPost2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemPost');
  late final _SDL_SemPost2 =
      _SDL_SemPost2Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Get the current value of a semaphore.
  ///
  /// \param sem the semaphore to query
  /// \returns the current value of the semaphore.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  int SDL_SemValue2(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemValue2(
      sem,
    );
  }

  late final _SDL_SemValue2Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemValue');
  late final _SDL_SemValue2 =
      _SDL_SemValue2Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Create a condition variable.
  ///
  /// \returns a new condition variable or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_DestroyCond
  ffi.Pointer<SDL_cond> SDL_CreateCond2() {
    return _SDL_CreateCond2();
  }

  late final _SDL_CreateCond2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_cond> Function()>>(
          'SDL_CreateCond');
  late final _SDL_CreateCond2 =
      _SDL_CreateCond2Ptr.asFunction<ffi.Pointer<SDL_cond> Function()>();

  /// Destroy a condition variable.
  ///
  /// \param cond the condition variable to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  void SDL_DestroyCond2(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_DestroyCond2(
      cond,
    );
  }

  late final _SDL_DestroyCond2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_DestroyCond');
  late final _SDL_DestroyCond2 =
      _SDL_DestroyCond2Ptr.asFunction<void Function(ffi.Pointer<SDL_cond>)>();

  /// Restart one of the threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondSignal2(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondSignal2(
      cond,
    );
  }

  late final _SDL_CondSignal2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondSignal');
  late final _SDL_CondSignal2 =
      _SDL_CondSignal2Ptr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Restart all threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondBroadcast2(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondBroadcast2(
      cond,
    );
  }

  late final _SDL_CondBroadcast2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondBroadcast');
  late final _SDL_CondBroadcast2 =
      _SDL_CondBroadcast2Ptr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Wait until a condition variable is signaled.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`. Once the condition variable is signaled, the mutex is re-locked and
  /// the function returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// This function is the equivalent of calling SDL_CondWaitTimeout() with a
  /// time length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \returns 0 when it is signaled or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWait2(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_CondWait2(
      cond,
      mutex,
    );
  }

  late final _SDL_CondWait2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>>('SDL_CondWait');
  late final _SDL_CondWait2 = _SDL_CondWait2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>();

  /// Wait until a condition variable is signaled or a certain time has passed.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`, or for the specified time to elapse. Once the condition variable is
  /// signaled or the time elapsed, the mutex is re-locked and the function
  /// returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \param ms the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`
  /// to wait indefinitely
  /// \returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if
  /// the condition is not signaled in the allotted time, or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWaitTimeout2(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
    int ms,
  ) {
    return _SDL_CondWaitTimeout2(
      cond,
      mutex,
      ms,
    );
  }

  late final _SDL_CondWaitTimeout2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>,
              Uint32)>>('SDL_CondWaitTimeout');
  late final _SDL_CondWaitTimeout2 = _SDL_CondWaitTimeout2Ptr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>, int)>();

  ffi.Pointer<SDL_Thread> SDL_CreateThread2(
    SDL_ThreadFunction fn,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThread2(
      fn,
      name,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThread2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              SDL_ThreadFunction,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThread');
  late final _SDL_CreateThread2 = _SDL_CreateThread2Ptr.asFunction<
      ffi.Pointer<SDL_Thread> Function(
          SDL_ThreadFunction,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          pfnSDL_CurrentBeginThread,
          pfnSDL_CurrentEndThread)>();

  ffi.Pointer<SDL_Thread> SDL_CreateThreadWithStackSize2(
    ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>> fn,
    ffi.Pointer<ffi.Char> name,
    int stacksize,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThreadWithStackSize2(
      fn,
      name,
      stacksize,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadWithStackSize2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThreadWithStackSize');
  late final _SDL_CreateThreadWithStackSize2 =
      _SDL_CreateThreadWithStackSize2Ptr.asFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>();

  /// Get the thread name as it was specified in SDL_CreateThread().
  ///
  /// This is internal memory, not to be freed by the caller, and remains valid
  /// until the specified thread is cleaned up by SDL_WaitThread().
  ///
  /// \param thread the thread to query
  /// \returns a pointer to a UTF-8 string that names the specified thread, or
  /// NULL if it doesn't have a name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateThread
  ffi.Pointer<ffi.Char> SDL_GetThreadName2(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadName2(
      thread,
    );
  }

  late final _SDL_GetThreadName2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Thread>)>>('SDL_GetThreadName');
  late final _SDL_GetThreadName2 = _SDL_GetThreadName2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Thread>)>();

  /// Get the thread identifier for the current thread.
  ///
  /// This thread identifier is as reported by the underlying operating system.
  /// If SDL is running on a platform that does not support threads the return
  /// value will always be zero.
  ///
  /// This function also returns a valid thread ID when called from the main
  /// thread.
  ///
  /// \returns the ID of the current thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetThreadID
  int SDL_ThreadID2() {
    return _SDL_ThreadID2();
  }

  late final _SDL_ThreadID2Ptr =
      _lookup<ffi.NativeFunction<SDL_threadID Function()>>('SDL_ThreadID');
  late final _SDL_ThreadID2 = _SDL_ThreadID2Ptr.asFunction<int Function()>();

  /// Get the thread identifier for the specified thread.
  ///
  /// This thread identifier is as reported by the underlying operating system.
  /// If SDL is running on a platform that does not support threads the return
  /// value will always be zero.
  ///
  /// \param thread the thread to query
  /// \returns the ID of the specified thread, or the ID of the current thread if
  /// `thread` is NULL.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ThreadID
  int SDL_GetThreadID2(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadID2(
      thread,
    );
  }

  late final _SDL_GetThreadID2Ptr = _lookup<
          ffi.NativeFunction<SDL_threadID Function(ffi.Pointer<SDL_Thread>)>>(
      'SDL_GetThreadID');
  late final _SDL_GetThreadID2 =
      _SDL_GetThreadID2Ptr.asFunction<int Function(ffi.Pointer<SDL_Thread>)>();

  /// Set the priority for the current thread.
  ///
  /// Note that some platforms will not let you alter the priority (or at least,
  /// promote the thread to a higher priority) at all, and some require you to be
  /// an administrator account. Be prepared for this to fail.
  ///
  /// \param priority the SDL_ThreadPriority to set
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetThreadPriority2(
    int priority,
  ) {
    return _SDL_SetThreadPriority2(
      priority,
    );
  }

  late final _SDL_SetThreadPriority2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'SDL_SetThreadPriority');
  late final _SDL_SetThreadPriority2 =
      _SDL_SetThreadPriority2Ptr.asFunction<int Function(int)>();

  /// Wait for a thread to finish.
  ///
  /// Threads that haven't been detached will remain (as a "zombie") until this
  /// function cleans them up. Not doing so is a resource leak.
  ///
  /// Once a thread has been cleaned up through this function, the SDL_Thread
  /// that references it becomes invalid and should not be referenced again. As
  /// such, only one thread may call SDL_WaitThread() on another.
  ///
  /// The return code for the thread function is placed in the area pointed to by
  /// `status`, if `status` is not NULL.
  ///
  /// You may not wait on a thread that has been used in a call to
  /// SDL_DetachThread(). Use either that function or this one, but not both, or
  /// behavior is undefined.
  ///
  /// It is safe to pass a NULL thread to this function; it is a no-op.
  ///
  /// Note that the thread pointer is freed by this function and is not valid
  /// afterward.
  ///
  /// \param thread the SDL_Thread pointer that was returned from the
  /// SDL_CreateThread() call that started this thread
  /// \param status pointer to an integer that will receive the value returned
  /// from the thread function by its 'return', or NULL to not
  /// receive such value back.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateThread
  /// \sa SDL_DetachThread
  void SDL_WaitThread2(
    ffi.Pointer<SDL_Thread> thread,
    ffi.Pointer<ffi.Int> status,
  ) {
    return _SDL_WaitThread2(
      thread,
      status,
    );
  }

  late final _SDL_WaitThread2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Thread>,
              ffi.Pointer<ffi.Int>)>>('SDL_WaitThread');
  late final _SDL_WaitThread2 = _SDL_WaitThread2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Thread>, ffi.Pointer<ffi.Int>)>();

  /// Let a thread clean up on exit without intervention.
  ///
  /// A thread may be "detached" to signify that it should not remain until
  /// another thread has called SDL_WaitThread() on it. Detaching a thread is
  /// useful for long-running threads that nothing needs to synchronize with or
  /// further manage. When a detached thread is done, it simply goes away.
  ///
  /// There is no way to recover the return code of a detached thread. If you
  /// need this, don't detach the thread and instead use SDL_WaitThread().
  ///
  /// Once a thread is detached, you should usually assume the SDL_Thread isn't
  /// safe to reference again, as it will become invalid immediately upon the
  /// detached thread's exit, instead of remaining until someone has called
  /// SDL_WaitThread() to finally clean it up. As such, don't detach the same
  /// thread more than once.
  ///
  /// If a thread has already exited when passed to SDL_DetachThread(), it will
  /// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
  /// not safe to detach a thread that might be used with SDL_WaitThread().
  ///
  /// You may not call SDL_WaitThread() on a thread that has been detached. Use
  /// either that function or this one, but not both, or behavior is undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  ///
  /// \param thread the SDL_Thread pointer that was returned from the
  /// SDL_CreateThread() call that started this thread
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_CreateThread
  /// \sa SDL_WaitThread
  void SDL_DetachThread2(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_DetachThread2(
      thread,
    );
  }

  late final _SDL_DetachThread2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Thread>)>>(
          'SDL_DetachThread');
  late final _SDL_DetachThread2 = _SDL_DetachThread2Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Thread>)>();

  /// Create a piece of thread-local storage.
  ///
  /// This creates an identifier that is globally visible to all threads but
  /// refers to data that is thread-specific.
  ///
  /// \returns the newly created thread local storage identifier or 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSGet
  /// \sa SDL_TLSSet
  int SDL_TLSCreate2() {
    return _SDL_TLSCreate2();
  }

  late final _SDL_TLSCreate2Ptr =
      _lookup<ffi.NativeFunction<SDL_TLSID Function()>>('SDL_TLSCreate');
  late final _SDL_TLSCreate2 = _SDL_TLSCreate2Ptr.asFunction<int Function()>();

  /// Get the current thread's value associated with a thread local storage ID.
  ///
  /// \param id the thread local storage ID
  /// \returns the value associated with the ID for the current thread or NULL if
  /// no value has been set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSCreate
  /// \sa SDL_TLSSet
  ffi.Pointer<ffi.Void> SDL_TLSGet2(
    int id,
  ) {
    return _SDL_TLSGet2(
      id,
    );
  }

  late final _SDL_TLSGet2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(SDL_TLSID)>>(
          'SDL_TLSGet');
  late final _SDL_TLSGet2 =
      _SDL_TLSGet2Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Set the current thread's value associated with a thread local storage ID.
  ///
  /// The function prototype for `destructor` is:
  ///
  /// ```c
  /// void destructor(void *value)
  /// ```
  ///
  /// where its parameter `value` is what was passed as `value` to SDL_TLSSet().
  ///
  /// \param id the thread local storage ID
  /// \param value the value to associate with the ID for the current thread
  /// \param destructor a function called when the thread exits, to free the
  /// value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TLSCreate
  /// \sa SDL_TLSGet
  int SDL_TLSSet2(
    int id,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        destructor,
  ) {
    return _SDL_TLSSet2(
      id,
      value,
      destructor,
    );
  }

  late final _SDL_TLSSet2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              SDL_TLSID,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_TLSSet');
  late final _SDL_TLSSet2 = _SDL_TLSSet2Ptr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// Cleanup all TLS data for this thread.
  ///
  /// \since This function is available since SDL 2.0.16.
  void SDL_TLSCleanup2() {
    return _SDL_TLSCleanup2();
  }

  late final _SDL_TLSCleanup2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_TLSCleanup');
  late final _SDL_TLSCleanup2 =
      _SDL_TLSCleanup2Ptr.asFunction<void Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform17() {
    return _SDL_GetPlatform17();
  }

  late final _SDL_GetPlatform17Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform17 =
      _SDL_GetPlatform17Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc16(
    int size,
  ) {
    return _SDL_malloc16(
      size,
    );
  }

  late final _SDL_malloc16Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc16 =
      _SDL_malloc16Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc16(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc16(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc16 =
      _SDL_calloc16Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc16(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc16(
      mem,
      size,
    );
  }

  late final _SDL_realloc16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc16 = _SDL_realloc16Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free16(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free16(
      mem,
    );
  }

  late final _SDL_free16Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free16 =
      _SDL_free16Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions16(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions16(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions16 =
      _SDL_GetMemoryFunctions16Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions16(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions16(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions16 =
      _SDL_SetMemoryFunctions16Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations16() {
    return _SDL_GetNumAllocations16();
  }

  late final _SDL_GetNumAllocations16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations16 =
      _SDL_GetNumAllocations16Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv16(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv16(
      name,
    );
  }

  late final _SDL_getenv16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv16 = _SDL_getenv16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv16(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv16(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv16 = _SDL_setenv16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort16(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort16(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort16 = _SDL_qsort16Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs16(
    int x,
  ) {
    return _SDL_abs16(
      x,
    );
  }

  late final _SDL_abs16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs16 = _SDL_abs16Ptr.asFunction<int Function(int)>();

  int SDL_isalpha16(
    int x,
  ) {
    return _SDL_isalpha16(
      x,
    );
  }

  late final _SDL_isalpha16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha16 = _SDL_isalpha16Ptr.asFunction<int Function(int)>();

  int SDL_isalnum16(
    int x,
  ) {
    return _SDL_isalnum16(
      x,
    );
  }

  late final _SDL_isalnum16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum16 = _SDL_isalnum16Ptr.asFunction<int Function(int)>();

  int SDL_isblank16(
    int x,
  ) {
    return _SDL_isblank16(
      x,
    );
  }

  late final _SDL_isblank16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank16 = _SDL_isblank16Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl16(
    int x,
  ) {
    return _SDL_iscntrl16(
      x,
    );
  }

  late final _SDL_iscntrl16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl16 = _SDL_iscntrl16Ptr.asFunction<int Function(int)>();

  int SDL_isdigit16(
    int x,
  ) {
    return _SDL_isdigit16(
      x,
    );
  }

  late final _SDL_isdigit16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit16 = _SDL_isdigit16Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit16(
    int x,
  ) {
    return _SDL_isxdigit16(
      x,
    );
  }

  late final _SDL_isxdigit16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit16 =
      _SDL_isxdigit16Ptr.asFunction<int Function(int)>();

  int SDL_ispunct16(
    int x,
  ) {
    return _SDL_ispunct16(
      x,
    );
  }

  late final _SDL_ispunct16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct16 = _SDL_ispunct16Ptr.asFunction<int Function(int)>();

  int SDL_isspace16(
    int x,
  ) {
    return _SDL_isspace16(
      x,
    );
  }

  late final _SDL_isspace16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace16 = _SDL_isspace16Ptr.asFunction<int Function(int)>();

  int SDL_isupper16(
    int x,
  ) {
    return _SDL_isupper16(
      x,
    );
  }

  late final _SDL_isupper16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper16 = _SDL_isupper16Ptr.asFunction<int Function(int)>();

  int SDL_islower16(
    int x,
  ) {
    return _SDL_islower16(
      x,
    );
  }

  late final _SDL_islower16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower16 = _SDL_islower16Ptr.asFunction<int Function(int)>();

  int SDL_isprint16(
    int x,
  ) {
    return _SDL_isprint16(
      x,
    );
  }

  late final _SDL_isprint16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint16 = _SDL_isprint16Ptr.asFunction<int Function(int)>();

  int SDL_isgraph16(
    int x,
  ) {
    return _SDL_isgraph16(
      x,
    );
  }

  late final _SDL_isgraph16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph16 = _SDL_isgraph16Ptr.asFunction<int Function(int)>();

  int SDL_toupper16(
    int x,
  ) {
    return _SDL_toupper16(
      x,
    );
  }

  late final _SDL_toupper16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper16 = _SDL_toupper16Ptr.asFunction<int Function(int)>();

  int SDL_tolower16(
    int x,
  ) {
    return _SDL_tolower16(
      x,
    );
  }

  late final _SDL_tolower16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower16 = _SDL_tolower16Ptr.asFunction<int Function(int)>();

  int SDL_crc3216(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3216(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3216Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3216 = _SDL_crc3216Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset16(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset16(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset16 = _SDL_memset16Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy16(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy16(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy16 = _SDL_memcpy16Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove16(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove16(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove16 = _SDL_memmove16Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp16(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp16(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp16 = _SDL_memcmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen16(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen16(
      wstr,
    );
  }

  late final _SDL_wcslen16Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen16 =
      _SDL_wcslen16Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy16(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy16(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy16 = _SDL_wcslcpy16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat16(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat16(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat16 = _SDL_wcslcat16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup16(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup16(
      wstr,
    );
  }

  late final _SDL_wcsdup16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup16 = _SDL_wcsdup16Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr16(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr16(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr16 = _SDL_wcsstr16Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp16(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp16(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp16 = _SDL_wcscmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp16(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp16(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp16 = _SDL_wcsncmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp16(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp16(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp16 = _SDL_wcscasecmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp16(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp16(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp16 = _SDL_wcsncasecmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen16(
      str,
    );
  }

  late final _SDL_strlen16Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen16 =
      _SDL_strlen16Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy16(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy16(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy16 = _SDL_strlcpy16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy16(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy16(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy16 = _SDL_utf8strlcpy16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat16(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat16(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat16 = _SDL_strlcat16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup16(
      str,
    );
  }

  late final _SDL_strdup16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup16 = _SDL_strdup16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev16(
      str,
    );
  }

  late final _SDL_strrev16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev16 = _SDL_strrev16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr16(
      str,
    );
  }

  late final _SDL_strupr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr16 = _SDL_strupr16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr16(
      str,
    );
  }

  late final _SDL_strlwr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr16 = _SDL_strlwr16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr16(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr16(
      str,
      c,
    );
  }

  late final _SDL_strchr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr16 = _SDL_strchr16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr16(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr16(
      str,
      c,
    );
  }

  late final _SDL_strrchr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr16 = _SDL_strrchr16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr16(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr16(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr16 = _SDL_strstr16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr16(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr16(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr16 = _SDL_strtokr16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen16(
      str,
    );
  }

  late final _SDL_utf8strlen16Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen16 =
      _SDL_utf8strlen16Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa16(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa16(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa16 = _SDL_itoa16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa16(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa16(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa16 = _SDL_uitoa16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa16(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa16(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa16 = _SDL_ltoa16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa16(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa16(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa16 = _SDL_ultoa16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa16(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa16(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa16 = _SDL_lltoa16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa16(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa16(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa16 = _SDL_ulltoa16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi16(
      str,
    );
  }

  late final _SDL_atoi16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi16 =
      _SDL_atoi16Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof16(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof16(
      str,
    );
  }

  late final _SDL_atof16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof16 =
      _SDL_atof16Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol16(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol16(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol16 = _SDL_strtol16Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul16(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul16(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul16 = _SDL_strtoul16Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll16(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll16(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll16Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll16 = _SDL_strtoll16Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull16(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull16(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull16Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull16 = _SDL_strtoull16Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod16(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod16(
      str,
      endp,
    );
  }

  late final _SDL_strtod16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod16 = _SDL_strtod16Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp16(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp16(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp16 = _SDL_strcmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp16(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp16(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp16 = _SDL_strncmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp16(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp16(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp16 = _SDL_strcasecmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp16(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp16(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp16 = _SDL_strncasecmp16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf16(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf16(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf16 = _SDL_sscanf16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf16(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf16(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf16 = _SDL_vsscanf16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf16(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf16(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf16 = _SDL_snprintf16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf16(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf16(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf16 = _SDL_vsnprintf16Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf16(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf16(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf16 = _SDL_asprintf16Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf16(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf16(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf16 = _SDL_vasprintf16Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos16(
    double x,
  ) {
    return _SDL_acos16(
      x,
    );
  }

  late final _SDL_acos16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos16 = _SDL_acos16Ptr.asFunction<double Function(double)>();

  double SDL_acosf16(
    double x,
  ) {
    return _SDL_acosf16(
      x,
    );
  }

  late final _SDL_acosf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf16 =
      _SDL_acosf16Ptr.asFunction<double Function(double)>();

  double SDL_asin16(
    double x,
  ) {
    return _SDL_asin16(
      x,
    );
  }

  late final _SDL_asin16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin16 = _SDL_asin16Ptr.asFunction<double Function(double)>();

  double SDL_asinf16(
    double x,
  ) {
    return _SDL_asinf16(
      x,
    );
  }

  late final _SDL_asinf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf16 =
      _SDL_asinf16Ptr.asFunction<double Function(double)>();

  double SDL_atan17(
    double x,
  ) {
    return _SDL_atan17(
      x,
    );
  }

  late final _SDL_atan17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan17 = _SDL_atan17Ptr.asFunction<double Function(double)>();

  double SDL_atanf16(
    double x,
  ) {
    return _SDL_atanf16(
      x,
    );
  }

  late final _SDL_atanf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf16 =
      _SDL_atanf16Ptr.asFunction<double Function(double)>();

  double SDL_atan216(
    double y,
    double x,
  ) {
    return _SDL_atan216(
      y,
      x,
    );
  }

  late final _SDL_atan216Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan216 =
      _SDL_atan216Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f16(
    double y,
    double x,
  ) {
    return _SDL_atan2f16(
      y,
      x,
    );
  }

  late final _SDL_atan2f16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f16 =
      _SDL_atan2f16Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil16(
    double x,
  ) {
    return _SDL_ceil16(
      x,
    );
  }

  late final _SDL_ceil16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil16 = _SDL_ceil16Ptr.asFunction<double Function(double)>();

  double SDL_ceilf16(
    double x,
  ) {
    return _SDL_ceilf16(
      x,
    );
  }

  late final _SDL_ceilf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf16 =
      _SDL_ceilf16Ptr.asFunction<double Function(double)>();

  double SDL_copysign16(
    double x,
    double y,
  ) {
    return _SDL_copysign16(
      x,
      y,
    );
  }

  late final _SDL_copysign16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign16 =
      _SDL_copysign16Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf16(
    double x,
    double y,
  ) {
    return _SDL_copysignf16(
      x,
      y,
    );
  }

  late final _SDL_copysignf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf16 =
      _SDL_copysignf16Ptr.asFunction<double Function(double, double)>();

  double SDL_cos16(
    double x,
  ) {
    return _SDL_cos16(
      x,
    );
  }

  late final _SDL_cos16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos16 = _SDL_cos16Ptr.asFunction<double Function(double)>();

  double SDL_cosf16(
    double x,
  ) {
    return _SDL_cosf16(
      x,
    );
  }

  late final _SDL_cosf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf16 = _SDL_cosf16Ptr.asFunction<double Function(double)>();

  double SDL_exp16(
    double x,
  ) {
    return _SDL_exp16(
      x,
    );
  }

  late final _SDL_exp16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp16 = _SDL_exp16Ptr.asFunction<double Function(double)>();

  double SDL_expf16(
    double x,
  ) {
    return _SDL_expf16(
      x,
    );
  }

  late final _SDL_expf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf16 = _SDL_expf16Ptr.asFunction<double Function(double)>();

  double SDL_fabs16(
    double x,
  ) {
    return _SDL_fabs16(
      x,
    );
  }

  late final _SDL_fabs16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs16 = _SDL_fabs16Ptr.asFunction<double Function(double)>();

  double SDL_fabsf16(
    double x,
  ) {
    return _SDL_fabsf16(
      x,
    );
  }

  late final _SDL_fabsf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf16 =
      _SDL_fabsf16Ptr.asFunction<double Function(double)>();

  double SDL_floor16(
    double x,
  ) {
    return _SDL_floor16(
      x,
    );
  }

  late final _SDL_floor16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor16 =
      _SDL_floor16Ptr.asFunction<double Function(double)>();

  double SDL_floorf16(
    double x,
  ) {
    return _SDL_floorf16(
      x,
    );
  }

  late final _SDL_floorf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf16 =
      _SDL_floorf16Ptr.asFunction<double Function(double)>();

  double SDL_trunc16(
    double x,
  ) {
    return _SDL_trunc16(
      x,
    );
  }

  late final _SDL_trunc16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc16 =
      _SDL_trunc16Ptr.asFunction<double Function(double)>();

  double SDL_truncf16(
    double x,
  ) {
    return _SDL_truncf16(
      x,
    );
  }

  late final _SDL_truncf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf16 =
      _SDL_truncf16Ptr.asFunction<double Function(double)>();

  double SDL_fmod16(
    double x,
    double y,
  ) {
    return _SDL_fmod16(
      x,
      y,
    );
  }

  late final _SDL_fmod16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod16 =
      _SDL_fmod16Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf16(
    double x,
    double y,
  ) {
    return _SDL_fmodf16(
      x,
      y,
    );
  }

  late final _SDL_fmodf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf16 =
      _SDL_fmodf16Ptr.asFunction<double Function(double, double)>();

  double SDL_log17(
    double x,
  ) {
    return _SDL_log17(
      x,
    );
  }

  late final _SDL_log17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log17 = _SDL_log17Ptr.asFunction<double Function(double)>();

  double SDL_logf16(
    double x,
  ) {
    return _SDL_logf16(
      x,
    );
  }

  late final _SDL_logf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf16 = _SDL_logf16Ptr.asFunction<double Function(double)>();

  double SDL_log1016(
    double x,
  ) {
    return _SDL_log1016(
      x,
    );
  }

  late final _SDL_log1016Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1016 =
      _SDL_log1016Ptr.asFunction<double Function(double)>();

  double SDL_log10f16(
    double x,
  ) {
    return _SDL_log10f16(
      x,
    );
  }

  late final _SDL_log10f16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f16 =
      _SDL_log10f16Ptr.asFunction<double Function(double)>();

  double SDL_pow16(
    double x,
    double y,
  ) {
    return _SDL_pow16(
      x,
      y,
    );
  }

  late final _SDL_pow16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow16 =
      _SDL_pow16Ptr.asFunction<double Function(double, double)>();

  double SDL_powf16(
    double x,
    double y,
  ) {
    return _SDL_powf16(
      x,
      y,
    );
  }

  late final _SDL_powf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf16 =
      _SDL_powf16Ptr.asFunction<double Function(double, double)>();

  double SDL_round16(
    double x,
  ) {
    return _SDL_round16(
      x,
    );
  }

  late final _SDL_round16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round16 =
      _SDL_round16Ptr.asFunction<double Function(double)>();

  double SDL_roundf16(
    double x,
  ) {
    return _SDL_roundf16(
      x,
    );
  }

  late final _SDL_roundf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf16 =
      _SDL_roundf16Ptr.asFunction<double Function(double)>();

  int SDL_lround16(
    double x,
  ) {
    return _SDL_lround16(
      x,
    );
  }

  late final _SDL_lround16Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround16 =
      _SDL_lround16Ptr.asFunction<int Function(double)>();

  int SDL_lroundf16(
    double x,
  ) {
    return _SDL_lroundf16(
      x,
    );
  }

  late final _SDL_lroundf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf16 =
      _SDL_lroundf16Ptr.asFunction<int Function(double)>();

  double SDL_scalbn16(
    double x,
    int n,
  ) {
    return _SDL_scalbn16(
      x,
      n,
    );
  }

  late final _SDL_scalbn16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn16 =
      _SDL_scalbn16Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf16(
    double x,
    int n,
  ) {
    return _SDL_scalbnf16(
      x,
      n,
    );
  }

  late final _SDL_scalbnf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf16 =
      _SDL_scalbnf16Ptr.asFunction<double Function(double, int)>();

  double SDL_sin16(
    double x,
  ) {
    return _SDL_sin16(
      x,
    );
  }

  late final _SDL_sin16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin16 = _SDL_sin16Ptr.asFunction<double Function(double)>();

  double SDL_sinf16(
    double x,
  ) {
    return _SDL_sinf16(
      x,
    );
  }

  late final _SDL_sinf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf16 = _SDL_sinf16Ptr.asFunction<double Function(double)>();

  double SDL_sqrt16(
    double x,
  ) {
    return _SDL_sqrt16(
      x,
    );
  }

  late final _SDL_sqrt16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt16 = _SDL_sqrt16Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf16(
    double x,
  ) {
    return _SDL_sqrtf16(
      x,
    );
  }

  late final _SDL_sqrtf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf16 =
      _SDL_sqrtf16Ptr.asFunction<double Function(double)>();

  double SDL_tan16(
    double x,
  ) {
    return _SDL_tan16(
      x,
    );
  }

  late final _SDL_tan16Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan16 = _SDL_tan16Ptr.asFunction<double Function(double)>();

  double SDL_tanf16(
    double x,
  ) {
    return _SDL_tanf16(
      x,
    );
  }

  late final _SDL_tanf16Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf16 = _SDL_tanf16Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open16(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open16(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open16Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open16 = _SDL_iconv_open16Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close16(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close16(
      cd,
    );
  }

  late final _SDL_iconv_close16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close16 =
      _SDL_iconv_close16Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv16(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv16(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv16 = _SDL_iconv16Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string16(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string16(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string16 = _SDL_iconv_string16Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError10(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError10(
      fmt,
    );
  }

  late final _SDL_SetError10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError10 =
      _SDL_SetError10Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError10() {
    return _SDL_GetError10();
  }

  late final _SDL_GetError10Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError10 =
      _SDL_GetError10Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg10(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg10(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg10 = _SDL_GetErrorMsg10Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError10() {
    return _SDL_ClearError10();
  }

  late final _SDL_ClearError10Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError10 =
      _SDL_ClearError10Ptr.asFunction<void Function()>();

  int SDL_Error10(
    int code,
  ) {
    return _SDL_Error10(
      code,
    );
  }

  late final _SDL_Error10Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error10 = _SDL_Error10Ptr.asFunction<int Function(int)>();

  /// Create a new mutex.
  ///
  /// All newly-created mutexes begin in the _unlocked_ state.
  ///
  /// Calls to SDL_LockMutex() will not return while the mutex is locked by
  /// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
  ///
  /// SDL mutexes are reentrant.
  ///
  /// \returns the initialized and unlocked mutex or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  ffi.Pointer<SDL_mutex> SDL_CreateMutex3() {
    return _SDL_CreateMutex3();
  }

  late final _SDL_CreateMutex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_mutex> Function()>>(
          'SDL_CreateMutex');
  late final _SDL_CreateMutex3 =
      _SDL_CreateMutex3Ptr.asFunction<ffi.Pointer<SDL_mutex> Function()>();

  /// Lock the mutex.
  ///
  /// This will block until the mutex is available, which is to say it is in the
  /// unlocked state and the OS has chosen the caller as the next thread to lock
  /// it. Of all threads waiting to lock the mutex, only one may do so at a time.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// \param mutex the mutex to lock
  /// \return 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_LockMutex3(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_LockMutex3(
      mutex,
    );
  }

  late final _SDL_LockMutex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_LockMutex');
  late final _SDL_LockMutex3 =
      _SDL_LockMutex3Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Try to lock a mutex without blocking.
  ///
  /// This works just like SDL_LockMutex(), but if the mutex is not available,
  /// this function returns `SDL_MUTEX_TIMEOUT` immediately.
  ///
  /// This technique is useful if you need exclusive access to a resource but
  /// don't want to wait for it, and will return to it to try again later.
  ///
  /// \param mutex the mutex to try to lock
  /// \returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_DestroyMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_UnlockMutex
  int SDL_TryLockMutex3(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_TryLockMutex3(
      mutex,
    );
  }

  late final _SDL_TryLockMutex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_TryLockMutex');
  late final _SDL_TryLockMutex3 =
      _SDL_TryLockMutex3Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Unlock the mutex.
  ///
  /// It is legal for the owning thread to lock an already-locked mutex. It must
  /// unlock it the same number of times before it is actually made available for
  /// other threads in the system (this is known as a "recursive mutex").
  ///
  /// It is an error to unlock a mutex that has not been locked by the current
  /// thread, and doing so results in undefined behavior.
  ///
  /// It is also an error to unlock a mutex that isn't locked at all.
  ///
  /// \param mutex the mutex to unlock.
  /// \returns 0, or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_UnlockMutex3(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_UnlockMutex3(
      mutex,
    );
  }

  late final _SDL_UnlockMutex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_UnlockMutex');
  late final _SDL_UnlockMutex3 =
      _SDL_UnlockMutex3Ptr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Destroy a mutex created with SDL_CreateMutex().
  ///
  /// This function must be called on any mutex that is no longer needed. Failure
  /// to destroy a mutex will result in a system memory or resource leak. While
  /// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
  /// to destroy a locked mutex, and may result in undefined behavior depending
  /// on the platform.
  ///
  /// \param mutex the mutex to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateMutex
  /// \sa SDL_LockMutex
  /// \sa SDL_TryLockMutex
  /// \sa SDL_UnlockMutex
  void SDL_DestroyMutex3(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_DestroyMutex3(
      mutex,
    );
  }

  late final _SDL_DestroyMutex3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_DestroyMutex');
  late final _SDL_DestroyMutex3 =
      _SDL_DestroyMutex3Ptr.asFunction<void Function(ffi.Pointer<SDL_mutex>)>();

  /// Create a semaphore.
  ///
  /// This function creates a new semaphore and initializes it with the value
  /// `initial_value`. Each wait operation on the semaphore will atomically
  /// decrement the semaphore value and potentially block if the semaphore value
  /// is 0. Each post operation will atomically increment the semaphore value and
  /// wake waiting threads and allow them to retry the wait operation.
  ///
  /// \param initial_value the starting value of the semaphore
  /// \returns a new semaphore or NULL on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  ffi.Pointer<SDL_sem> SDL_CreateSemaphore3(
    int initial_value,
  ) {
    return _SDL_CreateSemaphore3(
      initial_value,
    );
  }

  late final _SDL_CreateSemaphore3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_sem> Function(Uint32)>>(
          'SDL_CreateSemaphore');
  late final _SDL_CreateSemaphore3 =
      _SDL_CreateSemaphore3Ptr.asFunction<ffi.Pointer<SDL_sem> Function(int)>();

  /// Destroy a semaphore.
  ///
  /// It is not safe to destroy a semaphore if there are threads currently
  /// waiting on it.
  ///
  /// \param sem the semaphore to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  void SDL_DestroySemaphore3(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_DestroySemaphore3(
      sem,
    );
  }

  late final _SDL_DestroySemaphore3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_DestroySemaphore');
  late final _SDL_DestroySemaphore3 = _SDL_DestroySemaphore3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value or the call is interrupted by a
  /// signal or error. If the call is successful it will atomically decrement the
  /// semaphore value.
  ///
  /// This function is the equivalent of calling SDL_SemWaitTimeout() with a time
  /// length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param sem the semaphore wait on
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemWait3(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemWait3(
      sem,
    );
  }

  late final _SDL_SemWait3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemWait');
  late final _SDL_SemWait3 =
      _SDL_SemWait3Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// See if a semaphore has a positive value and decrement it if it does.
  ///
  /// This function checks to see if the semaphore pointed to by `sem` has a
  /// positive value and atomically decrements the semaphore value if it does. If
  /// the semaphore doesn't have a positive value, the function immediately
  /// returns SDL_MUTEX_TIMEDOUT.
  ///
  /// \param sem the semaphore to wait on
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would
  /// block, or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemTryWait3(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemTryWait3(
      sem,
    );
  }

  late final _SDL_SemTryWait3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemTryWait');
  late final _SDL_SemTryWait3 =
      _SDL_SemTryWait3Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Wait until a semaphore has a positive value and then decrements it.
  ///
  /// This function suspends the calling thread until either the semaphore
  /// pointed to by `sem` has a positive value, the call is interrupted by a
  /// signal or error, or the specified time has elapsed. If the call is
  /// successful it will atomically decrement the semaphore value.
  ///
  /// \param sem the semaphore to wait on
  /// \param ms the length of the timeout, in milliseconds
  /// \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not
  /// succeed in the allotted time, or a negative error code on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemPost
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  int SDL_SemWaitTimeout3(
    ffi.Pointer<SDL_sem> sem,
    int ms,
  ) {
    return _SDL_SemWaitTimeout3(
      sem,
      ms,
    );
  }

  late final _SDL_SemWaitTimeout3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>, Uint32)>>(
      'SDL_SemWaitTimeout');
  late final _SDL_SemWaitTimeout3 = _SDL_SemWaitTimeout3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_sem>, int)>();

  /// Atomically increment a semaphore's value and wake waiting threads.
  ///
  /// \param sem the semaphore to increment
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  /// \sa SDL_DestroySemaphore
  /// \sa SDL_SemTryWait
  /// \sa SDL_SemValue
  /// \sa SDL_SemWait
  /// \sa SDL_SemWaitTimeout
  int SDL_SemPost3(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemPost3(
      sem,
    );
  }

  late final _SDL_SemPost3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemPost');
  late final _SDL_SemPost3 =
      _SDL_SemPost3Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Get the current value of a semaphore.
  ///
  /// \param sem the semaphore to query
  /// \returns the current value of the semaphore.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSemaphore
  int SDL_SemValue3(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemValue3(
      sem,
    );
  }

  late final _SDL_SemValue3Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemValue');
  late final _SDL_SemValue3 =
      _SDL_SemValue3Ptr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Create a condition variable.
  ///
  /// \returns a new condition variable or NULL on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_DestroyCond
  ffi.Pointer<SDL_cond> SDL_CreateCond3() {
    return _SDL_CreateCond3();
  }

  late final _SDL_CreateCond3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_cond> Function()>>(
          'SDL_CreateCond');
  late final _SDL_CreateCond3 =
      _SDL_CreateCond3Ptr.asFunction<ffi.Pointer<SDL_cond> Function()>();

  /// Destroy a condition variable.
  ///
  /// \param cond the condition variable to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  void SDL_DestroyCond3(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_DestroyCond3(
      cond,
    );
  }

  late final _SDL_DestroyCond3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_DestroyCond');
  late final _SDL_DestroyCond3 =
      _SDL_DestroyCond3Ptr.asFunction<void Function(ffi.Pointer<SDL_cond>)>();

  /// Restart one of the threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondSignal3(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondSignal3(
      cond,
    );
  }

  late final _SDL_CondSignal3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondSignal');
  late final _SDL_CondSignal3 =
      _SDL_CondSignal3Ptr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Restart all threads that are waiting on the condition variable.
  ///
  /// \param cond the condition variable to signal
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondBroadcast3(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondBroadcast3(
      cond,
    );
  }

  late final _SDL_CondBroadcast3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondBroadcast');
  late final _SDL_CondBroadcast3 =
      _SDL_CondBroadcast3Ptr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Wait until a condition variable is signaled.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`. Once the condition variable is signaled, the mutex is re-locked and
  /// the function returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// This function is the equivalent of calling SDL_CondWaitTimeout() with a
  /// time length of `SDL_MUTEX_MAXWAIT`.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \returns 0 when it is signaled or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWaitTimeout
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWait3(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_CondWait3(
      cond,
      mutex,
    );
  }

  late final _SDL_CondWait3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>>('SDL_CondWait');
  late final _SDL_CondWait3 = _SDL_CondWait3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>();

  /// Wait until a condition variable is signaled or a certain time has passed.
  ///
  /// This function unlocks the specified `mutex` and waits for another thread to
  /// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
  /// `cond`, or for the specified time to elapse. Once the condition variable is
  /// signaled or the time elapsed, the mutex is re-locked and the function
  /// returns.
  ///
  /// The mutex must be locked before calling this function.
  ///
  /// \param cond the condition variable to wait on
  /// \param mutex the mutex used to coordinate thread access
  /// \param ms the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`
  /// to wait indefinitely
  /// \returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if
  /// the condition is not signaled in the allotted time, or a negative
  /// error code on failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CondBroadcast
  /// \sa SDL_CondSignal
  /// \sa SDL_CondWait
  /// \sa SDL_CreateCond
  /// \sa SDL_DestroyCond
  int SDL_CondWaitTimeout3(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
    int ms,
  ) {
    return _SDL_CondWaitTimeout3(
      cond,
      mutex,
      ms,
    );
  }

  late final _SDL_CondWaitTimeout3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>,
              Uint32)>>('SDL_CondWaitTimeout');
  late final _SDL_CondWaitTimeout3 = _SDL_CondWaitTimeout3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>, int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform18() {
    return _SDL_GetPlatform18();
  }

  late final _SDL_GetPlatform18Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform18 =
      _SDL_GetPlatform18Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc17(
    int size,
  ) {
    return _SDL_malloc17(
      size,
    );
  }

  late final _SDL_malloc17Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc17 =
      _SDL_malloc17Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc17(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc17(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc17 =
      _SDL_calloc17Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc17(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc17(
      mem,
      size,
    );
  }

  late final _SDL_realloc17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc17 = _SDL_realloc17Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free17(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free17(
      mem,
    );
  }

  late final _SDL_free17Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free17 =
      _SDL_free17Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions17(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions17(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions17 =
      _SDL_GetMemoryFunctions17Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions17(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions17(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions17 =
      _SDL_SetMemoryFunctions17Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations17() {
    return _SDL_GetNumAllocations17();
  }

  late final _SDL_GetNumAllocations17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations17 =
      _SDL_GetNumAllocations17Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv17(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv17(
      name,
    );
  }

  late final _SDL_getenv17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv17 = _SDL_getenv17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv17(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv17(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv17 = _SDL_setenv17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort17(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort17(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort17 = _SDL_qsort17Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs17(
    int x,
  ) {
    return _SDL_abs17(
      x,
    );
  }

  late final _SDL_abs17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs17 = _SDL_abs17Ptr.asFunction<int Function(int)>();

  int SDL_isalpha17(
    int x,
  ) {
    return _SDL_isalpha17(
      x,
    );
  }

  late final _SDL_isalpha17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha17 = _SDL_isalpha17Ptr.asFunction<int Function(int)>();

  int SDL_isalnum17(
    int x,
  ) {
    return _SDL_isalnum17(
      x,
    );
  }

  late final _SDL_isalnum17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum17 = _SDL_isalnum17Ptr.asFunction<int Function(int)>();

  int SDL_isblank17(
    int x,
  ) {
    return _SDL_isblank17(
      x,
    );
  }

  late final _SDL_isblank17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank17 = _SDL_isblank17Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl17(
    int x,
  ) {
    return _SDL_iscntrl17(
      x,
    );
  }

  late final _SDL_iscntrl17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl17 = _SDL_iscntrl17Ptr.asFunction<int Function(int)>();

  int SDL_isdigit17(
    int x,
  ) {
    return _SDL_isdigit17(
      x,
    );
  }

  late final _SDL_isdigit17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit17 = _SDL_isdigit17Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit17(
    int x,
  ) {
    return _SDL_isxdigit17(
      x,
    );
  }

  late final _SDL_isxdigit17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit17 =
      _SDL_isxdigit17Ptr.asFunction<int Function(int)>();

  int SDL_ispunct17(
    int x,
  ) {
    return _SDL_ispunct17(
      x,
    );
  }

  late final _SDL_ispunct17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct17 = _SDL_ispunct17Ptr.asFunction<int Function(int)>();

  int SDL_isspace17(
    int x,
  ) {
    return _SDL_isspace17(
      x,
    );
  }

  late final _SDL_isspace17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace17 = _SDL_isspace17Ptr.asFunction<int Function(int)>();

  int SDL_isupper17(
    int x,
  ) {
    return _SDL_isupper17(
      x,
    );
  }

  late final _SDL_isupper17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper17 = _SDL_isupper17Ptr.asFunction<int Function(int)>();

  int SDL_islower17(
    int x,
  ) {
    return _SDL_islower17(
      x,
    );
  }

  late final _SDL_islower17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower17 = _SDL_islower17Ptr.asFunction<int Function(int)>();

  int SDL_isprint17(
    int x,
  ) {
    return _SDL_isprint17(
      x,
    );
  }

  late final _SDL_isprint17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint17 = _SDL_isprint17Ptr.asFunction<int Function(int)>();

  int SDL_isgraph17(
    int x,
  ) {
    return _SDL_isgraph17(
      x,
    );
  }

  late final _SDL_isgraph17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph17 = _SDL_isgraph17Ptr.asFunction<int Function(int)>();

  int SDL_toupper17(
    int x,
  ) {
    return _SDL_toupper17(
      x,
    );
  }

  late final _SDL_toupper17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper17 = _SDL_toupper17Ptr.asFunction<int Function(int)>();

  int SDL_tolower17(
    int x,
  ) {
    return _SDL_tolower17(
      x,
    );
  }

  late final _SDL_tolower17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower17 = _SDL_tolower17Ptr.asFunction<int Function(int)>();

  int SDL_crc3217(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3217(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3217Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3217 = _SDL_crc3217Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset17(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset17(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset17 = _SDL_memset17Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy17(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy17(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy17 = _SDL_memcpy17Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove17(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove17(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove17 = _SDL_memmove17Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp17(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp17(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp17 = _SDL_memcmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen17(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen17(
      wstr,
    );
  }

  late final _SDL_wcslen17Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen17 =
      _SDL_wcslen17Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy17(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy17(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy17 = _SDL_wcslcpy17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat17(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat17(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat17 = _SDL_wcslcat17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup17(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup17(
      wstr,
    );
  }

  late final _SDL_wcsdup17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup17 = _SDL_wcsdup17Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr17(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr17(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr17 = _SDL_wcsstr17Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp17(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp17(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp17 = _SDL_wcscmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp17(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp17(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp17 = _SDL_wcsncmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp17(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp17(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp17 = _SDL_wcscasecmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp17(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp17(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp17 = _SDL_wcsncasecmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen17(
      str,
    );
  }

  late final _SDL_strlen17Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen17 =
      _SDL_strlen17Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy17(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy17(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy17 = _SDL_strlcpy17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy17(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy17(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy17 = _SDL_utf8strlcpy17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat17(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat17(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat17 = _SDL_strlcat17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup17(
      str,
    );
  }

  late final _SDL_strdup17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup17 = _SDL_strdup17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev17(
      str,
    );
  }

  late final _SDL_strrev17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev17 = _SDL_strrev17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr17(
      str,
    );
  }

  late final _SDL_strupr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr17 = _SDL_strupr17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr17(
      str,
    );
  }

  late final _SDL_strlwr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr17 = _SDL_strlwr17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr17(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr17(
      str,
      c,
    );
  }

  late final _SDL_strchr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr17 = _SDL_strchr17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr17(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr17(
      str,
      c,
    );
  }

  late final _SDL_strrchr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr17 = _SDL_strrchr17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr17(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr17(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr17 = _SDL_strstr17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr17(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr17(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr17 = _SDL_strtokr17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen17(
      str,
    );
  }

  late final _SDL_utf8strlen17Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen17 =
      _SDL_utf8strlen17Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa17(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa17(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa17 = _SDL_itoa17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa17(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa17(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa17 = _SDL_uitoa17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa17(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa17(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa17 = _SDL_ltoa17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa17(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa17(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa17 = _SDL_ultoa17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa17(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa17(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa17 = _SDL_lltoa17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa17(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa17(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa17 = _SDL_ulltoa17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi17(
      str,
    );
  }

  late final _SDL_atoi17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi17 =
      _SDL_atoi17Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof17(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof17(
      str,
    );
  }

  late final _SDL_atof17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof17 =
      _SDL_atof17Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol17(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol17(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol17 = _SDL_strtol17Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul17(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul17(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul17 = _SDL_strtoul17Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll17(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll17(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll17Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll17 = _SDL_strtoll17Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull17(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull17(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull17Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull17 = _SDL_strtoull17Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod17(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod17(
      str,
      endp,
    );
  }

  late final _SDL_strtod17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod17 = _SDL_strtod17Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp17(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp17(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp17 = _SDL_strcmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp17(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp17(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp17 = _SDL_strncmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp17(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp17(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp17 = _SDL_strcasecmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp17(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp17(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp17 = _SDL_strncasecmp17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf17(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf17(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf17 = _SDL_sscanf17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf17(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf17(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf17 = _SDL_vsscanf17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf17(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf17(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf17 = _SDL_snprintf17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf17(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf17(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf17 = _SDL_vsnprintf17Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf17(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf17(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf17 = _SDL_asprintf17Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf17(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf17(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf17 = _SDL_vasprintf17Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos17(
    double x,
  ) {
    return _SDL_acos17(
      x,
    );
  }

  late final _SDL_acos17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos17 = _SDL_acos17Ptr.asFunction<double Function(double)>();

  double SDL_acosf17(
    double x,
  ) {
    return _SDL_acosf17(
      x,
    );
  }

  late final _SDL_acosf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf17 =
      _SDL_acosf17Ptr.asFunction<double Function(double)>();

  double SDL_asin17(
    double x,
  ) {
    return _SDL_asin17(
      x,
    );
  }

  late final _SDL_asin17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin17 = _SDL_asin17Ptr.asFunction<double Function(double)>();

  double SDL_asinf17(
    double x,
  ) {
    return _SDL_asinf17(
      x,
    );
  }

  late final _SDL_asinf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf17 =
      _SDL_asinf17Ptr.asFunction<double Function(double)>();

  double SDL_atan18(
    double x,
  ) {
    return _SDL_atan18(
      x,
    );
  }

  late final _SDL_atan18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan18 = _SDL_atan18Ptr.asFunction<double Function(double)>();

  double SDL_atanf17(
    double x,
  ) {
    return _SDL_atanf17(
      x,
    );
  }

  late final _SDL_atanf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf17 =
      _SDL_atanf17Ptr.asFunction<double Function(double)>();

  double SDL_atan217(
    double y,
    double x,
  ) {
    return _SDL_atan217(
      y,
      x,
    );
  }

  late final _SDL_atan217Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan217 =
      _SDL_atan217Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f17(
    double y,
    double x,
  ) {
    return _SDL_atan2f17(
      y,
      x,
    );
  }

  late final _SDL_atan2f17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f17 =
      _SDL_atan2f17Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil17(
    double x,
  ) {
    return _SDL_ceil17(
      x,
    );
  }

  late final _SDL_ceil17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil17 = _SDL_ceil17Ptr.asFunction<double Function(double)>();

  double SDL_ceilf17(
    double x,
  ) {
    return _SDL_ceilf17(
      x,
    );
  }

  late final _SDL_ceilf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf17 =
      _SDL_ceilf17Ptr.asFunction<double Function(double)>();

  double SDL_copysign17(
    double x,
    double y,
  ) {
    return _SDL_copysign17(
      x,
      y,
    );
  }

  late final _SDL_copysign17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign17 =
      _SDL_copysign17Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf17(
    double x,
    double y,
  ) {
    return _SDL_copysignf17(
      x,
      y,
    );
  }

  late final _SDL_copysignf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf17 =
      _SDL_copysignf17Ptr.asFunction<double Function(double, double)>();

  double SDL_cos17(
    double x,
  ) {
    return _SDL_cos17(
      x,
    );
  }

  late final _SDL_cos17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos17 = _SDL_cos17Ptr.asFunction<double Function(double)>();

  double SDL_cosf17(
    double x,
  ) {
    return _SDL_cosf17(
      x,
    );
  }

  late final _SDL_cosf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf17 = _SDL_cosf17Ptr.asFunction<double Function(double)>();

  double SDL_exp17(
    double x,
  ) {
    return _SDL_exp17(
      x,
    );
  }

  late final _SDL_exp17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp17 = _SDL_exp17Ptr.asFunction<double Function(double)>();

  double SDL_expf17(
    double x,
  ) {
    return _SDL_expf17(
      x,
    );
  }

  late final _SDL_expf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf17 = _SDL_expf17Ptr.asFunction<double Function(double)>();

  double SDL_fabs17(
    double x,
  ) {
    return _SDL_fabs17(
      x,
    );
  }

  late final _SDL_fabs17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs17 = _SDL_fabs17Ptr.asFunction<double Function(double)>();

  double SDL_fabsf17(
    double x,
  ) {
    return _SDL_fabsf17(
      x,
    );
  }

  late final _SDL_fabsf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf17 =
      _SDL_fabsf17Ptr.asFunction<double Function(double)>();

  double SDL_floor17(
    double x,
  ) {
    return _SDL_floor17(
      x,
    );
  }

  late final _SDL_floor17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor17 =
      _SDL_floor17Ptr.asFunction<double Function(double)>();

  double SDL_floorf17(
    double x,
  ) {
    return _SDL_floorf17(
      x,
    );
  }

  late final _SDL_floorf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf17 =
      _SDL_floorf17Ptr.asFunction<double Function(double)>();

  double SDL_trunc17(
    double x,
  ) {
    return _SDL_trunc17(
      x,
    );
  }

  late final _SDL_trunc17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc17 =
      _SDL_trunc17Ptr.asFunction<double Function(double)>();

  double SDL_truncf17(
    double x,
  ) {
    return _SDL_truncf17(
      x,
    );
  }

  late final _SDL_truncf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf17 =
      _SDL_truncf17Ptr.asFunction<double Function(double)>();

  double SDL_fmod17(
    double x,
    double y,
  ) {
    return _SDL_fmod17(
      x,
      y,
    );
  }

  late final _SDL_fmod17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod17 =
      _SDL_fmod17Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf17(
    double x,
    double y,
  ) {
    return _SDL_fmodf17(
      x,
      y,
    );
  }

  late final _SDL_fmodf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf17 =
      _SDL_fmodf17Ptr.asFunction<double Function(double, double)>();

  double SDL_log18(
    double x,
  ) {
    return _SDL_log18(
      x,
    );
  }

  late final _SDL_log18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log18 = _SDL_log18Ptr.asFunction<double Function(double)>();

  double SDL_logf17(
    double x,
  ) {
    return _SDL_logf17(
      x,
    );
  }

  late final _SDL_logf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf17 = _SDL_logf17Ptr.asFunction<double Function(double)>();

  double SDL_log1017(
    double x,
  ) {
    return _SDL_log1017(
      x,
    );
  }

  late final _SDL_log1017Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1017 =
      _SDL_log1017Ptr.asFunction<double Function(double)>();

  double SDL_log10f17(
    double x,
  ) {
    return _SDL_log10f17(
      x,
    );
  }

  late final _SDL_log10f17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f17 =
      _SDL_log10f17Ptr.asFunction<double Function(double)>();

  double SDL_pow17(
    double x,
    double y,
  ) {
    return _SDL_pow17(
      x,
      y,
    );
  }

  late final _SDL_pow17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow17 =
      _SDL_pow17Ptr.asFunction<double Function(double, double)>();

  double SDL_powf17(
    double x,
    double y,
  ) {
    return _SDL_powf17(
      x,
      y,
    );
  }

  late final _SDL_powf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf17 =
      _SDL_powf17Ptr.asFunction<double Function(double, double)>();

  double SDL_round17(
    double x,
  ) {
    return _SDL_round17(
      x,
    );
  }

  late final _SDL_round17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round17 =
      _SDL_round17Ptr.asFunction<double Function(double)>();

  double SDL_roundf17(
    double x,
  ) {
    return _SDL_roundf17(
      x,
    );
  }

  late final _SDL_roundf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf17 =
      _SDL_roundf17Ptr.asFunction<double Function(double)>();

  int SDL_lround17(
    double x,
  ) {
    return _SDL_lround17(
      x,
    );
  }

  late final _SDL_lround17Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround17 =
      _SDL_lround17Ptr.asFunction<int Function(double)>();

  int SDL_lroundf17(
    double x,
  ) {
    return _SDL_lroundf17(
      x,
    );
  }

  late final _SDL_lroundf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf17 =
      _SDL_lroundf17Ptr.asFunction<int Function(double)>();

  double SDL_scalbn17(
    double x,
    int n,
  ) {
    return _SDL_scalbn17(
      x,
      n,
    );
  }

  late final _SDL_scalbn17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn17 =
      _SDL_scalbn17Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf17(
    double x,
    int n,
  ) {
    return _SDL_scalbnf17(
      x,
      n,
    );
  }

  late final _SDL_scalbnf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf17 =
      _SDL_scalbnf17Ptr.asFunction<double Function(double, int)>();

  double SDL_sin17(
    double x,
  ) {
    return _SDL_sin17(
      x,
    );
  }

  late final _SDL_sin17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin17 = _SDL_sin17Ptr.asFunction<double Function(double)>();

  double SDL_sinf17(
    double x,
  ) {
    return _SDL_sinf17(
      x,
    );
  }

  late final _SDL_sinf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf17 = _SDL_sinf17Ptr.asFunction<double Function(double)>();

  double SDL_sqrt17(
    double x,
  ) {
    return _SDL_sqrt17(
      x,
    );
  }

  late final _SDL_sqrt17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt17 = _SDL_sqrt17Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf17(
    double x,
  ) {
    return _SDL_sqrtf17(
      x,
    );
  }

  late final _SDL_sqrtf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf17 =
      _SDL_sqrtf17Ptr.asFunction<double Function(double)>();

  double SDL_tan17(
    double x,
  ) {
    return _SDL_tan17(
      x,
    );
  }

  late final _SDL_tan17Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan17 = _SDL_tan17Ptr.asFunction<double Function(double)>();

  double SDL_tanf17(
    double x,
  ) {
    return _SDL_tanf17(
      x,
    );
  }

  late final _SDL_tanf17Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf17 = _SDL_tanf17Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open17(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open17(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open17Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open17 = _SDL_iconv_open17Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close17(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close17(
      cd,
    );
  }

  late final _SDL_iconv_close17Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close17 =
      _SDL_iconv_close17Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv17(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv17(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv17 = _SDL_iconv17Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string17(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string17(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string17 = _SDL_iconv_string17Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Try to lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  /// \returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already
  /// held.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicUnlock
  int SDL_AtomicTryLock3(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicTryLock3(
      lock,
    );
  }

  late final _SDL_AtomicTryLock3Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_SpinLock>)>>(
      'SDL_AtomicTryLock');
  late final _SDL_AtomicTryLock3 = _SDL_AtomicTryLock3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Lock a spin lock by setting it to a non-zero value.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicTryLock
  /// \sa SDL_AtomicUnlock
  void SDL_AtomicLock3(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicLock3(
      lock,
    );
  }

  late final _SDL_AtomicLock3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicLock');
  late final _SDL_AtomicLock3 = _SDL_AtomicLock3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Unlock a spin lock by setting it to 0.
  ///
  /// Always returns immediately.
  ///
  /// ***Please note that spinlocks are dangerous if you don't know what you're
  /// doing. Please be careful using any sort of spinlock!***
  ///
  /// \param lock a pointer to a lock variable
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicLock
  /// \sa SDL_AtomicTryLock
  void SDL_AtomicUnlock3(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicUnlock3(
      lock,
    );
  }

  late final _SDL_AtomicUnlock3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicUnlock');
  late final _SDL_AtomicUnlock3 = _SDL_AtomicUnlock3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Memory barriers are designed to prevent reads and writes from being
  /// reordered by the compiler and being seen out of order on multi-core CPUs.
  ///
  /// A typical pattern would be for thread A to write some data and a flag, and
  /// for thread B to read the flag and get the data. In this case you would
  /// insert a release barrier between writing the data and the flag,
  /// guaranteeing that the data write completes no later than the flag is
  /// written, and you would insert an acquire barrier between reading the flag
  /// and reading the data, to ensure that all the reads associated with the flag
  /// have completed.
  ///
  /// In this pattern you should always see a release barrier paired with an
  /// acquire barrier and you should gate the data reads/writes with a single
  /// flag variable.
  ///
  /// For more information on these semantics, take a look at the blog post:
  /// http://preshing.com/20120913/acquire-and-release-semantics
  ///
  /// \since This function is available since SDL 2.0.6.
  void SDL_MemoryBarrierReleaseFunction3() {
    return _SDL_MemoryBarrierReleaseFunction3();
  }

  late final _SDL_MemoryBarrierReleaseFunction3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierReleaseFunction');
  late final _SDL_MemoryBarrierReleaseFunction3 =
      _SDL_MemoryBarrierReleaseFunction3Ptr.asFunction<void Function()>();

  void SDL_MemoryBarrierAcquireFunction3() {
    return _SDL_MemoryBarrierAcquireFunction3();
  }

  late final _SDL_MemoryBarrierAcquireFunction3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierAcquireFunction');
  late final _SDL_MemoryBarrierAcquireFunction3 =
      _SDL_MemoryBarrierAcquireFunction3Ptr.asFunction<void Function()>();

  /// Set an atomic variable to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param oldval the old value
  /// \param newval the new value
  /// \returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGet
  /// \sa SDL_AtomicSet
  int SDL_AtomicCAS3(
    ffi.Pointer<SDL_atomic_t> a,
    int oldval,
    int newval,
  ) {
    return _SDL_AtomicCAS3(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCAS3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int, ffi.Int)>>('SDL_AtomicCAS');
  late final _SDL_AtomicCAS3 = _SDL_AtomicCAS3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int, int)>();

  /// Set an atomic variable to a value.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicGet
  int SDL_AtomicSet3(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicSet3(
      a,
      v,
    );
  }

  late final _SDL_AtomicSet3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicSet');
  late final _SDL_AtomicSet3 = _SDL_AtomicSet3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Get the value of an atomic variable.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable
  /// \returns the current value of an atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicSet
  int SDL_AtomicGet3(
    ffi.Pointer<SDL_atomic_t> a,
  ) {
    return _SDL_AtomicGet3(
      a,
    );
  }

  late final _SDL_AtomicGet3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_atomic_t>)>>(
          'SDL_AtomicGet');
  late final _SDL_AtomicGet3 =
      _SDL_AtomicGet3Ptr.asFunction<int Function(ffi.Pointer<SDL_atomic_t>)>();

  /// Add to an atomic variable.
  ///
  /// This function also acts as a full memory barrier.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to an SDL_atomic_t variable to be modified
  /// \param v the desired value to add
  /// \returns the previous value of the atomic variable.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicDecRef
  /// \sa SDL_AtomicIncRef
  int SDL_AtomicAdd3(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicAdd3(
      a,
      v,
    );
  }

  late final _SDL_AtomicAdd3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int)>>('SDL_AtomicAdd');
  late final _SDL_AtomicAdd3 = _SDL_AtomicAdd3Ptr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// Set a pointer to a new value if it is currently an old value.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param oldval the old pointer value
  /// \param newval the new pointer value
  /// \returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AtomicCAS
  /// \sa SDL_AtomicGetPtr
  /// \sa SDL_AtomicSetPtr
  int SDL_AtomicCASPtr3(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> oldval,
    ffi.Pointer<ffi.Void> newval,
  ) {
    return _SDL_AtomicCASPtr3(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicCASPtr');
  late final _SDL_AtomicCASPtr3 = _SDL_AtomicCASPtr3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// Set a pointer to a value atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \param v the desired pointer value
  /// \returns the previous value of the pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicGetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicSetPtr3(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> v,
  ) {
    return _SDL_AtomicSetPtr3(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicSetPtr');
  late final _SDL_AtomicSetPtr3 = _SDL_AtomicSetPtr3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>)>();

  /// Get the value of a pointer atomically.
  ///
  /// ***Note: If you don't know what this function is for, you shouldn't use
  /// it!***
  ///
  /// \param a a pointer to a pointer
  /// \returns the current value of a pointer.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_AtomicCASPtr
  /// \sa SDL_AtomicSetPtr
  ffi.Pointer<ffi.Void> SDL_AtomicGetPtr3(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ) {
    return _SDL_AtomicGetPtr3(
      a,
    );
  }

  late final _SDL_AtomicGetPtr3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_AtomicGetPtr');
  late final _SDL_AtomicGetPtr3 = _SDL_AtomicGetPtr3Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform19() {
    return _SDL_GetPlatform19();
  }

  late final _SDL_GetPlatform19Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform19 =
      _SDL_GetPlatform19Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc18(
    int size,
  ) {
    return _SDL_malloc18(
      size,
    );
  }

  late final _SDL_malloc18Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc18 =
      _SDL_malloc18Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc18(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc18(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc18 =
      _SDL_calloc18Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc18(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc18(
      mem,
      size,
    );
  }

  late final _SDL_realloc18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc18 = _SDL_realloc18Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free18(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free18(
      mem,
    );
  }

  late final _SDL_free18Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free18 =
      _SDL_free18Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions18(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions18(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions18 =
      _SDL_GetMemoryFunctions18Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions18(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions18(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions18 =
      _SDL_SetMemoryFunctions18Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations18() {
    return _SDL_GetNumAllocations18();
  }

  late final _SDL_GetNumAllocations18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations18 =
      _SDL_GetNumAllocations18Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv18(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv18(
      name,
    );
  }

  late final _SDL_getenv18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv18 = _SDL_getenv18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv18(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv18(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv18 = _SDL_setenv18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort18(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort18(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort18 = _SDL_qsort18Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs18(
    int x,
  ) {
    return _SDL_abs18(
      x,
    );
  }

  late final _SDL_abs18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs18 = _SDL_abs18Ptr.asFunction<int Function(int)>();

  int SDL_isalpha18(
    int x,
  ) {
    return _SDL_isalpha18(
      x,
    );
  }

  late final _SDL_isalpha18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha18 = _SDL_isalpha18Ptr.asFunction<int Function(int)>();

  int SDL_isalnum18(
    int x,
  ) {
    return _SDL_isalnum18(
      x,
    );
  }

  late final _SDL_isalnum18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum18 = _SDL_isalnum18Ptr.asFunction<int Function(int)>();

  int SDL_isblank18(
    int x,
  ) {
    return _SDL_isblank18(
      x,
    );
  }

  late final _SDL_isblank18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank18 = _SDL_isblank18Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl18(
    int x,
  ) {
    return _SDL_iscntrl18(
      x,
    );
  }

  late final _SDL_iscntrl18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl18 = _SDL_iscntrl18Ptr.asFunction<int Function(int)>();

  int SDL_isdigit18(
    int x,
  ) {
    return _SDL_isdigit18(
      x,
    );
  }

  late final _SDL_isdigit18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit18 = _SDL_isdigit18Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit18(
    int x,
  ) {
    return _SDL_isxdigit18(
      x,
    );
  }

  late final _SDL_isxdigit18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit18 =
      _SDL_isxdigit18Ptr.asFunction<int Function(int)>();

  int SDL_ispunct18(
    int x,
  ) {
    return _SDL_ispunct18(
      x,
    );
  }

  late final _SDL_ispunct18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct18 = _SDL_ispunct18Ptr.asFunction<int Function(int)>();

  int SDL_isspace18(
    int x,
  ) {
    return _SDL_isspace18(
      x,
    );
  }

  late final _SDL_isspace18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace18 = _SDL_isspace18Ptr.asFunction<int Function(int)>();

  int SDL_isupper18(
    int x,
  ) {
    return _SDL_isupper18(
      x,
    );
  }

  late final _SDL_isupper18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper18 = _SDL_isupper18Ptr.asFunction<int Function(int)>();

  int SDL_islower18(
    int x,
  ) {
    return _SDL_islower18(
      x,
    );
  }

  late final _SDL_islower18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower18 = _SDL_islower18Ptr.asFunction<int Function(int)>();

  int SDL_isprint18(
    int x,
  ) {
    return _SDL_isprint18(
      x,
    );
  }

  late final _SDL_isprint18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint18 = _SDL_isprint18Ptr.asFunction<int Function(int)>();

  int SDL_isgraph18(
    int x,
  ) {
    return _SDL_isgraph18(
      x,
    );
  }

  late final _SDL_isgraph18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph18 = _SDL_isgraph18Ptr.asFunction<int Function(int)>();

  int SDL_toupper18(
    int x,
  ) {
    return _SDL_toupper18(
      x,
    );
  }

  late final _SDL_toupper18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper18 = _SDL_toupper18Ptr.asFunction<int Function(int)>();

  int SDL_tolower18(
    int x,
  ) {
    return _SDL_tolower18(
      x,
    );
  }

  late final _SDL_tolower18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower18 = _SDL_tolower18Ptr.asFunction<int Function(int)>();

  int SDL_crc3218(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3218(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3218Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3218 = _SDL_crc3218Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset18(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset18(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset18 = _SDL_memset18Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy18(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy18(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy18 = _SDL_memcpy18Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove18(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove18(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove18 = _SDL_memmove18Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp18(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp18(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp18 = _SDL_memcmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen18(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen18(
      wstr,
    );
  }

  late final _SDL_wcslen18Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen18 =
      _SDL_wcslen18Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy18(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy18(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy18 = _SDL_wcslcpy18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat18(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat18(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat18 = _SDL_wcslcat18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup18(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup18(
      wstr,
    );
  }

  late final _SDL_wcsdup18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup18 = _SDL_wcsdup18Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr18(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr18(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr18 = _SDL_wcsstr18Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp18(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp18(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp18 = _SDL_wcscmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp18(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp18(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp18 = _SDL_wcsncmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp18(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp18(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp18 = _SDL_wcscasecmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp18(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp18(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp18 = _SDL_wcsncasecmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen18(
      str,
    );
  }

  late final _SDL_strlen18Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen18 =
      _SDL_strlen18Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy18(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy18(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy18 = _SDL_strlcpy18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy18(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy18(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy18 = _SDL_utf8strlcpy18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat18(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat18(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat18 = _SDL_strlcat18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup18(
      str,
    );
  }

  late final _SDL_strdup18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup18 = _SDL_strdup18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev18(
      str,
    );
  }

  late final _SDL_strrev18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev18 = _SDL_strrev18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr18(
      str,
    );
  }

  late final _SDL_strupr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr18 = _SDL_strupr18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr18(
      str,
    );
  }

  late final _SDL_strlwr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr18 = _SDL_strlwr18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr18(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr18(
      str,
      c,
    );
  }

  late final _SDL_strchr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr18 = _SDL_strchr18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr18(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr18(
      str,
      c,
    );
  }

  late final _SDL_strrchr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr18 = _SDL_strrchr18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr18(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr18(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr18 = _SDL_strstr18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr18(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr18(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr18 = _SDL_strtokr18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen18(
      str,
    );
  }

  late final _SDL_utf8strlen18Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen18 =
      _SDL_utf8strlen18Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa18(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa18(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa18 = _SDL_itoa18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa18(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa18(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa18 = _SDL_uitoa18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa18(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa18(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa18 = _SDL_ltoa18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa18(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa18(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa18 = _SDL_ultoa18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa18(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa18(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa18 = _SDL_lltoa18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa18(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa18(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa18 = _SDL_ulltoa18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi18(
      str,
    );
  }

  late final _SDL_atoi18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi18 =
      _SDL_atoi18Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof18(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof18(
      str,
    );
  }

  late final _SDL_atof18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof18 =
      _SDL_atof18Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol18(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol18(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol18 = _SDL_strtol18Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul18(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul18(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul18 = _SDL_strtoul18Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll18(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll18(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll18Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll18 = _SDL_strtoll18Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull18(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull18(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull18Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull18 = _SDL_strtoull18Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod18(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod18(
      str,
      endp,
    );
  }

  late final _SDL_strtod18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod18 = _SDL_strtod18Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp18(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp18(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp18 = _SDL_strcmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp18(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp18(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp18 = _SDL_strncmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp18(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp18(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp18 = _SDL_strcasecmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp18(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp18(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp18 = _SDL_strncasecmp18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf18(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf18(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf18 = _SDL_sscanf18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf18(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf18(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf18 = _SDL_vsscanf18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf18(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf18(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf18 = _SDL_snprintf18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf18(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf18(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf18 = _SDL_vsnprintf18Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf18(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf18(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf18 = _SDL_asprintf18Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf18(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf18(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf18 = _SDL_vasprintf18Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos18(
    double x,
  ) {
    return _SDL_acos18(
      x,
    );
  }

  late final _SDL_acos18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos18 = _SDL_acos18Ptr.asFunction<double Function(double)>();

  double SDL_acosf18(
    double x,
  ) {
    return _SDL_acosf18(
      x,
    );
  }

  late final _SDL_acosf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf18 =
      _SDL_acosf18Ptr.asFunction<double Function(double)>();

  double SDL_asin18(
    double x,
  ) {
    return _SDL_asin18(
      x,
    );
  }

  late final _SDL_asin18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin18 = _SDL_asin18Ptr.asFunction<double Function(double)>();

  double SDL_asinf18(
    double x,
  ) {
    return _SDL_asinf18(
      x,
    );
  }

  late final _SDL_asinf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf18 =
      _SDL_asinf18Ptr.asFunction<double Function(double)>();

  double SDL_atan19(
    double x,
  ) {
    return _SDL_atan19(
      x,
    );
  }

  late final _SDL_atan19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan19 = _SDL_atan19Ptr.asFunction<double Function(double)>();

  double SDL_atanf18(
    double x,
  ) {
    return _SDL_atanf18(
      x,
    );
  }

  late final _SDL_atanf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf18 =
      _SDL_atanf18Ptr.asFunction<double Function(double)>();

  double SDL_atan218(
    double y,
    double x,
  ) {
    return _SDL_atan218(
      y,
      x,
    );
  }

  late final _SDL_atan218Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan218 =
      _SDL_atan218Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f18(
    double y,
    double x,
  ) {
    return _SDL_atan2f18(
      y,
      x,
    );
  }

  late final _SDL_atan2f18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f18 =
      _SDL_atan2f18Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil18(
    double x,
  ) {
    return _SDL_ceil18(
      x,
    );
  }

  late final _SDL_ceil18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil18 = _SDL_ceil18Ptr.asFunction<double Function(double)>();

  double SDL_ceilf18(
    double x,
  ) {
    return _SDL_ceilf18(
      x,
    );
  }

  late final _SDL_ceilf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf18 =
      _SDL_ceilf18Ptr.asFunction<double Function(double)>();

  double SDL_copysign18(
    double x,
    double y,
  ) {
    return _SDL_copysign18(
      x,
      y,
    );
  }

  late final _SDL_copysign18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign18 =
      _SDL_copysign18Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf18(
    double x,
    double y,
  ) {
    return _SDL_copysignf18(
      x,
      y,
    );
  }

  late final _SDL_copysignf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf18 =
      _SDL_copysignf18Ptr.asFunction<double Function(double, double)>();

  double SDL_cos18(
    double x,
  ) {
    return _SDL_cos18(
      x,
    );
  }

  late final _SDL_cos18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos18 = _SDL_cos18Ptr.asFunction<double Function(double)>();

  double SDL_cosf18(
    double x,
  ) {
    return _SDL_cosf18(
      x,
    );
  }

  late final _SDL_cosf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf18 = _SDL_cosf18Ptr.asFunction<double Function(double)>();

  double SDL_exp18(
    double x,
  ) {
    return _SDL_exp18(
      x,
    );
  }

  late final _SDL_exp18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp18 = _SDL_exp18Ptr.asFunction<double Function(double)>();

  double SDL_expf18(
    double x,
  ) {
    return _SDL_expf18(
      x,
    );
  }

  late final _SDL_expf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf18 = _SDL_expf18Ptr.asFunction<double Function(double)>();

  double SDL_fabs18(
    double x,
  ) {
    return _SDL_fabs18(
      x,
    );
  }

  late final _SDL_fabs18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs18 = _SDL_fabs18Ptr.asFunction<double Function(double)>();

  double SDL_fabsf18(
    double x,
  ) {
    return _SDL_fabsf18(
      x,
    );
  }

  late final _SDL_fabsf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf18 =
      _SDL_fabsf18Ptr.asFunction<double Function(double)>();

  double SDL_floor18(
    double x,
  ) {
    return _SDL_floor18(
      x,
    );
  }

  late final _SDL_floor18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor18 =
      _SDL_floor18Ptr.asFunction<double Function(double)>();

  double SDL_floorf18(
    double x,
  ) {
    return _SDL_floorf18(
      x,
    );
  }

  late final _SDL_floorf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf18 =
      _SDL_floorf18Ptr.asFunction<double Function(double)>();

  double SDL_trunc18(
    double x,
  ) {
    return _SDL_trunc18(
      x,
    );
  }

  late final _SDL_trunc18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc18 =
      _SDL_trunc18Ptr.asFunction<double Function(double)>();

  double SDL_truncf18(
    double x,
  ) {
    return _SDL_truncf18(
      x,
    );
  }

  late final _SDL_truncf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf18 =
      _SDL_truncf18Ptr.asFunction<double Function(double)>();

  double SDL_fmod18(
    double x,
    double y,
  ) {
    return _SDL_fmod18(
      x,
      y,
    );
  }

  late final _SDL_fmod18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod18 =
      _SDL_fmod18Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf18(
    double x,
    double y,
  ) {
    return _SDL_fmodf18(
      x,
      y,
    );
  }

  late final _SDL_fmodf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf18 =
      _SDL_fmodf18Ptr.asFunction<double Function(double, double)>();

  double SDL_log19(
    double x,
  ) {
    return _SDL_log19(
      x,
    );
  }

  late final _SDL_log19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log19 = _SDL_log19Ptr.asFunction<double Function(double)>();

  double SDL_logf18(
    double x,
  ) {
    return _SDL_logf18(
      x,
    );
  }

  late final _SDL_logf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf18 = _SDL_logf18Ptr.asFunction<double Function(double)>();

  double SDL_log1018(
    double x,
  ) {
    return _SDL_log1018(
      x,
    );
  }

  late final _SDL_log1018Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1018 =
      _SDL_log1018Ptr.asFunction<double Function(double)>();

  double SDL_log10f18(
    double x,
  ) {
    return _SDL_log10f18(
      x,
    );
  }

  late final _SDL_log10f18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f18 =
      _SDL_log10f18Ptr.asFunction<double Function(double)>();

  double SDL_pow18(
    double x,
    double y,
  ) {
    return _SDL_pow18(
      x,
      y,
    );
  }

  late final _SDL_pow18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow18 =
      _SDL_pow18Ptr.asFunction<double Function(double, double)>();

  double SDL_powf18(
    double x,
    double y,
  ) {
    return _SDL_powf18(
      x,
      y,
    );
  }

  late final _SDL_powf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf18 =
      _SDL_powf18Ptr.asFunction<double Function(double, double)>();

  double SDL_round18(
    double x,
  ) {
    return _SDL_round18(
      x,
    );
  }

  late final _SDL_round18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round18 =
      _SDL_round18Ptr.asFunction<double Function(double)>();

  double SDL_roundf18(
    double x,
  ) {
    return _SDL_roundf18(
      x,
    );
  }

  late final _SDL_roundf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf18 =
      _SDL_roundf18Ptr.asFunction<double Function(double)>();

  int SDL_lround18(
    double x,
  ) {
    return _SDL_lround18(
      x,
    );
  }

  late final _SDL_lround18Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround18 =
      _SDL_lround18Ptr.asFunction<int Function(double)>();

  int SDL_lroundf18(
    double x,
  ) {
    return _SDL_lroundf18(
      x,
    );
  }

  late final _SDL_lroundf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf18 =
      _SDL_lroundf18Ptr.asFunction<int Function(double)>();

  double SDL_scalbn18(
    double x,
    int n,
  ) {
    return _SDL_scalbn18(
      x,
      n,
    );
  }

  late final _SDL_scalbn18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn18 =
      _SDL_scalbn18Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf18(
    double x,
    int n,
  ) {
    return _SDL_scalbnf18(
      x,
      n,
    );
  }

  late final _SDL_scalbnf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf18 =
      _SDL_scalbnf18Ptr.asFunction<double Function(double, int)>();

  double SDL_sin18(
    double x,
  ) {
    return _SDL_sin18(
      x,
    );
  }

  late final _SDL_sin18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin18 = _SDL_sin18Ptr.asFunction<double Function(double)>();

  double SDL_sinf18(
    double x,
  ) {
    return _SDL_sinf18(
      x,
    );
  }

  late final _SDL_sinf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf18 = _SDL_sinf18Ptr.asFunction<double Function(double)>();

  double SDL_sqrt18(
    double x,
  ) {
    return _SDL_sqrt18(
      x,
    );
  }

  late final _SDL_sqrt18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt18 = _SDL_sqrt18Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf18(
    double x,
  ) {
    return _SDL_sqrtf18(
      x,
    );
  }

  late final _SDL_sqrtf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf18 =
      _SDL_sqrtf18Ptr.asFunction<double Function(double)>();

  double SDL_tan18(
    double x,
  ) {
    return _SDL_tan18(
      x,
    );
  }

  late final _SDL_tan18Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan18 = _SDL_tan18Ptr.asFunction<double Function(double)>();

  double SDL_tanf18(
    double x,
  ) {
    return _SDL_tanf18(
      x,
    );
  }

  late final _SDL_tanf18Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf18 = _SDL_tanf18Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open18(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open18(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open18Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open18 = _SDL_iconv_open18Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close18(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close18(
      cd,
    );
  }

  late final _SDL_iconv_close18Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close18 =
      _SDL_iconv_close18Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv18(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv18(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv18 = _SDL_iconv18Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string18(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string18(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string18 = _SDL_iconv_string18Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError11(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError11(
      fmt,
    );
  }

  late final _SDL_SetError11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError11 =
      _SDL_SetError11Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError11() {
    return _SDL_GetError11();
  }

  late final _SDL_GetError11Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError11 =
      _SDL_GetError11Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg11(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg11(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg11 = _SDL_GetErrorMsg11Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError11() {
    return _SDL_ClearError11();
  }

  late final _SDL_ClearError11Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError11 =
      _SDL_ClearError11Ptr.asFunction<void Function()>();

  int SDL_Error11(
    int code,
  ) {
    return _SDL_Error11(
      code,
    );
  }

  late final _SDL_Error11Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error11 = _SDL_Error11Ptr.asFunction<int Function(int)>();

  /// Get the number of milliseconds since SDL library initialization.
  ///
  /// This value wraps if the program runs for more than ~49 days.
  ///
  /// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()
  /// instead, where the value doesn't wrap every ~49 days. There are places in
  /// SDL where we provide a 32-bit timestamp that can not change without
  /// breaking binary compatibility, though, so this function isn't officially
  /// deprecated.
  ///
  /// \returns an unsigned 32-bit value representing the number of milliseconds
  /// since the SDL library initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_TICKS_PASSED
  int SDL_GetTicks1() {
    return _SDL_GetTicks1();
  }

  late final _SDL_GetTicks1Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function()>>('SDL_GetTicks');
  late final _SDL_GetTicks1 = _SDL_GetTicks1Ptr.asFunction<int Function()>();

  /// Get the number of milliseconds since SDL library initialization.
  ///
  /// Note that you should not use the SDL_TICKS_PASSED macro with values
  /// returned by this function, as that macro does clever math to compensate for
  /// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit
  /// values from this function can be safely compared directly.
  ///
  /// For example, if you want to wait 100 ms, you could do this:
  ///
  /// ```c
  /// const Uint64 timeout = SDL_GetTicks64() + 100;
  /// while (SDL_GetTicks64() < timeout) {
  /// // ... do work until timeout has elapsed
  /// }
  /// ```
  ///
  /// \returns an unsigned 64-bit value representing the number of milliseconds
  /// since the SDL library initialized.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_GetTicks641() {
    return _SDL_GetTicks641();
  }

  late final _SDL_GetTicks641Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>('SDL_GetTicks64');
  late final _SDL_GetTicks641 =
      _SDL_GetTicks641Ptr.asFunction<int Function()>();

  /// Get the current value of the high resolution counter.
  ///
  /// This function is typically used for profiling.
  ///
  /// The counter values are only meaningful relative to each other. Differences
  /// between values can be converted to times by using
  /// SDL_GetPerformanceFrequency().
  ///
  /// \returns the current counter value.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetPerformanceFrequency
  int SDL_GetPerformanceCounter1() {
    return _SDL_GetPerformanceCounter1();
  }

  late final _SDL_GetPerformanceCounter1Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceCounter');
  late final _SDL_GetPerformanceCounter1 =
      _SDL_GetPerformanceCounter1Ptr.asFunction<int Function()>();

  /// Get the count per second of the high resolution counter.
  ///
  /// \returns a platform-specific count per second.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetPerformanceCounter
  int SDL_GetPerformanceFrequency1() {
    return _SDL_GetPerformanceFrequency1();
  }

  late final _SDL_GetPerformanceFrequency1Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceFrequency');
  late final _SDL_GetPerformanceFrequency1 =
      _SDL_GetPerformanceFrequency1Ptr.asFunction<int Function()>();

  /// Wait a specified number of milliseconds before returning.
  ///
  /// This function waits a specified number of milliseconds before returning. It
  /// waits at least the specified time, but possibly longer due to OS
  /// scheduling.
  ///
  /// \param ms the number of milliseconds to delay
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_Delay1(
    int ms,
  ) {
    return _SDL_Delay1(
      ms,
    );
  }

  late final _SDL_Delay1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_Delay');
  late final _SDL_Delay1 = _SDL_Delay1Ptr.asFunction<void Function(int)>();

  /// Call a callback function at a future time.
  ///
  /// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().
  ///
  /// The callback function is passed the current timer interval and the user
  /// supplied parameter from the SDL_AddTimer() call and should return the next
  /// timer interval. If the value returned from the callback is 0, the timer is
  /// canceled.
  ///
  /// The callback is run on a separate thread.
  ///
  /// Timers take into account the amount of time it took to execute the
  /// callback. For example, if the callback took 250 ms to execute and returned
  /// 1000 (ms), the timer would only wait another 750 ms before its next
  /// iteration.
  ///
  /// Timing may be inexact due to OS scheduling. Be sure to note the current
  /// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your
  /// callback needs to adjust for variances.
  ///
  /// \param interval the timer delay, in milliseconds, passed to `callback`
  /// \param callback the SDL_TimerCallback function to call when the specified
  /// `interval` elapses
  /// \param param a pointer that is passed to `callback`
  /// \returns a timer ID or 0 if an error occurs; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RemoveTimer
  int SDL_AddTimer1(
    int interval,
    SDL_TimerCallback callback,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _SDL_AddTimer1(
      interval,
      callback,
      param,
    );
  }

  late final _SDL_AddTimer1Ptr = _lookup<
      ffi.NativeFunction<
          SDL_TimerID Function(Uint32, SDL_TimerCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddTimer');
  late final _SDL_AddTimer1 = _SDL_AddTimer1Ptr.asFunction<
      int Function(int, SDL_TimerCallback, ffi.Pointer<ffi.Void>)>();

  /// Remove a timer created with SDL_AddTimer().
  ///
  /// \param id the ID of the timer to remove
  /// \returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't
  /// found.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AddTimer
  int SDL_RemoveTimer1(
    int id,
  ) {
    return _SDL_RemoveTimer1(
      id,
    );
  }

  late final _SDL_RemoveTimer1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TimerID)>>(
          'SDL_RemoveTimer');
  late final _SDL_RemoveTimer1 =
      _SDL_RemoveTimer1Ptr.asFunction<int Function(int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform20() {
    return _SDL_GetPlatform20();
  }

  late final _SDL_GetPlatform20Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform20 =
      _SDL_GetPlatform20Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc19(
    int size,
  ) {
    return _SDL_malloc19(
      size,
    );
  }

  late final _SDL_malloc19Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc19 =
      _SDL_malloc19Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc19(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc19(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc19 =
      _SDL_calloc19Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc19(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc19(
      mem,
      size,
    );
  }

  late final _SDL_realloc19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc19 = _SDL_realloc19Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free19(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free19(
      mem,
    );
  }

  late final _SDL_free19Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free19 =
      _SDL_free19Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions19(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions19(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions19 =
      _SDL_GetMemoryFunctions19Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions19(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions19(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions19 =
      _SDL_SetMemoryFunctions19Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations19() {
    return _SDL_GetNumAllocations19();
  }

  late final _SDL_GetNumAllocations19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations19 =
      _SDL_GetNumAllocations19Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv19(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv19(
      name,
    );
  }

  late final _SDL_getenv19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv19 = _SDL_getenv19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv19(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv19(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv19 = _SDL_setenv19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort19(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort19(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort19 = _SDL_qsort19Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs19(
    int x,
  ) {
    return _SDL_abs19(
      x,
    );
  }

  late final _SDL_abs19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs19 = _SDL_abs19Ptr.asFunction<int Function(int)>();

  int SDL_isalpha19(
    int x,
  ) {
    return _SDL_isalpha19(
      x,
    );
  }

  late final _SDL_isalpha19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha19 = _SDL_isalpha19Ptr.asFunction<int Function(int)>();

  int SDL_isalnum19(
    int x,
  ) {
    return _SDL_isalnum19(
      x,
    );
  }

  late final _SDL_isalnum19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum19 = _SDL_isalnum19Ptr.asFunction<int Function(int)>();

  int SDL_isblank19(
    int x,
  ) {
    return _SDL_isblank19(
      x,
    );
  }

  late final _SDL_isblank19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank19 = _SDL_isblank19Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl19(
    int x,
  ) {
    return _SDL_iscntrl19(
      x,
    );
  }

  late final _SDL_iscntrl19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl19 = _SDL_iscntrl19Ptr.asFunction<int Function(int)>();

  int SDL_isdigit19(
    int x,
  ) {
    return _SDL_isdigit19(
      x,
    );
  }

  late final _SDL_isdigit19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit19 = _SDL_isdigit19Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit19(
    int x,
  ) {
    return _SDL_isxdigit19(
      x,
    );
  }

  late final _SDL_isxdigit19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit19 =
      _SDL_isxdigit19Ptr.asFunction<int Function(int)>();

  int SDL_ispunct19(
    int x,
  ) {
    return _SDL_ispunct19(
      x,
    );
  }

  late final _SDL_ispunct19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct19 = _SDL_ispunct19Ptr.asFunction<int Function(int)>();

  int SDL_isspace19(
    int x,
  ) {
    return _SDL_isspace19(
      x,
    );
  }

  late final _SDL_isspace19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace19 = _SDL_isspace19Ptr.asFunction<int Function(int)>();

  int SDL_isupper19(
    int x,
  ) {
    return _SDL_isupper19(
      x,
    );
  }

  late final _SDL_isupper19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper19 = _SDL_isupper19Ptr.asFunction<int Function(int)>();

  int SDL_islower19(
    int x,
  ) {
    return _SDL_islower19(
      x,
    );
  }

  late final _SDL_islower19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower19 = _SDL_islower19Ptr.asFunction<int Function(int)>();

  int SDL_isprint19(
    int x,
  ) {
    return _SDL_isprint19(
      x,
    );
  }

  late final _SDL_isprint19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint19 = _SDL_isprint19Ptr.asFunction<int Function(int)>();

  int SDL_isgraph19(
    int x,
  ) {
    return _SDL_isgraph19(
      x,
    );
  }

  late final _SDL_isgraph19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph19 = _SDL_isgraph19Ptr.asFunction<int Function(int)>();

  int SDL_toupper19(
    int x,
  ) {
    return _SDL_toupper19(
      x,
    );
  }

  late final _SDL_toupper19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper19 = _SDL_toupper19Ptr.asFunction<int Function(int)>();

  int SDL_tolower19(
    int x,
  ) {
    return _SDL_tolower19(
      x,
    );
  }

  late final _SDL_tolower19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower19 = _SDL_tolower19Ptr.asFunction<int Function(int)>();

  int SDL_crc3219(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3219(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3219Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3219 = _SDL_crc3219Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset19(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset19(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset19 = _SDL_memset19Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy19(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy19(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy19 = _SDL_memcpy19Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove19(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove19(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove19 = _SDL_memmove19Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp19(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp19(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp19 = _SDL_memcmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen19(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen19(
      wstr,
    );
  }

  late final _SDL_wcslen19Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen19 =
      _SDL_wcslen19Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy19(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy19(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy19 = _SDL_wcslcpy19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat19(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat19(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat19 = _SDL_wcslcat19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup19(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup19(
      wstr,
    );
  }

  late final _SDL_wcsdup19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup19 = _SDL_wcsdup19Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr19(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr19(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr19 = _SDL_wcsstr19Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp19(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp19(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp19 = _SDL_wcscmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp19(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp19(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp19 = _SDL_wcsncmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp19(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp19(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp19 = _SDL_wcscasecmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp19(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp19(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp19 = _SDL_wcsncasecmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen19(
      str,
    );
  }

  late final _SDL_strlen19Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen19 =
      _SDL_strlen19Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy19(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy19(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy19 = _SDL_strlcpy19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy19(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy19(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy19 = _SDL_utf8strlcpy19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat19(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat19(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat19 = _SDL_strlcat19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup19(
      str,
    );
  }

  late final _SDL_strdup19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup19 = _SDL_strdup19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev19(
      str,
    );
  }

  late final _SDL_strrev19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev19 = _SDL_strrev19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr19(
      str,
    );
  }

  late final _SDL_strupr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr19 = _SDL_strupr19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr19(
      str,
    );
  }

  late final _SDL_strlwr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr19 = _SDL_strlwr19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr19(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr19(
      str,
      c,
    );
  }

  late final _SDL_strchr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr19 = _SDL_strchr19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr19(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr19(
      str,
      c,
    );
  }

  late final _SDL_strrchr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr19 = _SDL_strrchr19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr19(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr19(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr19 = _SDL_strstr19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr19(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr19(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr19 = _SDL_strtokr19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen19(
      str,
    );
  }

  late final _SDL_utf8strlen19Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen19 =
      _SDL_utf8strlen19Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa19(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa19(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa19 = _SDL_itoa19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa19(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa19(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa19 = _SDL_uitoa19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa19(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa19(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa19 = _SDL_ltoa19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa19(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa19(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa19 = _SDL_ultoa19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa19(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa19(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa19 = _SDL_lltoa19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa19(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa19(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa19 = _SDL_ulltoa19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi19(
      str,
    );
  }

  late final _SDL_atoi19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi19 =
      _SDL_atoi19Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof19(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof19(
      str,
    );
  }

  late final _SDL_atof19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof19 =
      _SDL_atof19Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol19(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol19(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol19 = _SDL_strtol19Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul19(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul19(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul19 = _SDL_strtoul19Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll19(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll19(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll19Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll19 = _SDL_strtoll19Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull19(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull19(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull19Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull19 = _SDL_strtoull19Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod19(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod19(
      str,
      endp,
    );
  }

  late final _SDL_strtod19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod19 = _SDL_strtod19Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp19(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp19(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp19 = _SDL_strcmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp19(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp19(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp19 = _SDL_strncmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp19(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp19(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp19 = _SDL_strcasecmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp19(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp19(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp19 = _SDL_strncasecmp19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf19(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf19(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf19 = _SDL_sscanf19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf19(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf19(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf19 = _SDL_vsscanf19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf19(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf19(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf19 = _SDL_snprintf19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf19(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf19(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf19 = _SDL_vsnprintf19Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf19(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf19(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf19 = _SDL_asprintf19Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf19(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf19(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf19 = _SDL_vasprintf19Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos19(
    double x,
  ) {
    return _SDL_acos19(
      x,
    );
  }

  late final _SDL_acos19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos19 = _SDL_acos19Ptr.asFunction<double Function(double)>();

  double SDL_acosf19(
    double x,
  ) {
    return _SDL_acosf19(
      x,
    );
  }

  late final _SDL_acosf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf19 =
      _SDL_acosf19Ptr.asFunction<double Function(double)>();

  double SDL_asin19(
    double x,
  ) {
    return _SDL_asin19(
      x,
    );
  }

  late final _SDL_asin19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin19 = _SDL_asin19Ptr.asFunction<double Function(double)>();

  double SDL_asinf19(
    double x,
  ) {
    return _SDL_asinf19(
      x,
    );
  }

  late final _SDL_asinf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf19 =
      _SDL_asinf19Ptr.asFunction<double Function(double)>();

  double SDL_atan20(
    double x,
  ) {
    return _SDL_atan20(
      x,
    );
  }

  late final _SDL_atan20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan20 = _SDL_atan20Ptr.asFunction<double Function(double)>();

  double SDL_atanf19(
    double x,
  ) {
    return _SDL_atanf19(
      x,
    );
  }

  late final _SDL_atanf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf19 =
      _SDL_atanf19Ptr.asFunction<double Function(double)>();

  double SDL_atan219(
    double y,
    double x,
  ) {
    return _SDL_atan219(
      y,
      x,
    );
  }

  late final _SDL_atan219Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan219 =
      _SDL_atan219Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f19(
    double y,
    double x,
  ) {
    return _SDL_atan2f19(
      y,
      x,
    );
  }

  late final _SDL_atan2f19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f19 =
      _SDL_atan2f19Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil19(
    double x,
  ) {
    return _SDL_ceil19(
      x,
    );
  }

  late final _SDL_ceil19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil19 = _SDL_ceil19Ptr.asFunction<double Function(double)>();

  double SDL_ceilf19(
    double x,
  ) {
    return _SDL_ceilf19(
      x,
    );
  }

  late final _SDL_ceilf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf19 =
      _SDL_ceilf19Ptr.asFunction<double Function(double)>();

  double SDL_copysign19(
    double x,
    double y,
  ) {
    return _SDL_copysign19(
      x,
      y,
    );
  }

  late final _SDL_copysign19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign19 =
      _SDL_copysign19Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf19(
    double x,
    double y,
  ) {
    return _SDL_copysignf19(
      x,
      y,
    );
  }

  late final _SDL_copysignf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf19 =
      _SDL_copysignf19Ptr.asFunction<double Function(double, double)>();

  double SDL_cos19(
    double x,
  ) {
    return _SDL_cos19(
      x,
    );
  }

  late final _SDL_cos19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos19 = _SDL_cos19Ptr.asFunction<double Function(double)>();

  double SDL_cosf19(
    double x,
  ) {
    return _SDL_cosf19(
      x,
    );
  }

  late final _SDL_cosf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf19 = _SDL_cosf19Ptr.asFunction<double Function(double)>();

  double SDL_exp19(
    double x,
  ) {
    return _SDL_exp19(
      x,
    );
  }

  late final _SDL_exp19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp19 = _SDL_exp19Ptr.asFunction<double Function(double)>();

  double SDL_expf19(
    double x,
  ) {
    return _SDL_expf19(
      x,
    );
  }

  late final _SDL_expf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf19 = _SDL_expf19Ptr.asFunction<double Function(double)>();

  double SDL_fabs19(
    double x,
  ) {
    return _SDL_fabs19(
      x,
    );
  }

  late final _SDL_fabs19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs19 = _SDL_fabs19Ptr.asFunction<double Function(double)>();

  double SDL_fabsf19(
    double x,
  ) {
    return _SDL_fabsf19(
      x,
    );
  }

  late final _SDL_fabsf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf19 =
      _SDL_fabsf19Ptr.asFunction<double Function(double)>();

  double SDL_floor19(
    double x,
  ) {
    return _SDL_floor19(
      x,
    );
  }

  late final _SDL_floor19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor19 =
      _SDL_floor19Ptr.asFunction<double Function(double)>();

  double SDL_floorf19(
    double x,
  ) {
    return _SDL_floorf19(
      x,
    );
  }

  late final _SDL_floorf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf19 =
      _SDL_floorf19Ptr.asFunction<double Function(double)>();

  double SDL_trunc19(
    double x,
  ) {
    return _SDL_trunc19(
      x,
    );
  }

  late final _SDL_trunc19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc19 =
      _SDL_trunc19Ptr.asFunction<double Function(double)>();

  double SDL_truncf19(
    double x,
  ) {
    return _SDL_truncf19(
      x,
    );
  }

  late final _SDL_truncf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf19 =
      _SDL_truncf19Ptr.asFunction<double Function(double)>();

  double SDL_fmod19(
    double x,
    double y,
  ) {
    return _SDL_fmod19(
      x,
      y,
    );
  }

  late final _SDL_fmod19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod19 =
      _SDL_fmod19Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf19(
    double x,
    double y,
  ) {
    return _SDL_fmodf19(
      x,
      y,
    );
  }

  late final _SDL_fmodf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf19 =
      _SDL_fmodf19Ptr.asFunction<double Function(double, double)>();

  double SDL_log20(
    double x,
  ) {
    return _SDL_log20(
      x,
    );
  }

  late final _SDL_log20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log20 = _SDL_log20Ptr.asFunction<double Function(double)>();

  double SDL_logf19(
    double x,
  ) {
    return _SDL_logf19(
      x,
    );
  }

  late final _SDL_logf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf19 = _SDL_logf19Ptr.asFunction<double Function(double)>();

  double SDL_log1019(
    double x,
  ) {
    return _SDL_log1019(
      x,
    );
  }

  late final _SDL_log1019Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1019 =
      _SDL_log1019Ptr.asFunction<double Function(double)>();

  double SDL_log10f19(
    double x,
  ) {
    return _SDL_log10f19(
      x,
    );
  }

  late final _SDL_log10f19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f19 =
      _SDL_log10f19Ptr.asFunction<double Function(double)>();

  double SDL_pow19(
    double x,
    double y,
  ) {
    return _SDL_pow19(
      x,
      y,
    );
  }

  late final _SDL_pow19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow19 =
      _SDL_pow19Ptr.asFunction<double Function(double, double)>();

  double SDL_powf19(
    double x,
    double y,
  ) {
    return _SDL_powf19(
      x,
      y,
    );
  }

  late final _SDL_powf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf19 =
      _SDL_powf19Ptr.asFunction<double Function(double, double)>();

  double SDL_round19(
    double x,
  ) {
    return _SDL_round19(
      x,
    );
  }

  late final _SDL_round19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round19 =
      _SDL_round19Ptr.asFunction<double Function(double)>();

  double SDL_roundf19(
    double x,
  ) {
    return _SDL_roundf19(
      x,
    );
  }

  late final _SDL_roundf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf19 =
      _SDL_roundf19Ptr.asFunction<double Function(double)>();

  int SDL_lround19(
    double x,
  ) {
    return _SDL_lround19(
      x,
    );
  }

  late final _SDL_lround19Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround19 =
      _SDL_lround19Ptr.asFunction<int Function(double)>();

  int SDL_lroundf19(
    double x,
  ) {
    return _SDL_lroundf19(
      x,
    );
  }

  late final _SDL_lroundf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf19 =
      _SDL_lroundf19Ptr.asFunction<int Function(double)>();

  double SDL_scalbn19(
    double x,
    int n,
  ) {
    return _SDL_scalbn19(
      x,
      n,
    );
  }

  late final _SDL_scalbn19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn19 =
      _SDL_scalbn19Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf19(
    double x,
    int n,
  ) {
    return _SDL_scalbnf19(
      x,
      n,
    );
  }

  late final _SDL_scalbnf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf19 =
      _SDL_scalbnf19Ptr.asFunction<double Function(double, int)>();

  double SDL_sin19(
    double x,
  ) {
    return _SDL_sin19(
      x,
    );
  }

  late final _SDL_sin19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin19 = _SDL_sin19Ptr.asFunction<double Function(double)>();

  double SDL_sinf19(
    double x,
  ) {
    return _SDL_sinf19(
      x,
    );
  }

  late final _SDL_sinf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf19 = _SDL_sinf19Ptr.asFunction<double Function(double)>();

  double SDL_sqrt19(
    double x,
  ) {
    return _SDL_sqrt19(
      x,
    );
  }

  late final _SDL_sqrt19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt19 = _SDL_sqrt19Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf19(
    double x,
  ) {
    return _SDL_sqrtf19(
      x,
    );
  }

  late final _SDL_sqrtf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf19 =
      _SDL_sqrtf19Ptr.asFunction<double Function(double)>();

  double SDL_tan19(
    double x,
  ) {
    return _SDL_tan19(
      x,
    );
  }

  late final _SDL_tan19Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan19 = _SDL_tan19Ptr.asFunction<double Function(double)>();

  double SDL_tanf19(
    double x,
  ) {
    return _SDL_tanf19(
      x,
    );
  }

  late final _SDL_tanf19Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf19 = _SDL_tanf19Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open19(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open19(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open19Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open19 = _SDL_iconv_open19Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close19(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close19(
      cd,
    );
  }

  late final _SDL_iconv_close19Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close19 =
      _SDL_iconv_close19Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv19(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv19(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv19 = _SDL_iconv19Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string19(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string19(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string19 = _SDL_iconv_string19Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the directory where the application was run from.
  ///
  /// This is not necessarily a fast call, so you should call this once near
  /// startup and save the string if you need it.
  ///
  /// **Mac OS X and iOS Specific Functionality**: If the application is in a
  /// ".app" bundle, this function returns the Resource directory (e.g.
  /// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
  /// a property to the Info.plist file. Adding a string key with the name
  /// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
  /// behaviour.
  ///
  /// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
  /// application in /Applications/SDLApp/MyApp.app):
  ///
  /// - `resource`: bundle resource directory (the default). For example:
  /// `/Applications/SDLApp/MyApp.app/Contents/Resources`
  /// - `bundle`: the Bundle directory. For example:
  /// `/Applications/SDLApp/MyApp.app/`
  /// - `parent`: the containing directory of the bundle. For example:
  /// `/Applications/SDLApp/`
  ///
  /// The returned path is guaranteed to end with a path separator ('\' on
  /// Windows, '/' on most other platforms).
  ///
  /// The pointer returned is owned by the caller. Please call SDL_free() on the
  /// pointer when done with it.
  ///
  /// \returns an absolute path in UTF-8 encoding to the application data
  /// directory. NULL will be returned on error or when the platform
  /// doesn't implement this functionality, call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_GetPrefPath
  ffi.Pointer<ffi.Char> SDL_GetBasePath1() {
    return _SDL_GetBasePath1();
  }

  late final _SDL_GetBasePath1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetBasePath');
  late final _SDL_GetBasePath1 =
      _SDL_GetBasePath1Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the user-and-app-specific path where files can be written.
  ///
  /// Get the "pref dir". This is meant to be where users can write personal
  /// files (preferences and save games, etc) that are specific to your
  /// application. This directory is unique per user, per application.
  ///
  /// This function will decide the appropriate location in the native
  /// filesystem, create the directory if necessary, and return a string of the
  /// absolute path to the directory in UTF-8 encoding.
  ///
  /// On Windows, the string might look like:
  ///
  /// `C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\`
  ///
  /// On Linux, the string might look like"
  ///
  /// `/home/bob/.local/share/My Program Name/`
  ///
  /// On Mac OS X, the string might look like:
  ///
  /// `/Users/bob/Library/Application Support/My Program Name/`
  ///
  /// You should assume the path returned by this function is the only safe place
  /// to write files (and that SDL_GetBasePath(), while it might be writable, or
  /// even the parent of the returned path, isn't where you should be writing
  /// things).
  ///
  /// Both the org and app strings may become part of a directory name, so please
  /// follow these rules:
  ///
  /// - Try to use the same org string (_including case-sensitivity_) for all
  /// your applications that use this function.
  /// - Always use a unique app string for each one, and make sure it never
  /// changes for an app once you've decided on it.
  /// - Unicode characters are legal, as long as it's UTF-8 encoded, but...
  /// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
  /// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
  ///
  /// The returned path is guaranteed to end with a path separator ('\' on
  /// Windows, '/' on most other platforms).
  ///
  /// The pointer returned is owned by the caller. Please call SDL_free() on the
  /// pointer when done with it.
  ///
  /// \param org the name of your organization
  /// \param app the name of your application
  /// \returns a UTF-8 string of the user directory in platform-dependent
  /// notation. NULL if there's a problem (creating directory failed,
  /// etc.).
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_GetBasePath
  ffi.Pointer<ffi.Char> SDL_GetPrefPath1(
    ffi.Pointer<ffi.Char> org,
    ffi.Pointer<ffi.Char> app,
  ) {
    return _SDL_GetPrefPath1(
      org,
      app,
    );
  }

  late final _SDL_GetPrefPath1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetPrefPath');
  late final _SDL_GetPrefPath1 = _SDL_GetPrefPath1Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform21() {
    return _SDL_GetPlatform21();
  }

  late final _SDL_GetPlatform21Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform21 =
      _SDL_GetPlatform21Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc20(
    int size,
  ) {
    return _SDL_malloc20(
      size,
    );
  }

  late final _SDL_malloc20Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc20 =
      _SDL_malloc20Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc20(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc20(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc20 =
      _SDL_calloc20Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc20(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc20(
      mem,
      size,
    );
  }

  late final _SDL_realloc20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc20 = _SDL_realloc20Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free20(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free20(
      mem,
    );
  }

  late final _SDL_free20Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free20 =
      _SDL_free20Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions20(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions20(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions20 =
      _SDL_GetMemoryFunctions20Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions20(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions20(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions20 =
      _SDL_SetMemoryFunctions20Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations20() {
    return _SDL_GetNumAllocations20();
  }

  late final _SDL_GetNumAllocations20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations20 =
      _SDL_GetNumAllocations20Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv20(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv20(
      name,
    );
  }

  late final _SDL_getenv20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv20 = _SDL_getenv20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv20(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv20(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv20 = _SDL_setenv20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort20(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort20(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort20 = _SDL_qsort20Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs20(
    int x,
  ) {
    return _SDL_abs20(
      x,
    );
  }

  late final _SDL_abs20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs20 = _SDL_abs20Ptr.asFunction<int Function(int)>();

  int SDL_isalpha20(
    int x,
  ) {
    return _SDL_isalpha20(
      x,
    );
  }

  late final _SDL_isalpha20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha20 = _SDL_isalpha20Ptr.asFunction<int Function(int)>();

  int SDL_isalnum20(
    int x,
  ) {
    return _SDL_isalnum20(
      x,
    );
  }

  late final _SDL_isalnum20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum20 = _SDL_isalnum20Ptr.asFunction<int Function(int)>();

  int SDL_isblank20(
    int x,
  ) {
    return _SDL_isblank20(
      x,
    );
  }

  late final _SDL_isblank20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank20 = _SDL_isblank20Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl20(
    int x,
  ) {
    return _SDL_iscntrl20(
      x,
    );
  }

  late final _SDL_iscntrl20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl20 = _SDL_iscntrl20Ptr.asFunction<int Function(int)>();

  int SDL_isdigit20(
    int x,
  ) {
    return _SDL_isdigit20(
      x,
    );
  }

  late final _SDL_isdigit20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit20 = _SDL_isdigit20Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit20(
    int x,
  ) {
    return _SDL_isxdigit20(
      x,
    );
  }

  late final _SDL_isxdigit20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit20 =
      _SDL_isxdigit20Ptr.asFunction<int Function(int)>();

  int SDL_ispunct20(
    int x,
  ) {
    return _SDL_ispunct20(
      x,
    );
  }

  late final _SDL_ispunct20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct20 = _SDL_ispunct20Ptr.asFunction<int Function(int)>();

  int SDL_isspace20(
    int x,
  ) {
    return _SDL_isspace20(
      x,
    );
  }

  late final _SDL_isspace20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace20 = _SDL_isspace20Ptr.asFunction<int Function(int)>();

  int SDL_isupper20(
    int x,
  ) {
    return _SDL_isupper20(
      x,
    );
  }

  late final _SDL_isupper20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper20 = _SDL_isupper20Ptr.asFunction<int Function(int)>();

  int SDL_islower20(
    int x,
  ) {
    return _SDL_islower20(
      x,
    );
  }

  late final _SDL_islower20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower20 = _SDL_islower20Ptr.asFunction<int Function(int)>();

  int SDL_isprint20(
    int x,
  ) {
    return _SDL_isprint20(
      x,
    );
  }

  late final _SDL_isprint20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint20 = _SDL_isprint20Ptr.asFunction<int Function(int)>();

  int SDL_isgraph20(
    int x,
  ) {
    return _SDL_isgraph20(
      x,
    );
  }

  late final _SDL_isgraph20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph20 = _SDL_isgraph20Ptr.asFunction<int Function(int)>();

  int SDL_toupper20(
    int x,
  ) {
    return _SDL_toupper20(
      x,
    );
  }

  late final _SDL_toupper20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper20 = _SDL_toupper20Ptr.asFunction<int Function(int)>();

  int SDL_tolower20(
    int x,
  ) {
    return _SDL_tolower20(
      x,
    );
  }

  late final _SDL_tolower20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower20 = _SDL_tolower20Ptr.asFunction<int Function(int)>();

  int SDL_crc3220(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3220(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3220Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3220 = _SDL_crc3220Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset20(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset20(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset20 = _SDL_memset20Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy20(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy20(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy20 = _SDL_memcpy20Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove20(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove20(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove20 = _SDL_memmove20Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp20(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp20(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp20 = _SDL_memcmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen20(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen20(
      wstr,
    );
  }

  late final _SDL_wcslen20Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen20 =
      _SDL_wcslen20Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy20(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy20(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy20 = _SDL_wcslcpy20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat20(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat20(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat20 = _SDL_wcslcat20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup20(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup20(
      wstr,
    );
  }

  late final _SDL_wcsdup20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup20 = _SDL_wcsdup20Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr20(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr20(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr20 = _SDL_wcsstr20Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp20(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp20(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp20 = _SDL_wcscmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp20(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp20(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp20 = _SDL_wcsncmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp20(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp20(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp20 = _SDL_wcscasecmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp20(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp20(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp20 = _SDL_wcsncasecmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen20(
      str,
    );
  }

  late final _SDL_strlen20Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen20 =
      _SDL_strlen20Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy20(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy20(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy20 = _SDL_strlcpy20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy20(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy20(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy20 = _SDL_utf8strlcpy20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat20(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat20(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat20 = _SDL_strlcat20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup20(
      str,
    );
  }

  late final _SDL_strdup20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup20 = _SDL_strdup20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev20(
      str,
    );
  }

  late final _SDL_strrev20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev20 = _SDL_strrev20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr20(
      str,
    );
  }

  late final _SDL_strupr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr20 = _SDL_strupr20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr20(
      str,
    );
  }

  late final _SDL_strlwr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr20 = _SDL_strlwr20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr20(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr20(
      str,
      c,
    );
  }

  late final _SDL_strchr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr20 = _SDL_strchr20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr20(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr20(
      str,
      c,
    );
  }

  late final _SDL_strrchr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr20 = _SDL_strrchr20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr20(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr20(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr20 = _SDL_strstr20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr20(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr20(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr20 = _SDL_strtokr20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen20(
      str,
    );
  }

  late final _SDL_utf8strlen20Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen20 =
      _SDL_utf8strlen20Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa20(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa20(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa20 = _SDL_itoa20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa20(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa20(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa20 = _SDL_uitoa20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa20(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa20(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa20 = _SDL_ltoa20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa20(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa20(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa20 = _SDL_ultoa20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa20(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa20(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa20 = _SDL_lltoa20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa20(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa20(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa20 = _SDL_ulltoa20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi20(
      str,
    );
  }

  late final _SDL_atoi20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi20 =
      _SDL_atoi20Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof20(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof20(
      str,
    );
  }

  late final _SDL_atof20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof20 =
      _SDL_atof20Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol20(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol20(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol20 = _SDL_strtol20Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul20(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul20(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul20 = _SDL_strtoul20Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll20(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll20(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll20Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll20 = _SDL_strtoll20Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull20(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull20(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull20Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull20 = _SDL_strtoull20Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod20(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod20(
      str,
      endp,
    );
  }

  late final _SDL_strtod20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod20 = _SDL_strtod20Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp20(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp20(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp20 = _SDL_strcmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp20(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp20(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp20 = _SDL_strncmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp20(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp20(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp20 = _SDL_strcasecmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp20(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp20(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp20 = _SDL_strncasecmp20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf20(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf20(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf20 = _SDL_sscanf20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf20(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf20(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf20 = _SDL_vsscanf20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf20(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf20(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf20 = _SDL_snprintf20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf20(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf20(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf20 = _SDL_vsnprintf20Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf20(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf20(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf20 = _SDL_asprintf20Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf20(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf20(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf20 = _SDL_vasprintf20Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos20(
    double x,
  ) {
    return _SDL_acos20(
      x,
    );
  }

  late final _SDL_acos20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos20 = _SDL_acos20Ptr.asFunction<double Function(double)>();

  double SDL_acosf20(
    double x,
  ) {
    return _SDL_acosf20(
      x,
    );
  }

  late final _SDL_acosf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf20 =
      _SDL_acosf20Ptr.asFunction<double Function(double)>();

  double SDL_asin20(
    double x,
  ) {
    return _SDL_asin20(
      x,
    );
  }

  late final _SDL_asin20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin20 = _SDL_asin20Ptr.asFunction<double Function(double)>();

  double SDL_asinf20(
    double x,
  ) {
    return _SDL_asinf20(
      x,
    );
  }

  late final _SDL_asinf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf20 =
      _SDL_asinf20Ptr.asFunction<double Function(double)>();

  double SDL_atan30(
    double x,
  ) {
    return _SDL_atan30(
      x,
    );
  }

  late final _SDL_atan30Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan30 = _SDL_atan30Ptr.asFunction<double Function(double)>();

  double SDL_atanf20(
    double x,
  ) {
    return _SDL_atanf20(
      x,
    );
  }

  late final _SDL_atanf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf20 =
      _SDL_atanf20Ptr.asFunction<double Function(double)>();

  double SDL_atan220(
    double y,
    double x,
  ) {
    return _SDL_atan220(
      y,
      x,
    );
  }

  late final _SDL_atan220Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan220 =
      _SDL_atan220Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f20(
    double y,
    double x,
  ) {
    return _SDL_atan2f20(
      y,
      x,
    );
  }

  late final _SDL_atan2f20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f20 =
      _SDL_atan2f20Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil20(
    double x,
  ) {
    return _SDL_ceil20(
      x,
    );
  }

  late final _SDL_ceil20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil20 = _SDL_ceil20Ptr.asFunction<double Function(double)>();

  double SDL_ceilf20(
    double x,
  ) {
    return _SDL_ceilf20(
      x,
    );
  }

  late final _SDL_ceilf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf20 =
      _SDL_ceilf20Ptr.asFunction<double Function(double)>();

  double SDL_copysign20(
    double x,
    double y,
  ) {
    return _SDL_copysign20(
      x,
      y,
    );
  }

  late final _SDL_copysign20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign20 =
      _SDL_copysign20Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf20(
    double x,
    double y,
  ) {
    return _SDL_copysignf20(
      x,
      y,
    );
  }

  late final _SDL_copysignf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf20 =
      _SDL_copysignf20Ptr.asFunction<double Function(double, double)>();

  double SDL_cos20(
    double x,
  ) {
    return _SDL_cos20(
      x,
    );
  }

  late final _SDL_cos20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos20 = _SDL_cos20Ptr.asFunction<double Function(double)>();

  double SDL_cosf20(
    double x,
  ) {
    return _SDL_cosf20(
      x,
    );
  }

  late final _SDL_cosf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf20 = _SDL_cosf20Ptr.asFunction<double Function(double)>();

  double SDL_exp20(
    double x,
  ) {
    return _SDL_exp20(
      x,
    );
  }

  late final _SDL_exp20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp20 = _SDL_exp20Ptr.asFunction<double Function(double)>();

  double SDL_expf20(
    double x,
  ) {
    return _SDL_expf20(
      x,
    );
  }

  late final _SDL_expf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf20 = _SDL_expf20Ptr.asFunction<double Function(double)>();

  double SDL_fabs20(
    double x,
  ) {
    return _SDL_fabs20(
      x,
    );
  }

  late final _SDL_fabs20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs20 = _SDL_fabs20Ptr.asFunction<double Function(double)>();

  double SDL_fabsf20(
    double x,
  ) {
    return _SDL_fabsf20(
      x,
    );
  }

  late final _SDL_fabsf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf20 =
      _SDL_fabsf20Ptr.asFunction<double Function(double)>();

  double SDL_floor20(
    double x,
  ) {
    return _SDL_floor20(
      x,
    );
  }

  late final _SDL_floor20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor20 =
      _SDL_floor20Ptr.asFunction<double Function(double)>();

  double SDL_floorf20(
    double x,
  ) {
    return _SDL_floorf20(
      x,
    );
  }

  late final _SDL_floorf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf20 =
      _SDL_floorf20Ptr.asFunction<double Function(double)>();

  double SDL_trunc20(
    double x,
  ) {
    return _SDL_trunc20(
      x,
    );
  }

  late final _SDL_trunc20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc20 =
      _SDL_trunc20Ptr.asFunction<double Function(double)>();

  double SDL_truncf20(
    double x,
  ) {
    return _SDL_truncf20(
      x,
    );
  }

  late final _SDL_truncf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf20 =
      _SDL_truncf20Ptr.asFunction<double Function(double)>();

  double SDL_fmod20(
    double x,
    double y,
  ) {
    return _SDL_fmod20(
      x,
      y,
    );
  }

  late final _SDL_fmod20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod20 =
      _SDL_fmod20Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf20(
    double x,
    double y,
  ) {
    return _SDL_fmodf20(
      x,
      y,
    );
  }

  late final _SDL_fmodf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf20 =
      _SDL_fmodf20Ptr.asFunction<double Function(double, double)>();

  double SDL_log21(
    double x,
  ) {
    return _SDL_log21(
      x,
    );
  }

  late final _SDL_log21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log21 = _SDL_log21Ptr.asFunction<double Function(double)>();

  double SDL_logf20(
    double x,
  ) {
    return _SDL_logf20(
      x,
    );
  }

  late final _SDL_logf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf20 = _SDL_logf20Ptr.asFunction<double Function(double)>();

  double SDL_log1020(
    double x,
  ) {
    return _SDL_log1020(
      x,
    );
  }

  late final _SDL_log1020Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1020 =
      _SDL_log1020Ptr.asFunction<double Function(double)>();

  double SDL_log10f20(
    double x,
  ) {
    return _SDL_log10f20(
      x,
    );
  }

  late final _SDL_log10f20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f20 =
      _SDL_log10f20Ptr.asFunction<double Function(double)>();

  double SDL_pow20(
    double x,
    double y,
  ) {
    return _SDL_pow20(
      x,
      y,
    );
  }

  late final _SDL_pow20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow20 =
      _SDL_pow20Ptr.asFunction<double Function(double, double)>();

  double SDL_powf20(
    double x,
    double y,
  ) {
    return _SDL_powf20(
      x,
      y,
    );
  }

  late final _SDL_powf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf20 =
      _SDL_powf20Ptr.asFunction<double Function(double, double)>();

  double SDL_round20(
    double x,
  ) {
    return _SDL_round20(
      x,
    );
  }

  late final _SDL_round20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round20 =
      _SDL_round20Ptr.asFunction<double Function(double)>();

  double SDL_roundf20(
    double x,
  ) {
    return _SDL_roundf20(
      x,
    );
  }

  late final _SDL_roundf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf20 =
      _SDL_roundf20Ptr.asFunction<double Function(double)>();

  int SDL_lround20(
    double x,
  ) {
    return _SDL_lround20(
      x,
    );
  }

  late final _SDL_lround20Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround20 =
      _SDL_lround20Ptr.asFunction<int Function(double)>();

  int SDL_lroundf20(
    double x,
  ) {
    return _SDL_lroundf20(
      x,
    );
  }

  late final _SDL_lroundf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf20 =
      _SDL_lroundf20Ptr.asFunction<int Function(double)>();

  double SDL_scalbn20(
    double x,
    int n,
  ) {
    return _SDL_scalbn20(
      x,
      n,
    );
  }

  late final _SDL_scalbn20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn20 =
      _SDL_scalbn20Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf20(
    double x,
    int n,
  ) {
    return _SDL_scalbnf20(
      x,
      n,
    );
  }

  late final _SDL_scalbnf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf20 =
      _SDL_scalbnf20Ptr.asFunction<double Function(double, int)>();

  double SDL_sin20(
    double x,
  ) {
    return _SDL_sin20(
      x,
    );
  }

  late final _SDL_sin20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin20 = _SDL_sin20Ptr.asFunction<double Function(double)>();

  double SDL_sinf20(
    double x,
  ) {
    return _SDL_sinf20(
      x,
    );
  }

  late final _SDL_sinf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf20 = _SDL_sinf20Ptr.asFunction<double Function(double)>();

  double SDL_sqrt20(
    double x,
  ) {
    return _SDL_sqrt20(
      x,
    );
  }

  late final _SDL_sqrt20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt20 = _SDL_sqrt20Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf20(
    double x,
  ) {
    return _SDL_sqrtf20(
      x,
    );
  }

  late final _SDL_sqrtf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf20 =
      _SDL_sqrtf20Ptr.asFunction<double Function(double)>();

  double SDL_tan20(
    double x,
  ) {
    return _SDL_tan20(
      x,
    );
  }

  late final _SDL_tan20Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan20 = _SDL_tan20Ptr.asFunction<double Function(double)>();

  double SDL_tanf20(
    double x,
  ) {
    return _SDL_tanf20(
      x,
    );
  }

  late final _SDL_tanf20Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf20 = _SDL_tanf20Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open20(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open20(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open20Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open20 = _SDL_iconv_open20Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close20(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close20(
      cd,
    );
  }

  late final _SDL_iconv_close20Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close20 =
      _SDL_iconv_close20Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv20(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv20(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv20 = _SDL_iconv20Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string20(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string20(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string20 = _SDL_iconv_string20Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError12(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError12(
      fmt,
    );
  }

  late final _SDL_SetError12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError12 =
      _SDL_SetError12Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError12() {
    return _SDL_GetError12();
  }

  late final _SDL_GetError12Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError12 =
      _SDL_GetError12Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg12(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg12(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg12 = _SDL_GetErrorMsg12Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError12() {
    return _SDL_ClearError12();
  }

  late final _SDL_ClearError12Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError12 =
      _SDL_ClearError12Ptr.asFunction<void Function()>();

  int SDL_Error12(
    int code,
  ) {
    return _SDL_Error12(
      code,
    );
  }

  late final _SDL_Error12Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error12 = _SDL_Error12Ptr.asFunction<int Function(int)>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile5(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile5(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile5 = _SDL_RWFromFile5Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP5(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP5(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP5 = _SDL_RWFromFP5Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem5(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem5(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem5 = _SDL_RWFromMem5Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem5(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem5(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem5 = _SDL_RWFromConstMem5Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW5() {
    return _SDL_AllocRW5();
  }

  late final _SDL_AllocRW5Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW5 =
      _SDL_AllocRW5Ptr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW5(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW5(
      area,
    );
  }

  late final _SDL_FreeRW5Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW5 =
      _SDL_FreeRW5Ptr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize5(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize5(
      context,
    );
  }

  late final _SDL_RWsize5Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize5 =
      _SDL_RWsize5Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek5(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek5(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek5Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek5 = _SDL_RWseek5Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell5(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell5(
      context,
    );
  }

  late final _SDL_RWtell5Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell5 =
      _SDL_RWtell5Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread5(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread5(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread5 = _SDL_RWread5Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite5(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite5(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite5 = _SDL_RWwrite5Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose5(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose5(
      context,
    );
  }

  late final _SDL_RWclose5Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose5 =
      _SDL_RWclose5Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW5(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW5(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW5 = _SDL_LoadFile_RW5Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile5(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile5(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile5 = _SDL_LoadFile5Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU85(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU85(
      src,
    );
  }

  late final _SDL_ReadU85Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU85 =
      _SDL_ReadU85Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE165(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE165(
      src,
    );
  }

  late final _SDL_ReadLE165Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE165 =
      _SDL_ReadLE165Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE165(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE165(
      src,
    );
  }

  late final _SDL_ReadBE165Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE165 =
      _SDL_ReadBE165Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE325(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE325(
      src,
    );
  }

  late final _SDL_ReadLE325Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE325 =
      _SDL_ReadLE325Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE325(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE325(
      src,
    );
  }

  late final _SDL_ReadBE325Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE325 =
      _SDL_ReadBE325Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE645(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE645(
      src,
    );
  }

  late final _SDL_ReadLE645Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE645 =
      _SDL_ReadLE645Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE645(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE645(
      src,
    );
  }

  late final _SDL_ReadBE645Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE645 =
      _SDL_ReadBE645Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU85(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU85(
      dst,
      value,
    );
  }

  late final _SDL_WriteU85Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU85 =
      _SDL_WriteU85Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE165(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE165(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE165Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE165 = _SDL_WriteLE165Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE165(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE165(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE165Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE165 = _SDL_WriteBE165Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE325(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE325(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE325Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE325 = _SDL_WriteLE325Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE325(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE325(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE325Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE325 = _SDL_WriteBE325Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE645(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE645(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE645Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE645 = _SDL_WriteLE645Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE645(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE645(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE645Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE645 = _SDL_WriteBE645Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform22() {
    return _SDL_GetPlatform22();
  }

  late final _SDL_GetPlatform22Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform22 =
      _SDL_GetPlatform22Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc21(
    int size,
  ) {
    return _SDL_malloc21(
      size,
    );
  }

  late final _SDL_malloc21Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc21 =
      _SDL_malloc21Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc21(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc21(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc21 =
      _SDL_calloc21Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc21(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc21(
      mem,
      size,
    );
  }

  late final _SDL_realloc21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc21 = _SDL_realloc21Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free21(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free21(
      mem,
    );
  }

  late final _SDL_free21Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free21 =
      _SDL_free21Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions21(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions21(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions21 =
      _SDL_GetMemoryFunctions21Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions21(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions21(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions21 =
      _SDL_SetMemoryFunctions21Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations21() {
    return _SDL_GetNumAllocations21();
  }

  late final _SDL_GetNumAllocations21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations21 =
      _SDL_GetNumAllocations21Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv21(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv21(
      name,
    );
  }

  late final _SDL_getenv21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv21 = _SDL_getenv21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv21(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv21(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv21 = _SDL_setenv21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort21(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort21(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort21 = _SDL_qsort21Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs21(
    int x,
  ) {
    return _SDL_abs21(
      x,
    );
  }

  late final _SDL_abs21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs21 = _SDL_abs21Ptr.asFunction<int Function(int)>();

  int SDL_isalpha21(
    int x,
  ) {
    return _SDL_isalpha21(
      x,
    );
  }

  late final _SDL_isalpha21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha21 = _SDL_isalpha21Ptr.asFunction<int Function(int)>();

  int SDL_isalnum21(
    int x,
  ) {
    return _SDL_isalnum21(
      x,
    );
  }

  late final _SDL_isalnum21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum21 = _SDL_isalnum21Ptr.asFunction<int Function(int)>();

  int SDL_isblank21(
    int x,
  ) {
    return _SDL_isblank21(
      x,
    );
  }

  late final _SDL_isblank21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank21 = _SDL_isblank21Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl21(
    int x,
  ) {
    return _SDL_iscntrl21(
      x,
    );
  }

  late final _SDL_iscntrl21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl21 = _SDL_iscntrl21Ptr.asFunction<int Function(int)>();

  int SDL_isdigit21(
    int x,
  ) {
    return _SDL_isdigit21(
      x,
    );
  }

  late final _SDL_isdigit21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit21 = _SDL_isdigit21Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit21(
    int x,
  ) {
    return _SDL_isxdigit21(
      x,
    );
  }

  late final _SDL_isxdigit21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit21 =
      _SDL_isxdigit21Ptr.asFunction<int Function(int)>();

  int SDL_ispunct21(
    int x,
  ) {
    return _SDL_ispunct21(
      x,
    );
  }

  late final _SDL_ispunct21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct21 = _SDL_ispunct21Ptr.asFunction<int Function(int)>();

  int SDL_isspace21(
    int x,
  ) {
    return _SDL_isspace21(
      x,
    );
  }

  late final _SDL_isspace21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace21 = _SDL_isspace21Ptr.asFunction<int Function(int)>();

  int SDL_isupper21(
    int x,
  ) {
    return _SDL_isupper21(
      x,
    );
  }

  late final _SDL_isupper21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper21 = _SDL_isupper21Ptr.asFunction<int Function(int)>();

  int SDL_islower21(
    int x,
  ) {
    return _SDL_islower21(
      x,
    );
  }

  late final _SDL_islower21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower21 = _SDL_islower21Ptr.asFunction<int Function(int)>();

  int SDL_isprint21(
    int x,
  ) {
    return _SDL_isprint21(
      x,
    );
  }

  late final _SDL_isprint21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint21 = _SDL_isprint21Ptr.asFunction<int Function(int)>();

  int SDL_isgraph21(
    int x,
  ) {
    return _SDL_isgraph21(
      x,
    );
  }

  late final _SDL_isgraph21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph21 = _SDL_isgraph21Ptr.asFunction<int Function(int)>();

  int SDL_toupper21(
    int x,
  ) {
    return _SDL_toupper21(
      x,
    );
  }

  late final _SDL_toupper21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper21 = _SDL_toupper21Ptr.asFunction<int Function(int)>();

  int SDL_tolower21(
    int x,
  ) {
    return _SDL_tolower21(
      x,
    );
  }

  late final _SDL_tolower21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower21 = _SDL_tolower21Ptr.asFunction<int Function(int)>();

  int SDL_crc3221(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3221(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3221Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3221 = _SDL_crc3221Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset21(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset21(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset21 = _SDL_memset21Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy21(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy21(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy21 = _SDL_memcpy21Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove21(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove21(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove21 = _SDL_memmove21Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp21(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp21(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp21 = _SDL_memcmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen21(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen21(
      wstr,
    );
  }

  late final _SDL_wcslen21Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen21 =
      _SDL_wcslen21Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy21(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy21(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy21 = _SDL_wcslcpy21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat21(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat21(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat21 = _SDL_wcslcat21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup21(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup21(
      wstr,
    );
  }

  late final _SDL_wcsdup21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup21 = _SDL_wcsdup21Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr21(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr21(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr21 = _SDL_wcsstr21Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp21(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp21(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp21 = _SDL_wcscmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp21(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp21(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp21 = _SDL_wcsncmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp21(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp21(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp21 = _SDL_wcscasecmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp21(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp21(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp21 = _SDL_wcsncasecmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen21(
      str,
    );
  }

  late final _SDL_strlen21Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen21 =
      _SDL_strlen21Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy21(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy21(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy21 = _SDL_strlcpy21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy21(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy21(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy21 = _SDL_utf8strlcpy21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat21(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat21(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat21 = _SDL_strlcat21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup21(
      str,
    );
  }

  late final _SDL_strdup21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup21 = _SDL_strdup21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev21(
      str,
    );
  }

  late final _SDL_strrev21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev21 = _SDL_strrev21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr21(
      str,
    );
  }

  late final _SDL_strupr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr21 = _SDL_strupr21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr21(
      str,
    );
  }

  late final _SDL_strlwr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr21 = _SDL_strlwr21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr21(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr21(
      str,
      c,
    );
  }

  late final _SDL_strchr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr21 = _SDL_strchr21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr21(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr21(
      str,
      c,
    );
  }

  late final _SDL_strrchr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr21 = _SDL_strrchr21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr21(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr21(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr21 = _SDL_strstr21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr21(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr21(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr21 = _SDL_strtokr21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen21(
      str,
    );
  }

  late final _SDL_utf8strlen21Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen21 =
      _SDL_utf8strlen21Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa21(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa21(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa21 = _SDL_itoa21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa21(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa21(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa21 = _SDL_uitoa21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa21(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa21(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa21 = _SDL_ltoa21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa21(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa21(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa21 = _SDL_ultoa21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa21(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa21(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa21 = _SDL_lltoa21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa21(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa21(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa21 = _SDL_ulltoa21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi21(
      str,
    );
  }

  late final _SDL_atoi21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi21 =
      _SDL_atoi21Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof21(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof21(
      str,
    );
  }

  late final _SDL_atof21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof21 =
      _SDL_atof21Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol21(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol21(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol21 = _SDL_strtol21Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul21(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul21(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul21 = _SDL_strtoul21Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll21(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll21(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll21Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll21 = _SDL_strtoll21Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull21(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull21(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull21Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull21 = _SDL_strtoull21Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod21(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod21(
      str,
      endp,
    );
  }

  late final _SDL_strtod21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod21 = _SDL_strtod21Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp21(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp21(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp21 = _SDL_strcmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp21(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp21(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp21 = _SDL_strncmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp21(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp21(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp21 = _SDL_strcasecmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp21(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp21(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp21 = _SDL_strncasecmp21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf21(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf21(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf21 = _SDL_sscanf21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf21(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf21(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf21 = _SDL_vsscanf21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf21(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf21(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf21 = _SDL_snprintf21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf21(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf21(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf21 = _SDL_vsnprintf21Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf21(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf21(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf21 = _SDL_asprintf21Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf21(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf21(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf21 = _SDL_vasprintf21Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos21(
    double x,
  ) {
    return _SDL_acos21(
      x,
    );
  }

  late final _SDL_acos21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos21 = _SDL_acos21Ptr.asFunction<double Function(double)>();

  double SDL_acosf21(
    double x,
  ) {
    return _SDL_acosf21(
      x,
    );
  }

  late final _SDL_acosf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf21 =
      _SDL_acosf21Ptr.asFunction<double Function(double)>();

  double SDL_asin21(
    double x,
  ) {
    return _SDL_asin21(
      x,
    );
  }

  late final _SDL_asin21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin21 = _SDL_asin21Ptr.asFunction<double Function(double)>();

  double SDL_asinf21(
    double x,
  ) {
    return _SDL_asinf21(
      x,
    );
  }

  late final _SDL_asinf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf21 =
      _SDL_asinf21Ptr.asFunction<double Function(double)>();

  double SDL_atan31(
    double x,
  ) {
    return _SDL_atan31(
      x,
    );
  }

  late final _SDL_atan31Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan31 = _SDL_atan31Ptr.asFunction<double Function(double)>();

  double SDL_atanf21(
    double x,
  ) {
    return _SDL_atanf21(
      x,
    );
  }

  late final _SDL_atanf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf21 =
      _SDL_atanf21Ptr.asFunction<double Function(double)>();

  double SDL_atan221(
    double y,
    double x,
  ) {
    return _SDL_atan221(
      y,
      x,
    );
  }

  late final _SDL_atan221Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan221 =
      _SDL_atan221Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f21(
    double y,
    double x,
  ) {
    return _SDL_atan2f21(
      y,
      x,
    );
  }

  late final _SDL_atan2f21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f21 =
      _SDL_atan2f21Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil21(
    double x,
  ) {
    return _SDL_ceil21(
      x,
    );
  }

  late final _SDL_ceil21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil21 = _SDL_ceil21Ptr.asFunction<double Function(double)>();

  double SDL_ceilf21(
    double x,
  ) {
    return _SDL_ceilf21(
      x,
    );
  }

  late final _SDL_ceilf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf21 =
      _SDL_ceilf21Ptr.asFunction<double Function(double)>();

  double SDL_copysign21(
    double x,
    double y,
  ) {
    return _SDL_copysign21(
      x,
      y,
    );
  }

  late final _SDL_copysign21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign21 =
      _SDL_copysign21Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf21(
    double x,
    double y,
  ) {
    return _SDL_copysignf21(
      x,
      y,
    );
  }

  late final _SDL_copysignf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf21 =
      _SDL_copysignf21Ptr.asFunction<double Function(double, double)>();

  double SDL_cos21(
    double x,
  ) {
    return _SDL_cos21(
      x,
    );
  }

  late final _SDL_cos21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos21 = _SDL_cos21Ptr.asFunction<double Function(double)>();

  double SDL_cosf21(
    double x,
  ) {
    return _SDL_cosf21(
      x,
    );
  }

  late final _SDL_cosf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf21 = _SDL_cosf21Ptr.asFunction<double Function(double)>();

  double SDL_exp21(
    double x,
  ) {
    return _SDL_exp21(
      x,
    );
  }

  late final _SDL_exp21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp21 = _SDL_exp21Ptr.asFunction<double Function(double)>();

  double SDL_expf21(
    double x,
  ) {
    return _SDL_expf21(
      x,
    );
  }

  late final _SDL_expf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf21 = _SDL_expf21Ptr.asFunction<double Function(double)>();

  double SDL_fabs21(
    double x,
  ) {
    return _SDL_fabs21(
      x,
    );
  }

  late final _SDL_fabs21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs21 = _SDL_fabs21Ptr.asFunction<double Function(double)>();

  double SDL_fabsf21(
    double x,
  ) {
    return _SDL_fabsf21(
      x,
    );
  }

  late final _SDL_fabsf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf21 =
      _SDL_fabsf21Ptr.asFunction<double Function(double)>();

  double SDL_floor21(
    double x,
  ) {
    return _SDL_floor21(
      x,
    );
  }

  late final _SDL_floor21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor21 =
      _SDL_floor21Ptr.asFunction<double Function(double)>();

  double SDL_floorf21(
    double x,
  ) {
    return _SDL_floorf21(
      x,
    );
  }

  late final _SDL_floorf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf21 =
      _SDL_floorf21Ptr.asFunction<double Function(double)>();

  double SDL_trunc21(
    double x,
  ) {
    return _SDL_trunc21(
      x,
    );
  }

  late final _SDL_trunc21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc21 =
      _SDL_trunc21Ptr.asFunction<double Function(double)>();

  double SDL_truncf21(
    double x,
  ) {
    return _SDL_truncf21(
      x,
    );
  }

  late final _SDL_truncf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf21 =
      _SDL_truncf21Ptr.asFunction<double Function(double)>();

  double SDL_fmod21(
    double x,
    double y,
  ) {
    return _SDL_fmod21(
      x,
      y,
    );
  }

  late final _SDL_fmod21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod21 =
      _SDL_fmod21Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf21(
    double x,
    double y,
  ) {
    return _SDL_fmodf21(
      x,
      y,
    );
  }

  late final _SDL_fmodf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf21 =
      _SDL_fmodf21Ptr.asFunction<double Function(double, double)>();

  double SDL_log22(
    double x,
  ) {
    return _SDL_log22(
      x,
    );
  }

  late final _SDL_log22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log22 = _SDL_log22Ptr.asFunction<double Function(double)>();

  double SDL_logf21(
    double x,
  ) {
    return _SDL_logf21(
      x,
    );
  }

  late final _SDL_logf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf21 = _SDL_logf21Ptr.asFunction<double Function(double)>();

  double SDL_log1021(
    double x,
  ) {
    return _SDL_log1021(
      x,
    );
  }

  late final _SDL_log1021Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1021 =
      _SDL_log1021Ptr.asFunction<double Function(double)>();

  double SDL_log10f21(
    double x,
  ) {
    return _SDL_log10f21(
      x,
    );
  }

  late final _SDL_log10f21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f21 =
      _SDL_log10f21Ptr.asFunction<double Function(double)>();

  double SDL_pow21(
    double x,
    double y,
  ) {
    return _SDL_pow21(
      x,
      y,
    );
  }

  late final _SDL_pow21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow21 =
      _SDL_pow21Ptr.asFunction<double Function(double, double)>();

  double SDL_powf21(
    double x,
    double y,
  ) {
    return _SDL_powf21(
      x,
      y,
    );
  }

  late final _SDL_powf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf21 =
      _SDL_powf21Ptr.asFunction<double Function(double, double)>();

  double SDL_round21(
    double x,
  ) {
    return _SDL_round21(
      x,
    );
  }

  late final _SDL_round21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round21 =
      _SDL_round21Ptr.asFunction<double Function(double)>();

  double SDL_roundf21(
    double x,
  ) {
    return _SDL_roundf21(
      x,
    );
  }

  late final _SDL_roundf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf21 =
      _SDL_roundf21Ptr.asFunction<double Function(double)>();

  int SDL_lround21(
    double x,
  ) {
    return _SDL_lround21(
      x,
    );
  }

  late final _SDL_lround21Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround21 =
      _SDL_lround21Ptr.asFunction<int Function(double)>();

  int SDL_lroundf21(
    double x,
  ) {
    return _SDL_lroundf21(
      x,
    );
  }

  late final _SDL_lroundf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf21 =
      _SDL_lroundf21Ptr.asFunction<int Function(double)>();

  double SDL_scalbn21(
    double x,
    int n,
  ) {
    return _SDL_scalbn21(
      x,
      n,
    );
  }

  late final _SDL_scalbn21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn21 =
      _SDL_scalbn21Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf21(
    double x,
    int n,
  ) {
    return _SDL_scalbnf21(
      x,
      n,
    );
  }

  late final _SDL_scalbnf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf21 =
      _SDL_scalbnf21Ptr.asFunction<double Function(double, int)>();

  double SDL_sin21(
    double x,
  ) {
    return _SDL_sin21(
      x,
    );
  }

  late final _SDL_sin21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin21 = _SDL_sin21Ptr.asFunction<double Function(double)>();

  double SDL_sinf21(
    double x,
  ) {
    return _SDL_sinf21(
      x,
    );
  }

  late final _SDL_sinf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf21 = _SDL_sinf21Ptr.asFunction<double Function(double)>();

  double SDL_sqrt21(
    double x,
  ) {
    return _SDL_sqrt21(
      x,
    );
  }

  late final _SDL_sqrt21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt21 = _SDL_sqrt21Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf21(
    double x,
  ) {
    return _SDL_sqrtf21(
      x,
    );
  }

  late final _SDL_sqrtf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf21 =
      _SDL_sqrtf21Ptr.asFunction<double Function(double)>();

  double SDL_tan21(
    double x,
  ) {
    return _SDL_tan21(
      x,
    );
  }

  late final _SDL_tan21Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan21 = _SDL_tan21Ptr.asFunction<double Function(double)>();

  double SDL_tanf21(
    double x,
  ) {
    return _SDL_tanf21(
      x,
    );
  }

  late final _SDL_tanf21Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf21 = _SDL_tanf21Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open21(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open21(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open21Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open21 = _SDL_iconv_open21Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close21(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close21(
      cd,
    );
  }

  late final _SDL_iconv_close21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close21 =
      _SDL_iconv_close21Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv21(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv21(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv21 = _SDL_iconv21Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string21(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string21(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string21 = _SDL_iconv_string21Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError13(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError13(
      fmt,
    );
  }

  late final _SDL_SetError13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError13 =
      _SDL_SetError13Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError13() {
    return _SDL_GetError13();
  }

  late final _SDL_GetError13Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError13 =
      _SDL_GetError13Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg13(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg13(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg13 = _SDL_GetErrorMsg13Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError13() {
    return _SDL_ClearError13();
  }

  late final _SDL_ClearError13Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError13 =
      _SDL_ClearError13Ptr.asFunction<void Function()>();

  int SDL_Error13(
    int code,
  ) {
    return _SDL_Error13(
      code,
    );
  }

  late final _SDL_Error13Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error13 = _SDL_Error13Ptr.asFunction<int Function(int)>();

  /// Dynamically load a shared object.
  ///
  /// \param sofile a system-dependent name of the object file
  /// \returns an opaque pointer to the object handle or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadFunction
  /// \sa SDL_UnloadObject
  ffi.Pointer<ffi.Void> SDL_LoadObject1(
    ffi.Pointer<ffi.Char> sofile,
  ) {
    return _SDL_LoadObject1(
      sofile,
    );
  }

  late final _SDL_LoadObject1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_LoadObject');
  late final _SDL_LoadObject1 = _SDL_LoadObject1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Look up the address of the named function in a shared object.
  ///
  /// This function pointer is no longer valid after calling SDL_UnloadObject().
  ///
  /// This function can only look up C function names. Other languages may have
  /// name mangling and intrinsic language support that varies from compiler to
  /// compiler.
  ///
  /// Make sure you declare your function pointers with the same calling
  /// convention as the actual library function. Your code will crash
  /// mysteriously if you do not do this.
  ///
  /// If the requested function doesn't exist, NULL is returned.
  ///
  /// \param handle a valid shared object handle returned by SDL_LoadObject()
  /// \param name the name of the function to look up
  /// \returns a pointer to the function or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadObject
  /// \sa SDL_UnloadObject
  ffi.Pointer<ffi.Void> SDL_LoadFunction1(
    ffi.Pointer<ffi.Void> handle,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_LoadFunction1(
      handle,
      name,
    );
  }

  late final _SDL_LoadFunction1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>)>>('SDL_LoadFunction');
  late final _SDL_LoadFunction1 = _SDL_LoadFunction1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  /// Unload a shared object from memory.
  ///
  /// \param handle a valid shared object handle returned by SDL_LoadObject()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadFunction
  /// \sa SDL_LoadObject
  void SDL_UnloadObject1(
    ffi.Pointer<ffi.Void> handle,
  ) {
    return _SDL_UnloadObject1(
      handle,
    );
  }

  late final _SDL_UnloadObject1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_UnloadObject');
  late final _SDL_UnloadObject1 =
      _SDL_UnloadObject1Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform23() {
    return _SDL_GetPlatform23();
  }

  late final _SDL_GetPlatform23Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform23 =
      _SDL_GetPlatform23Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform24() {
    return _SDL_GetPlatform24();
  }

  late final _SDL_GetPlatform24Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform24 =
      _SDL_GetPlatform24Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc22(
    int size,
  ) {
    return _SDL_malloc22(
      size,
    );
  }

  late final _SDL_malloc22Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc22 =
      _SDL_malloc22Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc22(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc22(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc22 =
      _SDL_calloc22Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc22(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc22(
      mem,
      size,
    );
  }

  late final _SDL_realloc22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc22 = _SDL_realloc22Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free22(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free22(
      mem,
    );
  }

  late final _SDL_free22Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free22 =
      _SDL_free22Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions22(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions22(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions22 =
      _SDL_GetMemoryFunctions22Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions22(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions22(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions22 =
      _SDL_SetMemoryFunctions22Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations22() {
    return _SDL_GetNumAllocations22();
  }

  late final _SDL_GetNumAllocations22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations22 =
      _SDL_GetNumAllocations22Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv22(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv22(
      name,
    );
  }

  late final _SDL_getenv22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv22 = _SDL_getenv22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv22(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv22(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv22 = _SDL_setenv22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort22(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort22(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort22 = _SDL_qsort22Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs22(
    int x,
  ) {
    return _SDL_abs22(
      x,
    );
  }

  late final _SDL_abs22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs22 = _SDL_abs22Ptr.asFunction<int Function(int)>();

  int SDL_isalpha22(
    int x,
  ) {
    return _SDL_isalpha22(
      x,
    );
  }

  late final _SDL_isalpha22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha22 = _SDL_isalpha22Ptr.asFunction<int Function(int)>();

  int SDL_isalnum22(
    int x,
  ) {
    return _SDL_isalnum22(
      x,
    );
  }

  late final _SDL_isalnum22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum22 = _SDL_isalnum22Ptr.asFunction<int Function(int)>();

  int SDL_isblank22(
    int x,
  ) {
    return _SDL_isblank22(
      x,
    );
  }

  late final _SDL_isblank22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank22 = _SDL_isblank22Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl22(
    int x,
  ) {
    return _SDL_iscntrl22(
      x,
    );
  }

  late final _SDL_iscntrl22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl22 = _SDL_iscntrl22Ptr.asFunction<int Function(int)>();

  int SDL_isdigit22(
    int x,
  ) {
    return _SDL_isdigit22(
      x,
    );
  }

  late final _SDL_isdigit22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit22 = _SDL_isdigit22Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit22(
    int x,
  ) {
    return _SDL_isxdigit22(
      x,
    );
  }

  late final _SDL_isxdigit22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit22 =
      _SDL_isxdigit22Ptr.asFunction<int Function(int)>();

  int SDL_ispunct22(
    int x,
  ) {
    return _SDL_ispunct22(
      x,
    );
  }

  late final _SDL_ispunct22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct22 = _SDL_ispunct22Ptr.asFunction<int Function(int)>();

  int SDL_isspace22(
    int x,
  ) {
    return _SDL_isspace22(
      x,
    );
  }

  late final _SDL_isspace22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace22 = _SDL_isspace22Ptr.asFunction<int Function(int)>();

  int SDL_isupper22(
    int x,
  ) {
    return _SDL_isupper22(
      x,
    );
  }

  late final _SDL_isupper22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper22 = _SDL_isupper22Ptr.asFunction<int Function(int)>();

  int SDL_islower22(
    int x,
  ) {
    return _SDL_islower22(
      x,
    );
  }

  late final _SDL_islower22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower22 = _SDL_islower22Ptr.asFunction<int Function(int)>();

  int SDL_isprint22(
    int x,
  ) {
    return _SDL_isprint22(
      x,
    );
  }

  late final _SDL_isprint22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint22 = _SDL_isprint22Ptr.asFunction<int Function(int)>();

  int SDL_isgraph22(
    int x,
  ) {
    return _SDL_isgraph22(
      x,
    );
  }

  late final _SDL_isgraph22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph22 = _SDL_isgraph22Ptr.asFunction<int Function(int)>();

  int SDL_toupper22(
    int x,
  ) {
    return _SDL_toupper22(
      x,
    );
  }

  late final _SDL_toupper22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper22 = _SDL_toupper22Ptr.asFunction<int Function(int)>();

  int SDL_tolower22(
    int x,
  ) {
    return _SDL_tolower22(
      x,
    );
  }

  late final _SDL_tolower22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower22 = _SDL_tolower22Ptr.asFunction<int Function(int)>();

  int SDL_crc3222(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3222(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3222Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3222 = _SDL_crc3222Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset22(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset22(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset22 = _SDL_memset22Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy22(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy22(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy22 = _SDL_memcpy22Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove22(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove22(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove22 = _SDL_memmove22Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp22(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp22(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp22 = _SDL_memcmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen22(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen22(
      wstr,
    );
  }

  late final _SDL_wcslen22Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen22 =
      _SDL_wcslen22Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy22(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy22(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy22 = _SDL_wcslcpy22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat22(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat22(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat22 = _SDL_wcslcat22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup22(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup22(
      wstr,
    );
  }

  late final _SDL_wcsdup22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup22 = _SDL_wcsdup22Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr22(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr22(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr22 = _SDL_wcsstr22Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp22(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp22(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp22 = _SDL_wcscmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp22(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp22(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp22 = _SDL_wcsncmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp22(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp22(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp22 = _SDL_wcscasecmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp22(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp22(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp22 = _SDL_wcsncasecmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen22(
      str,
    );
  }

  late final _SDL_strlen22Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen22 =
      _SDL_strlen22Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy22(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy22(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy22 = _SDL_strlcpy22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy22(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy22(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy22 = _SDL_utf8strlcpy22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat22(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat22(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat22 = _SDL_strlcat22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup22(
      str,
    );
  }

  late final _SDL_strdup22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup22 = _SDL_strdup22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev22(
      str,
    );
  }

  late final _SDL_strrev22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev22 = _SDL_strrev22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr22(
      str,
    );
  }

  late final _SDL_strupr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr22 = _SDL_strupr22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr22(
      str,
    );
  }

  late final _SDL_strlwr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr22 = _SDL_strlwr22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr22(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr22(
      str,
      c,
    );
  }

  late final _SDL_strchr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr22 = _SDL_strchr22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr22(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr22(
      str,
      c,
    );
  }

  late final _SDL_strrchr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr22 = _SDL_strrchr22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr22(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr22(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr22 = _SDL_strstr22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr22(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr22(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr22 = _SDL_strtokr22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen22(
      str,
    );
  }

  late final _SDL_utf8strlen22Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen22 =
      _SDL_utf8strlen22Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa22(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa22(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa22 = _SDL_itoa22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa22(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa22(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa22 = _SDL_uitoa22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa22(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa22(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa22 = _SDL_ltoa22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa22(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa22(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa22 = _SDL_ultoa22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa22(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa22(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa22 = _SDL_lltoa22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa22(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa22(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa22 = _SDL_ulltoa22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi22(
      str,
    );
  }

  late final _SDL_atoi22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi22 =
      _SDL_atoi22Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof22(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof22(
      str,
    );
  }

  late final _SDL_atof22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof22 =
      _SDL_atof22Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol22(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol22(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol22 = _SDL_strtol22Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul22(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul22(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul22 = _SDL_strtoul22Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll22(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll22(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll22Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll22 = _SDL_strtoll22Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull22(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull22(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull22Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull22 = _SDL_strtoull22Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod22(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod22(
      str,
      endp,
    );
  }

  late final _SDL_strtod22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod22 = _SDL_strtod22Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp22(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp22(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp22 = _SDL_strcmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp22(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp22(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp22 = _SDL_strncmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp22(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp22(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp22 = _SDL_strcasecmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp22(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp22(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp22 = _SDL_strncasecmp22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf22(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf22(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf22 = _SDL_sscanf22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf22(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf22(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf22 = _SDL_vsscanf22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf22(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf22(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf22 = _SDL_snprintf22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf22(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf22(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf22 = _SDL_vsnprintf22Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf22(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf22(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf22 = _SDL_asprintf22Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf22(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf22(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf22 = _SDL_vasprintf22Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos22(
    double x,
  ) {
    return _SDL_acos22(
      x,
    );
  }

  late final _SDL_acos22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos22 = _SDL_acos22Ptr.asFunction<double Function(double)>();

  double SDL_acosf22(
    double x,
  ) {
    return _SDL_acosf22(
      x,
    );
  }

  late final _SDL_acosf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf22 =
      _SDL_acosf22Ptr.asFunction<double Function(double)>();

  double SDL_asin22(
    double x,
  ) {
    return _SDL_asin22(
      x,
    );
  }

  late final _SDL_asin22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin22 = _SDL_asin22Ptr.asFunction<double Function(double)>();

  double SDL_asinf22(
    double x,
  ) {
    return _SDL_asinf22(
      x,
    );
  }

  late final _SDL_asinf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf22 =
      _SDL_asinf22Ptr.asFunction<double Function(double)>();

  double SDL_atan32(
    double x,
  ) {
    return _SDL_atan32(
      x,
    );
  }

  late final _SDL_atan32Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan32 = _SDL_atan32Ptr.asFunction<double Function(double)>();

  double SDL_atanf22(
    double x,
  ) {
    return _SDL_atanf22(
      x,
    );
  }

  late final _SDL_atanf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf22 =
      _SDL_atanf22Ptr.asFunction<double Function(double)>();

  double SDL_atan222(
    double y,
    double x,
  ) {
    return _SDL_atan222(
      y,
      x,
    );
  }

  late final _SDL_atan222Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan222 =
      _SDL_atan222Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f22(
    double y,
    double x,
  ) {
    return _SDL_atan2f22(
      y,
      x,
    );
  }

  late final _SDL_atan2f22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f22 =
      _SDL_atan2f22Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil22(
    double x,
  ) {
    return _SDL_ceil22(
      x,
    );
  }

  late final _SDL_ceil22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil22 = _SDL_ceil22Ptr.asFunction<double Function(double)>();

  double SDL_ceilf22(
    double x,
  ) {
    return _SDL_ceilf22(
      x,
    );
  }

  late final _SDL_ceilf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf22 =
      _SDL_ceilf22Ptr.asFunction<double Function(double)>();

  double SDL_copysign22(
    double x,
    double y,
  ) {
    return _SDL_copysign22(
      x,
      y,
    );
  }

  late final _SDL_copysign22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign22 =
      _SDL_copysign22Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf22(
    double x,
    double y,
  ) {
    return _SDL_copysignf22(
      x,
      y,
    );
  }

  late final _SDL_copysignf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf22 =
      _SDL_copysignf22Ptr.asFunction<double Function(double, double)>();

  double SDL_cos22(
    double x,
  ) {
    return _SDL_cos22(
      x,
    );
  }

  late final _SDL_cos22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos22 = _SDL_cos22Ptr.asFunction<double Function(double)>();

  double SDL_cosf22(
    double x,
  ) {
    return _SDL_cosf22(
      x,
    );
  }

  late final _SDL_cosf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf22 = _SDL_cosf22Ptr.asFunction<double Function(double)>();

  double SDL_exp22(
    double x,
  ) {
    return _SDL_exp22(
      x,
    );
  }

  late final _SDL_exp22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp22 = _SDL_exp22Ptr.asFunction<double Function(double)>();

  double SDL_expf22(
    double x,
  ) {
    return _SDL_expf22(
      x,
    );
  }

  late final _SDL_expf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf22 = _SDL_expf22Ptr.asFunction<double Function(double)>();

  double SDL_fabs22(
    double x,
  ) {
    return _SDL_fabs22(
      x,
    );
  }

  late final _SDL_fabs22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs22 = _SDL_fabs22Ptr.asFunction<double Function(double)>();

  double SDL_fabsf22(
    double x,
  ) {
    return _SDL_fabsf22(
      x,
    );
  }

  late final _SDL_fabsf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf22 =
      _SDL_fabsf22Ptr.asFunction<double Function(double)>();

  double SDL_floor22(
    double x,
  ) {
    return _SDL_floor22(
      x,
    );
  }

  late final _SDL_floor22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor22 =
      _SDL_floor22Ptr.asFunction<double Function(double)>();

  double SDL_floorf22(
    double x,
  ) {
    return _SDL_floorf22(
      x,
    );
  }

  late final _SDL_floorf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf22 =
      _SDL_floorf22Ptr.asFunction<double Function(double)>();

  double SDL_trunc22(
    double x,
  ) {
    return _SDL_trunc22(
      x,
    );
  }

  late final _SDL_trunc22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc22 =
      _SDL_trunc22Ptr.asFunction<double Function(double)>();

  double SDL_truncf22(
    double x,
  ) {
    return _SDL_truncf22(
      x,
    );
  }

  late final _SDL_truncf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf22 =
      _SDL_truncf22Ptr.asFunction<double Function(double)>();

  double SDL_fmod22(
    double x,
    double y,
  ) {
    return _SDL_fmod22(
      x,
      y,
    );
  }

  late final _SDL_fmod22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod22 =
      _SDL_fmod22Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf22(
    double x,
    double y,
  ) {
    return _SDL_fmodf22(
      x,
      y,
    );
  }

  late final _SDL_fmodf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf22 =
      _SDL_fmodf22Ptr.asFunction<double Function(double, double)>();

  double SDL_log23(
    double x,
  ) {
    return _SDL_log23(
      x,
    );
  }

  late final _SDL_log23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log23 = _SDL_log23Ptr.asFunction<double Function(double)>();

  double SDL_logf22(
    double x,
  ) {
    return _SDL_logf22(
      x,
    );
  }

  late final _SDL_logf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf22 = _SDL_logf22Ptr.asFunction<double Function(double)>();

  double SDL_log1022(
    double x,
  ) {
    return _SDL_log1022(
      x,
    );
  }

  late final _SDL_log1022Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1022 =
      _SDL_log1022Ptr.asFunction<double Function(double)>();

  double SDL_log10f22(
    double x,
  ) {
    return _SDL_log10f22(
      x,
    );
  }

  late final _SDL_log10f22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f22 =
      _SDL_log10f22Ptr.asFunction<double Function(double)>();

  double SDL_pow22(
    double x,
    double y,
  ) {
    return _SDL_pow22(
      x,
      y,
    );
  }

  late final _SDL_pow22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow22 =
      _SDL_pow22Ptr.asFunction<double Function(double, double)>();

  double SDL_powf22(
    double x,
    double y,
  ) {
    return _SDL_powf22(
      x,
      y,
    );
  }

  late final _SDL_powf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf22 =
      _SDL_powf22Ptr.asFunction<double Function(double, double)>();

  double SDL_round22(
    double x,
  ) {
    return _SDL_round22(
      x,
    );
  }

  late final _SDL_round22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round22 =
      _SDL_round22Ptr.asFunction<double Function(double)>();

  double SDL_roundf22(
    double x,
  ) {
    return _SDL_roundf22(
      x,
    );
  }

  late final _SDL_roundf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf22 =
      _SDL_roundf22Ptr.asFunction<double Function(double)>();

  int SDL_lround22(
    double x,
  ) {
    return _SDL_lround22(
      x,
    );
  }

  late final _SDL_lround22Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround22 =
      _SDL_lround22Ptr.asFunction<int Function(double)>();

  int SDL_lroundf22(
    double x,
  ) {
    return _SDL_lroundf22(
      x,
    );
  }

  late final _SDL_lroundf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf22 =
      _SDL_lroundf22Ptr.asFunction<int Function(double)>();

  double SDL_scalbn22(
    double x,
    int n,
  ) {
    return _SDL_scalbn22(
      x,
      n,
    );
  }

  late final _SDL_scalbn22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn22 =
      _SDL_scalbn22Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf22(
    double x,
    int n,
  ) {
    return _SDL_scalbnf22(
      x,
      n,
    );
  }

  late final _SDL_scalbnf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf22 =
      _SDL_scalbnf22Ptr.asFunction<double Function(double, int)>();

  double SDL_sin22(
    double x,
  ) {
    return _SDL_sin22(
      x,
    );
  }

  late final _SDL_sin22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin22 = _SDL_sin22Ptr.asFunction<double Function(double)>();

  double SDL_sinf22(
    double x,
  ) {
    return _SDL_sinf22(
      x,
    );
  }

  late final _SDL_sinf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf22 = _SDL_sinf22Ptr.asFunction<double Function(double)>();

  double SDL_sqrt22(
    double x,
  ) {
    return _SDL_sqrt22(
      x,
    );
  }

  late final _SDL_sqrt22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt22 = _SDL_sqrt22Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf22(
    double x,
  ) {
    return _SDL_sqrtf22(
      x,
    );
  }

  late final _SDL_sqrtf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf22 =
      _SDL_sqrtf22Ptr.asFunction<double Function(double)>();

  double SDL_tan22(
    double x,
  ) {
    return _SDL_tan22(
      x,
    );
  }

  late final _SDL_tan22Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan22 = _SDL_tan22Ptr.asFunction<double Function(double)>();

  double SDL_tanf22(
    double x,
  ) {
    return _SDL_tanf22(
      x,
    );
  }

  late final _SDL_tanf22Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf22 = _SDL_tanf22Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open22(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open22(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open22Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open22 = _SDL_iconv_open22Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close22(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close22(
      cd,
    );
  }

  late final _SDL_iconv_close22Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close22 =
      _SDL_iconv_close22Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv22(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv22(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv22 = _SDL_iconv22Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string22(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string22(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string22 = _SDL_iconv_string22Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the number of CPU cores available.
  ///
  /// \returns the total number of logical CPU cores. On CPUs that include
  /// technologies such as hyperthreading, the number of logical cores
  /// may be more than the number of physical cores.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetCPUCount1() {
    return _SDL_GetCPUCount1();
  }

  late final _SDL_GetCPUCount1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetCPUCount');
  late final _SDL_GetCPUCount1 =
      _SDL_GetCPUCount1Ptr.asFunction<int Function()>();

  /// Determine the L1 cache line size of the CPU.
  ///
  /// This is useful for determining multi-threaded structure padding or SIMD
  /// prefetch sizes.
  ///
  /// \returns the L1 cache line size of the CPU, in bytes.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetCPUCacheLineSize1() {
    return _SDL_GetCPUCacheLineSize1();
  }

  late final _SDL_GetCPUCacheLineSize1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetCPUCacheLineSize');
  late final _SDL_GetCPUCacheLineSize1 =
      _SDL_GetCPUCacheLineSize1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has the RDTSC instruction.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasRDTSC1() {
    return _SDL_HasRDTSC1();
  }

  late final _SDL_HasRDTSC1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasRDTSC');
  late final _SDL_HasRDTSC1 = _SDL_HasRDTSC1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has AltiVec features.
  ///
  /// This always returns false on CPUs that aren't using PowerPC instruction
  /// sets.
  ///
  /// \returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasAltiVec1() {
    return _SDL_HasAltiVec1();
  }

  late final _SDL_HasAltiVec1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAltiVec');
  late final _SDL_HasAltiVec1 =
      _SDL_HasAltiVec1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has MMX features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasMMX1() {
    return _SDL_HasMMX1();
  }

  late final _SDL_HasMMX1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasMMX');
  late final _SDL_HasMMX1 = _SDL_HasMMX1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has 3DNow! features.
  ///
  /// This always returns false on CPUs that aren't using AMD instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has 3DNow! features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_Has3DNow1() {
    return _SDL_Has3DNow1();
  }

  late final _SDL_Has3DNow1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_Has3DNow');
  late final _SDL_Has3DNow1 = _SDL_Has3DNow1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasSSE1() {
    return _SDL_HasSSE1();
  }

  late final _SDL_HasSSE1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE');
  late final _SDL_HasSSE1 = _SDL_HasSSE1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE2 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasSSE21() {
    return _SDL_HasSSE21();
  }

  late final _SDL_HasSSE21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE2');
  late final _SDL_HasSSE21 = _SDL_HasSSE21Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE3 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasSSE31() {
    return _SDL_HasSSE31();
  }

  late final _SDL_HasSSE31Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE3');
  late final _SDL_HasSSE31 = _SDL_HasSSE31Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE4.1 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE4.1 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE42
  int SDL_HasSSE411() {
    return _SDL_HasSSE411();
  }

  late final _SDL_HasSSE411Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE41');
  late final _SDL_HasSSE411 = _SDL_HasSSE411Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has SSE4.2 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has SSE4.2 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  int SDL_HasSSE421() {
    return _SDL_HasSSE421();
  }

  late final _SDL_HasSSE421Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE42');
  late final _SDL_HasSSE421 = _SDL_HasSSE421Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has AVX features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX2
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasAVX1() {
    return _SDL_HasAVX1();
  }

  late final _SDL_HasAVX1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX');
  late final _SDL_HasAVX1 = _SDL_HasAVX1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has AVX2 features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_Has3DNow
  /// \sa SDL_HasAltiVec
  /// \sa SDL_HasAVX
  /// \sa SDL_HasMMX
  /// \sa SDL_HasRDTSC
  /// \sa SDL_HasSSE
  /// \sa SDL_HasSSE2
  /// \sa SDL_HasSSE3
  /// \sa SDL_HasSSE41
  /// \sa SDL_HasSSE42
  int SDL_HasAVX21() {
    return _SDL_HasAVX21();
  }

  late final _SDL_HasAVX21Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX2');
  late final _SDL_HasAVX21 = _SDL_HasAVX21Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has AVX-512F (foundation) features.
  ///
  /// This always returns false on CPUs that aren't using Intel instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_HasAVX
  int SDL_HasAVX512F1() {
    return _SDL_HasAVX512F1();
  }

  late final _SDL_HasAVX512F1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX512F');
  late final _SDL_HasAVX512F1 =
      _SDL_HasAVX512F1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has ARM SIMD (ARMv6) features.
  ///
  /// This is different from ARM NEON, which is a different instruction set.
  ///
  /// This always returns false on CPUs that aren't using ARM instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_HasNEON
  int SDL_HasARMSIMD1() {
    return _SDL_HasARMSIMD1();
  }

  late final _SDL_HasARMSIMD1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasARMSIMD');
  late final _SDL_HasARMSIMD1 =
      _SDL_HasARMSIMD1Ptr.asFunction<int Function()>();

  /// Determine whether the CPU has NEON (ARM SIMD) features.
  ///
  /// This always returns false on CPUs that aren't using ARM instruction sets.
  ///
  /// \returns SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.6.
  int SDL_HasNEON1() {
    return _SDL_HasNEON1();
  }

  late final _SDL_HasNEON1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasNEON');
  late final _SDL_HasNEON1 = _SDL_HasNEON1Ptr.asFunction<int Function()>();

  /// Get the amount of RAM configured in the system.
  ///
  /// \returns the amount of RAM configured in the system in MB.
  ///
  /// \since This function is available since SDL 2.0.1.
  int SDL_GetSystemRAM1() {
    return _SDL_GetSystemRAM1();
  }

  late final _SDL_GetSystemRAM1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetSystemRAM');
  late final _SDL_GetSystemRAM1 =
      _SDL_GetSystemRAM1Ptr.asFunction<int Function()>();

  /// Report the alignment this system needs for SIMD allocations.
  ///
  /// This will return the minimum number of bytes to which a pointer must be
  /// aligned to be compatible with SIMD instructions on the current machine. For
  /// example, if the machine supports SSE only, it will return 16, but if it
  /// supports AVX-512F, it'll return 64 (etc). This only reports values for
  /// instruction sets SDL knows about, so if your SDL build doesn't have
  /// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
  /// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
  /// Plan accordingly.
  ///
  /// \returns the alignment in bytes needed for available, known SIMD
  /// instructions.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_SIMDGetAlignment1() {
    return _SDL_SIMDGetAlignment1();
  }

  late final _SDL_SIMDGetAlignment1Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('SDL_SIMDGetAlignment');
  late final _SDL_SIMDGetAlignment1 =
      _SDL_SIMDGetAlignment1Ptr.asFunction<int Function()>();

  /// Allocate memory in a SIMD-friendly way.
  ///
  /// This will allocate a block of memory that is suitable for use with SIMD
  /// instructions. Specifically, it will be properly aligned and padded for the
  /// system's supported vector instructions.
  ///
  /// The memory returned will be padded such that it is safe to read or write an
  /// incomplete vector at the end of the memory block. This can be useful so you
  /// don't have to drop back to a scalar fallback at the end of your SIMD
  /// processing loop to deal with the final elements without overflowing the
  /// allocated buffer.
  ///
  /// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or
  /// delete[], etc.
  ///
  /// Note that SDL will only deal with SIMD instruction sets it is aware of; for
  /// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and
  /// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants
  /// 64. To be clear: if you can't decide to use an instruction set with an
  /// SDL_Has*() function, don't use that instruction set with memory allocated
  /// through here.
  ///
  /// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't
  /// out of memory, but you are not allowed to dereference it (because you only
  /// own zero bytes of that buffer).
  ///
  /// \param len The length, in bytes, of the block to allocate. The actual
  /// allocated block might be larger due to padding, etc.
  /// \returns a pointer to the newly-allocated block, NULL if out of memory.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDRealloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDAlloc1(
    int len,
  ) {
    return _SDL_SIMDAlloc1(
      len,
    );
  }

  late final _SDL_SIMDAlloc1Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_SIMDAlloc');
  late final _SDL_SIMDAlloc1 =
      _SDL_SIMDAlloc1Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Reallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
  /// SDL_malloc, memalign, new[], etc.
  ///
  /// \param mem The pointer obtained from SDL_SIMDAlloc. This function also
  /// accepts NULL, at which point this function is the same as
  /// calling SDL_SIMDAlloc with a NULL pointer.
  /// \param len The length, in bytes, of the block to allocated. The actual
  /// allocated block might be larger due to padding, etc. Passing 0
  /// will return a non-NULL pointer, assuming the system isn't out of
  /// memory.
  /// \returns a pointer to the newly-reallocated block, NULL if out of memory.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDRealloc1(
    ffi.Pointer<ffi.Void> mem,
    int len,
  ) {
    return _SDL_SIMDRealloc1(
      mem,
      len,
    );
  }

  late final _SDL_SIMDRealloc1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_SIMDRealloc');
  late final _SDL_SIMDRealloc1 = _SDL_SIMDRealloc1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Deallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from
  /// malloc, realloc, SDL_malloc, memalign, new[], etc.
  ///
  /// However, SDL_SIMDFree(NULL) is a legal no-op.
  ///
  /// The memory pointed to by `ptr` is no longer valid for access upon return,
  /// and may be returned to the system or reused by a future allocation. The
  /// pointer passed to this function is no longer safe to dereference once this
  /// function returns, and should be discarded.
  ///
  /// \param ptr The pointer, returned from SDL_SIMDAlloc or SDL_SIMDRealloc, to
  /// deallocate. NULL is a legal no-op.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDRealloc
  void SDL_SIMDFree1(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _SDL_SIMDFree1(
      ptr,
    );
  }

  late final _SDL_SIMDFree1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_SIMDFree');
  late final _SDL_SIMDFree1 =
      _SDL_SIMDFree1Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform25() {
    return _SDL_GetPlatform25();
  }

  late final _SDL_GetPlatform25Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform25 =
      _SDL_GetPlatform25Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc23(
    int size,
  ) {
    return _SDL_malloc23(
      size,
    );
  }

  late final _SDL_malloc23Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc23 =
      _SDL_malloc23Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc23(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc23(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc23 =
      _SDL_calloc23Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc23(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc23(
      mem,
      size,
    );
  }

  late final _SDL_realloc23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc23 = _SDL_realloc23Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free23(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free23(
      mem,
    );
  }

  late final _SDL_free23Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free23 =
      _SDL_free23Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions23(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions23(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions23 =
      _SDL_GetMemoryFunctions23Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions23(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions23(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions23 =
      _SDL_SetMemoryFunctions23Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations23() {
    return _SDL_GetNumAllocations23();
  }

  late final _SDL_GetNumAllocations23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations23 =
      _SDL_GetNumAllocations23Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv23(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv23(
      name,
    );
  }

  late final _SDL_getenv23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv23 = _SDL_getenv23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv23(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv23(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv23 = _SDL_setenv23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort23(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort23(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort23 = _SDL_qsort23Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs23(
    int x,
  ) {
    return _SDL_abs23(
      x,
    );
  }

  late final _SDL_abs23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs23 = _SDL_abs23Ptr.asFunction<int Function(int)>();

  int SDL_isalpha23(
    int x,
  ) {
    return _SDL_isalpha23(
      x,
    );
  }

  late final _SDL_isalpha23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha23 = _SDL_isalpha23Ptr.asFunction<int Function(int)>();

  int SDL_isalnum23(
    int x,
  ) {
    return _SDL_isalnum23(
      x,
    );
  }

  late final _SDL_isalnum23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum23 = _SDL_isalnum23Ptr.asFunction<int Function(int)>();

  int SDL_isblank23(
    int x,
  ) {
    return _SDL_isblank23(
      x,
    );
  }

  late final _SDL_isblank23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank23 = _SDL_isblank23Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl23(
    int x,
  ) {
    return _SDL_iscntrl23(
      x,
    );
  }

  late final _SDL_iscntrl23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl23 = _SDL_iscntrl23Ptr.asFunction<int Function(int)>();

  int SDL_isdigit23(
    int x,
  ) {
    return _SDL_isdigit23(
      x,
    );
  }

  late final _SDL_isdigit23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit23 = _SDL_isdigit23Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit23(
    int x,
  ) {
    return _SDL_isxdigit23(
      x,
    );
  }

  late final _SDL_isxdigit23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit23 =
      _SDL_isxdigit23Ptr.asFunction<int Function(int)>();

  int SDL_ispunct23(
    int x,
  ) {
    return _SDL_ispunct23(
      x,
    );
  }

  late final _SDL_ispunct23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct23 = _SDL_ispunct23Ptr.asFunction<int Function(int)>();

  int SDL_isspace23(
    int x,
  ) {
    return _SDL_isspace23(
      x,
    );
  }

  late final _SDL_isspace23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace23 = _SDL_isspace23Ptr.asFunction<int Function(int)>();

  int SDL_isupper23(
    int x,
  ) {
    return _SDL_isupper23(
      x,
    );
  }

  late final _SDL_isupper23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper23 = _SDL_isupper23Ptr.asFunction<int Function(int)>();

  int SDL_islower23(
    int x,
  ) {
    return _SDL_islower23(
      x,
    );
  }

  late final _SDL_islower23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower23 = _SDL_islower23Ptr.asFunction<int Function(int)>();

  int SDL_isprint23(
    int x,
  ) {
    return _SDL_isprint23(
      x,
    );
  }

  late final _SDL_isprint23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint23 = _SDL_isprint23Ptr.asFunction<int Function(int)>();

  int SDL_isgraph23(
    int x,
  ) {
    return _SDL_isgraph23(
      x,
    );
  }

  late final _SDL_isgraph23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph23 = _SDL_isgraph23Ptr.asFunction<int Function(int)>();

  int SDL_toupper23(
    int x,
  ) {
    return _SDL_toupper23(
      x,
    );
  }

  late final _SDL_toupper23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper23 = _SDL_toupper23Ptr.asFunction<int Function(int)>();

  int SDL_tolower23(
    int x,
  ) {
    return _SDL_tolower23(
      x,
    );
  }

  late final _SDL_tolower23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower23 = _SDL_tolower23Ptr.asFunction<int Function(int)>();

  int SDL_crc3223(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3223(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3223Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3223 = _SDL_crc3223Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset23(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset23(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset23 = _SDL_memset23Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy23(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy23(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy23 = _SDL_memcpy23Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove23(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove23(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove23 = _SDL_memmove23Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp23(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp23(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp23 = _SDL_memcmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen23(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen23(
      wstr,
    );
  }

  late final _SDL_wcslen23Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen23 =
      _SDL_wcslen23Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy23(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy23(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy23 = _SDL_wcslcpy23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat23(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat23(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat23 = _SDL_wcslcat23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup23(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup23(
      wstr,
    );
  }

  late final _SDL_wcsdup23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup23 = _SDL_wcsdup23Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr23(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr23(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr23 = _SDL_wcsstr23Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp23(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp23(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp23 = _SDL_wcscmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp23(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp23(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp23 = _SDL_wcsncmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp23(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp23(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp23 = _SDL_wcscasecmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp23(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp23(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp23 = _SDL_wcsncasecmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen23(
      str,
    );
  }

  late final _SDL_strlen23Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen23 =
      _SDL_strlen23Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy23(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy23(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy23 = _SDL_strlcpy23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy23(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy23(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy23 = _SDL_utf8strlcpy23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat23(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat23(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat23 = _SDL_strlcat23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup23(
      str,
    );
  }

  late final _SDL_strdup23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup23 = _SDL_strdup23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev23(
      str,
    );
  }

  late final _SDL_strrev23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev23 = _SDL_strrev23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr23(
      str,
    );
  }

  late final _SDL_strupr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr23 = _SDL_strupr23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr23(
      str,
    );
  }

  late final _SDL_strlwr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr23 = _SDL_strlwr23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr23(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr23(
      str,
      c,
    );
  }

  late final _SDL_strchr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr23 = _SDL_strchr23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr23(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr23(
      str,
      c,
    );
  }

  late final _SDL_strrchr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr23 = _SDL_strrchr23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr23(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr23(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr23 = _SDL_strstr23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr23(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr23(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr23 = _SDL_strtokr23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen23(
      str,
    );
  }

  late final _SDL_utf8strlen23Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen23 =
      _SDL_utf8strlen23Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa23(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa23(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa23 = _SDL_itoa23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa23(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa23(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa23 = _SDL_uitoa23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa23(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa23(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa23 = _SDL_ltoa23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa23(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa23(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa23 = _SDL_ultoa23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa23(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa23(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa23 = _SDL_lltoa23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa23(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa23(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa23 = _SDL_ulltoa23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi23(
      str,
    );
  }

  late final _SDL_atoi23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi23 =
      _SDL_atoi23Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof23(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof23(
      str,
    );
  }

  late final _SDL_atof23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof23 =
      _SDL_atof23Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol23(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol23(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol23 = _SDL_strtol23Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul23(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul23(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul23 = _SDL_strtoul23Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll23(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll23(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll23Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll23 = _SDL_strtoll23Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull23(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull23(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull23Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull23 = _SDL_strtoull23Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod23(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod23(
      str,
      endp,
    );
  }

  late final _SDL_strtod23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod23 = _SDL_strtod23Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp23(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp23(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp23 = _SDL_strcmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp23(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp23(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp23 = _SDL_strncmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp23(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp23(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp23 = _SDL_strcasecmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp23(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp23(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp23 = _SDL_strncasecmp23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf23(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf23(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf23 = _SDL_sscanf23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf23(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf23(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf23 = _SDL_vsscanf23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf23(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf23(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf23 = _SDL_snprintf23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf23(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf23(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf23 = _SDL_vsnprintf23Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf23(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf23(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf23 = _SDL_asprintf23Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf23(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf23(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf23 = _SDL_vasprintf23Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos23(
    double x,
  ) {
    return _SDL_acos23(
      x,
    );
  }

  late final _SDL_acos23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos23 = _SDL_acos23Ptr.asFunction<double Function(double)>();

  double SDL_acosf23(
    double x,
  ) {
    return _SDL_acosf23(
      x,
    );
  }

  late final _SDL_acosf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf23 =
      _SDL_acosf23Ptr.asFunction<double Function(double)>();

  double SDL_asin23(
    double x,
  ) {
    return _SDL_asin23(
      x,
    );
  }

  late final _SDL_asin23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin23 = _SDL_asin23Ptr.asFunction<double Function(double)>();

  double SDL_asinf23(
    double x,
  ) {
    return _SDL_asinf23(
      x,
    );
  }

  late final _SDL_asinf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf23 =
      _SDL_asinf23Ptr.asFunction<double Function(double)>();

  double SDL_atan33(
    double x,
  ) {
    return _SDL_atan33(
      x,
    );
  }

  late final _SDL_atan33Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan33 = _SDL_atan33Ptr.asFunction<double Function(double)>();

  double SDL_atanf23(
    double x,
  ) {
    return _SDL_atanf23(
      x,
    );
  }

  late final _SDL_atanf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf23 =
      _SDL_atanf23Ptr.asFunction<double Function(double)>();

  double SDL_atan223(
    double y,
    double x,
  ) {
    return _SDL_atan223(
      y,
      x,
    );
  }

  late final _SDL_atan223Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan223 =
      _SDL_atan223Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f23(
    double y,
    double x,
  ) {
    return _SDL_atan2f23(
      y,
      x,
    );
  }

  late final _SDL_atan2f23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f23 =
      _SDL_atan2f23Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil23(
    double x,
  ) {
    return _SDL_ceil23(
      x,
    );
  }

  late final _SDL_ceil23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil23 = _SDL_ceil23Ptr.asFunction<double Function(double)>();

  double SDL_ceilf23(
    double x,
  ) {
    return _SDL_ceilf23(
      x,
    );
  }

  late final _SDL_ceilf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf23 =
      _SDL_ceilf23Ptr.asFunction<double Function(double)>();

  double SDL_copysign23(
    double x,
    double y,
  ) {
    return _SDL_copysign23(
      x,
      y,
    );
  }

  late final _SDL_copysign23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign23 =
      _SDL_copysign23Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf23(
    double x,
    double y,
  ) {
    return _SDL_copysignf23(
      x,
      y,
    );
  }

  late final _SDL_copysignf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf23 =
      _SDL_copysignf23Ptr.asFunction<double Function(double, double)>();

  double SDL_cos23(
    double x,
  ) {
    return _SDL_cos23(
      x,
    );
  }

  late final _SDL_cos23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos23 = _SDL_cos23Ptr.asFunction<double Function(double)>();

  double SDL_cosf23(
    double x,
  ) {
    return _SDL_cosf23(
      x,
    );
  }

  late final _SDL_cosf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf23 = _SDL_cosf23Ptr.asFunction<double Function(double)>();

  double SDL_exp23(
    double x,
  ) {
    return _SDL_exp23(
      x,
    );
  }

  late final _SDL_exp23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp23 = _SDL_exp23Ptr.asFunction<double Function(double)>();

  double SDL_expf23(
    double x,
  ) {
    return _SDL_expf23(
      x,
    );
  }

  late final _SDL_expf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf23 = _SDL_expf23Ptr.asFunction<double Function(double)>();

  double SDL_fabs23(
    double x,
  ) {
    return _SDL_fabs23(
      x,
    );
  }

  late final _SDL_fabs23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs23 = _SDL_fabs23Ptr.asFunction<double Function(double)>();

  double SDL_fabsf23(
    double x,
  ) {
    return _SDL_fabsf23(
      x,
    );
  }

  late final _SDL_fabsf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf23 =
      _SDL_fabsf23Ptr.asFunction<double Function(double)>();

  double SDL_floor23(
    double x,
  ) {
    return _SDL_floor23(
      x,
    );
  }

  late final _SDL_floor23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor23 =
      _SDL_floor23Ptr.asFunction<double Function(double)>();

  double SDL_floorf23(
    double x,
  ) {
    return _SDL_floorf23(
      x,
    );
  }

  late final _SDL_floorf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf23 =
      _SDL_floorf23Ptr.asFunction<double Function(double)>();

  double SDL_trunc23(
    double x,
  ) {
    return _SDL_trunc23(
      x,
    );
  }

  late final _SDL_trunc23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc23 =
      _SDL_trunc23Ptr.asFunction<double Function(double)>();

  double SDL_truncf23(
    double x,
  ) {
    return _SDL_truncf23(
      x,
    );
  }

  late final _SDL_truncf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf23 =
      _SDL_truncf23Ptr.asFunction<double Function(double)>();

  double SDL_fmod23(
    double x,
    double y,
  ) {
    return _SDL_fmod23(
      x,
      y,
    );
  }

  late final _SDL_fmod23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod23 =
      _SDL_fmod23Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf23(
    double x,
    double y,
  ) {
    return _SDL_fmodf23(
      x,
      y,
    );
  }

  late final _SDL_fmodf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf23 =
      _SDL_fmodf23Ptr.asFunction<double Function(double, double)>();

  double SDL_log24(
    double x,
  ) {
    return _SDL_log24(
      x,
    );
  }

  late final _SDL_log24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log24 = _SDL_log24Ptr.asFunction<double Function(double)>();

  double SDL_logf23(
    double x,
  ) {
    return _SDL_logf23(
      x,
    );
  }

  late final _SDL_logf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf23 = _SDL_logf23Ptr.asFunction<double Function(double)>();

  double SDL_log1023(
    double x,
  ) {
    return _SDL_log1023(
      x,
    );
  }

  late final _SDL_log1023Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1023 =
      _SDL_log1023Ptr.asFunction<double Function(double)>();

  double SDL_log10f23(
    double x,
  ) {
    return _SDL_log10f23(
      x,
    );
  }

  late final _SDL_log10f23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f23 =
      _SDL_log10f23Ptr.asFunction<double Function(double)>();

  double SDL_pow23(
    double x,
    double y,
  ) {
    return _SDL_pow23(
      x,
      y,
    );
  }

  late final _SDL_pow23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow23 =
      _SDL_pow23Ptr.asFunction<double Function(double, double)>();

  double SDL_powf23(
    double x,
    double y,
  ) {
    return _SDL_powf23(
      x,
      y,
    );
  }

  late final _SDL_powf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf23 =
      _SDL_powf23Ptr.asFunction<double Function(double, double)>();

  double SDL_round23(
    double x,
  ) {
    return _SDL_round23(
      x,
    );
  }

  late final _SDL_round23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round23 =
      _SDL_round23Ptr.asFunction<double Function(double)>();

  double SDL_roundf23(
    double x,
  ) {
    return _SDL_roundf23(
      x,
    );
  }

  late final _SDL_roundf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf23 =
      _SDL_roundf23Ptr.asFunction<double Function(double)>();

  int SDL_lround23(
    double x,
  ) {
    return _SDL_lround23(
      x,
    );
  }

  late final _SDL_lround23Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround23 =
      _SDL_lround23Ptr.asFunction<int Function(double)>();

  int SDL_lroundf23(
    double x,
  ) {
    return _SDL_lroundf23(
      x,
    );
  }

  late final _SDL_lroundf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf23 =
      _SDL_lroundf23Ptr.asFunction<int Function(double)>();

  double SDL_scalbn23(
    double x,
    int n,
  ) {
    return _SDL_scalbn23(
      x,
      n,
    );
  }

  late final _SDL_scalbn23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn23 =
      _SDL_scalbn23Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf23(
    double x,
    int n,
  ) {
    return _SDL_scalbnf23(
      x,
      n,
    );
  }

  late final _SDL_scalbnf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf23 =
      _SDL_scalbnf23Ptr.asFunction<double Function(double, int)>();

  double SDL_sin23(
    double x,
  ) {
    return _SDL_sin23(
      x,
    );
  }

  late final _SDL_sin23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin23 = _SDL_sin23Ptr.asFunction<double Function(double)>();

  double SDL_sinf23(
    double x,
  ) {
    return _SDL_sinf23(
      x,
    );
  }

  late final _SDL_sinf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf23 = _SDL_sinf23Ptr.asFunction<double Function(double)>();

  double SDL_sqrt23(
    double x,
  ) {
    return _SDL_sqrt23(
      x,
    );
  }

  late final _SDL_sqrt23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt23 = _SDL_sqrt23Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf23(
    double x,
  ) {
    return _SDL_sqrtf23(
      x,
    );
  }

  late final _SDL_sqrtf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf23 =
      _SDL_sqrtf23Ptr.asFunction<double Function(double)>();

  double SDL_tan23(
    double x,
  ) {
    return _SDL_tan23(
      x,
    );
  }

  late final _SDL_tan23Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan23 = _SDL_tan23Ptr.asFunction<double Function(double)>();

  double SDL_tanf23(
    double x,
  ) {
    return _SDL_tanf23(
      x,
    );
  }

  late final _SDL_tanf23Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf23 = _SDL_tanf23Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open23(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open23(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open23Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open23 = _SDL_iconv_open23Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close23(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close23(
      cd,
    );
  }

  late final _SDL_iconv_close23Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close23 =
      _SDL_iconv_close23Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv23(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv23(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv23 = _SDL_iconv23Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string23(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string23(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string23 = _SDL_iconv_string23Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform26() {
    return _SDL_GetPlatform26();
  }

  late final _SDL_GetPlatform26Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform26 =
      _SDL_GetPlatform26Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc24(
    int size,
  ) {
    return _SDL_malloc24(
      size,
    );
  }

  late final _SDL_malloc24Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc24 =
      _SDL_malloc24Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc24(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc24(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc24 =
      _SDL_calloc24Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc24(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc24(
      mem,
      size,
    );
  }

  late final _SDL_realloc24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc24 = _SDL_realloc24Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free24(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free24(
      mem,
    );
  }

  late final _SDL_free24Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free24 =
      _SDL_free24Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions24(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions24(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions24 =
      _SDL_GetMemoryFunctions24Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions24(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions24(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions24 =
      _SDL_SetMemoryFunctions24Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations24() {
    return _SDL_GetNumAllocations24();
  }

  late final _SDL_GetNumAllocations24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations24 =
      _SDL_GetNumAllocations24Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv24(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv24(
      name,
    );
  }

  late final _SDL_getenv24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv24 = _SDL_getenv24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv24(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv24(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv24 = _SDL_setenv24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort24(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort24(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort24 = _SDL_qsort24Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs24(
    int x,
  ) {
    return _SDL_abs24(
      x,
    );
  }

  late final _SDL_abs24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs24 = _SDL_abs24Ptr.asFunction<int Function(int)>();

  int SDL_isalpha24(
    int x,
  ) {
    return _SDL_isalpha24(
      x,
    );
  }

  late final _SDL_isalpha24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha24 = _SDL_isalpha24Ptr.asFunction<int Function(int)>();

  int SDL_isalnum24(
    int x,
  ) {
    return _SDL_isalnum24(
      x,
    );
  }

  late final _SDL_isalnum24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum24 = _SDL_isalnum24Ptr.asFunction<int Function(int)>();

  int SDL_isblank24(
    int x,
  ) {
    return _SDL_isblank24(
      x,
    );
  }

  late final _SDL_isblank24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank24 = _SDL_isblank24Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl24(
    int x,
  ) {
    return _SDL_iscntrl24(
      x,
    );
  }

  late final _SDL_iscntrl24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl24 = _SDL_iscntrl24Ptr.asFunction<int Function(int)>();

  int SDL_isdigit24(
    int x,
  ) {
    return _SDL_isdigit24(
      x,
    );
  }

  late final _SDL_isdigit24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit24 = _SDL_isdigit24Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit24(
    int x,
  ) {
    return _SDL_isxdigit24(
      x,
    );
  }

  late final _SDL_isxdigit24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit24 =
      _SDL_isxdigit24Ptr.asFunction<int Function(int)>();

  int SDL_ispunct24(
    int x,
  ) {
    return _SDL_ispunct24(
      x,
    );
  }

  late final _SDL_ispunct24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct24 = _SDL_ispunct24Ptr.asFunction<int Function(int)>();

  int SDL_isspace24(
    int x,
  ) {
    return _SDL_isspace24(
      x,
    );
  }

  late final _SDL_isspace24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace24 = _SDL_isspace24Ptr.asFunction<int Function(int)>();

  int SDL_isupper24(
    int x,
  ) {
    return _SDL_isupper24(
      x,
    );
  }

  late final _SDL_isupper24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper24 = _SDL_isupper24Ptr.asFunction<int Function(int)>();

  int SDL_islower24(
    int x,
  ) {
    return _SDL_islower24(
      x,
    );
  }

  late final _SDL_islower24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower24 = _SDL_islower24Ptr.asFunction<int Function(int)>();

  int SDL_isprint24(
    int x,
  ) {
    return _SDL_isprint24(
      x,
    );
  }

  late final _SDL_isprint24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint24 = _SDL_isprint24Ptr.asFunction<int Function(int)>();

  int SDL_isgraph24(
    int x,
  ) {
    return _SDL_isgraph24(
      x,
    );
  }

  late final _SDL_isgraph24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph24 = _SDL_isgraph24Ptr.asFunction<int Function(int)>();

  int SDL_toupper24(
    int x,
  ) {
    return _SDL_toupper24(
      x,
    );
  }

  late final _SDL_toupper24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper24 = _SDL_toupper24Ptr.asFunction<int Function(int)>();

  int SDL_tolower24(
    int x,
  ) {
    return _SDL_tolower24(
      x,
    );
  }

  late final _SDL_tolower24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower24 = _SDL_tolower24Ptr.asFunction<int Function(int)>();

  int SDL_crc3224(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3224(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3224Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3224 = _SDL_crc3224Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset24(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset24(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset24 = _SDL_memset24Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy24(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy24(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy24 = _SDL_memcpy24Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove24(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove24(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove24 = _SDL_memmove24Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp24(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp24(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp24 = _SDL_memcmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen24(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen24(
      wstr,
    );
  }

  late final _SDL_wcslen24Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen24 =
      _SDL_wcslen24Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy24(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy24(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy24 = _SDL_wcslcpy24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat24(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat24(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat24 = _SDL_wcslcat24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup24(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup24(
      wstr,
    );
  }

  late final _SDL_wcsdup24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup24 = _SDL_wcsdup24Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr24(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr24(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr24 = _SDL_wcsstr24Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp24(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp24(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp24 = _SDL_wcscmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp24(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp24(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp24 = _SDL_wcsncmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp24(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp24(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp24 = _SDL_wcscasecmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp24(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp24(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp24 = _SDL_wcsncasecmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen24(
      str,
    );
  }

  late final _SDL_strlen24Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen24 =
      _SDL_strlen24Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy24(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy24(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy24 = _SDL_strlcpy24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy24(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy24(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy24 = _SDL_utf8strlcpy24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat24(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat24(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat24 = _SDL_strlcat24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup24(
      str,
    );
  }

  late final _SDL_strdup24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup24 = _SDL_strdup24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev24(
      str,
    );
  }

  late final _SDL_strrev24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev24 = _SDL_strrev24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr24(
      str,
    );
  }

  late final _SDL_strupr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr24 = _SDL_strupr24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr24(
      str,
    );
  }

  late final _SDL_strlwr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr24 = _SDL_strlwr24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr24(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr24(
      str,
      c,
    );
  }

  late final _SDL_strchr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr24 = _SDL_strchr24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr24(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr24(
      str,
      c,
    );
  }

  late final _SDL_strrchr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr24 = _SDL_strrchr24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr24(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr24(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr24 = _SDL_strstr24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr24(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr24(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr24 = _SDL_strtokr24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen24(
      str,
    );
  }

  late final _SDL_utf8strlen24Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen24 =
      _SDL_utf8strlen24Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa24(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa24(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa24 = _SDL_itoa24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa24(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa24(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa24 = _SDL_uitoa24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa24(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa24(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa24 = _SDL_ltoa24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa24(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa24(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa24 = _SDL_ultoa24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa24(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa24(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa24 = _SDL_lltoa24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa24(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa24(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa24 = _SDL_ulltoa24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi24(
      str,
    );
  }

  late final _SDL_atoi24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi24 =
      _SDL_atoi24Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof24(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof24(
      str,
    );
  }

  late final _SDL_atof24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof24 =
      _SDL_atof24Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol24(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol24(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol24 = _SDL_strtol24Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul24(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul24(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul24 = _SDL_strtoul24Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll24(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll24(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll24Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll24 = _SDL_strtoll24Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull24(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull24(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull24Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull24 = _SDL_strtoull24Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod24(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod24(
      str,
      endp,
    );
  }

  late final _SDL_strtod24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod24 = _SDL_strtod24Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp24(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp24(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp24 = _SDL_strcmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp24(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp24(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp24 = _SDL_strncmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp24(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp24(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp24 = _SDL_strcasecmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp24(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp24(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp24 = _SDL_strncasecmp24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf24(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf24(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf24 = _SDL_sscanf24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf24(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf24(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf24 = _SDL_vsscanf24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf24(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf24(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf24 = _SDL_snprintf24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf24(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf24(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf24 = _SDL_vsnprintf24Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf24(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf24(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf24 = _SDL_asprintf24Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf24(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf24(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf24 = _SDL_vasprintf24Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos24(
    double x,
  ) {
    return _SDL_acos24(
      x,
    );
  }

  late final _SDL_acos24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos24 = _SDL_acos24Ptr.asFunction<double Function(double)>();

  double SDL_acosf24(
    double x,
  ) {
    return _SDL_acosf24(
      x,
    );
  }

  late final _SDL_acosf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf24 =
      _SDL_acosf24Ptr.asFunction<double Function(double)>();

  double SDL_asin24(
    double x,
  ) {
    return _SDL_asin24(
      x,
    );
  }

  late final _SDL_asin24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin24 = _SDL_asin24Ptr.asFunction<double Function(double)>();

  double SDL_asinf24(
    double x,
  ) {
    return _SDL_asinf24(
      x,
    );
  }

  late final _SDL_asinf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf24 =
      _SDL_asinf24Ptr.asFunction<double Function(double)>();

  double SDL_atan34(
    double x,
  ) {
    return _SDL_atan34(
      x,
    );
  }

  late final _SDL_atan34Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan34 = _SDL_atan34Ptr.asFunction<double Function(double)>();

  double SDL_atanf24(
    double x,
  ) {
    return _SDL_atanf24(
      x,
    );
  }

  late final _SDL_atanf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf24 =
      _SDL_atanf24Ptr.asFunction<double Function(double)>();

  double SDL_atan224(
    double y,
    double x,
  ) {
    return _SDL_atan224(
      y,
      x,
    );
  }

  late final _SDL_atan224Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan224 =
      _SDL_atan224Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f24(
    double y,
    double x,
  ) {
    return _SDL_atan2f24(
      y,
      x,
    );
  }

  late final _SDL_atan2f24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f24 =
      _SDL_atan2f24Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil24(
    double x,
  ) {
    return _SDL_ceil24(
      x,
    );
  }

  late final _SDL_ceil24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil24 = _SDL_ceil24Ptr.asFunction<double Function(double)>();

  double SDL_ceilf24(
    double x,
  ) {
    return _SDL_ceilf24(
      x,
    );
  }

  late final _SDL_ceilf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf24 =
      _SDL_ceilf24Ptr.asFunction<double Function(double)>();

  double SDL_copysign24(
    double x,
    double y,
  ) {
    return _SDL_copysign24(
      x,
      y,
    );
  }

  late final _SDL_copysign24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign24 =
      _SDL_copysign24Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf24(
    double x,
    double y,
  ) {
    return _SDL_copysignf24(
      x,
      y,
    );
  }

  late final _SDL_copysignf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf24 =
      _SDL_copysignf24Ptr.asFunction<double Function(double, double)>();

  double SDL_cos24(
    double x,
  ) {
    return _SDL_cos24(
      x,
    );
  }

  late final _SDL_cos24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos24 = _SDL_cos24Ptr.asFunction<double Function(double)>();

  double SDL_cosf24(
    double x,
  ) {
    return _SDL_cosf24(
      x,
    );
  }

  late final _SDL_cosf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf24 = _SDL_cosf24Ptr.asFunction<double Function(double)>();

  double SDL_exp24(
    double x,
  ) {
    return _SDL_exp24(
      x,
    );
  }

  late final _SDL_exp24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp24 = _SDL_exp24Ptr.asFunction<double Function(double)>();

  double SDL_expf24(
    double x,
  ) {
    return _SDL_expf24(
      x,
    );
  }

  late final _SDL_expf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf24 = _SDL_expf24Ptr.asFunction<double Function(double)>();

  double SDL_fabs24(
    double x,
  ) {
    return _SDL_fabs24(
      x,
    );
  }

  late final _SDL_fabs24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs24 = _SDL_fabs24Ptr.asFunction<double Function(double)>();

  double SDL_fabsf24(
    double x,
  ) {
    return _SDL_fabsf24(
      x,
    );
  }

  late final _SDL_fabsf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf24 =
      _SDL_fabsf24Ptr.asFunction<double Function(double)>();

  double SDL_floor24(
    double x,
  ) {
    return _SDL_floor24(
      x,
    );
  }

  late final _SDL_floor24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor24 =
      _SDL_floor24Ptr.asFunction<double Function(double)>();

  double SDL_floorf24(
    double x,
  ) {
    return _SDL_floorf24(
      x,
    );
  }

  late final _SDL_floorf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf24 =
      _SDL_floorf24Ptr.asFunction<double Function(double)>();

  double SDL_trunc24(
    double x,
  ) {
    return _SDL_trunc24(
      x,
    );
  }

  late final _SDL_trunc24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc24 =
      _SDL_trunc24Ptr.asFunction<double Function(double)>();

  double SDL_truncf24(
    double x,
  ) {
    return _SDL_truncf24(
      x,
    );
  }

  late final _SDL_truncf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf24 =
      _SDL_truncf24Ptr.asFunction<double Function(double)>();

  double SDL_fmod24(
    double x,
    double y,
  ) {
    return _SDL_fmod24(
      x,
      y,
    );
  }

  late final _SDL_fmod24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod24 =
      _SDL_fmod24Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf24(
    double x,
    double y,
  ) {
    return _SDL_fmodf24(
      x,
      y,
    );
  }

  late final _SDL_fmodf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf24 =
      _SDL_fmodf24Ptr.asFunction<double Function(double, double)>();

  double SDL_log25(
    double x,
  ) {
    return _SDL_log25(
      x,
    );
  }

  late final _SDL_log25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log25 = _SDL_log25Ptr.asFunction<double Function(double)>();

  double SDL_logf24(
    double x,
  ) {
    return _SDL_logf24(
      x,
    );
  }

  late final _SDL_logf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf24 = _SDL_logf24Ptr.asFunction<double Function(double)>();

  double SDL_log1024(
    double x,
  ) {
    return _SDL_log1024(
      x,
    );
  }

  late final _SDL_log1024Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1024 =
      _SDL_log1024Ptr.asFunction<double Function(double)>();

  double SDL_log10f24(
    double x,
  ) {
    return _SDL_log10f24(
      x,
    );
  }

  late final _SDL_log10f24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f24 =
      _SDL_log10f24Ptr.asFunction<double Function(double)>();

  double SDL_pow24(
    double x,
    double y,
  ) {
    return _SDL_pow24(
      x,
      y,
    );
  }

  late final _SDL_pow24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow24 =
      _SDL_pow24Ptr.asFunction<double Function(double, double)>();

  double SDL_powf24(
    double x,
    double y,
  ) {
    return _SDL_powf24(
      x,
      y,
    );
  }

  late final _SDL_powf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf24 =
      _SDL_powf24Ptr.asFunction<double Function(double, double)>();

  double SDL_round24(
    double x,
  ) {
    return _SDL_round24(
      x,
    );
  }

  late final _SDL_round24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round24 =
      _SDL_round24Ptr.asFunction<double Function(double)>();

  double SDL_roundf24(
    double x,
  ) {
    return _SDL_roundf24(
      x,
    );
  }

  late final _SDL_roundf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf24 =
      _SDL_roundf24Ptr.asFunction<double Function(double)>();

  int SDL_lround24(
    double x,
  ) {
    return _SDL_lround24(
      x,
    );
  }

  late final _SDL_lround24Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround24 =
      _SDL_lround24Ptr.asFunction<int Function(double)>();

  int SDL_lroundf24(
    double x,
  ) {
    return _SDL_lroundf24(
      x,
    );
  }

  late final _SDL_lroundf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf24 =
      _SDL_lroundf24Ptr.asFunction<int Function(double)>();

  double SDL_scalbn24(
    double x,
    int n,
  ) {
    return _SDL_scalbn24(
      x,
      n,
    );
  }

  late final _SDL_scalbn24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn24 =
      _SDL_scalbn24Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf24(
    double x,
    int n,
  ) {
    return _SDL_scalbnf24(
      x,
      n,
    );
  }

  late final _SDL_scalbnf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf24 =
      _SDL_scalbnf24Ptr.asFunction<double Function(double, int)>();

  double SDL_sin24(
    double x,
  ) {
    return _SDL_sin24(
      x,
    );
  }

  late final _SDL_sin24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin24 = _SDL_sin24Ptr.asFunction<double Function(double)>();

  double SDL_sinf24(
    double x,
  ) {
    return _SDL_sinf24(
      x,
    );
  }

  late final _SDL_sinf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf24 = _SDL_sinf24Ptr.asFunction<double Function(double)>();

  double SDL_sqrt24(
    double x,
  ) {
    return _SDL_sqrt24(
      x,
    );
  }

  late final _SDL_sqrt24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt24 = _SDL_sqrt24Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf24(
    double x,
  ) {
    return _SDL_sqrtf24(
      x,
    );
  }

  late final _SDL_sqrtf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf24 =
      _SDL_sqrtf24Ptr.asFunction<double Function(double)>();

  double SDL_tan24(
    double x,
  ) {
    return _SDL_tan24(
      x,
    );
  }

  late final _SDL_tan24Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan24 = _SDL_tan24Ptr.asFunction<double Function(double)>();

  double SDL_tanf24(
    double x,
  ) {
    return _SDL_tanf24(
      x,
    );
  }

  late final _SDL_tanf24Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf24 = _SDL_tanf24Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open24(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open24(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open24Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open24 = _SDL_iconv_open24Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close24(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close24(
      cd,
    );
  }

  late final _SDL_iconv_close24Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close24 =
      _SDL_iconv_close24Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv24(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv24(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv24 = _SDL_iconv24Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string24(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string24(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string24 = _SDL_iconv_string24Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform27() {
    return _SDL_GetPlatform27();
  }

  late final _SDL_GetPlatform27Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform27 =
      _SDL_GetPlatform27Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc25(
    int size,
  ) {
    return _SDL_malloc25(
      size,
    );
  }

  late final _SDL_malloc25Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc25 =
      _SDL_malloc25Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc25(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc25(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc25 =
      _SDL_calloc25Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc25(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc25(
      mem,
      size,
    );
  }

  late final _SDL_realloc25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc25 = _SDL_realloc25Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free25(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free25(
      mem,
    );
  }

  late final _SDL_free25Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free25 =
      _SDL_free25Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions25(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions25(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions25 =
      _SDL_GetMemoryFunctions25Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions25(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions25(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions25 =
      _SDL_SetMemoryFunctions25Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations25() {
    return _SDL_GetNumAllocations25();
  }

  late final _SDL_GetNumAllocations25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations25 =
      _SDL_GetNumAllocations25Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv25(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv25(
      name,
    );
  }

  late final _SDL_getenv25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv25 = _SDL_getenv25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv25(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv25(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv25 = _SDL_setenv25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort25(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort25(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort25 = _SDL_qsort25Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs25(
    int x,
  ) {
    return _SDL_abs25(
      x,
    );
  }

  late final _SDL_abs25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs25 = _SDL_abs25Ptr.asFunction<int Function(int)>();

  int SDL_isalpha25(
    int x,
  ) {
    return _SDL_isalpha25(
      x,
    );
  }

  late final _SDL_isalpha25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha25 = _SDL_isalpha25Ptr.asFunction<int Function(int)>();

  int SDL_isalnum25(
    int x,
  ) {
    return _SDL_isalnum25(
      x,
    );
  }

  late final _SDL_isalnum25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum25 = _SDL_isalnum25Ptr.asFunction<int Function(int)>();

  int SDL_isblank25(
    int x,
  ) {
    return _SDL_isblank25(
      x,
    );
  }

  late final _SDL_isblank25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank25 = _SDL_isblank25Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl25(
    int x,
  ) {
    return _SDL_iscntrl25(
      x,
    );
  }

  late final _SDL_iscntrl25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl25 = _SDL_iscntrl25Ptr.asFunction<int Function(int)>();

  int SDL_isdigit25(
    int x,
  ) {
    return _SDL_isdigit25(
      x,
    );
  }

  late final _SDL_isdigit25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit25 = _SDL_isdigit25Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit25(
    int x,
  ) {
    return _SDL_isxdigit25(
      x,
    );
  }

  late final _SDL_isxdigit25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit25 =
      _SDL_isxdigit25Ptr.asFunction<int Function(int)>();

  int SDL_ispunct25(
    int x,
  ) {
    return _SDL_ispunct25(
      x,
    );
  }

  late final _SDL_ispunct25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct25 = _SDL_ispunct25Ptr.asFunction<int Function(int)>();

  int SDL_isspace25(
    int x,
  ) {
    return _SDL_isspace25(
      x,
    );
  }

  late final _SDL_isspace25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace25 = _SDL_isspace25Ptr.asFunction<int Function(int)>();

  int SDL_isupper25(
    int x,
  ) {
    return _SDL_isupper25(
      x,
    );
  }

  late final _SDL_isupper25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper25 = _SDL_isupper25Ptr.asFunction<int Function(int)>();

  int SDL_islower25(
    int x,
  ) {
    return _SDL_islower25(
      x,
    );
  }

  late final _SDL_islower25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower25 = _SDL_islower25Ptr.asFunction<int Function(int)>();

  int SDL_isprint25(
    int x,
  ) {
    return _SDL_isprint25(
      x,
    );
  }

  late final _SDL_isprint25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint25 = _SDL_isprint25Ptr.asFunction<int Function(int)>();

  int SDL_isgraph25(
    int x,
  ) {
    return _SDL_isgraph25(
      x,
    );
  }

  late final _SDL_isgraph25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph25 = _SDL_isgraph25Ptr.asFunction<int Function(int)>();

  int SDL_toupper25(
    int x,
  ) {
    return _SDL_toupper25(
      x,
    );
  }

  late final _SDL_toupper25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper25 = _SDL_toupper25Ptr.asFunction<int Function(int)>();

  int SDL_tolower25(
    int x,
  ) {
    return _SDL_tolower25(
      x,
    );
  }

  late final _SDL_tolower25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower25 = _SDL_tolower25Ptr.asFunction<int Function(int)>();

  int SDL_crc3225(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3225(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3225Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3225 = _SDL_crc3225Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset25(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset25(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset25 = _SDL_memset25Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy25(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy25(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy25 = _SDL_memcpy25Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove25(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove25(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove25 = _SDL_memmove25Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp25(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp25(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp25 = _SDL_memcmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen25(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen25(
      wstr,
    );
  }

  late final _SDL_wcslen25Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen25 =
      _SDL_wcslen25Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy25(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy25(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy25 = _SDL_wcslcpy25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat25(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat25(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat25 = _SDL_wcslcat25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup25(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup25(
      wstr,
    );
  }

  late final _SDL_wcsdup25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup25 = _SDL_wcsdup25Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr25(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr25(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr25 = _SDL_wcsstr25Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp25(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp25(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp25 = _SDL_wcscmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp25(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp25(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp25 = _SDL_wcsncmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp25(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp25(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp25 = _SDL_wcscasecmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp25(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp25(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp25 = _SDL_wcsncasecmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen25(
      str,
    );
  }

  late final _SDL_strlen25Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen25 =
      _SDL_strlen25Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy25(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy25(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy25 = _SDL_strlcpy25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy25(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy25(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy25 = _SDL_utf8strlcpy25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat25(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat25(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat25 = _SDL_strlcat25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup25(
      str,
    );
  }

  late final _SDL_strdup25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup25 = _SDL_strdup25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev25(
      str,
    );
  }

  late final _SDL_strrev25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev25 = _SDL_strrev25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr25(
      str,
    );
  }

  late final _SDL_strupr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr25 = _SDL_strupr25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr25(
      str,
    );
  }

  late final _SDL_strlwr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr25 = _SDL_strlwr25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr25(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr25(
      str,
      c,
    );
  }

  late final _SDL_strchr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr25 = _SDL_strchr25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr25(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr25(
      str,
      c,
    );
  }

  late final _SDL_strrchr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr25 = _SDL_strrchr25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr25(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr25(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr25 = _SDL_strstr25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr25(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr25(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr25 = _SDL_strtokr25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen25(
      str,
    );
  }

  late final _SDL_utf8strlen25Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen25 =
      _SDL_utf8strlen25Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa25(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa25(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa25 = _SDL_itoa25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa25(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa25(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa25 = _SDL_uitoa25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa25(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa25(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa25 = _SDL_ltoa25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa25(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa25(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa25 = _SDL_ultoa25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa25(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa25(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa25 = _SDL_lltoa25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa25(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa25(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa25 = _SDL_ulltoa25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi25(
      str,
    );
  }

  late final _SDL_atoi25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi25 =
      _SDL_atoi25Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof25(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof25(
      str,
    );
  }

  late final _SDL_atof25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof25 =
      _SDL_atof25Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol25(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol25(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol25 = _SDL_strtol25Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul25(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul25(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul25 = _SDL_strtoul25Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll25(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll25(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll25Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll25 = _SDL_strtoll25Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull25(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull25(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull25Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull25 = _SDL_strtoull25Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod25(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod25(
      str,
      endp,
    );
  }

  late final _SDL_strtod25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod25 = _SDL_strtod25Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp25(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp25(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp25 = _SDL_strcmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp25(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp25(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp25 = _SDL_strncmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp25(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp25(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp25 = _SDL_strcasecmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp25(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp25(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp25 = _SDL_strncasecmp25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf25(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf25(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf25 = _SDL_sscanf25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf25(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf25(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf25 = _SDL_vsscanf25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf25(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf25(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf25 = _SDL_snprintf25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf25(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf25(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf25 = _SDL_vsnprintf25Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf25(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf25(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf25 = _SDL_asprintf25Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf25(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf25(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf25 = _SDL_vasprintf25Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos25(
    double x,
  ) {
    return _SDL_acos25(
      x,
    );
  }

  late final _SDL_acos25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos25 = _SDL_acos25Ptr.asFunction<double Function(double)>();

  double SDL_acosf25(
    double x,
  ) {
    return _SDL_acosf25(
      x,
    );
  }

  late final _SDL_acosf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf25 =
      _SDL_acosf25Ptr.asFunction<double Function(double)>();

  double SDL_asin25(
    double x,
  ) {
    return _SDL_asin25(
      x,
    );
  }

  late final _SDL_asin25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin25 = _SDL_asin25Ptr.asFunction<double Function(double)>();

  double SDL_asinf25(
    double x,
  ) {
    return _SDL_asinf25(
      x,
    );
  }

  late final _SDL_asinf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf25 =
      _SDL_asinf25Ptr.asFunction<double Function(double)>();

  double SDL_atan35(
    double x,
  ) {
    return _SDL_atan35(
      x,
    );
  }

  late final _SDL_atan35Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan35 = _SDL_atan35Ptr.asFunction<double Function(double)>();

  double SDL_atanf25(
    double x,
  ) {
    return _SDL_atanf25(
      x,
    );
  }

  late final _SDL_atanf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf25 =
      _SDL_atanf25Ptr.asFunction<double Function(double)>();

  double SDL_atan225(
    double y,
    double x,
  ) {
    return _SDL_atan225(
      y,
      x,
    );
  }

  late final _SDL_atan225Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan225 =
      _SDL_atan225Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f25(
    double y,
    double x,
  ) {
    return _SDL_atan2f25(
      y,
      x,
    );
  }

  late final _SDL_atan2f25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f25 =
      _SDL_atan2f25Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil25(
    double x,
  ) {
    return _SDL_ceil25(
      x,
    );
  }

  late final _SDL_ceil25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil25 = _SDL_ceil25Ptr.asFunction<double Function(double)>();

  double SDL_ceilf25(
    double x,
  ) {
    return _SDL_ceilf25(
      x,
    );
  }

  late final _SDL_ceilf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf25 =
      _SDL_ceilf25Ptr.asFunction<double Function(double)>();

  double SDL_copysign25(
    double x,
    double y,
  ) {
    return _SDL_copysign25(
      x,
      y,
    );
  }

  late final _SDL_copysign25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign25 =
      _SDL_copysign25Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf25(
    double x,
    double y,
  ) {
    return _SDL_copysignf25(
      x,
      y,
    );
  }

  late final _SDL_copysignf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf25 =
      _SDL_copysignf25Ptr.asFunction<double Function(double, double)>();

  double SDL_cos25(
    double x,
  ) {
    return _SDL_cos25(
      x,
    );
  }

  late final _SDL_cos25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos25 = _SDL_cos25Ptr.asFunction<double Function(double)>();

  double SDL_cosf25(
    double x,
  ) {
    return _SDL_cosf25(
      x,
    );
  }

  late final _SDL_cosf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf25 = _SDL_cosf25Ptr.asFunction<double Function(double)>();

  double SDL_exp25(
    double x,
  ) {
    return _SDL_exp25(
      x,
    );
  }

  late final _SDL_exp25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp25 = _SDL_exp25Ptr.asFunction<double Function(double)>();

  double SDL_expf25(
    double x,
  ) {
    return _SDL_expf25(
      x,
    );
  }

  late final _SDL_expf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf25 = _SDL_expf25Ptr.asFunction<double Function(double)>();

  double SDL_fabs25(
    double x,
  ) {
    return _SDL_fabs25(
      x,
    );
  }

  late final _SDL_fabs25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs25 = _SDL_fabs25Ptr.asFunction<double Function(double)>();

  double SDL_fabsf25(
    double x,
  ) {
    return _SDL_fabsf25(
      x,
    );
  }

  late final _SDL_fabsf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf25 =
      _SDL_fabsf25Ptr.asFunction<double Function(double)>();

  double SDL_floor25(
    double x,
  ) {
    return _SDL_floor25(
      x,
    );
  }

  late final _SDL_floor25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor25 =
      _SDL_floor25Ptr.asFunction<double Function(double)>();

  double SDL_floorf25(
    double x,
  ) {
    return _SDL_floorf25(
      x,
    );
  }

  late final _SDL_floorf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf25 =
      _SDL_floorf25Ptr.asFunction<double Function(double)>();

  double SDL_trunc25(
    double x,
  ) {
    return _SDL_trunc25(
      x,
    );
  }

  late final _SDL_trunc25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc25 =
      _SDL_trunc25Ptr.asFunction<double Function(double)>();

  double SDL_truncf25(
    double x,
  ) {
    return _SDL_truncf25(
      x,
    );
  }

  late final _SDL_truncf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf25 =
      _SDL_truncf25Ptr.asFunction<double Function(double)>();

  double SDL_fmod25(
    double x,
    double y,
  ) {
    return _SDL_fmod25(
      x,
      y,
    );
  }

  late final _SDL_fmod25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod25 =
      _SDL_fmod25Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf25(
    double x,
    double y,
  ) {
    return _SDL_fmodf25(
      x,
      y,
    );
  }

  late final _SDL_fmodf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf25 =
      _SDL_fmodf25Ptr.asFunction<double Function(double, double)>();

  double SDL_log26(
    double x,
  ) {
    return _SDL_log26(
      x,
    );
  }

  late final _SDL_log26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log26 = _SDL_log26Ptr.asFunction<double Function(double)>();

  double SDL_logf25(
    double x,
  ) {
    return _SDL_logf25(
      x,
    );
  }

  late final _SDL_logf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf25 = _SDL_logf25Ptr.asFunction<double Function(double)>();

  double SDL_log1025(
    double x,
  ) {
    return _SDL_log1025(
      x,
    );
  }

  late final _SDL_log1025Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1025 =
      _SDL_log1025Ptr.asFunction<double Function(double)>();

  double SDL_log10f25(
    double x,
  ) {
    return _SDL_log10f25(
      x,
    );
  }

  late final _SDL_log10f25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f25 =
      _SDL_log10f25Ptr.asFunction<double Function(double)>();

  double SDL_pow25(
    double x,
    double y,
  ) {
    return _SDL_pow25(
      x,
      y,
    );
  }

  late final _SDL_pow25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow25 =
      _SDL_pow25Ptr.asFunction<double Function(double, double)>();

  double SDL_powf25(
    double x,
    double y,
  ) {
    return _SDL_powf25(
      x,
      y,
    );
  }

  late final _SDL_powf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf25 =
      _SDL_powf25Ptr.asFunction<double Function(double, double)>();

  double SDL_round25(
    double x,
  ) {
    return _SDL_round25(
      x,
    );
  }

  late final _SDL_round25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round25 =
      _SDL_round25Ptr.asFunction<double Function(double)>();

  double SDL_roundf25(
    double x,
  ) {
    return _SDL_roundf25(
      x,
    );
  }

  late final _SDL_roundf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf25 =
      _SDL_roundf25Ptr.asFunction<double Function(double)>();

  int SDL_lround25(
    double x,
  ) {
    return _SDL_lround25(
      x,
    );
  }

  late final _SDL_lround25Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround25 =
      _SDL_lround25Ptr.asFunction<int Function(double)>();

  int SDL_lroundf25(
    double x,
  ) {
    return _SDL_lroundf25(
      x,
    );
  }

  late final _SDL_lroundf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf25 =
      _SDL_lroundf25Ptr.asFunction<int Function(double)>();

  double SDL_scalbn25(
    double x,
    int n,
  ) {
    return _SDL_scalbn25(
      x,
      n,
    );
  }

  late final _SDL_scalbn25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn25 =
      _SDL_scalbn25Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf25(
    double x,
    int n,
  ) {
    return _SDL_scalbnf25(
      x,
      n,
    );
  }

  late final _SDL_scalbnf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf25 =
      _SDL_scalbnf25Ptr.asFunction<double Function(double, int)>();

  double SDL_sin25(
    double x,
  ) {
    return _SDL_sin25(
      x,
    );
  }

  late final _SDL_sin25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin25 = _SDL_sin25Ptr.asFunction<double Function(double)>();

  double SDL_sinf25(
    double x,
  ) {
    return _SDL_sinf25(
      x,
    );
  }

  late final _SDL_sinf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf25 = _SDL_sinf25Ptr.asFunction<double Function(double)>();

  double SDL_sqrt25(
    double x,
  ) {
    return _SDL_sqrt25(
      x,
    );
  }

  late final _SDL_sqrt25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt25 = _SDL_sqrt25Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf25(
    double x,
  ) {
    return _SDL_sqrtf25(
      x,
    );
  }

  late final _SDL_sqrtf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf25 =
      _SDL_sqrtf25Ptr.asFunction<double Function(double)>();

  double SDL_tan25(
    double x,
  ) {
    return _SDL_tan25(
      x,
    );
  }

  late final _SDL_tan25Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan25 = _SDL_tan25Ptr.asFunction<double Function(double)>();

  double SDL_tanf25(
    double x,
  ) {
    return _SDL_tanf25(
      x,
    );
  }

  late final _SDL_tanf25Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf25 = _SDL_tanf25Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open25(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open25(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open25Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open25 = _SDL_iconv_open25Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close25(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close25(
      cd,
    );
  }

  late final _SDL_iconv_close25Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close25 =
      _SDL_iconv_close25Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv25(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv25(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv25 = _SDL_iconv25Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string25(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string25(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string25 = _SDL_iconv_string25Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the current power supply details.
  ///
  /// You should never take a battery status as absolute truth. Batteries
  /// (especially failing batteries) are delicate hardware, and the values
  /// reported here are best estimates based on what that hardware reports. It's
  /// not uncommon for older batteries to lose stored power much faster than it
  /// reports, or completely drain when reporting it has 20 percent left, etc.
  ///
  /// Battery status can change at any time; if you are concerned with power
  /// state, you should call this function frequently, and perhaps ignore changes
  /// until they seem to be stable for a few seconds.
  ///
  /// It's possible a platform can only report battery percentage or time left
  /// but not both.
  ///
  /// \param secs seconds of battery life left, you can pass a NULL here if you
  /// don't care, will return -1 if we can't determine a value, or
  /// we're not running on a battery
  /// \param pct percentage of battery life left, between 0 and 100, you can pass
  /// a NULL here if you don't care, will return -1 if we can't
  /// determine a value, or we're not running on a battery
  /// \returns an SDL_PowerState enum representing the current battery state.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetPowerInfo1(
    ffi.Pointer<ffi.Int> secs,
    ffi.Pointer<ffi.Int> pct,
  ) {
    return _SDL_GetPowerInfo1(
      secs,
      pct,
    );
  }

  late final _SDL_GetPowerInfo1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('SDL_GetPowerInfo');
  late final _SDL_GetPowerInfo1 = _SDL_GetPowerInfo1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform28() {
    return _SDL_GetPlatform28();
  }

  late final _SDL_GetPlatform28Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform28 =
      _SDL_GetPlatform28Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc26(
    int size,
  ) {
    return _SDL_malloc26(
      size,
    );
  }

  late final _SDL_malloc26Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc26 =
      _SDL_malloc26Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc26(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc26(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc26 =
      _SDL_calloc26Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc26(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc26(
      mem,
      size,
    );
  }

  late final _SDL_realloc26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc26 = _SDL_realloc26Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free26(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free26(
      mem,
    );
  }

  late final _SDL_free26Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free26 =
      _SDL_free26Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions26(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions26(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions26 =
      _SDL_GetMemoryFunctions26Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions26(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions26(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions26 =
      _SDL_SetMemoryFunctions26Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations26() {
    return _SDL_GetNumAllocations26();
  }

  late final _SDL_GetNumAllocations26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations26 =
      _SDL_GetNumAllocations26Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv26(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv26(
      name,
    );
  }

  late final _SDL_getenv26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv26 = _SDL_getenv26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv26(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv26(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv26 = _SDL_setenv26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort26(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort26(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort26 = _SDL_qsort26Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs26(
    int x,
  ) {
    return _SDL_abs26(
      x,
    );
  }

  late final _SDL_abs26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs26 = _SDL_abs26Ptr.asFunction<int Function(int)>();

  int SDL_isalpha26(
    int x,
  ) {
    return _SDL_isalpha26(
      x,
    );
  }

  late final _SDL_isalpha26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha26 = _SDL_isalpha26Ptr.asFunction<int Function(int)>();

  int SDL_isalnum26(
    int x,
  ) {
    return _SDL_isalnum26(
      x,
    );
  }

  late final _SDL_isalnum26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum26 = _SDL_isalnum26Ptr.asFunction<int Function(int)>();

  int SDL_isblank26(
    int x,
  ) {
    return _SDL_isblank26(
      x,
    );
  }

  late final _SDL_isblank26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank26 = _SDL_isblank26Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl26(
    int x,
  ) {
    return _SDL_iscntrl26(
      x,
    );
  }

  late final _SDL_iscntrl26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl26 = _SDL_iscntrl26Ptr.asFunction<int Function(int)>();

  int SDL_isdigit26(
    int x,
  ) {
    return _SDL_isdigit26(
      x,
    );
  }

  late final _SDL_isdigit26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit26 = _SDL_isdigit26Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit26(
    int x,
  ) {
    return _SDL_isxdigit26(
      x,
    );
  }

  late final _SDL_isxdigit26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit26 =
      _SDL_isxdigit26Ptr.asFunction<int Function(int)>();

  int SDL_ispunct26(
    int x,
  ) {
    return _SDL_ispunct26(
      x,
    );
  }

  late final _SDL_ispunct26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct26 = _SDL_ispunct26Ptr.asFunction<int Function(int)>();

  int SDL_isspace26(
    int x,
  ) {
    return _SDL_isspace26(
      x,
    );
  }

  late final _SDL_isspace26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace26 = _SDL_isspace26Ptr.asFunction<int Function(int)>();

  int SDL_isupper26(
    int x,
  ) {
    return _SDL_isupper26(
      x,
    );
  }

  late final _SDL_isupper26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper26 = _SDL_isupper26Ptr.asFunction<int Function(int)>();

  int SDL_islower26(
    int x,
  ) {
    return _SDL_islower26(
      x,
    );
  }

  late final _SDL_islower26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower26 = _SDL_islower26Ptr.asFunction<int Function(int)>();

  int SDL_isprint26(
    int x,
  ) {
    return _SDL_isprint26(
      x,
    );
  }

  late final _SDL_isprint26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint26 = _SDL_isprint26Ptr.asFunction<int Function(int)>();

  int SDL_isgraph26(
    int x,
  ) {
    return _SDL_isgraph26(
      x,
    );
  }

  late final _SDL_isgraph26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph26 = _SDL_isgraph26Ptr.asFunction<int Function(int)>();

  int SDL_toupper26(
    int x,
  ) {
    return _SDL_toupper26(
      x,
    );
  }

  late final _SDL_toupper26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper26 = _SDL_toupper26Ptr.asFunction<int Function(int)>();

  int SDL_tolower26(
    int x,
  ) {
    return _SDL_tolower26(
      x,
    );
  }

  late final _SDL_tolower26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower26 = _SDL_tolower26Ptr.asFunction<int Function(int)>();

  int SDL_crc3226(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3226(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3226Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3226 = _SDL_crc3226Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset26(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset26(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset26 = _SDL_memset26Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy26(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy26(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy26 = _SDL_memcpy26Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove26(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove26(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove26 = _SDL_memmove26Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp26(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp26(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp26 = _SDL_memcmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen26(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen26(
      wstr,
    );
  }

  late final _SDL_wcslen26Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen26 =
      _SDL_wcslen26Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy26(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy26(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy26 = _SDL_wcslcpy26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat26(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat26(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat26 = _SDL_wcslcat26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup26(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup26(
      wstr,
    );
  }

  late final _SDL_wcsdup26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup26 = _SDL_wcsdup26Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr26(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr26(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr26 = _SDL_wcsstr26Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp26(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp26(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp26 = _SDL_wcscmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp26(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp26(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp26 = _SDL_wcsncmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp26(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp26(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp26 = _SDL_wcscasecmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp26(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp26(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp26 = _SDL_wcsncasecmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen26(
      str,
    );
  }

  late final _SDL_strlen26Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen26 =
      _SDL_strlen26Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy26(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy26(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy26 = _SDL_strlcpy26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy26(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy26(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy26 = _SDL_utf8strlcpy26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat26(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat26(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat26 = _SDL_strlcat26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup26(
      str,
    );
  }

  late final _SDL_strdup26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup26 = _SDL_strdup26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev26(
      str,
    );
  }

  late final _SDL_strrev26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev26 = _SDL_strrev26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr26(
      str,
    );
  }

  late final _SDL_strupr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr26 = _SDL_strupr26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr26(
      str,
    );
  }

  late final _SDL_strlwr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr26 = _SDL_strlwr26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr26(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr26(
      str,
      c,
    );
  }

  late final _SDL_strchr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr26 = _SDL_strchr26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr26(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr26(
      str,
      c,
    );
  }

  late final _SDL_strrchr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr26 = _SDL_strrchr26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr26(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr26(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr26 = _SDL_strstr26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr26(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr26(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr26 = _SDL_strtokr26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen26(
      str,
    );
  }

  late final _SDL_utf8strlen26Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen26 =
      _SDL_utf8strlen26Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa26(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa26(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa26 = _SDL_itoa26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa26(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa26(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa26 = _SDL_uitoa26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa26(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa26(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa26 = _SDL_ltoa26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa26(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa26(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa26 = _SDL_ultoa26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa26(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa26(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa26 = _SDL_lltoa26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa26(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa26(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa26 = _SDL_ulltoa26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi26(
      str,
    );
  }

  late final _SDL_atoi26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi26 =
      _SDL_atoi26Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof26(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof26(
      str,
    );
  }

  late final _SDL_atof26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof26 =
      _SDL_atof26Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol26(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol26(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol26 = _SDL_strtol26Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul26(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul26(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul26 = _SDL_strtoul26Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll26(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll26(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll26Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll26 = _SDL_strtoll26Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull26(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull26(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull26Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull26 = _SDL_strtoull26Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod26(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod26(
      str,
      endp,
    );
  }

  late final _SDL_strtod26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod26 = _SDL_strtod26Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp26(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp26(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp26 = _SDL_strcmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp26(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp26(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp26 = _SDL_strncmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp26(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp26(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp26 = _SDL_strcasecmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp26(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp26(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp26 = _SDL_strncasecmp26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf26(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf26(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf26 = _SDL_sscanf26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf26(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf26(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf26 = _SDL_vsscanf26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf26(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf26(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf26 = _SDL_snprintf26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf26(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf26(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf26 = _SDL_vsnprintf26Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf26(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf26(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf26 = _SDL_asprintf26Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf26(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf26(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf26 = _SDL_vasprintf26Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos26(
    double x,
  ) {
    return _SDL_acos26(
      x,
    );
  }

  late final _SDL_acos26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos26 = _SDL_acos26Ptr.asFunction<double Function(double)>();

  double SDL_acosf26(
    double x,
  ) {
    return _SDL_acosf26(
      x,
    );
  }

  late final _SDL_acosf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf26 =
      _SDL_acosf26Ptr.asFunction<double Function(double)>();

  double SDL_asin26(
    double x,
  ) {
    return _SDL_asin26(
      x,
    );
  }

  late final _SDL_asin26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin26 = _SDL_asin26Ptr.asFunction<double Function(double)>();

  double SDL_asinf26(
    double x,
  ) {
    return _SDL_asinf26(
      x,
    );
  }

  late final _SDL_asinf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf26 =
      _SDL_asinf26Ptr.asFunction<double Function(double)>();

  double SDL_atan36(
    double x,
  ) {
    return _SDL_atan36(
      x,
    );
  }

  late final _SDL_atan36Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan36 = _SDL_atan36Ptr.asFunction<double Function(double)>();

  double SDL_atanf26(
    double x,
  ) {
    return _SDL_atanf26(
      x,
    );
  }

  late final _SDL_atanf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf26 =
      _SDL_atanf26Ptr.asFunction<double Function(double)>();

  double SDL_atan226(
    double y,
    double x,
  ) {
    return _SDL_atan226(
      y,
      x,
    );
  }

  late final _SDL_atan226Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan226 =
      _SDL_atan226Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f26(
    double y,
    double x,
  ) {
    return _SDL_atan2f26(
      y,
      x,
    );
  }

  late final _SDL_atan2f26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f26 =
      _SDL_atan2f26Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil26(
    double x,
  ) {
    return _SDL_ceil26(
      x,
    );
  }

  late final _SDL_ceil26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil26 = _SDL_ceil26Ptr.asFunction<double Function(double)>();

  double SDL_ceilf26(
    double x,
  ) {
    return _SDL_ceilf26(
      x,
    );
  }

  late final _SDL_ceilf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf26 =
      _SDL_ceilf26Ptr.asFunction<double Function(double)>();

  double SDL_copysign26(
    double x,
    double y,
  ) {
    return _SDL_copysign26(
      x,
      y,
    );
  }

  late final _SDL_copysign26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign26 =
      _SDL_copysign26Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf26(
    double x,
    double y,
  ) {
    return _SDL_copysignf26(
      x,
      y,
    );
  }

  late final _SDL_copysignf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf26 =
      _SDL_copysignf26Ptr.asFunction<double Function(double, double)>();

  double SDL_cos26(
    double x,
  ) {
    return _SDL_cos26(
      x,
    );
  }

  late final _SDL_cos26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos26 = _SDL_cos26Ptr.asFunction<double Function(double)>();

  double SDL_cosf26(
    double x,
  ) {
    return _SDL_cosf26(
      x,
    );
  }

  late final _SDL_cosf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf26 = _SDL_cosf26Ptr.asFunction<double Function(double)>();

  double SDL_exp26(
    double x,
  ) {
    return _SDL_exp26(
      x,
    );
  }

  late final _SDL_exp26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp26 = _SDL_exp26Ptr.asFunction<double Function(double)>();

  double SDL_expf26(
    double x,
  ) {
    return _SDL_expf26(
      x,
    );
  }

  late final _SDL_expf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf26 = _SDL_expf26Ptr.asFunction<double Function(double)>();

  double SDL_fabs26(
    double x,
  ) {
    return _SDL_fabs26(
      x,
    );
  }

  late final _SDL_fabs26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs26 = _SDL_fabs26Ptr.asFunction<double Function(double)>();

  double SDL_fabsf26(
    double x,
  ) {
    return _SDL_fabsf26(
      x,
    );
  }

  late final _SDL_fabsf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf26 =
      _SDL_fabsf26Ptr.asFunction<double Function(double)>();

  double SDL_floor26(
    double x,
  ) {
    return _SDL_floor26(
      x,
    );
  }

  late final _SDL_floor26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor26 =
      _SDL_floor26Ptr.asFunction<double Function(double)>();

  double SDL_floorf26(
    double x,
  ) {
    return _SDL_floorf26(
      x,
    );
  }

  late final _SDL_floorf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf26 =
      _SDL_floorf26Ptr.asFunction<double Function(double)>();

  double SDL_trunc26(
    double x,
  ) {
    return _SDL_trunc26(
      x,
    );
  }

  late final _SDL_trunc26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc26 =
      _SDL_trunc26Ptr.asFunction<double Function(double)>();

  double SDL_truncf26(
    double x,
  ) {
    return _SDL_truncf26(
      x,
    );
  }

  late final _SDL_truncf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf26 =
      _SDL_truncf26Ptr.asFunction<double Function(double)>();

  double SDL_fmod26(
    double x,
    double y,
  ) {
    return _SDL_fmod26(
      x,
      y,
    );
  }

  late final _SDL_fmod26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod26 =
      _SDL_fmod26Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf26(
    double x,
    double y,
  ) {
    return _SDL_fmodf26(
      x,
      y,
    );
  }

  late final _SDL_fmodf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf26 =
      _SDL_fmodf26Ptr.asFunction<double Function(double, double)>();

  double SDL_log27(
    double x,
  ) {
    return _SDL_log27(
      x,
    );
  }

  late final _SDL_log27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log27 = _SDL_log27Ptr.asFunction<double Function(double)>();

  double SDL_logf26(
    double x,
  ) {
    return _SDL_logf26(
      x,
    );
  }

  late final _SDL_logf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf26 = _SDL_logf26Ptr.asFunction<double Function(double)>();

  double SDL_log1026(
    double x,
  ) {
    return _SDL_log1026(
      x,
    );
  }

  late final _SDL_log1026Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1026 =
      _SDL_log1026Ptr.asFunction<double Function(double)>();

  double SDL_log10f26(
    double x,
  ) {
    return _SDL_log10f26(
      x,
    );
  }

  late final _SDL_log10f26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f26 =
      _SDL_log10f26Ptr.asFunction<double Function(double)>();

  double SDL_pow26(
    double x,
    double y,
  ) {
    return _SDL_pow26(
      x,
      y,
    );
  }

  late final _SDL_pow26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow26 =
      _SDL_pow26Ptr.asFunction<double Function(double, double)>();

  double SDL_powf26(
    double x,
    double y,
  ) {
    return _SDL_powf26(
      x,
      y,
    );
  }

  late final _SDL_powf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf26 =
      _SDL_powf26Ptr.asFunction<double Function(double, double)>();

  double SDL_round26(
    double x,
  ) {
    return _SDL_round26(
      x,
    );
  }

  late final _SDL_round26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round26 =
      _SDL_round26Ptr.asFunction<double Function(double)>();

  double SDL_roundf26(
    double x,
  ) {
    return _SDL_roundf26(
      x,
    );
  }

  late final _SDL_roundf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf26 =
      _SDL_roundf26Ptr.asFunction<double Function(double)>();

  int SDL_lround26(
    double x,
  ) {
    return _SDL_lround26(
      x,
    );
  }

  late final _SDL_lround26Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround26 =
      _SDL_lround26Ptr.asFunction<int Function(double)>();

  int SDL_lroundf26(
    double x,
  ) {
    return _SDL_lroundf26(
      x,
    );
  }

  late final _SDL_lroundf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf26 =
      _SDL_lroundf26Ptr.asFunction<int Function(double)>();

  double SDL_scalbn26(
    double x,
    int n,
  ) {
    return _SDL_scalbn26(
      x,
      n,
    );
  }

  late final _SDL_scalbn26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn26 =
      _SDL_scalbn26Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf26(
    double x,
    int n,
  ) {
    return _SDL_scalbnf26(
      x,
      n,
    );
  }

  late final _SDL_scalbnf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf26 =
      _SDL_scalbnf26Ptr.asFunction<double Function(double, int)>();

  double SDL_sin26(
    double x,
  ) {
    return _SDL_sin26(
      x,
    );
  }

  late final _SDL_sin26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin26 = _SDL_sin26Ptr.asFunction<double Function(double)>();

  double SDL_sinf26(
    double x,
  ) {
    return _SDL_sinf26(
      x,
    );
  }

  late final _SDL_sinf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf26 = _SDL_sinf26Ptr.asFunction<double Function(double)>();

  double SDL_sqrt26(
    double x,
  ) {
    return _SDL_sqrt26(
      x,
    );
  }

  late final _SDL_sqrt26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt26 = _SDL_sqrt26Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf26(
    double x,
  ) {
    return _SDL_sqrtf26(
      x,
    );
  }

  late final _SDL_sqrtf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf26 =
      _SDL_sqrtf26Ptr.asFunction<double Function(double)>();

  double SDL_tan26(
    double x,
  ) {
    return _SDL_tan26(
      x,
    );
  }

  late final _SDL_tan26Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan26 = _SDL_tan26Ptr.asFunction<double Function(double)>();

  double SDL_tanf26(
    double x,
  ) {
    return _SDL_tanf26(
      x,
    );
  }

  late final _SDL_tanf26Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf26 = _SDL_tanf26Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open26(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open26(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open26Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open26 = _SDL_iconv_open26Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close26(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close26(
      cd,
    );
  }

  late final _SDL_iconv_close26Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close26 =
      _SDL_iconv_close26Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv26(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv26(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv26 = _SDL_iconv26Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string26(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string26(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string26 = _SDL_iconv_string26Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the SDL error message for the current thread.
  ///
  /// Calling this function will replace any previous error message that was set.
  ///
  /// This function always returns -1, since SDL frequently uses -1 to signify an
  /// failing result, leading to this idiom:
  ///
  /// ```c
  /// if (error_code) {
  /// return SDL_SetError("This operation has failed: %d", error_code);
  /// }
  /// ```
  ///
  /// \param fmt a printf()-style message format string
  /// \param ... additional parameters matching % tokens in the `fmt` string, if
  /// any
  /// \returns always -1.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_GetError
  int SDL_SetError14(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_SetError14(
      fmt,
    );
  }

  late final _SDL_SetError14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_SetError');
  late final _SDL_SetError14 =
      _SDL_SetError14Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Retrieve a message about the last error that occurred on the current
  /// thread.
  ///
  /// It is possible for multiple errors to occur before calling SDL_GetError().
  /// Only the last error is returned.
  ///
  /// The message is only applicable when an SDL function has signaled an error.
  /// You must check the return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError(). You should *not* use the results of
  /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
  /// an error string even when reporting success.
  ///
  /// SDL will *not* clear the error string for successful API calls. You *must*
  /// check return values for failure cases before you can assume the error
  /// string applies.
  ///
  /// Error strings are set per-thread, so an error set in a different thread
  /// will not interfere with the current thread's operation.
  ///
  /// The returned string is internally allocated and must not be freed by the
  /// application.
  ///
  /// \returns a message with information about the specific error that occurred,
  /// or an empty string if there hasn't been an error message set since
  /// the last call to SDL_ClearError(). The message is only applicable
  /// when an SDL function has signaled an error. You must check the
  /// return values of SDL function calls to determine when to
  /// appropriately call SDL_GetError().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ClearError
  /// \sa SDL_SetError
  ffi.Pointer<ffi.Char> SDL_GetError14() {
    return _SDL_GetError14();
  }

  late final _SDL_GetError14Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError14 =
      _SDL_GetError14Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the last error message that was set for the current thread.
  ///
  /// This allows the caller to copy the error string into a provided buffer, but
  /// otherwise operates exactly the same as SDL_GetError().
  ///
  /// \param errstr A buffer to fill with the last error message that was set for
  /// the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  /// \returns the pointer passed in as the `errstr` parameter.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_GetError
  ffi.Pointer<ffi.Char> SDL_GetErrorMsg14(
    ffi.Pointer<ffi.Char> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg14(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg14 = _SDL_GetErrorMsg14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Clear any previous error message for this thread.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetError
  /// \sa SDL_SetError
  void SDL_ClearError14() {
    return _SDL_ClearError14();
  }

  late final _SDL_ClearError14Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError14 =
      _SDL_ClearError14Ptr.asFunction<void Function()>();

  int SDL_Error14(
    int code,
  ) {
    return _SDL_Error14(
      code,
    );
  }

  late final _SDL_Error14Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error14 = _SDL_Error14Ptr.asFunction<int Function(int)>();

  /// Get the human readable name of a pixel format.
  ///
  /// \param format the pixel format to query
  /// \returns the human readable name of the specified pixel format or
  /// `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPixelFormatName4(
    int format,
  ) {
    return _SDL_GetPixelFormatName4(
      format,
    );
  }

  late final _SDL_GetPixelFormatName4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Uint32)>>(
          'SDL_GetPixelFormatName');
  late final _SDL_GetPixelFormatName4 = _SDL_GetPixelFormatName4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
  ///
  /// \param format one of the SDL_PixelFormatEnum values
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask a pointer filled in with the red mask for the format
  /// \param Gmask a pointer filled in with the green mask for the format
  /// \param Bmask a pointer filled in with the blue mask for the format
  /// \param Amask a pointer filled in with the alpha mask for the format
  /// \returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't
  /// possible; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MasksToPixelFormatEnum
  int SDL_PixelFormatEnumToMasks4(
    int format,
    ffi.Pointer<ffi.Int> bpp,
    ffi.Pointer<Uint32> Rmask,
    ffi.Pointer<Uint32> Gmask,
    ffi.Pointer<Uint32> Bmask,
    ffi.Pointer<Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks4(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasks4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>)>>('SDL_PixelFormatEnumToMasks');
  late final _SDL_PixelFormatEnumToMasks4 =
      _SDL_PixelFormatEnumToMasks4Ptr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>, ffi.Pointer<Uint32>, ffi.Pointer<Uint32>)>();

  /// Convert a bpp value and RGBA masks to an enumerated pixel format.
  ///
  /// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
  /// possible.
  ///
  /// \param bpp a bits per pixel value; usually 15, 16, or 32
  /// \param Rmask the red mask for the format
  /// \param Gmask the green mask for the format
  /// \param Bmask the blue mask for the format
  /// \param Amask the alpha mask for the format
  /// \returns one of the SDL_PixelFormatEnum values
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PixelFormatEnumToMasks
  int SDL_MasksToPixelFormatEnum4(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum4(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnum4Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Int, Uint32, Uint32, Uint32,
              Uint32)>>('SDL_MasksToPixelFormatEnum');
  late final _SDL_MasksToPixelFormatEnum4 = _SDL_MasksToPixelFormatEnum4Ptr
      .asFunction<int Function(int, int, int, int, int)>();

  /// Create an SDL_PixelFormat structure corresponding to a pixel format.
  ///
  /// Returned structure may come from a shared global cache (i.e. not newly
  /// allocated), and hence should not be modified, especially the palette. Weird
  /// errors such as `Blit combination not supported` may occur.
  ///
  /// \param pixel_format one of the SDL_PixelFormatEnum values
  /// \returns the new SDL_PixelFormat structure or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeFormat
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat4(
    int pixel_format,
  ) {
    return _SDL_AllocFormat4(
      pixel_format,
    );
  }

  late final _SDL_AllocFormat4Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_PixelFormat> Function(Uint32)>>(
      'SDL_AllocFormat');
  late final _SDL_AllocFormat4 = _SDL_AllocFormat4Ptr.asFunction<
      ffi.Pointer<SDL_PixelFormat> Function(int)>();

  /// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().
  ///
  /// \param format the SDL_PixelFormat structure to free
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  void SDL_FreeFormat4(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat4(
      format,
    );
  }

  late final _SDL_FreeFormat4Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_PixelFormat>)>>(
      'SDL_FreeFormat');
  late final _SDL_FreeFormat4 = _SDL_FreeFormat4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_PixelFormat>)>();

  /// Create a palette structure with the specified number of color entries.
  ///
  /// The palette entries are initialized to white.
  ///
  /// \param ncolors represents the number of color entries in the color palette
  /// \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
  /// there wasn't enough memory); call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreePalette
  ffi.Pointer<SDL_Palette> SDL_AllocPalette4(
    int ncolors,
  ) {
    return _SDL_AllocPalette4(
      ncolors,
    );
  }

  late final _SDL_AllocPalette4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Palette> Function(ffi.Int)>>(
          'SDL_AllocPalette');
  late final _SDL_AllocPalette4 = _SDL_AllocPalette4Ptr.asFunction<
      ffi.Pointer<SDL_Palette> Function(int)>();

  /// Set the palette for a pixel format structure.
  ///
  /// \param format the SDL_PixelFormat structure that will use the palette
  /// \param palette the SDL_Palette structure that will be used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_FreePalette
  int SDL_SetPixelFormatPalette4(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette4(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalette4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetPixelFormatPalette');
  late final _SDL_SetPixelFormatPalette4 =
      _SDL_SetPixelFormatPalette4Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<SDL_Palette>)>();

  /// Set a range of colors in a palette.
  ///
  /// \param palette the SDL_Palette structure to modify
  /// \param colors an array of SDL_Color structures to copy into the palette
  /// \param firstcolor the index of the first palette entry to modify
  /// \param ncolors the number of entries to modify
  /// \returns 0 on success or a negative error code if not all of the colors
  /// could be set; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  /// \sa SDL_CreateRGBSurface
  int SDL_SetPaletteColors4(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors4(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColors4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>,
              ffi.Int, ffi.Int)>>('SDL_SetPaletteColors');
  late final _SDL_SetPaletteColors4 = _SDL_SetPaletteColors4Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>, int, int)>();

  /// Free a palette created with SDL_AllocPalette().
  ///
  /// \param palette the SDL_Palette structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocPalette
  void SDL_FreePalette4(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette4(
      palette,
    );
  }

  late final _SDL_FreePalette4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Palette>)>>(
          'SDL_FreePalette');
  late final _SDL_FreePalette4 = _SDL_FreePalette4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Palette>)>();

  /// Map an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// This function maps the RGB color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGB color value for
  /// the given pixel format.
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the specified pixel format has an alpha component it will be returned as
  /// all 1 bits (fully opaque).
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the pixel format
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGBA
  int SDL_MapRGB4(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB4(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGB4Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8,
              Uint8)>>('SDL_MapRGB');
  late final _SDL_MapRGB4 = _SDL_MapRGB4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int)>();

  /// Map an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// This function maps the RGBA color value to the specified pixel format and
  /// returns the pixel value best approximating the given RGBA color value for
  /// the given pixel format.
  ///
  /// If the specified pixel format has no alpha component the alpha value will
  /// be ignored (as it will be in formats with a palette).
  ///
  /// If the format has a palette (8-bit) the index of the closest matching color
  /// in the palette will be returned.
  ///
  /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
  /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
  /// format the return value can be assigned to a Uint16, and similarly a Uint8
  /// for an 8-bpp format).
  ///
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r the red component of the pixel in the range 0-255
  /// \param g the green component of the pixel in the range 0-255
  /// \param b the blue component of the pixel in the range 0-255
  /// \param a the alpha component of the pixel in the range 0-255
  /// \returns a pixel value
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  int SDL_MapRGBA4(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA4(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBA4Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_MapRGBA');
  late final _SDL_MapRGBA4 = _SDL_MapRGBA4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int, int)>();

  /// Get RGB values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGBA
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGB4(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetRGB4(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGB4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGB');
  late final _SDL_GetRGB4 = _SDL_GetRGB4Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Get RGBA values from a pixel in the specified format.
  ///
  /// This function uses the entire 8-bit [0..255] range when converting color
  /// components from pixel formats with less than 8-bits per RGB component
  /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
  /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
  ///
  /// If the surface has no alpha component, the alpha will be returned as 0xff
  /// (100% opaque).
  ///
  /// \param pixel a pixel value
  /// \param format an SDL_PixelFormat structure describing the format of the
  /// pixel
  /// \param r a pointer filled in with the red component
  /// \param g a pointer filled in with the green component
  /// \param b a pointer filled in with the blue component
  /// \param a a pointer filled in with the alpha component
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRGB
  /// \sa SDL_MapRGB
  /// \sa SDL_MapRGBA
  void SDL_GetRGBA4(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRGBA4(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBA4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGBA');
  late final _SDL_GetRGBA4 = _SDL_GetRGBA4Ptr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Calculate a 256 entry gamma ramp for a gamma value.
  ///
  /// \param gamma a gamma value where 0.0 is black and 1.0 is identity
  /// \param ramp an array of 256 values filled in with the gamma ramp
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  void SDL_CalculateGammaRamp4(
    double gamma,
    ffi.Pointer<Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp4(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRamp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Float, ffi.Pointer<Uint16>)>>('SDL_CalculateGammaRamp');
  late final _SDL_CalculateGammaRamp4 = _SDL_CalculateGammaRamp4Ptr.asFunction<
      void Function(double, ffi.Pointer<Uint16>)>();

  /// Use this function to create a new SDL_RWops structure for reading from
  /// and/or writing to a named file.
  ///
  /// The `mode` string is treated roughly the same as in a call to the C
  /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
  /// scenes.
  ///
  /// Available `mode` strings:
  ///
  /// - "r": Open a file for reading. The file must exist.
  /// - "w": Create an empty file for writing. If a file with the same name
  /// already exists its content is erased and the file is treated as a new
  /// empty file.
  /// - "a": Append to a file. Writing operations append data at the end of the
  /// file. The file is created if it does not exist.
  /// - "r+": Open a file for update both reading and writing. The file must
  /// exist.
  /// - "w+": Create an empty file for both reading and writing. If a file with
  /// the same name already exists its content is erased and the file is
  /// treated as a new empty file.
  /// - "a+": Open a file for reading and appending. All writing operations are
  /// performed at the end of the file, protecting the previous content to be
  /// overwritten. You can reposition (fseek, rewind) the internal pointer to
  /// anywhere in the file for reading, but writing operations will move it
  /// back to the end of file. The file is created if it does not exist.
  ///
  /// **NOTE**: In order to open a file as a binary file, a "b" character has to
  /// be included in the `mode` string. This additional "b" character can either
  /// be appended at the end of the string (thus making the following compound
  /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
  /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
  /// Additional characters may follow the sequence, although they should have no
  /// effect. For example, "t" is sometimes appended to make explicit the file is
  /// a text file.
  ///
  /// This function supports Unicode filenames, but they must be encoded in UTF-8
  /// format, regardless of the underlying operating system.
  ///
  /// As a fallback, SDL_RWFromFile() will transparently open a matching filename
  /// in an Android app's `assets`.
  ///
  /// Closing the SDL_RWops will close the file handle SDL is holding internally.
  ///
  /// \param file a UTF-8 string representing the filename to open
  /// \param mode an ASCII string representing the mode to be used for opening
  /// the file.
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFile6(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _SDL_RWFromFile6(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile6 = _SDL_RWFromFile6Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Use this function to create an SDL_RWops structure from a standard I/O file
  /// pointer (stdio.h's `FILE*`).
  ///
  /// This function is not available on Windows, since files opened in an
  /// application on that platform cannot be used by a dynamically linked
  /// library.
  ///
  /// On some platforms, the first parameter is a `void*`, on others, it's a
  /// `FILE*`, depending on what system headers are available to SDL. It is
  /// always intended to be the `FILE*` type from the C runtime's stdio.h.
  ///
  /// \param fp the `FILE*` that feeds the SDL_RWops stream
  /// \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
  /// SDL_FALSE to leave the `FILE*` open when the RWops is
  /// closed
  /// \returns a pointer to the SDL_RWops structure that is created, or NULL on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromFP6(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP6(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP6 = _SDL_RWFromFP6Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-write memory buffer for use with
  /// SDL_RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size, for both read and write access.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to make sure the RWops never writes to the memory buffer, you
  /// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
  ///
  /// \param mem a pointer to a buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  ffi.Pointer<SDL_RWops> SDL_RWFromMem6(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem6(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem6 = _SDL_RWFromMem6Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to prepare a read-only memory buffer for use with RWops.
  ///
  /// This function sets up an SDL_RWops struct based on a memory area of a
  /// certain size. It assumes the memory area is not writable.
  ///
  /// Attempting to write to this RWops stream will report an error without
  /// writing to the memory buffer.
  ///
  /// This memory buffer is not copied by the RWops; the pointer you provide must
  /// remain valid until you close the stream. Closing the stream will not free
  /// the original buffer.
  ///
  /// If you need to write to a memory buffer, you should use SDL_RWFromMem()
  /// with a writable buffer of memory instead.
  ///
  /// \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
  /// \param size the buffer size, in bytes
  /// \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWtell
  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem6(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem6(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem6 = _SDL_RWFromConstMem6Ptr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Use this function to allocate an empty, unpopulated SDL_RWops structure.
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
  ///
  /// You must free the returned pointer with SDL_FreeRW(). Depending on your
  /// operating system and compiler, there may be a difference between the
  /// malloc() and free() your program uses and the versions SDL calls
  /// internally. Trying to mix the two can cause crashing such as segmentation
  /// faults. Since all SDL_RWops must free themselves when their **close**
  /// method is called, all SDL_RWops must be allocated through this function, so
  /// they can all be freed correctly with SDL_FreeRW().
  ///
  /// \returns a pointer to the allocated memory on success, or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeRW
  ffi.Pointer<SDL_RWops> SDL_AllocRW6() {
    return _SDL_AllocRW6();
  }

  late final _SDL_AllocRW6Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW6 =
      _SDL_AllocRW6Ptr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  /// Use this function to free an SDL_RWops structure allocated by
  /// SDL_AllocRW().
  ///
  /// Applications do not need to use this function unless they are providing
  /// their own SDL_RWops implementation. If you just need a SDL_RWops to
  /// read/write a common data source, you should use the built-in
  /// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
  /// call the **close** method on those SDL_RWops pointers when you are done
  /// with them.
  ///
  /// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
  /// invalid as soon as this function returns. Any extra memory allocated during
  /// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
  /// be responsible for managing that memory in their **close** method.
  ///
  /// \param area the SDL_RWops structure to be freed
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocRW
  void SDL_FreeRW6(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW6(
      area,
    );
  }

  late final _SDL_FreeRW6Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW6 =
      _SDL_FreeRW6Ptr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to get the size of the data stream in an SDL_RWops.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context the SDL_RWops to get the size of the data stream from
  /// \returns the size of the data stream in the SDL_RWops on success, -1 if
  /// unknown or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RWsize6(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize6(
      context,
    );
  }

  late final _SDL_RWsize6Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize6 =
      _SDL_RWsize6Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek within an SDL_RWops data stream.
  ///
  /// This function seeks to byte `offset`, relative to `whence`.
  ///
  /// `whence` may be any of the following values:
  ///
  /// - `RW_SEEK_SET`: seek from the beginning of data
  /// - `RW_SEEK_CUR`: seek relative to current read point
  /// - `RW_SEEK_END`: seek relative to the end of data
  ///
  /// If this stream can not seek, it will return -1.
  ///
  /// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
  /// `seek` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param offset an offset in bytes, relative to **whence** location; can be
  /// negative
  /// \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
  /// \returns the final offset in the data stream after the seek or -1 on error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWtell
  /// \sa SDL_RWwrite
  int SDL_RWseek6(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek6(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek6Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>>('SDL_RWseek');
  late final _SDL_RWseek6 = _SDL_RWseek6Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Determine the current read/write offset in an SDL_RWops data stream.
  ///
  /// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
  /// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
  /// application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a SDL_RWops data stream object from which to get the current
  /// offset
  /// \returns the current offset in the stream, or -1 if the information can not
  /// be determined.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWtell6(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell6(
      context,
    );
  }

  late final _SDL_RWtell6Ptr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell6 =
      _SDL_RWtell6Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read from a data source.
  ///
  /// This function reads up to `maxnum` objects each of size `size` from the
  /// data source to the area pointed at by `ptr`. This function may read less
  /// objects than requested. It will return zero when there has been an error or
  /// the data stream is completely read.
  ///
  /// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
  /// `read` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer to read data into
  /// \param size the size of each object to read, in bytes
  /// \param maxnum the maximum number of objects to be read
  /// \returns the number of objects read, or 0 at error or end of file; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWread6(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread6(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWread');
  late final _SDL_RWread6 = _SDL_RWread6Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write to an SDL_RWops data stream.
  ///
  /// This function writes exactly `num` objects each of size `size` from the
  /// area pointed at by `ptr` to the stream. If this fails for any reason, it'll
  /// return less than `num` to demonstrate how far the write progressed. On
  /// success, it returns `num`.
  ///
  /// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
  /// `write` method appropriately, to simplify application development.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context a pointer to an SDL_RWops structure
  /// \param ptr a pointer to a buffer containing data to write
  /// \param size the size of an object to write, in bytes
  /// \param num the number of objects to write
  /// \returns the number of objects written, which will be less than **num** on
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWclose
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  int SDL_RWwrite6(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite6(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>>('SDL_RWwrite');
  late final _SDL_RWwrite6 = _SDL_RWwrite6Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
  /// resources used by the stream and frees the SDL_RWops itself with
  /// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
  /// flush to its output (e.g. to disk).
  ///
  /// Note that if this fails to flush the stream to disk, this function reports
  /// an error, but the SDL_RWops is still invalid once this function returns.
  ///
  /// Prior to SDL 2.0.10, this function was a macro.
  ///
  /// \param context SDL_RWops structure to close
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  ///
  /// \sa SDL_RWFromConstMem
  /// \sa SDL_RWFromFile
  /// \sa SDL_RWFromFP
  /// \sa SDL_RWFromMem
  /// \sa SDL_RWread
  /// \sa SDL_RWseek
  /// \sa SDL_RWwrite
  int SDL_RWclose6(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose6(
      context,
    );
  }

  late final _SDL_RWclose6Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose6 =
      _SDL_RWclose6Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \param src the SDL_RWops to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.6.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW6(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Size> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW6(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<ffi.Size>, ffi.Int)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW6 = _SDL_LoadFile_RW6Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Size>, int)>();

  /// Load all the data from a file path.
  ///
  /// The data is allocated with a zero byte at the end (null terminated) for
  /// convenience. This extra byte is not included in the value reported via
  /// `datasize`.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// Prior to SDL 2.0.10, this function was a macro wrapping around
  /// SDL_LoadFile_RW.
  ///
  /// \param file the path to read all available data from
  /// \param datasize if not NULL, will store the number of bytes read
  /// \returns the data, or NULL if there was an error.
  ///
  /// \since This function is available since SDL 2.0.10.
  ffi.Pointer<ffi.Void> SDL_LoadFile6(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Size> datasize,
  ) {
    return _SDL_LoadFile6(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>>('SDL_LoadFile');
  late final _SDL_LoadFile6 = _SDL_LoadFile6Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Use this function to read a byte from an SDL_RWops.
  ///
  /// \param src the SDL_RWops to read from
  /// \returns the read byte on success or 0 on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteU8
  int SDL_ReadU86(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU86(
      src,
    );
  }

  late final _SDL_ReadU86Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU86 =
      _SDL_ReadU86Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE16
  int SDL_ReadLE166(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE166(
      src,
    );
  }

  late final _SDL_ReadLE166Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE166 =
      _SDL_ReadLE166Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 16 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 16 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE16
  int SDL_ReadBE166(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE166(
      src,
    );
  }

  late final _SDL_ReadBE166Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE166 =
      _SDL_ReadBE166Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE32
  int SDL_ReadLE326(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE326(
      src,
    );
  }

  late final _SDL_ReadLE326Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE326 =
      _SDL_ReadLE326Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 32 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 32 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE32
  int SDL_ReadBE326(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE326(
      src,
    );
  }

  late final _SDL_ReadBE326Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE326 =
      _SDL_ReadBE326Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of little-endian data from an SDL_RWops
  /// and return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadBE64
  int SDL_ReadLE646(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE646(
      src,
    );
  }

  late final _SDL_ReadLE646Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE646 =
      _SDL_ReadLE646Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to read 64 bits of big-endian data from an SDL_RWops and
  /// return in native format.
  ///
  /// SDL byteswaps the data only if necessary, so the data returned will be in
  /// the native byte order.
  ///
  /// \param src the stream from which to read data
  /// \returns 64 bits of data in the native byte order of the platform.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadLE64
  int SDL_ReadBE646(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE646(
      src,
    );
  }

  late final _SDL_ReadBE646Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE646 =
      _SDL_ReadBE646Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Use this function to write a byte to an SDL_RWops.
  ///
  /// \param dst the SDL_RWops to write to
  /// \param value the byte value to write
  /// \returns 1 on success or 0 on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ReadU8
  int SDL_WriteU86(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU86(
      dst,
      value,
    );
  }

  late final _SDL_WriteU86Ptr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU86 =
      _SDL_WriteU86Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE16
  int SDL_WriteLE166(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE166(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE166Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteLE16');
  late final _SDL_WriteLE166 = _SDL_WriteLE166Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 16 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE16
  int SDL_WriteBE166(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE166(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE166Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint16)>>('SDL_WriteBE16');
  late final _SDL_WriteBE166 = _SDL_WriteBE166Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE32
  int SDL_WriteLE326(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE326(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE326Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteLE32');
  late final _SDL_WriteLE326 = _SDL_WriteLE326Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 32 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE32
  int SDL_WriteBE326(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE326(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE326Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint32)>>('SDL_WriteBE32');
  late final _SDL_WriteBE326 = _SDL_WriteBE326Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// little-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in little-endian
  /// format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteBE64
  int SDL_WriteLE646(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE646(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE646Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteLE64');
  late final _SDL_WriteLE646 = _SDL_WriteLE646Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Use this function to write 64 bits in native format to a SDL_RWops as
  /// big-endian data.
  ///
  /// SDL byteswaps the data only if necessary, so the application always
  /// specifies native format, and the data written will be in big-endian format.
  ///
  /// \param dst the stream to which data will be written
  /// \param value the data to be written, in native format
  /// \returns 1 on successful write, 0 on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_WriteLE64
  int SDL_WriteBE646(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE646(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE646Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, Uint64)>>('SDL_WriteBE64');
  late final _SDL_WriteBE646 = _SDL_WriteBE646Ptr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Determine whether two rectangles intersect.
  ///
  /// If either pointer is NULL the function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_IntersectRect
  int SDL_HasIntersection4(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection4(
      A,
      B,
    );
  }

  late final _SDL_HasIntersection4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_HasIntersection');
  late final _SDL_HasIntersection4 = _SDL_HasIntersection4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of two rectangles.
  ///
  /// If `result` is NULL then this function will return SDL_FALSE.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the intersection of
  /// rectangles `A` and `B`
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasIntersection
  int SDL_IntersectRect4(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect4(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_IntersectRect');
  late final _SDL_IntersectRect4 = _SDL_IntersectRect4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the union of two rectangles.
  ///
  /// \param A an SDL_Rect structure representing the first rectangle
  /// \param B an SDL_Rect structure representing the second rectangle
  /// \param result an SDL_Rect structure filled in with the union of rectangles
  /// `A` and `B`
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_UnionRect4(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect4(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UnionRect');
  late final _SDL_UnionRect4 = _SDL_UnionRect4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate a minimal rectangle enclosing a set of points.
  ///
  /// If `clip` is not NULL then only points inside of the clipping rectangle are
  /// considered.
  ///
  /// \param points an array of SDL_Point structures representing points to be
  /// enclosed
  /// \param count the number of structures in the `points` array
  /// \param clip an SDL_Rect used for clipping or NULL to enclose all points
  /// \param result an SDL_Rect structure filled in with the minimal enclosing
  /// rectangle
  /// \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
  /// points were outside of the clipping rectangle.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_EnclosePoints4(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints4(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePoints4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Point>,
              ffi.Int,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_EnclosePoints');
  late final _SDL_EnclosePoints4 = _SDL_EnclosePoints4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Point>, int, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// Calculate the intersection of a rectangle and line segment.
  ///
  /// This function is used to clip a line segment to a rectangle. A line segment
  /// contained entirely within the rectangle or that does not intersect will
  /// remain unchanged. A line segment that crosses the rectangle at either or
  /// both ends will be clipped to the boundary of the rectangle and the new
  /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
  ///
  /// \param rect an SDL_Rect structure representing the rectangle to intersect
  /// \param X1 a pointer to the starting X-coordinate of the line
  /// \param Y1 a pointer to the starting Y-coordinate of the line
  /// \param X2 a pointer to the ending X-coordinate of the line
  /// \param Y2 a pointer to the ending Y-coordinate of the line
  /// \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_IntersectRectAndLine4(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int> X1,
    ffi.Pointer<ffi.Int> Y1,
    ffi.Pointer<ffi.Int> X2,
    ffi.Pointer<ffi.Int> Y2,
  ) {
    return _SDL_IntersectRectAndLine4(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLine4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_IntersectRectAndLine');
  late final _SDL_IntersectRectAndLine4 =
      _SDL_IntersectRectAndLine4Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Compose a custom blend mode for renderers.
  ///
  /// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
  /// the SDL_BlendMode returned by this function if the renderer supports it.
  ///
  /// A blend mode controls how the pixels from a drawing operation (source) get
  /// combined with the pixels from the render target (destination). First, the
  /// components of the source and destination pixels get multiplied with their
  /// blend factors. Then, the blend operation takes the two products and
  /// calculates the result that will get stored in the render target.
  ///
  /// Expressed in pseudocode, it would look like this:
  ///
  /// ```c
  /// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
  /// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
  /// ```
  ///
  /// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
  /// dst)` can return one of the following:
  ///
  /// - `src + dst`
  /// - `src - dst`
  /// - `dst - src`
  /// - `min(src, dst)`
  /// - `max(src, dst)`
  ///
  /// The red, green, and blue components are always multiplied with the first,
  /// second, and third components of the SDL_BlendFactor, respectively. The
  /// fourth component is not used.
  ///
  /// The alpha component is always multiplied with the fourth component of the
  /// SDL_BlendFactor. The other components are not used in the alpha
  /// calculation.
  ///
  /// Support for these blend modes varies for each renderer. To check if a
  /// specific SDL_BlendMode is supported, create a renderer and pass it to
  /// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
  /// return with an error if the blend mode is not supported.
  ///
  /// This list describes the support of custom blend modes for each renderer in
  /// SDL 2.0.6. All renderers support the four blend modes listed in the
  /// SDL_BlendMode enumeration.
  ///
  /// - **direct3d**: Supports `SDL_BLENDOPERATION_ADD` with all factors.
  /// - **direct3d11**: Supports all operations with all factors. However, some
  /// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
  /// `SDL_BLENDOPERATION_MAXIMUM`.
  /// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL
  /// 2.0.6.
  /// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
  /// factors. Color and alpha factors need to be the same. OpenGL ES 1
  /// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`
  /// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha
  /// operations being different from each other. May support color and alpha
  /// factors being different from each other.
  /// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
  /// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
  /// operations with all factors.
  /// - **psp**: No custom blend mode support.
  /// - **software**: No custom blend mode support.
  ///
  /// Some renderers do not provide an alpha component for the default render
  /// target. The `SDL_BLENDFACTOR_DST_ALPHA` and
  /// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
  /// case.
  ///
  /// \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the source pixels
  /// \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
  /// blue components of the destination pixels
  /// \param colorOperation the SDL_BlendOperation used to combine the red,
  /// green, and blue components of the source and
  /// destination pixels
  /// \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the source pixels
  /// \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
  /// the destination pixels
  /// \param alphaOperation the SDL_BlendOperation used to combine the alpha
  /// component of the source and destination pixels
  /// \returns an SDL_BlendMode that represents the chosen factors and
  /// operations.
  ///
  /// \since This function is available since SDL 2.0.6.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_GetTextureBlendMode
  int SDL_ComposeCustomBlendMode4(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode4(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_ComposeCustomBlendMode');
  late final _SDL_ComposeCustomBlendMode4 = _SDL_ComposeCustomBlendMode4Ptr
      .asFunction<int Function(int, int, int, int, int, int)>();

  /// Allocate a new RGB surface.
  ///
  /// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If `depth` is greater than 8 bits, the pixel format is set using the
  /// [RGBA]mask parameters.
  ///
  /// The [RGBA]mask parameters are the bitmasks used to extract that color from
  /// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
  /// stored in the most significant byte. Using zeros for the RGB masks sets a
  /// default value, based on the depth. For example:
  ///
  /// ```c++
  /// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
  /// ```
  ///
  /// However, using zero for the Amask results in an Amask of 0.
  ///
  /// By default surfaces with an alpha mask are set up for blending as with:
  ///
  /// ```c++
  /// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
  /// ```
  ///
  /// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
  /// different `blendMode`.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface4(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface4(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurface4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32, Uint32, Uint32, Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface4 = _SDL_CreateRGBSurface4Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with a specific pixel format.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except instead
  /// of providing pixel color masks, you provide it with a predefined format
  /// from SDL_PixelFormatEnum.
  ///
  /// \param flags the flags are unused and should be set to 0
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat4(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat4(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormat4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int, ffi.Int, ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat4 =
      _SDL_CreateRGBSurfaceWithFormat4Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  /// Allocate a new RGB surface with existing pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurface(), except it does
  /// not allocate memory for the pixel data, instead the caller provides an
  /// existing buffer of data for the surface to use.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param Rmask the red mask for the pixels
  /// \param Gmask the green mask for the pixels
  /// \param Bmask the blue mask for the pixels
  /// \param Amask the alpha mask for the pixels
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom4(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom4(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFrom4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom4 =
      _SDL_CreateRGBSurfaceFrom4Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// Allocate a new RGB surface with with a specific pixel format and existing
  /// pixel data.
  ///
  /// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
  /// instead of providing pixel color masks, you provide it with a predefined
  /// format from SDL_PixelFormatEnum.
  ///
  /// No copy is made of the pixel data. Pixel data is not managed automatically;
  /// you must free the surface before you free the pixel data.
  ///
  /// \param pixels a pointer to existing pixel data
  /// \param width the width of the surface
  /// \param height the height of the surface
  /// \param depth the depth of the surface in bits
  /// \param pitch the pitch of the surface in bytes
  /// \param format the SDL_PixelFormatEnum for the new surface's pixel format.
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_CreateRGBSurfaceWithFormat
  /// \sa SDL_FreeSurface
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom4(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom4(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFrom4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom4 =
      _SDL_CreateRGBSurfaceWithFormatFrom4Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// Free an RGB surface.
  ///
  /// It is safe to pass NULL to this function.
  ///
  /// \param surface the SDL_Surface to free.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRGBSurface
  /// \sa SDL_CreateRGBSurfaceFrom
  /// \sa SDL_LoadBMP
  /// \sa SDL_LoadBMP_RW
  void SDL_FreeSurface4(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface4(
      surface,
    );
  }

  late final _SDL_FreeSurface4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface4 = _SDL_FreeSurface4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the palette used by a surface.
  ///
  /// A single palette can be shared with many surfaces.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param palette the SDL_Palette structure to use
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SetSurfacePalette4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette4(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalette4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette4 = _SDL_SetSurfacePalette4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// Set up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
  /// and read from `surface->pixels`, using the pixel format stored in
  /// `surface->format`. Once you are done accessing the surface, you should use
  /// SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
  /// 0, then you can read and write to the surface at any time, and the pixel
  /// format of the surface will not change.
  ///
  /// \param surface the SDL_Surface structure to be locked
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MUSTLOCK
  /// \sa SDL_UnlockSurface
  int SDL_LockSurface4(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface4(
      surface,
    );
  }

  late final _SDL_LockSurface4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface4 =
      _SDL_LockSurface4Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Release a surface after directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to be unlocked
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockSurface
  void SDL_UnlockSurface4(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface4(
      surface,
    );
  }

  late final _SDL_UnlockSurface4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface4 = _SDL_UnlockSurface4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a BMP image from a seekable SDL data stream.
  ///
  /// The new surface should be freed with SDL_FreeSurface(). Not doing so will
  /// result in a memory leak.
  ///
  /// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
  /// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
  /// from a file, convert it to an SDL_Surface and then close the file.
  ///
  /// \param src the data stream for the surface
  /// \param freesrc non-zero to close the stream after being read
  /// \returns a pointer to a new SDL_Surface structure or NULL if there was an
  /// error; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FreeSurface
  /// \sa SDL_RWFromFile
  /// \sa SDL_LoadBMP
  /// \sa SDL_SaveBMP_RW
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW4(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW4(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RW4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW4 = _SDL_LoadBMP_RW4Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream in BMP format.
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// \param surface the SDL_Surface structure containing the image to be saved
  /// \param dst a data stream to save to
  /// \param freedst non-zero to close the stream after being written
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LoadBMP_RW
  /// \sa SDL_SaveBMP
  int SDL_SaveBMP_RW4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW4(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RW4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW4 = _SDL_SaveBMP_RW4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// Set the RLE acceleration hint for a surface.
  ///
  /// If RLE is enabled, color key and alpha blending blits are much faster, but
  /// the surface must be locked before directly accessing the pixels.
  ///
  /// \param surface the SDL_Surface structure to optimize
  /// \param flag 0 to disable, non-zero to enable RLE acceleration
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_LockSurface
  /// \sa SDL_UnlockSurface
  int SDL_SetSurfaceRLE4(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE4(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLE4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int)>>('SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE4 = _SDL_SetSurfaceRLE4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Returns whether the surface is RLE enabled
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.14.
  ///
  /// \sa SDL_SetSurfaceRLE
  int SDL_HasSurfaceRLE4(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE4(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLE4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE4 = _SDL_HasSurfaceRLE4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// Set the color key (transparent pixel) in a surface.
  ///
  /// The color key defines a pixel value that will be treated as transparent in
  /// a blit. For example, one can use this to specify that cyan pixels should be
  /// considered transparent, and therefore not rendered.
  ///
  /// It is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// RLE acceleration can substantially speed up blitting of images with large
  /// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
  /// \param key the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetColorKey
  int SDL_SetColorKey4(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey4(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKey4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey4 = _SDL_SetColorKey4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// Returns whether the surface has a color key
  ///
  /// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_SetColorKey
  /// \sa SDL_GetColorKey
  int SDL_HasColorKey4(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey4(
      surface,
    );
  }

  late final _SDL_HasColorKey4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasColorKey');
  late final _SDL_HasColorKey4 =
      _SDL_HasColorKey4Ptr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the color key (transparent pixel) for a surface.
  ///
  /// The color key is a pixel of the format used by the surface, as generated by
  /// SDL_MapRGB().
  ///
  /// If the surface doesn't have color key enabled this function returns -1.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param key a pointer filled in with the transparent pixel
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetColorKey
  int SDL_GetColorKey4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey4(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKey4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey4 = _SDL_GetColorKey4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// Set an additional color value multiplied into blit operations.
  ///
  /// When this surface is blitted, during the blit operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param r the red color value multiplied into blit operations
  /// \param g the green color value multiplied into blit operations
  /// \param b the blue color value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_SetSurfaceColorMod4(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod4(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorMod4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod4 = _SDL_SetSurfaceColorMod4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// Get the additional color value multiplied into blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_GetSurfaceColorMod4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod4(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorMod4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod4 = _SDL_GetSurfaceColorMod4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value used in blit operations.
  ///
  /// When this surface is blitted, during the blit operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param alpha the alpha value multiplied into blit operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceAlphaMod
  /// \sa SDL_SetSurfaceColorMod
  int SDL_SetSurfaceAlphaMod4(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod4(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaMod4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, Uint8)>>('SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod4 = _SDL_SetSurfaceAlphaMod4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the additional alpha value used in blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceColorMod
  /// \sa SDL_SetSurfaceAlphaMod
  int SDL_GetSurfaceAlphaMod4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod4(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaMod4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod4 = _SDL_GetSurfaceAlphaMod4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for blit operations.
  ///
  /// To copy a surface to another surface (or texture) without blending with the
  /// existing data, the blendmode of the SOURCE surface should be set to
  /// `SDL_BLENDMODE_NONE`.
  ///
  /// \param surface the SDL_Surface structure to update
  /// \param blendMode the SDL_BlendMode to use for blit blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetSurfaceBlendMode
  int SDL_SetSurfaceBlendMode4(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode4(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode4 = _SDL_SetSurfaceBlendMode4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// Get the blend mode used for blit operations.
  ///
  /// \param surface the SDL_Surface structure to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetSurfaceBlendMode
  int SDL_GetSurfaceBlendMode4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode4(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode4 =
      _SDL_GetSurfaceBlendMode4Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.Int32>)>();

  /// Set the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// Note that blits are automatically clipped to the edges of the source and
  /// destination surfaces.
  ///
  /// \param surface the SDL_Surface structure to be clipped
  /// \param rect the SDL_Rect structure representing the clipping rectangle, or
  /// NULL to disable clipping
  /// \returns SDL_TRUE if the rectangle intersects the surface, otherwise
  /// SDL_FALSE and blits will be completely clipped.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_GetClipRect
  int SDL_SetClipRect4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect4(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect4 = _SDL_SetClipRect4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clipping rectangle for a surface.
  ///
  /// When `surface` is the destination of a blit, only the area within the clip
  /// rectangle is drawn into.
  ///
  /// \param surface the SDL_Surface structure representing the surface to be
  /// clipped
  /// \param rect an SDL_Rect structure filled in with the clipping rectangle for
  /// the surface
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  /// \sa SDL_SetClipRect
  void SDL_GetClipRect4(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect4(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect4 = _SDL_GetClipRect4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface4(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface4(
      surface,
    );
  }

  late final _SDL_DuplicateSurface4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface4 = _SDL_DuplicateSurface4Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Copy an existing surface to a new surface of the specified format.
  ///
  /// This function is used to optimize images for faster *repeat* blitting. This
  /// is accomplished by converting the original and storing the result as a new
  /// surface. The new, optimized surface can then be used as the source for
  /// future blits, making them faster.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param fmt the SDL_PixelFormat structure that the new surface is optimized
  /// for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurfaceFormat
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface4(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurface4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface4 = _SDL_ConvertSurface4Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  /// Copy an existing surface to a new surface of the specified format enum.
  ///
  /// This function operates just like SDL_ConvertSurface(), but accepts an
  /// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
  /// it might be easier to call but it doesn't have access to palette
  /// information for the destination surface, in case that would be important.
  ///
  /// \param src the existing SDL_Surface structure to convert
  /// \param pixel_format the SDL_PixelFormatEnum that the new surface is
  /// optimized for
  /// \param flags the flags are unused and should be set to 0; this is a
  /// leftover from SDL 1.2's API
  /// \returns the new SDL_Surface structure that is created or NULL if it fails;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_AllocFormat
  /// \sa SDL_ConvertSurface
  /// \sa SDL_CreateRGBSurface
  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat4(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat4(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormat4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat4 =
      _SDL_ConvertSurfaceFormat4Ptr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// Copy a block of pixels of one format to another format.
  ///
  /// \param width the width of the block to copy, in pixels
  /// \param height the height of the block to copy, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with new pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_ConvertPixels4(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels4(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixels4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels4 = _SDL_ConvertPixels4Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Premultiply the alpha on a block of pixels.
  ///
  /// This is safe to use with src == dst, but not for other overlapping areas.
  ///
  /// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
  ///
  /// \param width the width of the block to convert, in pixels
  /// \param height the height of the block to convert, in pixels
  /// \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
  /// \param src a pointer to the source pixels
  /// \param src_pitch the pitch of the source pixels, in bytes
  /// \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
  /// \param dst a pointer to be filled in with premultiplied pixel data
  /// \param dst_pitch the pitch of the destination pixels, in bytes
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_PremultiplyAlpha4(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_PremultiplyAlpha4(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_PremultiplyAlpha4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('SDL_PremultiplyAlpha');
  late final _SDL_PremultiplyAlpha4 = _SDL_PremultiplyAlpha4Ptr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Perform a fast fill of a rectangle with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL to fill the entire surface
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRects
  int SDL_FillRect4(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect4(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect4 = _SDL_FillRect4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  /// Perform a fast fill of a set of rectangles with a specific color.
  ///
  /// `color` should be a pixel of the format used by the surface, and can be
  /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
  /// alpha component then the destination is simply filled with that alpha
  /// information, no blending takes place.
  ///
  /// If there is a clip rectangle set on the destination (set via
  /// SDL_SetClipRect()), then this function will fill based on the intersection
  /// of the clip rectangle and `rect`.
  ///
  /// \param dst the SDL_Surface structure that is the drawing target
  /// \param rects an array of SDL_Rects representing the rectangles to fill.
  /// \param count the number of rectangles in the array
  /// \param color the color to fill with
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_FillRect
  int SDL_FillRects4(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects4(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRects4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects4 = _SDL_FillRects4Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// Perform a fast blit from the source surface to the destination surface.
  ///
  /// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
  /// macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_UpperBlit4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit4(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlit4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit4 = _SDL_UpperBlit4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface blitting only.
  ///
  /// This is a semi-private blit function and it performs low-level surface
  /// blitting, assuming the input rectangles have already been clipped.
  ///
  /// Unless you know what you're doing, you should be using SDL_BlitSurface()
  /// instead.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied, or NULL to copy the entire surface
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitSurface
  int SDL_LowerBlit4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit4(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlit4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit4 = _SDL_LowerBlit4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a fast, low quality, stretch blit between two surfaces of the same
  /// format.
  ///
  /// Please use SDL_BlitScaled() instead.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_SoftStretch4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch4(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretch4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch4 = _SDL_SoftStretch4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform bilinear scaling between two surfaces of the same format, 32BPP.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_SoftStretchLinear4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretchLinear4(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchLinear4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretchLinear');
  late final _SDL_SoftStretchLinear4 = _SDL_SoftStretchLinear4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform a scaled surface copy to a destination surface.
  ///
  /// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
  /// merely a macro for this function with a less confusing name.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_UpperBlitScaled4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled4(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaled4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled4 = _SDL_UpperBlitScaled4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Perform low-level surface scaled blitting only.
  ///
  /// This is a semi-private function and it performs low-level surface blitting,
  /// assuming the input rectangles have already been clipped.
  ///
  /// \param src the SDL_Surface structure to be copied from
  /// \param srcrect the SDL_Rect structure representing the rectangle to be
  /// copied
  /// \param dst the SDL_Surface structure that is the blit target
  /// \param dstrect the SDL_Rect structure representing the rectangle that is
  /// copied into
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_BlitScaled
  int SDL_LowerBlitScaled4(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled4(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaled4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled4 = _SDL_LowerBlitScaled4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Set the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  void SDL_SetYUVConversionMode4(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode4(
      mode,
    );
  }

  late final _SDL_SetYUVConversionMode4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode4 =
      _SDL_SetYUVConversionMode4Ptr.asFunction<void Function(int)>();

  /// Get the YUV conversion mode
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionMode4() {
    return _SDL_GetYUVConversionMode4();
  }

  late final _SDL_GetYUVConversionMode4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode4 =
      _SDL_GetYUVConversionMode4Ptr.asFunction<int Function()>();

  /// Get the YUV conversion mode, returning the correct mode for the resolution
  /// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  ///
  /// \since This function is available since SDL 2.0.8.
  int SDL_GetYUVConversionModeForResolution4(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution4(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolution4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int, ffi.Int)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution4 =
      _SDL_GetYUVConversionModeForResolution4Ptr.asFunction<
          int Function(int, int)>();

  /// Get the number of video drivers compiled into SDL.
  ///
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetVideoDriver
  int SDL_GetNumVideoDrivers4() {
    return _SDL_GetNumVideoDrivers4();
  }

  late final _SDL_GetNumVideoDrivers4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers4 =
      _SDL_GetNumVideoDrivers4Ptr.asFunction<int Function()>();

  /// Get the name of a built in video driver.
  ///
  /// The video drivers are presented in the order in which they are normally
  /// checked during initialization.
  ///
  /// \param index the index of a video driver
  /// \returns the name of the video driver with the given **index**.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  ffi.Pointer<ffi.Char> SDL_GetVideoDriver4(
    int index,
  ) {
    return _SDL_GetVideoDriver4(
      index,
    );
  }

  late final _SDL_GetVideoDriver4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver4 =
      _SDL_GetVideoDriver4Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// This function initializes the video subsystem, setting up a connection to
  /// the window manager, etc, and determines the available display modes and
  /// pixel formats, but does not initialize a window or graphics mode.
  ///
  /// If you use this function and you haven't used the SDL_INIT_VIDEO flag with
  /// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
  /// before calling SDL_Quit().
  ///
  /// It is safe to call this function multiple times. SDL_VideoInit() will call
  /// SDL_VideoQuit() itself if the video subsystem has already been initialized.
  ///
  /// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
  /// specific `driver_name`.
  ///
  /// \param driver_name the name of a video driver to initialize, or NULL for
  /// the default driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  /// \sa SDL_InitSubSystem
  /// \sa SDL_VideoQuit
  int SDL_VideoInit4(
    ffi.Pointer<ffi.Char> driver_name,
  ) {
    return _SDL_VideoInit4(
      driver_name,
    );
  }

  late final _SDL_VideoInit4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit4 =
      _SDL_VideoInit4Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Shut down the video subsystem, if initialized with SDL_VideoInit().
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_VideoInit
  void SDL_VideoQuit4() {
    return _SDL_VideoQuit4();
  }

  late final _SDL_VideoQuit4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit4 = _SDL_VideoQuit4Ptr.asFunction<void Function()>();

  /// Get the name of the currently initialized video driver.
  ///
  /// \returns the name of the current video driver or NULL if no driver has been
  /// initialized.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDrivers
  /// \sa SDL_GetVideoDriver
  ffi.Pointer<ffi.Char> SDL_GetCurrentVideoDriver4() {
    return _SDL_GetCurrentVideoDriver4();
  }

  late final _SDL_GetCurrentVideoDriver4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver4 = _SDL_GetCurrentVideoDriver4Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the number of available video displays.
  ///
  /// \returns a number >= 1 or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  int SDL_GetNumVideoDisplays4() {
    return _SDL_GetNumVideoDisplays4();
  }

  late final _SDL_GetNumVideoDisplays4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays4 =
      _SDL_GetNumVideoDisplays4Ptr.asFunction<int Function()>();

  /// Get the name of a display in UTF-8 encoding.
  ///
  /// \param displayIndex the index of display from which the name should be
  /// queried
  /// \returns the name of a display or NULL for an invalid display index or
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  ffi.Pointer<ffi.Char> SDL_GetDisplayName4(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName4(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayName4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName4 =
      _SDL_GetDisplayName4Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// \param displayIndex the index of the display to query
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayBounds4(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds4(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBounds4Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds4 = _SDL_GetDisplayBounds4Ptr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the usable desktop area represented by a display.
  ///
  /// The primary display (`displayIndex` zero) is always located at 0,0.
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Apple's macOS, this
  /// subtracts the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// The parameter `rect` is ignored if it is NULL.
  ///
  /// This function also returns -1 if the parameter `displayIndex` is out of
  /// range.
  ///
  /// \param displayIndex the index of the display to query the usable bounds
  /// from
  /// \param rect the SDL_Rect structure filled in with the display bounds
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayUsableBounds4(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds4(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBounds4Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<SDL_Rect>)>>(
      'SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds4 = _SDL_GetDisplayUsableBounds4Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// Get the dots/pixels-per-inch for a display.
  ///
  /// Diagonal, horizontal and vertical DPI can all be optionally returned if the
  /// appropriate parameter is non-NULL.
  ///
  /// A failure of this function usually means that either no DPI information is
  /// available or the `displayIndex` is out of range.
  ///
  /// \param displayIndex the index of the display from which DPI information
  /// should be queried
  /// \param ddpi a pointer filled in with the diagonal DPI of the display; may
  /// be NULL
  /// \param hdpi a pointer filled in with the horizontal DPI of the display; may
  /// be NULL
  /// \param vdpi a pointer filled in with the vertical DPI of the display; may
  /// be NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayDPI4(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI4(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPI4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI4 = _SDL_GetDisplayDPI4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get the orientation of a display.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns The SDL_DisplayOrientation enum value of the display, or
  /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
  ///
  /// \since This function is available since SDL 2.0.9.
  ///
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetDisplayOrientation4(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation4(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientation4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation4 =
      _SDL_GetDisplayOrientation4Ptr.asFunction<int Function(int)>();

  /// Get the number of available display modes.
  ///
  /// The `displayIndex` needs to be in the range from 0 to
  /// SDL_GetNumVideoDisplays() - 1.
  ///
  /// \param displayIndex the index of the display to query
  /// \returns a number >= 1 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetNumDisplayModes4(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes4(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModes4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes4 =
      _SDL_GetNumDisplayModes4Ptr.asFunction<int Function(int)>();

  /// Get information about a specific display mode.
  ///
  /// The display modes are sorted in this priority:
  ///
  /// - width -> largest to smallest
  /// - height -> largest to smallest
  /// - bits per pixel -> more colors to fewer colors
  /// - packed pixel layout -> largest to smallest
  /// - refresh rate -> highest to lowest
  ///
  /// \param displayIndex the index of the display to query
  /// \param modeIndex the index of the display mode to query
  /// \param mode an SDL_DisplayMode structure filled in with the mode at
  /// `modeIndex`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetNumDisplayModes
  int SDL_GetDisplayMode4(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode4(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode4 = _SDL_GetDisplayMode4Ptr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the desktop's display mode.
  ///
  /// There's a difference between this function and SDL_GetCurrentDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the previous native display mode, and not the current
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetCurrentDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetDesktopDisplayMode4(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode4(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode4 = _SDL_GetDesktopDisplayMode4Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get information about the current display mode.
  ///
  /// There's a difference between this function and SDL_GetDesktopDisplayMode()
  /// when SDL runs fullscreen and has changed the resolution. In that case this
  /// function will return the current display mode, and not the previous native
  /// display mode.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure filled in with the current display
  /// mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDesktopDisplayMode
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumVideoDisplays
  /// \sa SDL_SetWindowDisplayMode
  int SDL_GetCurrentDisplayMode4(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode4(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode4 = _SDL_GetCurrentDisplayMode4Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the closest match to the requested display mode.
  ///
  /// The available display modes are scanned and `closest` is filled in with the
  /// closest mode matching the requested mode and returned. The mode format and
  /// refresh rate default to the desktop mode if they are set to 0. The modes
  /// are scanned with size being first priority, format being second priority,
  /// and finally checking the refresh rate. If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \param displayIndex the index of the display to query
  /// \param mode an SDL_DisplayMode structure containing the desired display
  /// mode
  /// \param closest an SDL_DisplayMode structure filled in with the closest
  /// match of the available display modes
  /// \returns the passed in value `closest` or NULL if no matching video mode
  /// was available; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayMode
  /// \sa SDL_GetNumDisplayModes
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode4(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode4(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode4 =
      _SDL_GetClosestDisplayMode4Ptr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the index of the display associated with a window.
  ///
  /// \param window the window to query
  /// \returns the index of the display containing the center of the window on
  /// success or a negative error code on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetDisplayBounds
  /// \sa SDL_GetNumVideoDisplays
  int SDL_GetWindowDisplayIndex4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex4(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndex4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex4 = _SDL_GetWindowDisplayIndex4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the display mode to use when a window is visible at fullscreen.
  ///
  /// This only affects the display mode used when the window is fullscreen. To
  /// change the window size when the window is not fullscreen, use
  /// SDL_SetWindowSize().
  ///
  /// \param window the window to affect
  /// \param mode the SDL_DisplayMode structure representing the mode to use, or
  /// NULL to use the window's dimensions and the desktop's format
  /// and refresh rate
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_SetWindowDisplayMode4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode4(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode4 =
      _SDL_SetWindowDisplayMode4Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Query the display mode to use when a window is visible at fullscreen.
  ///
  /// \param window the window to query
  /// \param mode an SDL_DisplayMode structure filled in with the fullscreen
  /// display mode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowDisplayMode
  /// \sa SDL_SetWindowFullscreen
  int SDL_GetWindowDisplayMode4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode4(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayMode4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode4 =
      _SDL_GetWindowDisplayMode4Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// Get the raw ICC profile data for the screen the window is currently on.
  ///
  /// Data returned should be freed with SDL_free.
  ///
  /// \param window the window to query
  /// \param size the size of the ICC profile
  /// \returns the raw ICC profile data on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ffi.Pointer<ffi.Void> SDL_GetWindowICCProfile4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _SDL_GetWindowICCProfile4(
      window,
      size,
    );
  }

  late final _SDL_GetWindowICCProfile4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Size>)>>('SDL_GetWindowICCProfile');
  late final _SDL_GetWindowICCProfile4 =
      _SDL_GetWindowICCProfile4Ptr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Size>)>();

  /// Get the pixel format associated with the window.
  ///
  /// \param window the window to query
  /// \returns the pixel format of the window on success or
  /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GetWindowPixelFormat4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat4(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormat4Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat4 = _SDL_GetWindowPixelFormat4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Create a window with the specified position, dimensions, and flags.
  ///
  /// `flags` may be any of the following OR'd together:
  ///
  /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window
  /// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
  /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
  /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
  /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
  /// - `SDL_WINDOW_HIDDEN`: window is not visible
  /// - `SDL_WINDOW_BORDERLESS`: no window decoration
  /// - `SDL_WINDOW_RESIZABLE`: window can be resized
  /// - `SDL_WINDOW_MINIMIZED`: window is minimized
  /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
  /// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
  /// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
  /// supported (>= SDL 2.0.1)
  ///
  /// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
  /// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
  /// queried later using SDL_GetWindowFlags().
  ///
  /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
  /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
  ///
  /// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
  /// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to query the drawable size in pixels.
  ///
  /// If the window is set fullscreen, the width and height parameters `w` and
  /// `h` will not be used. However, invalid size parameters (e.g. too large) may
  /// still fail. Window size is actually limited to 16384 x 16384 for all
  /// platforms at window creation.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// On non-Apple devices, SDL requires you to either not link to the Vulkan
  /// loader or link to a dynamic library version. This limitation may be removed
  /// in a future version of SDL.
  ///
  /// \param title the title of the window, in UTF-8 encoding
  /// \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
  /// `SDL_WINDOWPOS_UNDEFINED`
  /// \param w the width of the window, in screen coordinates
  /// \param h the height of the window, in screen coordinates
  /// \param flags 0, or one or more SDL_WindowFlags OR'd together
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindowFrom
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindow4(
    ffi.Pointer<ffi.Char> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow4(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindow4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow4 = _SDL_CreateWindow4Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, int)>();

  /// Create an SDL window from an existing native window.
  ///
  /// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
  /// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
  /// before using SDL_CreateWindowFrom().
  ///
  /// \param data a pointer to driver-dependent window creation data, typically
  /// your native window cast to a void*
  /// \returns the window that was created or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_DestroyWindow
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom4(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom4(
      data,
    );
  }

  late final _SDL_CreateWindowFrom4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom4 = _SDL_CreateWindowFrom4Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// Get the numeric ID of a window.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param window the window to query
  /// \returns the ID of the window on success or 0 on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFromID
  int SDL_GetWindowID4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID4(
      window,
    );
  }

  late final _SDL_GetWindowID4Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID4 =
      _SDL_GetWindowID4Ptr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window from a stored ID.
  ///
  /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
  /// these events to specific SDL_Window objects.
  ///
  /// \param id the ID of the window
  /// \returns the window associated with `id` or NULL if it doesn't exist; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowID
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID4(
    int id,
  ) {
    return _SDL_GetWindowFromID4(
      id,
    );
  }

  late final _SDL_GetWindowFromID4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID4 = _SDL_GetWindowFromID4Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// Get the window flags.
  ///
  /// \param window the window to query
  /// \returns a mask of the SDL_WindowFlags associated with `window`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_HideWindow
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_SetWindowFullscreen
  /// \sa SDL_SetWindowGrab
  /// \sa SDL_ShowWindow
  int SDL_GetWindowFlags4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags4(
      window,
    );
  }

  late final _SDL_GetWindowFlags4Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags4 = _SDL_GetWindowFlags4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the title of a window.
  ///
  /// This string is expected to be in UTF-8 encoding.
  ///
  /// \param window the window to change
  /// \param title the desired window title in UTF-8 format
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowTitle
  void SDL_SetWindowTitle4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _SDL_SetWindowTitle4(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitle4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle4 = _SDL_SetWindowTitle4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Get the title of a window.
  ///
  /// \param window the window to query
  /// \returns the title of the window in UTF-8 format or "" if there is no
  /// title.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowTitle
  ffi.Pointer<ffi.Char> SDL_GetWindowTitle4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle4(
      window,
    );
  }

  late final _SDL_GetWindowTitle4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle4 = _SDL_GetWindowTitle4Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the icon for a window.
  ///
  /// \param window the window to change
  /// \param icon an SDL_Surface structure containing the icon for the window
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_SetWindowIcon4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon4(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIcon4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon4 = _SDL_SetWindowIcon4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// Associate an arbitrary named pointer with a window.
  ///
  /// `name` is case-sensitive.
  ///
  /// \param window the window to associate with the pointer
  /// \param name the name of the pointer
  /// \param userdata the associated pointer
  /// \returns the previous value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowData
  ffi.Pointer<ffi.Void> SDL_SetWindowData4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData4(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowData4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData4 = _SDL_SetWindowData4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Retrieve the data pointer associated with a window.
  ///
  /// \param window the window to query
  /// \param name the name of the pointer
  /// \returns the value associated with `name`.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowData
  ffi.Pointer<ffi.Void> SDL_GetWindowData4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetWindowData4(
      window,
      name,
    );
  }

  late final _SDL_GetWindowData4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Char>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData4 = _SDL_GetWindowData4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Char>)>();

  /// Set the position of a window.
  ///
  /// The window coordinate origin is the upper left of the display.
  ///
  /// \param window the window to reposition
  /// \param x the x coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  /// \param y the y coordinate of the window in screen coordinates, or
  /// `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowPosition
  void SDL_SetWindowPosition4(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition4(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPosition4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition4 = _SDL_SetWindowPosition4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the position of a window.
  ///
  /// If you do not need the value for one of the positions a NULL may be passed
  /// in the `x` or `y` parameter.
  ///
  /// \param window the window to query
  /// \param x a pointer filled in with the x position of the window, in screen
  /// coordinates, may be NULL
  /// \param y a pointer filled in with the y position of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowPosition
  void SDL_GetWindowPosition4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> x,
    ffi.Pointer<ffi.Int> y,
  ) {
    return _SDL_GetWindowPosition4(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPosition4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition4 = _SDL_GetWindowPosition4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the size of a window's client area.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// Fullscreen windows automatically match the size of the display mode, and
  /// you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// \param window the window to change
  /// \param w the width of the window in pixels, in screen coordinates, must be
  /// > 0
  /// \param h the height of the window in pixels, in screen coordinates, must be
  /// > 0
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSize
  /// \sa SDL_SetWindowDisplayMode
  void SDL_SetWindowSize4(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize4(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int, ffi.Int)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize4 = _SDL_SetWindowSize4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the size of a window's client area.
  ///
  /// NULL can safely be passed as the `w` or `h` parameter if the width or
  /// height value is not desired.
  ///
  /// The window size in screen coordinates may differ from the size in pixels,
  /// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
  /// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
  /// real client area size in pixels.
  ///
  /// \param window the window to query the width and height from
  /// \param w a pointer filled in with the width of the window, in screen
  /// coordinates, may be NULL
  /// \param h a pointer filled in with the height of the window, in screen
  /// coordinates, may be NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetDrawableSize
  /// \sa SDL_Vulkan_GetDrawableSize
  /// \sa SDL_SetWindowSize
  void SDL_GetWindowSize4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowSize4(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize4 = _SDL_GetWindowSize4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Get the size of a window's borders (decorations) around the client area.
  ///
  /// Note: If this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
  /// window in question was borderless.
  ///
  /// Note: This function may fail on systems where the window has not yet been
  /// decorated by the display server (for example, immediately after calling
  /// SDL_CreateWindow). It is recommended that you wait at least until the
  /// window has been presented and composited, so that the window system has a
  /// chance to decorate the window and provide the border dimensions to SDL.
  ///
  /// This function also returns -1 if getting the information is not supported.
  ///
  /// \param window the window to query the size values of the border
  /// (decorations) from
  /// \param top pointer to variable for storing the size of the top border; NULL
  /// is permitted
  /// \param left pointer to variable for storing the size of the left border;
  /// NULL is permitted
  /// \param bottom pointer to variable for storing the size of the bottom
  /// border; NULL is permitted
  /// \param right pointer to variable for storing the size of the right border;
  /// NULL is permitted
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowSize
  int SDL_GetWindowBordersSize4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> bottom,
    ffi.Pointer<ffi.Int> right,
  ) {
    return _SDL_GetWindowBordersSize4(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize4 =
      _SDL_GetWindowBordersSize4Ptr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the minimum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param min_w the minimum width of the window in pixels
  /// \param min_h the minimum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_SetWindowMinimumSize4(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize4(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize4 = _SDL_SetWindowMinimumSize4Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the minimum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the minimum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the minimum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_GetWindowMinimumSize4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMinimumSize4(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize4 =
      _SDL_GetWindowMinimumSize4Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the maximum size of a window's client area.
  ///
  /// \param window the window to change
  /// \param max_w the maximum width of the window in pixels
  /// \param max_h the maximum height of the window in pixels
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMaximumSize
  /// \sa SDL_SetWindowMinimumSize
  void SDL_SetWindowMaximumSize4(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize4(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int,
              ffi.Int)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize4 = _SDL_SetWindowMaximumSize4Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Get the maximum size of a window's client area.
  ///
  /// \param window the window to query
  /// \param w a pointer filled in with the maximum width of the window, may be
  /// NULL
  /// \param h a pointer filled in with the maximum height of the window, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowMinimumSize
  /// \sa SDL_SetWindowMaximumSize
  void SDL_GetWindowMaximumSize4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetWindowMaximumSize4(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize4 =
      _SDL_GetWindowMaximumSize4Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set the border state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
  /// or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// You can't change the border state of a fullscreen window.
  ///
  /// \param window the window of which to change the border state
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowBordered4(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered4(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBordered4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered4 = _SDL_SetWindowBordered4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
  /// allow/disallow user resizing of the window. This is a no-op if the window's
  /// resizable state already matches the requested state.
  ///
  /// You can't change the resizable state of a fullscreen window.
  ///
  /// \param window the window of which to change the resizable state
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowResizable4(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable4(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizable4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable4 = _SDL_SetWindowResizable4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set the window to always be above the others.
  ///
  /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
  /// will bring the window to the front and keep the window above the rest.
  ///
  /// \param window The window of which to change the always on top state
  /// \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
  /// disable
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowFlags
  void SDL_SetWindowAlwaysOnTop4(
    ffi.Pointer<SDL_Window> window,
    int on_top,
  ) {
    return _SDL_SetWindowAlwaysOnTop4(
      window,
      on_top,
    );
  }

  late final _SDL_SetWindowAlwaysOnTop4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowAlwaysOnTop');
  late final _SDL_SetWindowAlwaysOnTop4 = _SDL_SetWindowAlwaysOnTop4Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Show a window.
  ///
  /// \param window the window to show
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HideWindow
  /// \sa SDL_RaiseWindow
  void SDL_ShowWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow4(
      window,
    );
  }

  late final _SDL_ShowWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow4 =
      _SDL_ShowWindow4Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Hide a window.
  ///
  /// \param window the window to hide
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_ShowWindow
  void SDL_HideWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow4(
      window,
    );
  }

  late final _SDL_HideWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow4 =
      _SDL_HideWindow4Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Raise a window above other windows and set the input focus.
  ///
  /// \param window the window to raise
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_RaiseWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow4(
      window,
    );
  }

  late final _SDL_RaiseWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow4 =
      _SDL_RaiseWindow4Ptr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// Make a window as large as possible.
  ///
  /// \param window the window to maximize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MinimizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MaximizeWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow4(
      window,
    );
  }

  late final _SDL_MaximizeWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow4 = _SDL_MaximizeWindow4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Minimize a window to an iconic representation.
  ///
  /// \param window the window to minimize
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_RestoreWindow
  void SDL_MinimizeWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow4(
      window,
    );
  }

  late final _SDL_MinimizeWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow4 = _SDL_MinimizeWindow4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Restore the size and position of a minimized or maximized window.
  ///
  /// \param window the window to restore
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_MaximizeWindow
  /// \sa SDL_MinimizeWindow
  void SDL_RestoreWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow4(
      window,
    );
  }

  late final _SDL_RestoreWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow4 = _SDL_RestoreWindow4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Set a window's fullscreen state.
  ///
  /// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
  /// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
  /// that takes the size of the desktop; and 0 for windowed mode.
  ///
  /// \param window the window to change
  /// \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowDisplayMode
  /// \sa SDL_SetWindowDisplayMode
  int SDL_SetWindowFullscreen4(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen4(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreen4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, Uint32)>>('SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen4 = _SDL_SetWindowFullscreen4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get the SDL surface associated with the window.
  ///
  /// A new surface will be created with the optimal format for the window, if
  /// necessary. This surface will be freed when the window is destroyed. Do not
  /// free this surface.
  ///
  /// This surface will be invalidated if the window is resized. After resizing a
  /// window this function must be called again to return a valid surface.
  ///
  /// You may not combine this with 3D or the rendering API on this window.
  ///
  /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
  ///
  /// \param window the window to query
  /// \returns the surface associated with the window, or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UpdateWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface4(
      window,
    );
  }

  late final _SDL_GetWindowSurface4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface4 = _SDL_GetWindowSurface4Ptr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// Copy the window surface to the screen.
  ///
  /// This is the function you use to reflect any changes to the surface on the
  /// screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_Flip().
  ///
  /// \param window the window to update
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurfaceRects
  int SDL_UpdateWindowSurface4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface4(
      window,
    );
  }

  late final _SDL_UpdateWindowSurface4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface4 = _SDL_UpdateWindowSurface4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Copy areas of the window surface to the screen.
  ///
  /// This is the function you use to reflect changes to portions of the surface
  /// on the screen.
  ///
  /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
  ///
  /// \param window the window to update
  /// \param rects an array of SDL_Rect structures representing areas of the
  /// surface to copy
  /// \param numrects the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowSurface
  /// \sa SDL_UpdateWindowSurface
  int SDL_UpdateWindowSurfaceRects4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects4(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRects4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects4 =
      _SDL_UpdateWindowSurfaceRects4Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// Set a window's input grab mode.
  ///
  /// When input is grabbed, the mouse is confined to the window. This function
  /// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
  /// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window the window for which the input grab mode should be set
  /// \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetGrabbedWindow
  /// \sa SDL_GetWindowGrab
  void SDL_SetWindowGrab4(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab4(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrab4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab4 = _SDL_SetWindowGrab4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's keyboard grab mode.
  ///
  /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
  /// the Meta/Super key. Note that not all system keyboard shortcuts can be
  /// captured by applications (one example is Ctrl+Alt+Del on Windows).
  ///
  /// This is primarily intended for specialized applications such as VNC clients
  /// or VM frontends. Normal games should not use keyboard grab.
  ///
  /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
  /// window is full-screen to ensure the user is not trapped in your
  /// application. If you have a custom keyboard shortcut to exit fullscreen
  /// mode, you may suppress this behavior with
  /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
  ///
  /// If the caller enables a grab while another window is currently grabbed, the
  /// other window loses its grab in favor of the caller's window.
  ///
  /// \param window The window for which the keyboard grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowKeyboardGrab
  /// \sa SDL_SetWindowMouseGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowKeyboardGrab4(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowKeyboardGrab4(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowKeyboardGrab4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Int32)>>('SDL_SetWindowKeyboardGrab');
  late final _SDL_SetWindowKeyboardGrab4 = _SDL_SetWindowKeyboardGrab4Ptr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Set a window's mouse grab mode.
  ///
  /// Mouse grab confines the mouse cursor to the window.
  ///
  /// \param window The window for which the mouse grab mode should be set.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_GetWindowMouseGrab
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_SetWindowGrab
  void SDL_SetWindowMouseGrab4(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowMouseGrab4(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowMouseGrab4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowMouseGrab');
  late final _SDL_SetWindowMouseGrab4 = _SDL_SetWindowMouseGrab4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// Get a window's input grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGrab
  int SDL_GetWindowGrab4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab4(
      window,
    );
  }

  late final _SDL_GetWindowGrab4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab4 = _SDL_GetWindowGrab4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's keyboard grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowKeyboardGrab4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowKeyboardGrab4(
      window,
    );
  }

  late final _SDL_GetWindowKeyboardGrab4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowKeyboardGrab');
  late final _SDL_GetWindowKeyboardGrab4 = _SDL_GetWindowKeyboardGrab4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get a window's mouse grab mode.
  ///
  /// \param window the window to query
  /// \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.16.
  ///
  /// \sa SDL_SetWindowKeyboardGrab
  /// \sa SDL_GetWindowGrab
  int SDL_GetWindowMouseGrab4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseGrab4(
      window,
    );
  }

  late final _SDL_GetWindowMouseGrab4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowMouseGrab');
  late final _SDL_GetWindowMouseGrab4 = _SDL_GetWindowMouseGrab4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the window that currently has an input grab enabled.
  ///
  /// \returns the window if input is grabbed or NULL otherwise.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_GetWindowGrab
  /// \sa SDL_SetWindowGrab
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow4() {
    return _SDL_GetGrabbedWindow4();
  }

  late final _SDL_GetGrabbedWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow4 = _SDL_GetGrabbedWindow4Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Confines the cursor to the specified area of a window.
  ///
  /// Note that this does NOT grab the cursor, it only defines the area a cursor
  /// is restricted to when the window has mouse focus.
  ///
  /// \param window The window that will be associated with the barrier.
  /// \param rect A rectangle area in window-relative coordinates. If NULL the
  /// barrier for the specified window will be destroyed.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetWindowMouseRect
  /// \sa SDL_SetWindowMouseGrab
  int SDL_SetWindowMouseRect4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetWindowMouseRect4(
      window,
      rect,
    );
  }

  late final _SDL_SetWindowMouseRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetWindowMouseRect');
  late final _SDL_SetWindowMouseRect4 = _SDL_SetWindowMouseRect4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>)>();

  /// Get the mouse confinement rectangle of a window.
  ///
  /// \param window The window to query
  /// \returns A pointer to the mouse confinement rectangle of a window, or NULL
  /// if there isn't one.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetWindowMouseRect
  ffi.Pointer<SDL_Rect> SDL_GetWindowMouseRect4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowMouseRect4(
      window,
    );
  }

  late final _SDL_GetWindowMouseRect4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Rect> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowMouseRect');
  late final _SDL_GetWindowMouseRect4 = _SDL_GetWindowMouseRect4Ptr.asFunction<
      ffi.Pointer<SDL_Rect> Function(ffi.Pointer<SDL_Window>)>();

  /// Set the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method sets the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The
  /// brightness set will not follow the window if it is moved to another
  /// display.
  ///
  /// Many platforms will refuse to set the display brightness in modern times.
  /// You are better off using a shader to adjust gamma during rendering, or
  /// something similar.
  ///
  /// \param window the window used to select the display whose brightness will
  /// be changed
  /// \param brightness the brightness (gamma multiplier) value to set where 0.0
  /// is completely dark and 1.0 is normal brightness
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowBrightness
  /// \sa SDL_SetWindowGammaRamp
  int SDL_SetWindowBrightness4(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness4(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightness4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness4 = _SDL_SetWindowBrightness4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the brightness (gamma multiplier) for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the brightness of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose brightness will
  /// be queried
  /// \returns the brightness for the display where 0.0 is completely dark and
  /// 1.0 is normal brightness.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowBrightness
  double SDL_GetWindowBrightness4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness4(
      window,
    );
  }

  late final _SDL_GetWindowBrightness4Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness4 = _SDL_GetWindowBrightness4Ptr
      .asFunction<double Function(ffi.Pointer<SDL_Window>)>();

  /// Set the opacity for a window.
  ///
  /// The parameter `opacity` will be clamped internally between 0.0f
  /// (transparent) and 1.0f (opaque).
  ///
  /// This function also returns -1 if setting the opacity isn't supported.
  ///
  /// \param window the window which will be made transparent or opaque
  /// \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_GetWindowOpacity
  int SDL_SetWindowOpacity4(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity4(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacity4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity4 = _SDL_SetWindowOpacity4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// The parameter `opacity` is ignored if it is NULL.
  ///
  /// This function also returns -1 if an invalid window was provided.
  ///
  /// \param window the window to get the current opacity value from
  /// \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_SetWindowOpacity
  int SDL_GetWindowOpacity4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity4(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacity4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity4 = _SDL_GetWindowOpacity4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// Set the window as a modal for another window.
  ///
  /// \param modal_window the window that should be set modal
  /// \param parent_window the parent window for the modal window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  int SDL_SetWindowModalFor4(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor4(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalFor4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor4 = _SDL_SetWindowModalFor4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// Explicitly set input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that is completely
  /// obscured by other windows.
  ///
  /// \param window the window that should get the input focus
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RaiseWindow
  int SDL_SetWindowInputFocus4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus4(
      window,
    );
  }

  late final _SDL_SetWindowInputFocus4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus4 = _SDL_SetWindowInputFocus4Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Set the gamma ramp for the display that owns a given window.
  ///
  /// Set the gamma translation table for the red, green, and blue channels of
  /// the video hardware. Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel. The
  /// input is the index into the array, and the output is the 16-bit gamma value
  /// at that index, scaled to the output color precision.
  ///
  /// Despite the name and signature, this method sets the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
  /// ramp set will not follow the window if it is moved to another display.
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be changed
  /// \param red a 256 element array of 16-bit quantities representing the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities representing the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities representing the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetWindowGammaRamp
  int SDL_SetWindowGammaRamp4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp4(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRamp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp4 = _SDL_SetWindowGammaRamp4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Get the gamma ramp for a given window's display.
  ///
  /// Despite the name and signature, this method retrieves the gamma ramp of the
  /// entire display, not an individual window. A window is considered to be
  /// owned by the display that contains the window's center pixel. (The index of
  /// this display can be retrieved using SDL_GetWindowDisplayIndex().)
  ///
  /// \param window the window used to select the display whose gamma ramp will
  /// be queried
  /// \param red a 256 element array of 16-bit quantities filled in with the
  /// translation table for the red channel, or NULL
  /// \param green a 256 element array of 16-bit quantities filled in with the
  /// translation table for the green channel, or NULL
  /// \param blue a 256 element array of 16-bit quantities filled in with the
  /// translation table for the blue channel, or NULL
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetWindowGammaRamp
  int SDL_GetWindowGammaRamp4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp4(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRamp4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp4 = _SDL_GetWindowGammaRamp4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable from
  /// any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of a
  /// given window as special. This callback is run during event processing if we
  /// need to tell the OS to treat a region of the window specially; the use of
  /// this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within a
  /// special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire when
  /// the OS is deciding whether to drag your window, but it fires for lots of
  /// other reasons, too, some unrelated to anything you probably care about _and
  /// when the mouse isn't actually at the location it is testing_). Since this
  /// can fire at any time, you should try to keep your callback efficient,
  /// devoid of allocations, etc.
  ///
  /// \param window the window to set hit-testing on
  /// \param callback the function to call when doing a hit-test
  /// \param callback_data an app-defined void pointer passed to **callback**
  /// \returns 0 on success or -1 on error (including unsupported); call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  int SDL_SetWindowHitTest4(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest4(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTest4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest4 = _SDL_SetWindowHitTest4Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// Request a window to demand attention from the user.
  ///
  /// \param window the window to be flashed
  /// \param operation the flash operation
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_FlashWindow4(
    ffi.Pointer<SDL_Window> window,
    int operation,
  ) {
    return _SDL_FlashWindow4(
      window,
      operation,
    );
  }

  late final _SDL_FlashWindow4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_FlashWindow');
  late final _SDL_FlashWindow4 = _SDL_FlashWindow4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// Destroy a window.
  ///
  /// If `window` is NULL, this function will return immediately after setting
  /// the SDL error message to "Invalid window". See SDL_GetError().
  ///
  /// \param window the window to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_CreateWindowFrom
  void SDL_DestroyWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow4(
      window,
    );
  }

  late final _SDL_DestroyWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow4 = _SDL_DestroyWindow4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Check whether the screensaver is currently enabled.
  ///
  /// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
  /// the screensaver was enabled by default.
  ///
  /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
  ///
  /// \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
  /// disabled.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_EnableScreenSaver
  int SDL_IsScreenSaverEnabled4() {
    return _SDL_IsScreenSaverEnabled4();
  }

  late final _SDL_IsScreenSaverEnabled4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled4 =
      _SDL_IsScreenSaverEnabled4Ptr.asFunction<int Function()>();

  /// Allow the screen to be blanked by a screen saver.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_DisableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_EnableScreenSaver4() {
    return _SDL_EnableScreenSaver4();
  }

  late final _SDL_EnableScreenSaver4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver4 =
      _SDL_EnableScreenSaver4Ptr.asFunction<void Function()>();

  /// Prevent the screen from being blanked by a screen saver.
  ///
  /// If you disable the screensaver, it is automatically re-enabled when SDL
  /// quits.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_EnableScreenSaver
  /// \sa SDL_IsScreenSaverEnabled
  void SDL_DisableScreenSaver4() {
    return _SDL_DisableScreenSaver4();
  }

  late final _SDL_DisableScreenSaver4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver4 =
      _SDL_DisableScreenSaver4Ptr.asFunction<void Function()>();

  /// Dynamically load an OpenGL library.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows. If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// If you do this, you need to retrieve all of the GL functions used in your
  /// program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \param path the platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetProcAddress
  /// \sa SDL_GL_UnloadLibrary
  int SDL_GL_LoadLibrary4(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _SDL_GL_LoadLibrary4(
      path,
    );
  }

  late final _SDL_GL_LoadLibrary4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary4 =
      _SDL_GL_LoadLibrary4Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get an OpenGL function by name.
  ///
  /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
  /// GL functions must be retrieved this way. Usually this is used to retrieve
  /// function pointers to OpenGL extensions.
  ///
  /// There are some quirks to looking up OpenGL functions that require some
  /// extra care from the application. If you code carefully, you can handle
  /// these quirks without any platform-specific code, though:
  ///
  /// - On Windows, function pointers are specific to the current GL context;
  /// this means you need to have created a GL context and made it current
  /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
  /// create a second context, you should assume that any existing function
  /// pointers aren't valid to use with it. This is (currently) a
  /// Windows-specific limitation, and in practice lots of drivers don't suffer
  /// this limitation, but it is still the way the wgl API is documented to
  /// work and you should expect crashes if you don't respect it. Store a copy
  /// of the function pointers that comes and goes with context lifespan.
  /// - On X11, function pointers returned by this function are valid for any
  /// context, and can even be looked up before a context is created at all.
  /// This means that, for at least some common OpenGL implementations, if you
  /// look up a function that doesn't exist, you'll get a non-NULL result that
  /// is _NOT_ safe to call. You must always make sure the function is actually
  /// available for a given GL context before calling it, by checking for the
  /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
  /// or verifying that the version of OpenGL you're using offers the function
  /// as core functionality.
  /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
  /// isn't supported, but you can't count on this behavior. Check for
  /// extensions you use, and if you get a NULL anyway, act as if that
  /// extension wasn't available. This is probably a bug in the driver, but you
  /// can code defensively for this scenario anyhow.
  /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
  /// Next-gen display servers are waiting to replace it, and may or may not
  /// make the same promises about function pointers.
  /// - OpenGL function pointers must be declared `APIENTRY` as in the example
  /// code. This will ensure the proper calling convention is followed on
  /// platforms where this matters (Win32) thereby avoiding stack corruption.
  ///
  /// \param proc the name of an OpenGL function
  /// \returns a pointer to the named OpenGL function. The returned pointer
  /// should be cast to the appropriate function signature.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ExtensionSupported
  /// \sa SDL_GL_LoadLibrary
  /// \sa SDL_GL_UnloadLibrary
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress4(
    ffi.Pointer<ffi.Char> proc,
  ) {
    return _SDL_GL_GetProcAddress4(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddress4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress4 = _SDL_GL_GetProcAddress4Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_LoadLibrary
  void SDL_GL_UnloadLibrary4() {
    return _SDL_GL_UnloadLibrary4();
  }

  late final _SDL_GL_UnloadLibrary4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary4 =
      _SDL_GL_UnloadLibrary4Ptr.asFunction<void Function()>();

  /// Check if an OpenGL extension is supported for the current context.
  ///
  /// This function operates on the current GL context; you must have created a
  /// context and it must be current before calling this function. Do not assume
  /// that all contexts you create will have the same set of extensions
  /// available, or that recreating an existing context will offer the same
  /// extensions again.
  ///
  /// While it's probably not a massive overhead, this function is not an O(1)
  /// operation. Check the extensions you care about after creating the GL
  /// context and save that information somewhere instead of calling the function
  /// every time you need to know.
  ///
  /// \param extension the name of the extension to check
  /// \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_GL_ExtensionSupported4(
    ffi.Pointer<ffi.Char> extension1,
  ) {
    return _SDL_GL_ExtensionSupported4(
      extension1,
    );
  }

  late final _SDL_GL_ExtensionSupported4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported4 = _SDL_GL_ExtensionSupported4Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Reset all previously set OpenGL context attributes to their default values.
  ///
  /// \since This function is available since SDL 2.0.2.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_SetAttribute
  void SDL_GL_ResetAttributes4() {
    return _SDL_GL_ResetAttributes4();
  }

  late final _SDL_GL_ResetAttributes4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes4 =
      _SDL_GL_ResetAttributes4Ptr.asFunction<void Function()>();

  /// Set an OpenGL window attribute before window creation.
  ///
  /// This function sets the OpenGL attribute `attr` to `value`. The requested
  /// attributes should be set before creating an OpenGL window. You should use
  /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
  /// context, since the values obtained can differ from the requested ones.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
  /// \param value the desired value for the attribute
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetAttribute
  /// \sa SDL_GL_ResetAttributes
  int SDL_GL_SetAttribute4(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute4(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttribute4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32, ffi.Int)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute4 =
      _SDL_GL_SetAttribute4Ptr.asFunction<int Function(int, int)>();

  /// Get the actual value for an attribute from the current context.
  ///
  /// \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
  /// \param value a pointer filled in with the current value of `attr`
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_ResetAttributes
  /// \sa SDL_GL_SetAttribute
  int SDL_GL_GetAttribute4(
    int attr,
    ffi.Pointer<ffi.Int> value,
  ) {
    return _SDL_GL_GetAttribute4(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttribute4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, ffi.Pointer<ffi.Int>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute4 = _SDL_GL_GetAttribute4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Create an OpenGL context for an OpenGL window, and make it current.
  ///
  /// Windows users new to OpenGL should note that, for historical reasons, GL
  /// functions added after OpenGL version 1.1 are not available by default.
  /// Those functions must be loaded at run-time, either with an OpenGL
  /// extension-handling library or with SDL_GL_GetProcAddress() and its related
  /// functions.
  ///
  /// SDL_GLContext is an alias for `void *`. It's opaque to the application.
  ///
  /// \param window the window to associate with the context
  /// \returns the OpenGL context associated with `window` or NULL on error; call
  /// SDL_GetError() for more details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_DeleteContext
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_CreateContext4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext4(
      window,
    );
  }

  late final _SDL_GL_CreateContext4Ptr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext4 = _SDL_GL_CreateContext4Ptr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// The context must have been created with a compatible window.
  ///
  /// \param window the window to associate with the context
  /// \param context the OpenGL context to associate with the window
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  int SDL_GL_MakeCurrent4(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent4(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrent4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent4 = _SDL_GL_MakeCurrent4Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// Get the currently active OpenGL window.
  ///
  /// \returns the currently active OpenGL window on success or NULL on failure;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow4() {
    return _SDL_GL_GetCurrentWindow4();
  }

  late final _SDL_GL_GetCurrentWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow4 = _SDL_GL_GetCurrentWindow4Ptr
      .asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// Get the currently active OpenGL context.
  ///
  /// \returns the currently active OpenGL context or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  SDL_GLContext SDL_GL_GetCurrentContext4() {
    return _SDL_GL_GetCurrentContext4();
  }

  late final _SDL_GL_GetCurrentContext4Ptr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext4 =
      _SDL_GL_GetCurrentContext4Ptr.asFunction<SDL_GLContext Function()>();

  /// Get the size of a window's underlying drawable in pixels.
  ///
  /// This returns info useful for calling glViewport().
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not
  /// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
  ///
  /// \param window the window from which the drawable size should be queried
  /// \param w a pointer to variable for storing the width in pixels, may be NULL
  /// \param h a pointer to variable for storing the height in pixels, may be
  /// NULL
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_CreateWindow
  /// \sa SDL_GetWindowSize
  void SDL_GL_GetDrawableSize4(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GL_GetDrawableSize4(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSize4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize4 = _SDL_GL_GetDrawableSize4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Set the swap interval for the current OpenGL context.
  ///
  /// Some systems allow specifying -1 for the interval, to enable adaptive
  /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
  /// the vertical retrace for a given frame, it swaps buffers immediately, which
  /// might be less jarring for the user during occasional framerate drops. If an
  /// application requests adaptive vsync and the system does not support it,
  /// this function will fail and return -1. In such a case, you should probably
  /// retry the call with 1 for the interval.
  ///
  /// Adaptive vsync is implemented for some glX drivers with
  /// GLX_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/glx_swap_control_tear.txt
  ///
  /// and for some Windows drivers with WGL_EXT_swap_control_tear:
  ///
  /// https://www.opengl.org/registry/specs/EXT/wgl_swap_control_tear.txt
  ///
  /// Read more on the Khronos wiki:
  /// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with
  /// the vertical retrace, -1 for adaptive vsync
  /// \returns 0 on success or -1 if setting the swap interval is not supported;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_GetSwapInterval
  int SDL_GL_SetSwapInterval4(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval4(
      interval,
    );
  }

  late final _SDL_GL_SetSwapInterval4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval4 =
      _SDL_GL_SetSwapInterval4Ptr.asFunction<int Function(int)>();

  /// Get the swap interval for the current OpenGL context.
  ///
  /// If the system can't determine the swap interval, or there isn't a valid
  /// current context, this function will return 0 as a safe default.
  ///
  /// \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace;
  /// call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_SetSwapInterval
  int SDL_GL_GetSwapInterval4() {
    return _SDL_GL_GetSwapInterval4();
  }

  late final _SDL_GL_GetSwapInterval4Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval4 =
      _SDL_GL_GetSwapInterval4Ptr.asFunction<int Function()>();

  /// Update a window with OpenGL rendering.
  ///
  /// This is used with double-buffered OpenGL contexts, which are the default.
  ///
  /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
  /// window, otherwise nothing will happen. If you aren't using
  /// glBindFramebuffer(), this is the default and you won't have to do anything
  /// extra.
  ///
  /// \param window the window to change
  ///
  /// \since This function is available since SDL 2.0.0.
  void SDL_GL_SwapWindow4(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow4(
      window,
    );
  }

  late final _SDL_GL_SwapWindow4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow4 = _SDL_GL_SwapWindow4Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// Delete an OpenGL context.
  ///
  /// \param context the OpenGL context to be deleted
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_CreateContext
  void SDL_GL_DeleteContext4(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext4(
      context,
    );
  }

  late final _SDL_GL_DeleteContext4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext4 =
      _SDL_GL_DeleteContext4Ptr.asFunction<void Function(SDL_GLContext)>();

  /// Query the window which currently has keyboard focus.
  ///
  /// \returns the window with keyboard focus.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<SDL_Window> SDL_GetKeyboardFocus3() {
    return _SDL_GetKeyboardFocus3();
  }

  late final _SDL_GetKeyboardFocus3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetKeyboardFocus');
  late final _SDL_GetKeyboardFocus3 = _SDL_GetKeyboardFocus3Ptr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// Get a snapshot of the current state of the keyboard.
  ///
  /// The pointer returned is a pointer to an internal SDL array. It will be
  /// valid for the whole lifetime of the application and should not be freed by
  /// the caller.
  ///
  /// A array element with a value of 1 means that the key is pressed and a value
  /// of 0 means that it is not. Indexes into this array are obtained by using
  /// SDL_Scancode values.
  ///
  /// Use SDL_PumpEvents() to update the state array.
  ///
  /// This function gives you the current state after all events have been
  /// processed, so if a key or button has been pressed and released before you
  /// process events, then the pressed state will never show up in the
  /// SDL_GetKeyboardState() calls.
  ///
  /// Note: This function doesn't take into account whether shift has been
  /// pressed or not.
  ///
  /// \param numkeys if non-NULL, receives the length of the returned array
  /// \returns a pointer to an array of key states.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_PumpEvents
  ffi.Pointer<Uint8> SDL_GetKeyboardState3(
    ffi.Pointer<ffi.Int> numkeys,
  ) {
    return _SDL_GetKeyboardState3(
      numkeys,
    );
  }

  late final _SDL_GetKeyboardState3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Uint8> Function(
              ffi.Pointer<ffi.Int>)>>('SDL_GetKeyboardState');
  late final _SDL_GetKeyboardState3 = _SDL_GetKeyboardState3Ptr.asFunction<
      ffi.Pointer<Uint8> Function(ffi.Pointer<ffi.Int>)>();

  /// Get the current key modifier state for the keyboard.
  ///
  /// \returns an OR'd combination of the modifier keys for the keyboard. See
  /// SDL_Keymod for details.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyboardState
  /// \sa SDL_SetModState
  int SDL_GetModState3() {
    return _SDL_GetModState3();
  }

  late final _SDL_GetModState3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetModState');
  late final _SDL_GetModState3 =
      _SDL_GetModState3Ptr.asFunction<int Function()>();

  /// Set the current key modifier state for the keyboard.
  ///
  /// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
  /// modifier key states on your application. Simply pass your desired modifier
  /// states into `modstate`. This value may be a bitwise, OR'd combination of
  /// SDL_Keymod values.
  ///
  /// This does not change the keyboard state, only the key modifier flags that
  /// SDL reports.
  ///
  /// \param modstate the desired SDL_Keymod for the keyboard
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetModState
  void SDL_SetModState3(
    int modstate,
  ) {
    return _SDL_SetModState3(
      modstate,
    );
  }

  late final _SDL_SetModState3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetModState');
  late final _SDL_SetModState3 =
      _SDL_SetModState3Ptr.asFunction<void Function(int)>();

  /// Get the key code corresponding to the given scancode according to the
  /// current keyboard layout.
  ///
  /// See SDL_Keycode for details.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns the SDL_Keycode that corresponds to the given SDL_Scancode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromKey
  int SDL_GetKeyFromScancode3(
    int scancode,
  ) {
    return _SDL_GetKeyFromScancode3(
      scancode,
    );
  }

  late final _SDL_GetKeyFromScancode3Ptr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Int32)>>(
          'SDL_GetKeyFromScancode');
  late final _SDL_GetKeyFromScancode3 =
      _SDL_GetKeyFromScancode3Ptr.asFunction<int Function(int)>();

  /// Get the scancode corresponding to the given key code according to the
  /// current keyboard layout.
  ///
  /// See SDL_Scancode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns the SDL_Scancode that corresponds to the given SDL_Keycode.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromKey3(
    int key,
  ) {
    return _SDL_GetScancodeFromKey3(
      key,
    );
  }

  late final _SDL_GetScancodeFromKey3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_Keycode)>>(
          'SDL_GetScancodeFromKey');
  late final _SDL_GetScancodeFromKey3 =
      _SDL_GetScancodeFromKey3Ptr.asFunction<int Function(int)>();

  /// Get a human-readable name for a scancode.
  ///
  /// See SDL_Scancode for details.
  ///
  /// **Warning**: The returned name is by design not stable across platforms,
  /// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
  /// Windows" under Microsoft Windows, and some scancodes like
  /// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
  /// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
  /// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
  /// unsuitable for creating a stable cross-platform two-way mapping between
  /// strings and scancodes.
  ///
  /// \param scancode the desired SDL_Scancode to query
  /// \returns a pointer to the name for the scancode. If the scancode doesn't
  /// have a name this function returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeFromName
  ffi.Pointer<ffi.Char> SDL_GetScancodeName3(
    int scancode,
  ) {
    return _SDL_GetScancodeName3(
      scancode,
    );
  }

  late final _SDL_GetScancodeName3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'SDL_GetScancodeName');
  late final _SDL_GetScancodeName3 = _SDL_GetScancodeName3Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a scancode from a human-readable name.
  ///
  /// \param name the human-readable scancode name
  /// \returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
  /// recognized; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetScancodeFromKey
  /// \sa SDL_GetScancodeName
  int SDL_GetScancodeFromName3(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetScancodeFromName3(
      name,
    );
  }

  late final _SDL_GetScancodeFromName3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetScancodeFromName');
  late final _SDL_GetScancodeFromName3 = _SDL_GetScancodeFromName3Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a human-readable name for a key.
  ///
  /// See SDL_Scancode and SDL_Keycode for details.
  ///
  /// \param key the desired SDL_Keycode to query
  /// \returns a pointer to a UTF-8 string that stays valid at least until the
  /// next call to this function. If you need it around any longer, you
  /// must copy it. If the key doesn't have a name, this function
  /// returns an empty string ("").
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromName
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetScancodeFromKey
  ffi.Pointer<ffi.Char> SDL_GetKeyName3(
    int key,
  ) {
    return _SDL_GetKeyName3(
      key,
    );
  }

  late final _SDL_GetKeyName3Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SDL_Keycode)>>(
          'SDL_GetKeyName');
  late final _SDL_GetKeyName3 =
      _SDL_GetKeyName3Ptr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get a key code from a human-readable name.
  ///
  /// \param name the human-readable key name
  /// \returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetKeyFromScancode
  /// \sa SDL_GetKeyName
  /// \sa SDL_GetScancodeFromName
  int SDL_GetKeyFromName3(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_GetKeyFromName3(
      name,
    );
  }

  late final _SDL_GetKeyFromName3Ptr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_GetKeyFromName');
  late final _SDL_GetKeyFromName3 =
      _SDL_GetKeyFromName3Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Start accepting Unicode text input events.
  ///
  /// This function will start accepting Unicode text input events in the focused
  /// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and
  /// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in
  /// pair with SDL_StopTextInput().
  ///
  /// On some platforms using this function activates the screen keyboard.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextInputRect
  /// \sa SDL_StopTextInput
  void SDL_StartTextInput3() {
    return _SDL_StartTextInput3();
  }

  late final _SDL_StartTextInput3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StartTextInput');
  late final _SDL_StartTextInput3 =
      _SDL_StartTextInput3Ptr.asFunction<void Function()>();

  /// Check whether or not Unicode text input events are enabled.
  ///
  /// \returns SDL_TRUE if text input events are enabled else SDL_FALSE.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  int SDL_IsTextInputActive3() {
    return _SDL_IsTextInputActive3();
  }

  late final _SDL_IsTextInputActive3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsTextInputActive');
  late final _SDL_IsTextInputActive3 =
      _SDL_IsTextInputActive3Ptr.asFunction<int Function()>();

  /// Stop receiving any text input events.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_StopTextInput3() {
    return _SDL_StopTextInput3();
  }

  late final _SDL_StopTextInput3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StopTextInput');
  late final _SDL_StopTextInput3 =
      _SDL_StopTextInput3Ptr.asFunction<void Function()>();

  /// Set the rectangle used to type Unicode text inputs.
  ///
  /// \param rect the SDL_Rect structure representing the rectangle to receive
  /// text (ignored if NULL)
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  void SDL_SetTextInputRect3(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetTextInputRect3(
      rect,
    );
  }

  late final _SDL_SetTextInputRect3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Rect>)>>(
          'SDL_SetTextInputRect');
  late final _SDL_SetTextInputRect3 = _SDL_SetTextInputRect3Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>)>();

  /// Check whether the platform has screen keyboard support.
  ///
  /// \returns SDL_TRUE if the platform has some screen keyboard support or
  /// SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_StartTextInput
  /// \sa SDL_IsScreenKeyboardShown
  int SDL_HasScreenKeyboardSupport3() {
    return _SDL_HasScreenKeyboardSupport3();
  }

  late final _SDL_HasScreenKeyboardSupport3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_HasScreenKeyboardSupport');
  late final _SDL_HasScreenKeyboardSupport3 =
      _SDL_HasScreenKeyboardSupport3Ptr.asFunction<int Function()>();

  /// Check whether the screen keyboard is shown for given window.
  ///
  /// \param window the window for which screen keyboard should be queried
  /// \returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_HasScreenKeyboardSupport
  int SDL_IsScreenKeyboardShown3(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsScreenKeyboardShown3(
      window,
    );
  }

  late final _SDL_IsScreenKeyboardShown3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsScreenKeyboardShown');
  late final _SDL_IsScreenKeyboardShown3 = _SDL_IsScreenKeyboardShown3Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// Get the number of 2D rendering drivers available for the current display.
  ///
  /// A render driver is a set of code that handles rendering and texture
  /// management on a particular display. Normally there is only one, but some
  /// drivers may have several available with different capabilities.
  ///
  /// There may be none if SDL was compiled without render support.
  ///
  /// \returns a number >= 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_GetRenderDriverInfo
  int SDL_GetNumRenderDrivers1() {
    return _SDL_GetNumRenderDrivers1();
  }

  late final _SDL_GetNumRenderDrivers1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'SDL_GetNumRenderDrivers');
  late final _SDL_GetNumRenderDrivers1 =
      _SDL_GetNumRenderDrivers1Ptr.asFunction<int Function()>();

  /// Get info about a specific 2D rendering driver for the current display.
  ///
  /// \param index the index of the driver to query information about
  /// \param info an SDL_RendererInfo structure to be filled with information on
  /// the rendering driver
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_GetNumRenderDrivers
  int SDL_GetRenderDriverInfo1(
    int index,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRenderDriverInfo1(
      index,
      info,
    );
  }

  late final _SDL_GetRenderDriverInfo1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRenderDriverInfo');
  late final _SDL_GetRenderDriverInfo1 = _SDL_GetRenderDriverInfo1Ptr
      .asFunction<int Function(int, ffi.Pointer<SDL_RendererInfo>)>();

  /// Create a window and default renderer.
  ///
  /// \param width the width of the window
  /// \param height the height of the window
  /// \param window_flags the flags used to create the window (see
  /// SDL_CreateWindow())
  /// \param window a pointer filled with the window, or NULL on error
  /// \param renderer a pointer filled with the renderer, or NULL on error
  /// \returns 0 on success, or -1 on error; call SDL_GetError() for more
  /// information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_CreateWindow
  int SDL_CreateWindowAndRenderer1(
    int width,
    int height,
    int window_flags,
    ffi.Pointer<ffi.Pointer<SDL_Window>> window,
    ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
  ) {
    return _SDL_CreateWindowAndRenderer1(
      width,
      height,
      window_flags,
      window,
      renderer,
    );
  }

  late final _SDL_CreateWindowAndRenderer1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Int,
                  ffi.Int,
                  Uint32,
                  ffi.Pointer<ffi.Pointer<SDL_Window>>,
                  ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>>(
      'SDL_CreateWindowAndRenderer');
  late final _SDL_CreateWindowAndRenderer1 =
      _SDL_CreateWindowAndRenderer1Ptr.asFunction<
          int Function(int, int, int, ffi.Pointer<ffi.Pointer<SDL_Window>>,
              ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>();

  /// Create a 2D rendering context for a window.
  ///
  /// \param window the window where rendering is displayed
  /// \param index the index of the rendering driver to initialize, or -1 to
  /// initialize the first one supporting the requested flags
  /// \param flags 0, or one or more SDL_RendererFlags OR'd together
  /// \returns a valid rendering context or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateSoftwareRenderer
  /// \sa SDL_DestroyRenderer
  /// \sa SDL_GetNumRenderDrivers
  /// \sa SDL_GetRendererInfo
  ffi.Pointer<SDL_Renderer> SDL_CreateRenderer1(
    ffi.Pointer<SDL_Window> window,
    int index,
    int flags,
  ) {
    return _SDL_CreateRenderer1(
      window,
      index,
      flags,
    );
  }

  late final _SDL_CreateRenderer1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>, ffi.Int, Uint32)>>('SDL_CreateRenderer');
  late final _SDL_CreateRenderer1 = _SDL_CreateRenderer1Ptr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// Create a 2D software rendering context for a surface.
  ///
  /// Two other API which can be used to create SDL_Renderer:
  /// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
  /// create a software renderer, but they are intended to be used with an
  /// SDL_Window as the final destination and not an SDL_Surface.
  ///
  /// \param surface the SDL_Surface structure representing the surface where
  /// rendering is done
  /// \returns a valid rendering context or NULL if there was an error; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  /// \sa SDL_CreateWindowRenderer
  /// \sa SDL_DestroyRenderer
  ffi.Pointer<SDL_Renderer> SDL_CreateSoftwareRenderer1(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateSoftwareRenderer1(
      surface,
    );
  }

  late final _SDL_CreateSoftwareRenderer1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateSoftwareRenderer');
  late final _SDL_CreateSoftwareRenderer1 =
      _SDL_CreateSoftwareRenderer1Ptr.asFunction<
          ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Surface>)>();

  /// Get the renderer associated with a window.
  ///
  /// \param window the window to query
  /// \returns the rendering context on success or NULL on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  ffi.Pointer<SDL_Renderer> SDL_GetRenderer1(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetRenderer1(
      window,
    );
  }

  late final _SDL_GetRenderer1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetRenderer');
  late final _SDL_GetRenderer1 = _SDL_GetRenderer1Ptr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>)>();

  /// Get information about a rendering context.
  ///
  /// \param renderer the rendering context
  /// \param info an SDL_RendererInfo structure filled with information about the
  /// current renderer
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  int SDL_GetRendererInfo1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRendererInfo1(
      renderer,
      info,
    );
  }

  late final _SDL_GetRendererInfo1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRendererInfo');
  late final _SDL_GetRendererInfo1 = _SDL_GetRendererInfo1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_RendererInfo>)>();

  /// Get the output size in pixels of a rendering context.
  ///
  /// Due to high-dpi displays, you might end up with a rendering context that
  /// has more pixels than the window that contains it, so use this instead of
  /// SDL_GetWindowSize() to decide how much drawing area you have.
  ///
  /// \param renderer the rendering context
  /// \param w an int filled with the width
  /// \param h an int filled with the height
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderer
  int SDL_GetRendererOutputSize1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_GetRendererOutputSize1(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_GetRendererOutputSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_GetRendererOutputSize');
  late final _SDL_GetRendererOutputSize1 =
      _SDL_GetRendererOutputSize1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Create a texture for a rendering context.
  ///
  /// You can set the texture scaling method by setting
  /// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.
  ///
  /// \param renderer the rendering context
  /// \param format one of the enumerated values in SDL_PixelFormatEnum
  /// \param access one of the enumerated values in SDL_TextureAccess
  /// \param w the width of the texture in pixels
  /// \param h the height of the texture in pixels
  /// \returns a pointer to the created texture or NULL if no rendering context
  /// was active, the format was unsupported, or the width or height
  /// were out of range; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTextureFromSurface
  /// \sa SDL_DestroyTexture
  /// \sa SDL_QueryTexture
  /// \sa SDL_UpdateTexture
  ffi.Pointer<SDL_Texture> SDL_CreateTexture1(
    ffi.Pointer<SDL_Renderer> renderer,
    int format,
    int access,
    int w,
    int h,
  ) {
    return _SDL_CreateTexture1(
      renderer,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_CreateTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>, Uint32,
              ffi.Int, ffi.Int, ffi.Int)>>('SDL_CreateTexture');
  late final _SDL_CreateTexture1 = _SDL_CreateTexture1Ptr.asFunction<
      ffi.Pointer<SDL_Texture> Function(
          ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Create a texture from an existing surface.
  ///
  /// The surface is not modified or freed by this function.
  ///
  /// The SDL_TextureAccess hint for the created texture is
  /// `SDL_TEXTUREACCESS_STATIC`.
  ///
  /// The pixel format of the created texture may be different from the pixel
  /// format of the surface. Use SDL_QueryTexture() to query the pixel format of
  /// the texture.
  ///
  /// \param renderer the rendering context
  /// \param surface the SDL_Surface structure containing pixel data used to fill
  /// the texture
  /// \returns the created texture or NULL on failure; call SDL_GetError() for
  /// more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_DestroyTexture
  /// \sa SDL_QueryTexture
  ffi.Pointer<SDL_Texture> SDL_CreateTextureFromSurface1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateTextureFromSurface1(
      renderer,
      surface,
    );
  }

  late final _SDL_CreateTextureFromSurface1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateTextureFromSurface');
  late final _SDL_CreateTextureFromSurface1 =
      _SDL_CreateTextureFromSurface1Ptr.asFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Surface>)>();

  /// Query the attributes of a texture.
  ///
  /// \param texture the texture to query
  /// \param format a pointer filled in with the raw format of the texture; the
  /// actual format may differ, but pixel transfers will use this
  /// format (one of the SDL_PixelFormatEnum values)
  /// \param access a pointer filled in with the actual access to the texture
  /// (one of the SDL_TextureAccess values)
  /// \param w a pointer filled in with the width of the texture in pixels
  /// \param h a pointer filled in with the height of the texture in pixels
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  int SDL_QueryTexture1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint32> format,
    ffi.Pointer<ffi.Int> access,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_QueryTexture1(
      texture,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_QueryTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_QueryTexture');
  late final _SDL_QueryTexture1 = _SDL_QueryTexture1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint32>,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Set an additional color value multiplied into render copy operations.
  ///
  /// When this texture is rendered, during the copy operation each source color
  /// channel is modulated by the appropriate color value according to the
  /// following formula:
  ///
  /// `srcC = srcC * (color / 255)`
  ///
  /// Color modulation is not always supported by the renderer; it will return -1
  /// if color modulation is not supported.
  ///
  /// \param texture the texture to update
  /// \param r the red color value multiplied into copy operations
  /// \param g the green color value multiplied into copy operations
  /// \param b the blue color value multiplied into copy operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureColorMod
  /// \sa SDL_SetTextureAlphaMod
  int SDL_SetTextureColorMod1(
    ffi.Pointer<SDL_Texture> texture,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetTextureColorMod1(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetTextureColorMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, Uint8, Uint8,
              Uint8)>>('SDL_SetTextureColorMod');
  late final _SDL_SetTextureColorMod1 = _SDL_SetTextureColorMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int, int, int)>();

  /// Get the additional color value multiplied into render copy operations.
  ///
  /// \param texture the texture to query
  /// \param r a pointer filled in with the current red color value
  /// \param g a pointer filled in with the current green color value
  /// \param b a pointer filled in with the current blue color value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureAlphaMod
  /// \sa SDL_SetTextureColorMod
  int SDL_GetTextureColorMod1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetTextureColorMod1(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetTextureColorMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureColorMod');
  late final _SDL_GetTextureColorMod1 = _SDL_GetTextureColorMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set an additional alpha value multiplied into render copy operations.
  ///
  /// When this texture is rendered, during the copy operation the source alpha
  /// value is modulated by this alpha value according to the following formula:
  ///
  /// `srcA = srcA * (alpha / 255)`
  ///
  /// Alpha modulation is not always supported by the renderer; it will return -1
  /// if alpha modulation is not supported.
  ///
  /// \param texture the texture to update
  /// \param alpha the source alpha value multiplied into copy operations
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureAlphaMod
  /// \sa SDL_SetTextureColorMod
  int SDL_SetTextureAlphaMod1(
    ffi.Pointer<SDL_Texture> texture,
    int alpha,
  ) {
    return _SDL_SetTextureAlphaMod1(
      texture,
      alpha,
    );
  }

  late final _SDL_SetTextureAlphaMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>, Uint8)>>('SDL_SetTextureAlphaMod');
  late final _SDL_SetTextureAlphaMod1 = _SDL_SetTextureAlphaMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the additional alpha value multiplied into render copy operations.
  ///
  /// \param texture the texture to query
  /// \param alpha a pointer filled in with the current alpha value
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureColorMod
  /// \sa SDL_SetTextureAlphaMod
  int SDL_GetTextureAlphaMod1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetTextureAlphaMod1(
      texture,
      alpha,
    );
  }

  late final _SDL_GetTextureAlphaMod1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureAlphaMod');
  late final _SDL_GetTextureAlphaMod1 = _SDL_GetTextureAlphaMod1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode for a texture, used by SDL_RenderCopy().
  ///
  /// If the blend mode is not supported, the closest supported mode is chosen
  /// and this function returns -1.
  ///
  /// \param texture the texture to update
  /// \param blendMode the SDL_BlendMode to use for texture blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetTextureBlendMode
  /// \sa SDL_RenderCopy
  int SDL_SetTextureBlendMode1(
    ffi.Pointer<SDL_Texture> texture,
    int blendMode,
  ) {
    return _SDL_SetTextureBlendMode1(
      texture,
      blendMode,
    );
  }

  late final _SDL_SetTextureBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>, ffi.Int32)>>('SDL_SetTextureBlendMode');
  late final _SDL_SetTextureBlendMode1 = _SDL_SetTextureBlendMode1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the blend mode used for texture copy operations.
  ///
  /// \param texture the texture to query
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetTextureBlendMode
  int SDL_GetTextureBlendMode1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetTextureBlendMode1(
      texture,
      blendMode,
    );
  }

  late final _SDL_GetTextureBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetTextureBlendMode');
  late final _SDL_GetTextureBlendMode1 =
      _SDL_GetTextureBlendMode1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Int32>)>();

  /// Set the scale mode used for texture scale operations.
  ///
  /// If the scale mode is not supported, the closest supported mode is chosen.
  ///
  /// \param texture The texture to update.
  /// \param scaleMode the SDL_ScaleMode to use for texture scaling.
  /// \returns 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_GetTextureScaleMode
  int SDL_SetTextureScaleMode1(
    ffi.Pointer<SDL_Texture> texture,
    int scaleMode,
  ) {
    return _SDL_SetTextureScaleMode1(
      texture,
      scaleMode,
    );
  }

  late final _SDL_SetTextureScaleMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>, ffi.Int32)>>('SDL_SetTextureScaleMode');
  late final _SDL_SetTextureScaleMode1 = _SDL_SetTextureScaleMode1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// Get the scale mode used for texture scale operations.
  ///
  /// \param texture the texture to query.
  /// \param scaleMode a pointer filled in with the current scale mode.
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_SetTextureScaleMode
  int SDL_GetTextureScaleMode1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> scaleMode,
  ) {
    return _SDL_GetTextureScaleMode1(
      texture,
      scaleMode,
    );
  }

  late final _SDL_GetTextureScaleMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetTextureScaleMode');
  late final _SDL_GetTextureScaleMode1 =
      _SDL_GetTextureScaleMode1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Int32>)>();

  /// Associate a user-specified pointer with a texture.
  ///
  /// \param texture the texture to update.
  /// \param userdata the pointer to associate with the texture.
  /// \returns 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_GetTextureUserData
  int SDL_SetTextureUserData1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetTextureUserData1(
      texture,
      userdata,
    );
  }

  late final _SDL_SetTextureUserData1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetTextureUserData');
  late final _SDL_SetTextureUserData1 = _SDL_SetTextureUserData1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Void>)>();

  /// Get the user-specified pointer associated with a texture
  ///
  /// \param texture the texture to query.
  /// \return the pointer associated with the texture, or NULL if the texture is
  /// not valid.
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_SetTextureUserData
  ffi.Pointer<ffi.Void> SDL_GetTextureUserData1(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GetTextureUserData1(
      texture,
    );
  }

  late final _SDL_GetTextureUserData1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Texture>)>>('SDL_GetTextureUserData');
  late final _SDL_GetTextureUserData1 = _SDL_GetTextureUserData1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Texture>)>();

  /// Update the given texture rectangle with new pixel data.
  ///
  /// The pixel data must be in the pixel format of the texture. Use
  /// SDL_QueryTexture() to query the pixel format of the texture.
  ///
  /// This is a fairly slow function, intended for use with static textures that
  /// do not change often.
  ///
  /// If the texture is intended to be updated often, it is preferred to create
  /// the texture as streaming and use the locking functions referenced below.
  /// While this function will work with streaming textures, for optimization
  /// reasons you may not get the pixels back if you lock the texture afterward.
  ///
  /// \param texture the texture to update
  /// \param rect an SDL_Rect structure representing the area to update, or NULL
  /// to update the entire texture
  /// \param pixels the raw pixel data in the format of the texture
  /// \param pitch the number of bytes in a row of pixel data, including padding
  /// between lines
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_LockTexture
  /// \sa SDL_UnlockTexture
  int SDL_UpdateTexture1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_UpdateTexture1(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_UpdateTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_UpdateTexture');
  late final _SDL_UpdateTexture1 = _SDL_UpdateTexture1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Void>, int)>();

  /// Update a rectangle within a planar YV12 or IYUV texture with new pixel
  /// data.
  ///
  /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
  /// block of Y and U/V planes in the proper order, but this function is
  /// available if your pixel data is not contiguous.
  ///
  /// \param texture the texture to update
  /// \param rect a pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture
  /// \param Yplane the raw pixel data for the Y plane
  /// \param Ypitch the number of bytes between rows of pixel data for the Y
  /// plane
  /// \param Uplane the raw pixel data for the U plane
  /// \param Upitch the number of bytes between rows of pixel data for the U
  /// plane
  /// \param Vplane the raw pixel data for the V plane
  /// \param Vpitch the number of bytes between rows of pixel data for the V
  /// plane
  /// \returns 0 on success or -1 if the texture is not valid; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ///
  /// \sa SDL_UpdateTexture
  int SDL_UpdateYUVTexture1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> Uplane,
    int Upitch,
    ffi.Pointer<Uint8> Vplane,
    int Vpitch,
  ) {
    return _SDL_UpdateYUVTexture1(
      texture,
      rect,
      Yplane,
      Ypitch,
      Uplane,
      Upitch,
      Vplane,
      Vpitch,
    );
  }

  late final _SDL_UpdateYUVTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int)>>('SDL_UpdateYUVTexture');
  late final _SDL_UpdateYUVTexture1 = _SDL_UpdateYUVTexture1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int)>();

  /// Update a rectangle within a planar NV12 or NV21 texture with new pixels.
  ///
  /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
  /// block of NV12/21 planes in the proper order, but this function is available
  /// if your pixel data is not contiguous.
  ///
  /// \param texture the texture to update
  /// \param rect a pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param Yplane the raw pixel data for the Y plane.
  /// \param Ypitch the number of bytes between rows of pixel data for the Y
  /// plane.
  /// \param UVplane the raw pixel data for the UV plane.
  /// \param UVpitch the number of bytes between rows of pixel data for the UV
  /// plane.
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \since This function is available since SDL 2.0.16.
  int SDL_UpdateNVTexture1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> UVplane,
    int UVpitch,
  ) {
    return _SDL_UpdateNVTexture1(
      texture,
      rect,
      Yplane,
      Ypitch,
      UVplane,
      UVpitch,
    );
  }

  late final _SDL_UpdateNVTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int,
              ffi.Pointer<Uint8>,
              ffi.Int)>>('SDL_UpdateNVTexture');
  late final _SDL_UpdateNVTexture1 = _SDL_UpdateNVTexture1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>, int, ffi.Pointer<Uint8>, int)>();

  /// Lock a portion of the texture for **write-only** pixel access.
  ///
  /// As an optimization, the pixels made available for editing don't necessarily
  /// contain the old texture data. This is a write-only operation, and if you
  /// need to keep a copy of the texture data you should do that at the
  /// application level.
  ///
  /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
  /// changes.
  ///
  /// \param texture the texture to lock for access, which was created with
  /// `SDL_TEXTUREACCESS_STREAMING`
  /// \param rect an SDL_Rect structure representing the area to lock for access;
  /// NULL to lock the entire texture
  /// \param pixels this is filled in with a pointer to the locked pixels,
  /// appropriately offset by the locked area
  /// \param pitch this is filled in with the pitch of the locked pixels; the
  /// pitch is the length of one row in bytes
  /// \returns 0 on success or a negative error code if the texture is not valid
  /// or was not created with `SDL_TEXTUREACCESS_STREAMING`; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_UnlockTexture
  int SDL_LockTexture1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
    ffi.Pointer<ffi.Int> pitch,
  ) {
    return _SDL_LockTexture1(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_LockTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Int>)>>('SDL_LockTexture');
  late final _SDL_LockTexture1 = _SDL_LockTexture1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Int>)>();

  /// Lock a portion of the texture for **write-only** pixel access, and expose
  /// it as a SDL surface.
  ///
  /// Besides providing an SDL_Surface instead of raw pixel data, this function
  /// operates like SDL_LockTexture.
  ///
  /// As an optimization, the pixels made available for editing don't necessarily
  /// contain the old texture data. This is a write-only operation, and if you
  /// need to keep a copy of the texture data you should do that at the
  /// application level.
  ///
  /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
  /// changes.
  ///
  /// The returned surface is freed internally after calling SDL_UnlockTexture()
  /// or SDL_DestroyTexture(). The caller should not free it.
  ///
  /// \param texture the texture to lock for access, which was created with
  /// `SDL_TEXTUREACCESS_STREAMING`
  /// \param rect a pointer to the rectangle to lock for access. If the rect is
  /// NULL, the entire texture will be locked
  /// \param surface this is filled in with an SDL surface representing the
  /// locked area
  /// \returns 0 on success, or -1 if the texture is not valid or was not created
  /// with `SDL_TEXTUREACCESS_STREAMING`
  ///
  /// \since This function is available since SDL 2.0.12.
  ///
  /// \sa SDL_LockTexture
  /// \sa SDL_UnlockTexture
  int SDL_LockTextureToSurface1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
  ) {
    return _SDL_LockTextureToSurface1(
      texture,
      rect,
      surface,
    );
  }

  late final _SDL_LockTextureToSurface1Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
                  ffi.Pointer<ffi.Pointer<SDL_Surface>>)>>(
      'SDL_LockTextureToSurface');
  late final _SDL_LockTextureToSurface1 =
      _SDL_LockTextureToSurface1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<SDL_Surface>>)>();

  /// Unlock a texture, uploading the changes to video memory, if needed.
  ///
  /// **Warning**: Please note that SDL_LockTexture() is intended to be
  /// write-only; it will not guarantee the previous contents of the texture will
  /// be provided. You must fully initialize any area of a texture that you lock
  /// before unlocking it, as the pixels might otherwise be uninitialized memory.
  ///
  /// Which is to say: locking and immediately unlocking a texture can result in
  /// corrupted textures, depending on the renderer in use.
  ///
  /// \param texture a texture locked by SDL_LockTexture()
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_LockTexture
  void SDL_UnlockTexture1(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_UnlockTexture1(
      texture,
    );
  }

  late final _SDL_UnlockTexture1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_UnlockTexture');
  late final _SDL_UnlockTexture1 = _SDL_UnlockTexture1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// Determine whether a renderer supports the use of render targets.
  ///
  /// \param renderer the renderer that will be checked
  /// \returns SDL_TRUE if supported or SDL_FALSE if not.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderTarget
  int SDL_RenderTargetSupported1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderTargetSupported1(
      renderer,
    );
  }

  late final _SDL_RenderTargetSupported1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderTargetSupported');
  late final _SDL_RenderTargetSupported1 = _SDL_RenderTargetSupported1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set a texture as the current rendering target.
  ///
  /// Before using this function, you should check the
  /// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if
  /// render targets are supported.
  ///
  /// The default render target is the window for which the renderer was created.
  /// To stop rendering to a texture and render to the window again, call this
  /// function with a NULL `texture`.
  ///
  /// \param renderer the rendering context
  /// \param texture the targeted texture, which must be created with the
  /// `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
  /// window instead of a texture.
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderTarget
  int SDL_SetRenderTarget1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_SetRenderTarget1(
      renderer,
      texture,
    );
  }

  late final _SDL_SetRenderTarget1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>)>>('SDL_SetRenderTarget');
  late final _SDL_SetRenderTarget1 = _SDL_SetRenderTarget1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>)>();

  /// Get the current render target.
  ///
  /// The default render target is the window for which the renderer was created,
  /// and is reported a NULL here.
  ///
  /// \param renderer the rendering context
  /// \returns the current render target or NULL for the default render target.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderTarget
  ffi.Pointer<SDL_Texture> SDL_GetRenderTarget1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_GetRenderTarget1(
      renderer,
    );
  }

  late final _SDL_GetRenderTarget1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_GetRenderTarget');
  late final _SDL_GetRenderTarget1 = _SDL_GetRenderTarget1Ptr.asFunction<
      ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set a device independent resolution for rendering.
  ///
  /// This function uses the viewport and scaling functionality to allow a fixed
  /// logical resolution for rendering, regardless of the actual output
  /// resolution. If the actual output resolution doesn't have the same aspect
  /// ratio the output rendering will be centered within the output display.
  ///
  /// If the output display is a window, mouse and touch events in the window
  /// will be filtered and scaled so they seem to arrive within the logical
  /// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether
  /// relative motion events are also scaled.
  ///
  /// If this function results in scaling or subpixel drawing by the rendering
  /// backend, it will be handled using the appropriate quality hints.
  ///
  /// \param renderer the renderer for which resolution should be set
  /// \param w the width of the logical resolution
  /// \param h the height of the logical resolution
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetLogicalSize
  int SDL_RenderSetLogicalSize1(
    ffi.Pointer<SDL_Renderer> renderer,
    int w,
    int h,
  ) {
    return _SDL_RenderSetLogicalSize1(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderSetLogicalSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int,
              ffi.Int)>>('SDL_RenderSetLogicalSize');
  late final _SDL_RenderSetLogicalSize1 = _SDL_RenderSetLogicalSize1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// Get device independent resolution for rendering.
  ///
  /// This may return 0 for `w` and `h` if the SDL_Renderer has never had its
  /// logical size set by SDL_RenderSetLogicalSize() and never had a render
  /// target set.
  ///
  /// \param renderer a rendering context
  /// \param w an int to be filled with the width
  /// \param h an int to be filled with the height
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderGetLogicalSize1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int> w,
    ffi.Pointer<ffi.Int> h,
  ) {
    return _SDL_RenderGetLogicalSize1(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderGetLogicalSize1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_RenderGetLogicalSize');
  late final _SDL_RenderGetLogicalSize1 =
      _SDL_RenderGetLogicalSize1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Set whether to force integer scales for resolution-independent rendering.
  ///
  /// This function restricts the logical viewport to integer values - that is,
  /// when a resolution is between two multiples of a logical size, the viewport
  /// size is rounded down to the lower multiple.
  ///
  /// \param renderer the renderer for which integer scaling should be set
  /// \param enable enable or disable the integer scaling for rendering
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RenderGetIntegerScale
  /// \sa SDL_RenderSetLogicalSize
  int SDL_RenderSetIntegerScale1(
    ffi.Pointer<SDL_Renderer> renderer,
    int enable,
  ) {
    return _SDL_RenderSetIntegerScale1(
      renderer,
      enable,
    );
  }

  late final _SDL_RenderSetIntegerScale1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Int32)>>('SDL_RenderSetIntegerScale');
  late final _SDL_RenderSetIntegerScale1 = _SDL_RenderSetIntegerScale1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get whether integer scales are forced for resolution-independent rendering.
  ///
  /// \param renderer the renderer from which integer scaling should be queried
  /// \returns SDL_TRUE if integer scales are forced or SDL_FALSE if not and on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.5.
  ///
  /// \sa SDL_RenderSetIntegerScale
  int SDL_RenderGetIntegerScale1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetIntegerScale1(
      renderer,
    );
  }

  late final _SDL_RenderGetIntegerScale1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderGetIntegerScale');
  late final _SDL_RenderGetIntegerScale1 = _SDL_RenderGetIntegerScale1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set the drawing area for rendering on the current target.
  ///
  /// When the window is resized, the viewport is reset to fill the entire new
  /// window size.
  ///
  /// \param renderer the rendering context
  /// \param rect the SDL_Rect structure representing the drawing area, or NULL
  /// to set the viewport to the entire target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetViewport
  int SDL_RenderSetViewport1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetViewport1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetViewport1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetViewport');
  late final _SDL_RenderSetViewport1 = _SDL_RenderSetViewport1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get the drawing area for the current target.
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure filled in with the current drawing area
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetViewport
  void SDL_RenderGetViewport1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetViewport1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetViewport1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetViewport');
  late final _SDL_RenderGetViewport1 = _SDL_RenderGetViewport1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Set the clip rectangle for rendering on the specified target.
  ///
  /// \param renderer the rendering context for which clip rectangle should be
  /// set
  /// \param rect an SDL_Rect structure representing the clip area, relative to
  /// the viewport, or NULL to disable clipping
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetClipRect
  /// \sa SDL_RenderIsClipEnabled
  int SDL_RenderSetClipRect1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetClipRect1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetClipRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetClipRect');
  late final _SDL_RenderSetClipRect1 = _SDL_RenderSetClipRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get the clip rectangle for the current target.
  ///
  /// \param renderer the rendering context from which clip rectangle should be
  /// queried
  /// \param rect an SDL_Rect structure filled in with the current clipping area
  /// or an empty rectangle if clipping is disabled
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderIsClipEnabled
  /// \sa SDL_RenderSetClipRect
  void SDL_RenderGetClipRect1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetClipRect1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetClipRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetClipRect');
  late final _SDL_RenderGetClipRect1 = _SDL_RenderGetClipRect1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Get whether clipping is enabled on the given renderer.
  ///
  /// \param renderer the renderer from which clip state should be queried
  /// \returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.4.
  ///
  /// \sa SDL_RenderGetClipRect
  /// \sa SDL_RenderSetClipRect
  int SDL_RenderIsClipEnabled1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderIsClipEnabled1(
      renderer,
    );
  }

  late final _SDL_RenderIsClipEnabled1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderIsClipEnabled');
  late final _SDL_RenderIsClipEnabled1 = _SDL_RenderIsClipEnabled1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Set the drawing scale for rendering on the current target.
  ///
  /// The drawing coordinates are scaled by the x/y scaling factors before they
  /// are used by the renderer. This allows resolution independent drawing with a
  /// single coordinate system.
  ///
  /// If this results in scaling or subpixel drawing by the rendering backend, it
  /// will be handled using the appropriate quality hints. For best results use
  /// integer scaling factors.
  ///
  /// \param renderer a rendering context
  /// \param scaleX the horizontal scaling factor
  /// \param scaleY the vertical scaling factor
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetLogicalSize
  int SDL_RenderSetScale1(
    ffi.Pointer<SDL_Renderer> renderer,
    double scaleX,
    double scaleY,
  ) {
    return _SDL_RenderSetScale1(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderSetScale1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderSetScale');
  late final _SDL_RenderSetScale1 = _SDL_RenderSetScale1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// Get the drawing scale for the current target.
  ///
  /// \param renderer the renderer from which drawing scale should be queried
  /// \param scaleX a pointer filled in with the horizontal scaling factor
  /// \param scaleY a pointer filled in with the vertical scaling factor
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderSetScale
  void SDL_RenderGetScale1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Float> scaleX,
    ffi.Pointer<ffi.Float> scaleY,
  ) {
    return _SDL_RenderGetScale1(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderGetScale1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderGetScale');
  late final _SDL_RenderGetScale1 = _SDL_RenderGetScale1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Get logical coordinates of point in renderer when given real coordinates of
  /// point in window.
  ///
  /// Logical coordinates will differ from real coordinates when render is scaled
  /// and logical renderer size set
  ///
  /// \param renderer the renderer from which the logical coordinates should be
  /// calcualted
  /// \param windowX the real X coordinate in the window
  /// \param windowY the real Y coordinate in the window
  /// \param logicalX the pointer filled with the logical x coordinate
  /// \param logicalY the pointer filled with the logical y coordinate
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetScale
  /// \sa SDL_RenderGetLogicalSize
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderWindowToLogical1(
    ffi.Pointer<SDL_Renderer> renderer,
    int windowX,
    int windowY,
    ffi.Pointer<ffi.Float> logicalX,
    ffi.Pointer<ffi.Float> logicalY,
  ) {
    return _SDL_RenderWindowToLogical1(
      renderer,
      windowX,
      windowY,
      logicalX,
      logicalY,
    );
  }

  late final _SDL_RenderWindowToLogical1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderWindowToLogical');
  late final _SDL_RenderWindowToLogical1 =
      _SDL_RenderWindowToLogical1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, int, int,
              ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get real coordinates of point in window when given logical coordinates of point in renderer.
  /// Logical coordinates will differ from real coordinates when render is scaled and logical renderer size set
  ///
  /// \param renderer the renderer from which the window coordinates should be calculated
  /// \param logicalX the logical x coordinate
  /// \param logicalY the logical y coordinate
  /// \param windowX the pointer filled with the real X coordinate in the window
  /// \param windowY the pointer filled with the real Y coordinate in the window
  ///
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGetScale
  /// \sa SDL_RenderSetScale
  /// \sa SDL_RenderGetLogicalSize
  /// \sa SDL_RenderSetLogicalSize
  void SDL_RenderLogicalToWindow1(
    ffi.Pointer<SDL_Renderer> renderer,
    double logicalX,
    double logicalY,
    ffi.Pointer<ffi.Int> windowX,
    ffi.Pointer<ffi.Int> windowY,
  ) {
    return _SDL_RenderLogicalToWindow1(
      renderer,
      logicalX,
      logicalY,
      windowX,
      windowY,
    );
  }

  late final _SDL_RenderLogicalToWindow1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Float,
              ffi.Float,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_RenderLogicalToWindow');
  late final _SDL_RenderLogicalToWindow1 =
      _SDL_RenderLogicalToWindow1Ptr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, double, double,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Set the color used for drawing operations (Rect, Line and Clear).
  ///
  /// Set the color for drawing or filling rectangles, lines, and points, and for
  /// SDL_RenderClear().
  ///
  /// \param renderer the rendering context
  /// \param r the red value used to draw on the rendering target
  /// \param g the green value used to draw on the rendering target
  /// \param b the blue value used to draw on the rendering target
  /// \param a the alpha value used to draw on the rendering target; usually
  /// `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
  /// specify how the alpha channel is used
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderDrawColor
  /// \sa SDL_RenderClear
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  int SDL_SetRenderDrawColor1(
    ffi.Pointer<SDL_Renderer> renderer,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_SetRenderDrawColor1(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_SetRenderDrawColor1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_SetRenderDrawColor');
  late final _SDL_SetRenderDrawColor1 = _SDL_SetRenderDrawColor1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Get the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer the rendering context
  /// \param r a pointer filled in with the red value used to draw on the
  /// rendering target
  /// \param g a pointer filled in with the green value used to draw on the
  /// rendering target
  /// \param b a pointer filled in with the blue value used to draw on the
  /// rendering target
  /// \param a a pointer filled in with the alpha value used to draw on the
  /// rendering target; usually `SDL_ALPHA_OPAQUE` (255)
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawColor
  int SDL_GetRenderDrawColor1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRenderDrawColor1(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRenderDrawColor1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRenderDrawColor');
  late final _SDL_GetRenderDrawColor1 = _SDL_GetRenderDrawColor1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// Set the blend mode used for drawing operations (Fill and Line).
  ///
  /// If the blend mode is not supported, the closest supported mode is chosen.
  ///
  /// \param renderer the rendering context
  /// \param blendMode the SDL_BlendMode to use for blending
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GetRenderDrawBlendMode
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  int SDL_SetRenderDrawBlendMode1(
    ffi.Pointer<SDL_Renderer> renderer,
    int blendMode,
  ) {
    return _SDL_SetRenderDrawBlendMode1(
      renderer,
      blendMode,
    );
  }

  late final _SDL_SetRenderDrawBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Int32)>>('SDL_SetRenderDrawBlendMode');
  late final _SDL_SetRenderDrawBlendMode1 = _SDL_SetRenderDrawBlendMode1Ptr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Get the blend mode used for drawing operations.
  ///
  /// \param renderer the rendering context
  /// \param blendMode a pointer filled in with the current SDL_BlendMode
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawBlendMode
  int SDL_GetRenderDrawBlendMode1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetRenderDrawBlendMode1(
      renderer,
      blendMode,
    );
  }

  late final _SDL_GetRenderDrawBlendMode1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetRenderDrawBlendMode');
  late final _SDL_GetRenderDrawBlendMode1 =
      _SDL_GetRenderDrawBlendMode1Ptr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>)>();

  /// Clear the current rendering target with the drawing color.
  ///
  /// This function clears the entire rendering target, ignoring the viewport and
  /// the clip rectangle.
  ///
  /// \param renderer the rendering context
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderClear1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderClear1(
      renderer,
    );
  }

  late final _SDL_RenderClear1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderClear');
  late final _SDL_RenderClear1 = _SDL_RenderClear1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Draw a point on the current rendering target.
  ///
  /// SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,
  /// use SDL_RenderDrawPoints() instead.
  ///
  /// \param renderer the rendering context
  /// \param x the x coordinate of the point
  /// \param y the y coordinate of the point
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawPoint1(
    ffi.Pointer<SDL_Renderer> renderer,
    int x,
    int y,
  ) {
    return _SDL_RenderDrawPoint1(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPoint1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int,
              ffi.Int)>>('SDL_RenderDrawPoint');
  late final _SDL_RenderDrawPoint1 = _SDL_RenderDrawPoint1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// Draw multiple points on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param points an array of SDL_Point structures that represent the points to
  /// draw
  /// \param count the number of points to draw
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawPoints1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawPoints1(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPoints1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int)>>('SDL_RenderDrawPoints');
  late final _SDL_RenderDrawPoints1 = _SDL_RenderDrawPoints1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// Draw a line on the current rendering target.
  ///
  /// SDL_RenderDrawLine() draws the line to include both end points. If you want
  /// to draw multiple, connecting lines use SDL_RenderDrawLines() instead.
  ///
  /// \param renderer the rendering context
  /// \param x1 the x coordinate of the start point
  /// \param y1 the y coordinate of the start point
  /// \param x2 the x coordinate of the end point
  /// \param y2 the y coordinate of the end point
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawLine1(
    ffi.Pointer<SDL_Renderer> renderer,
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _SDL_RenderDrawLine1(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLine1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('SDL_RenderDrawLine');
  late final _SDL_RenderDrawLine1 = _SDL_RenderDrawLine1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param points an array of SDL_Point structures representing points along
  /// the lines
  /// \param count the number of points, drawing count-1 lines
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawLines1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawLines1(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLines1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int)>>('SDL_RenderDrawLines');
  late final _SDL_RenderDrawLines1 = _SDL_RenderDrawLines1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// Draw a rectangle on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure representing the rectangle to draw, or
  /// NULL to outline the entire rendering target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawRect1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderDrawRect1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderDrawRect');
  late final _SDL_RenderDrawRect1 = _SDL_RenderDrawRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer the rendering context
  /// \param rects an array of SDL_Rect structures representing the rectangles to
  /// be drawn
  /// \param count the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderDrawRects1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRects1(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRects1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_RenderDrawRects');
  late final _SDL_RenderDrawRects1 = _SDL_RenderDrawRects1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// The current drawing color is set by SDL_SetRenderDrawColor(), and the
  /// color's alpha value is ignored unless blending is enabled with the
  /// appropriate call to SDL_SetRenderDrawBlendMode().
  ///
  /// \param renderer the rendering context
  /// \param rect the SDL_Rect structure representing the rectangle to fill, or
  /// NULL for the entire rendering target
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRects
  /// \sa SDL_RenderPresent
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  int SDL_RenderFillRect1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderFillRect1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRect1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderFillRect');
  late final _SDL_RenderFillRect1 = _SDL_RenderFillRect1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// Fill some number of rectangles on the current rendering target with the
  /// drawing color.
  ///
  /// \param renderer the rendering context
  /// \param rects an array of SDL_Rect structures representing the rectangles to
  /// be filled
  /// \param count the number of rectangles
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderPresent
  int SDL_RenderFillRects1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderFillRects1(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRects1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int)>>('SDL_RenderFillRects');
  late final _SDL_RenderFillRects1 = _SDL_RenderFillRects1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// Copy a portion of the texture to the current rendering target.
  ///
  /// The texture is blended with the destination based on its blend mode set
  /// with SDL_SetTextureBlendMode().
  ///
  /// The texture color is affected based on its color modulation set by
  /// SDL_SetTextureColorMod().
  ///
  /// The texture alpha is affected based on its alpha modulation set by
  /// SDL_SetTextureAlphaMod().
  ///
  /// \param renderer the rendering context
  /// \param texture the source texture
  /// \param srcrect the source SDL_Rect structure or NULL for the entire texture
  /// \param dstrect the destination SDL_Rect structure or NULL for the entire
  /// rendering target; the texture will be stretched to fill the
  /// given rectangle
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderCopyEx
  /// \sa SDL_SetTextureAlphaMod
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_SetTextureColorMod
  int SDL_RenderCopy1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_RenderCopy1(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopy1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>>('SDL_RenderCopy');
  late final _SDL_RenderCopy1 = _SDL_RenderCopy1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// Copy a portion of the texture to the current rendering, with optional
  /// rotation and flipping.
  ///
  /// Copy a portion of the texture to the current rendering target, optionally
  /// rotating it by angle around the given center and also flipping it
  /// top-bottom and/or left-right.
  ///
  /// The texture is blended with the destination based on its blend mode set
  /// with SDL_SetTextureBlendMode().
  ///
  /// The texture color is affected based on its color modulation set by
  /// SDL_SetTextureColorMod().
  ///
  /// The texture alpha is affected based on its alpha modulation set by
  /// SDL_SetTextureAlphaMod().
  ///
  /// \param renderer the rendering context
  /// \param texture the source texture
  /// \param srcrect the source SDL_Rect structure or NULL for the entire texture
  /// \param dstrect the destination SDL_Rect structure or NULL for the entire
  /// rendering target
  /// \param angle an angle in degrees that indicates the rotation that will be
  /// applied to dstrect, rotating it in a clockwise direction
  /// \param center a pointer to a point indicating the point around which
  /// dstrect will be rotated (if NULL, rotation will be done
  /// around `dstrect.w / 2`, `dstrect.h / 2`)
  /// \param flip a SDL_RendererFlip value stating which flipping actions should
  /// be performed on the texture
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderCopy
  /// \sa SDL_SetTextureAlphaMod
  /// \sa SDL_SetTextureBlendMode
  /// \sa SDL_SetTextureColorMod
  int SDL_RenderCopyEx1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
    double angle,
    ffi.Pointer<SDL_Point> center,
    int flip,
  ) {
    return _SDL_RenderCopyEx1(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyEx1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>,
              ffi.Double,
              ffi.Pointer<SDL_Point>,
              ffi.Int32)>>('SDL_RenderCopyEx');
  late final _SDL_RenderCopyEx1 = _SDL_RenderCopyEx1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>,
          double,
          ffi.Pointer<SDL_Point>,
          int)>();

  /// Draw a point on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawPointF1(
    ffi.Pointer<SDL_Renderer> renderer,
    double x,
    double y,
  ) {
    return _SDL_RenderDrawPointF1(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderDrawPointF');
  late final _SDL_RenderDrawPointF1 = _SDL_RenderDrawPointF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// Draw multiple points on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawPointsF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawPointsF1(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int)>>('SDL_RenderDrawPointsF');
  late final _SDL_RenderDrawPointsF1 = _SDL_RenderDrawPointsF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// Draw a line on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawLineF1(
    ffi.Pointer<SDL_Renderer> renderer,
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _SDL_RenderDrawLineF1(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLineF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float)>>('SDL_RenderDrawLineF');
  late final _SDL_RenderDrawLineF1 = _SDL_RenderDrawLineF1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>, double, double, double, double)>();

  /// Draw a series of connected lines on the current rendering target at
  /// subpixel precision.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawLinesF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawLinesF1(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int)>>('SDL_RenderDrawLinesF');
  late final _SDL_RenderDrawLinesF1 = _SDL_RenderDrawLinesF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// Draw a rectangle on the current rendering target at subpixel precision.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the
  /// entire rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawRectF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderDrawRectF1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderDrawRectF');
  late final _SDL_RenderDrawRectF1 = _SDL_RenderDrawRectF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// Draw some number of rectangles on the current rendering target at subpixel
  /// precision.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderDrawRectsF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRectsF1(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int)>>('SDL_RenderDrawRectsF');
  late final _SDL_RenderDrawRectsF1 = _SDL_RenderDrawRectsF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// Fill a rectangle on the current rendering target with the drawing color at
  /// subpixel precision.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFillRectF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderFillRectF1(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderFillRectF');
  late final _SDL_RenderFillRectF1 = _SDL_RenderFillRectF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// Fill some number of rectangles on the current rendering target with the
  /// drawing color at subpixel precision.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFillRectsF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderFillRectsF1(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int)>>('SDL_RenderFillRectsF');
  late final _SDL_RenderFillRectsF1 = _SDL_RenderFillRectsF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// Copy a portion of the texture to the current rendering target at subpixel
  /// precision.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderCopyF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
  ) {
    return _SDL_RenderCopyF1(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderCopyF');
  late final _SDL_RenderCopyF1 = _SDL_RenderCopyF1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_FRect>)>();

  /// Copy a portion of the source texture to the current rendering target, with
  /// rotation and flipping, at subpixel precision.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle An angle in degrees that indicates the rotation that will be
  /// applied to dstrect, rotating it in a clockwise direction
  /// \param center A pointer to a point indicating the point around which
  /// dstrect will be rotated (if NULL, rotation will be done
  /// around dstrect.w/2, dstrect.h/2).
  /// \param flip An SDL_RendererFlip value stating which flipping actions should
  /// be performed on the texture
  /// \return 0 on success, or -1 on error
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderCopyExF1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
    double angle,
    ffi.Pointer<SDL_FPoint> center,
    int flip,
  ) {
    return _SDL_RenderCopyExF1(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyExF1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>,
              ffi.Double,
              ffi.Pointer<SDL_FPoint>,
              ffi.Int32)>>('SDL_RenderCopyExF');
  late final _SDL_RenderCopyExF1 = _SDL_RenderCopyExF1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_FRect>,
          double,
          ffi.Pointer<SDL_FPoint>,
          int)>();

  /// Render a list of triangles, optionally using a texture and indices into the
  /// vertex array Color and alpha modulation is done per vertex
  /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
  ///
  /// \param texture (optional) The SDL texture to use.
  /// \param vertices Vertices.
  /// \param num_vertices Number of vertices.
  /// \param indices (optional) An array of integer indices into the 'vertices'
  /// array, if NULL all vertices will be rendered in sequential
  /// order.
  /// \param num_indices Number of indices.
  /// \return 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGeometryRaw
  /// \sa SDL_Vertex
  int SDL_RenderGeometry1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Vertex> vertices,
    int num_vertices,
    ffi.Pointer<ffi.Int> indices,
    int num_indices,
  ) {
    return _SDL_RenderGeometry1(
      renderer,
      texture,
      vertices,
      num_vertices,
      indices,
      num_indices,
    );
  }

  late final _SDL_RenderGeometry1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Vertex>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('SDL_RenderGeometry');
  late final _SDL_RenderGeometry1 = _SDL_RenderGeometry1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Vertex>, int, ffi.Pointer<ffi.Int>, int)>();

  /// Render a list of triangles, optionally using a texture and indices into the
  /// vertex arrays Color and alpha modulation is done per vertex
  /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
  ///
  /// \param texture (optional) The SDL texture to use.
  /// \param xy Vertex positions
  /// \param xy_stride Byte size to move from one element to the next element
  /// \param color Vertex colors (as SDL_Color)
  /// \param color_stride Byte size to move from one element to the next element
  /// \param uv Vertex normalized texture coordinates
  /// \param uv_stride Byte size to move from one element to the next element
  /// \param num_vertices Number of vertices.
  /// \param indices (optional) An array of indices into the 'vertices' arrays,
  /// if NULL all vertices will be rendered in sequential order.
  /// \param num_indices Number of indices.
  /// \param size_indices Index size: 1 (byte), 2 (short), 4 (int)
  /// \return 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.18.
  ///
  /// \sa SDL_RenderGeometry
  /// \sa SDL_Vertex
  int SDL_RenderGeometryRaw1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> xy,
    int xy_stride,
    ffi.Pointer<SDL_Color> color,
    int color_stride,
    ffi.Pointer<ffi.Float> uv,
    int uv_stride,
    int num_vertices,
    ffi.Pointer<ffi.Void> indices,
    int num_indices,
    int size_indices,
  ) {
    return _SDL_RenderGeometryRaw1(
      renderer,
      texture,
      xy,
      xy_stride,
      color,
      color_stride,
      uv,
      uv_stride,
      num_vertices,
      indices,
      num_indices,
      size_indices,
    );
  }

  late final _SDL_RenderGeometryRaw1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Pointer<SDL_Color>,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int)>>('SDL_RenderGeometryRaw');
  late final _SDL_RenderGeometryRaw1 = _SDL_RenderGeometryRaw1Ptr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<ffi.Float>,
          int,
          ffi.Pointer<SDL_Color>,
          int,
          ffi.Pointer<ffi.Float>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Read pixels from the current rendering target to an array of pixels.
  ///
  /// **WARNING**: This is a very slow operation, and should not be used
  /// frequently.
  ///
  /// `pitch` specifies the number of bytes between rows in the destination
  /// `pixels` data. This allows you to write to a subrectangle or have padded
  /// rows in the destination. Generally, `pitch` should equal the number of
  /// pixels per row in the `pixels` data times the number of bytes per pixel,
  /// but it might contain additional padding (for example, 24bit RGB Windows
  /// Bitmap data pads all rows to multiples of 4 bytes).
  ///
  /// \param renderer the rendering context
  /// \param rect an SDL_Rect structure representing the area to read, or NULL
  /// for the entire render target
  /// \param format an SDL_PixelFormatEnum value of the desired format of the
  /// pixel data, or 0 to use the format of the rendering target
  /// \param pixels a pointer to the pixel data to copy into
  /// \param pitch the pitch of the `pixels` parameter
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  int SDL_RenderReadPixels1(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
    int format,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_RenderReadPixels1(
      renderer,
      rect,
      format,
      pixels,
      pitch,
    );
  }

  late final _SDL_RenderReadPixels1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              Uint32, ffi.Pointer<ffi.Void>, ffi.Int)>>('SDL_RenderReadPixels');
  late final _SDL_RenderReadPixels1 = _SDL_RenderReadPixels1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Update the screen with any rendering performed since the previous call.
  ///
  /// SDL's rendering functions operate on a backbuffer; that is, calling a
  /// rendering function such as SDL_RenderDrawLine() does not directly put a
  /// line on the screen, but rather updates the backbuffer. As such, you compose
  /// your entire scene and *present* the composed backbuffer to the screen as a
  /// complete picture.
  ///
  /// Therefore, when using SDL's rendering API, one does all drawing intended
  /// for the frame, and then calls this function once per frame to present the
  /// final drawing to the user.
  ///
  /// The backbuffer should be considered invalidated after each present; do not
  /// assume that previous contents will exist between frames. You are strongly
  /// encouraged to call SDL_RenderClear() to initialize the backbuffer before
  /// starting each new frame's drawing, even if you plan to overwrite every
  /// pixel.
  ///
  /// \param renderer the rendering context
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_RenderClear
  /// \sa SDL_RenderDrawLine
  /// \sa SDL_RenderDrawLines
  /// \sa SDL_RenderDrawPoint
  /// \sa SDL_RenderDrawPoints
  /// \sa SDL_RenderDrawRect
  /// \sa SDL_RenderDrawRects
  /// \sa SDL_RenderFillRect
  /// \sa SDL_RenderFillRects
  /// \sa SDL_SetRenderDrawBlendMode
  /// \sa SDL_SetRenderDrawColor
  void SDL_RenderPresent1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderPresent1(
      renderer,
    );
  }

  late final _SDL_RenderPresent1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderPresent');
  late final _SDL_RenderPresent1 = _SDL_RenderPresent1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// Destroy the specified texture.
  ///
  /// Passing NULL or an otherwise invalid texture will set the SDL error message
  /// to "Invalid texture".
  ///
  /// \param texture the texture to destroy
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateTexture
  /// \sa SDL_CreateTextureFromSurface
  void SDL_DestroyTexture1(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_DestroyTexture1(
      texture,
    );
  }

  late final _SDL_DestroyTexture1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_DestroyTexture');
  late final _SDL_DestroyTexture1 = _SDL_DestroyTexture1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// Destroy the rendering context for a window and free associated textures.
  ///
  /// \param renderer the rendering context
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_CreateRenderer
  void SDL_DestroyRenderer1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_DestroyRenderer1(
      renderer,
    );
  }

  late final _SDL_DestroyRenderer1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_DestroyRenderer');
  late final _SDL_DestroyRenderer1 = _SDL_DestroyRenderer1Ptr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// Force the rendering context to flush any pending commands to the underlying
  /// rendering API.
  ///
  /// You do not need to (and in fact, shouldn't) call this function unless you
  /// are planning to call into OpenGL/Direct3D/Metal/whatever directly in
  /// addition to using an SDL_Renderer.
  ///
  /// This is for a very-specific case: if you are using SDL's render API, you
  /// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set
  /// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever
  /// calls in addition to SDL render API calls. If all of this applies, you
  /// should call SDL_RenderFlush() between calls to SDL's render API and the
  /// low-level API you're using in cooperation.
  ///
  /// In all other cases, you can ignore this function. This is only here to get
  /// maximum performance out of a specific situation. In all other cases, SDL
  /// will do the right thing, perhaps at a performance loss.
  ///
  /// This function is first available in SDL 2.0.10, and is not needed in 2.0.9
  /// and earlier, as earlier versions did not queue rendering commands at all,
  /// instead flushing them to the OS immediately.
  ///
  /// \param renderer the rendering context
  /// \returns 0 on success or a negative error code on failure; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.10.
  int SDL_RenderFlush1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderFlush1(
      renderer,
    );
  }

  late final _SDL_RenderFlush1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderFlush');
  late final _SDL_RenderFlush1 = _SDL_RenderFlush1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>)>();

  /// Bind an OpenGL/ES/ES2 texture to the current context.
  ///
  /// This is for use with OpenGL instructions when rendering OpenGL primitives
  /// directly.
  ///
  /// If not NULL, `texw` and `texh` will be filled with the width and height
  /// values suitable for the provided texture. In most cases, both will be 1.0,
  /// however, on systems that support the GL_ARB_texture_rectangle extension,
  /// these values will actually be the pixel width and height used to create the
  /// texture, so this factor needs to be taken into account when providing
  /// texture coordinates to OpenGL.
  ///
  /// You need a renderer to create an SDL_Texture, therefore you can only use
  /// this function with an implicit OpenGL context from SDL_CreateRenderer(),
  /// not with your own OpenGL context. If you need control over your OpenGL
  /// context, you need to write your own texture-loading methods.
  ///
  /// Also note that SDL may upload RGB textures as BGR (or vice-versa), and
  /// re-order the color channels in the shaders phase, so the uploaded texture
  /// may have swapped color channels.
  ///
  /// \param texture the texture to bind to the current OpenGL/ES/ES2 context
  /// \param texw a pointer to a float value which will be filled with the
  /// texture width or NULL if you don't need that value
  /// \param texh a pointer to a float value which will be filled with the
  /// texture height or NULL if you don't need that value
  /// \returns 0 on success, or -1 if the operation is not supported; call
  /// SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_MakeCurrent
  /// \sa SDL_GL_UnbindTexture
  int SDL_GL_BindTexture1(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> texw,
    ffi.Pointer<ffi.Float> texh,
  ) {
    return _SDL_GL_BindTexture1(
      texture,
      texw,
      texh,
    );
  }

  late final _SDL_GL_BindTexture1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GL_BindTexture');
  late final _SDL_GL_BindTexture1 = _SDL_GL_BindTexture1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Unbind an OpenGL/ES/ES2 texture from the current context.
  ///
  /// See SDL_GL_BindTexture() for examples on how to use these functions
  ///
  /// \param texture the texture to unbind from the current OpenGL/ES/ES2 context
  /// \returns 0 on success, or -1 if the operation is not supported
  ///
  /// \since This function is available since SDL 2.0.0.
  ///
  /// \sa SDL_GL_BindTexture
  /// \sa SDL_GL_MakeCurrent
  int SDL_GL_UnbindTexture1(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GL_UnbindTexture1(
      texture,
    );
  }

  late final _SDL_GL_UnbindTexture1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_GL_UnbindTexture');
  late final _SDL_GL_UnbindTexture1 = _SDL_GL_UnbindTexture1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>)>();

  /// Get the CAMetalLayer associated with the given Metal renderer.
  ///
  /// This function returns `void *`, so SDL doesn't have to include Metal's
  /// headers, but it can be safely cast to a `CAMetalLayer *`.
  ///
  /// \param renderer The renderer to query
  /// \returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a
  /// Metal renderer
  ///
  /// \since This function is available since SDL 2.0.8.
  ///
  /// \sa SDL_RenderGetMetalCommandEncoder
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalLayer1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalLayer1(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalLayer1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalLayer');
  late final _SDL_RenderGetMetalLayer1 = _SDL_RenderGetMetalLayer1Ptr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the Metal command encoder for the current frame
  ///
  /// This function returns `void *`, so SDL doesn't have to include Metal's
  /// headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
  ///
  /// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give
  /// SDL a drawable to render to, which might happen if the window is
  /// hidden/minimized/offscreen. This doesn't apply to command encoders for
  /// render targets, just the window's backbacker. Check your return values!
  ///
  /// \param renderer The renderer to query
  /// \returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the
  /// renderer isn't a Metal renderer or there was an error.
  ///
  /// \since This function is available since SDL 2.0.8.
  ///
  /// \sa SDL_RenderGetMetalLayer
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalCommandEncoder1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalCommandEncoder1(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalCommandEncoder1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalCommandEncoder');
  late final _SDL_RenderGetMetalCommandEncoder1 =
      _SDL_RenderGetMetalCommandEncoder1Ptr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Toggle VSync of the given renderer.
  ///
  /// \param renderer The renderer to toggle
  /// \param vsync 1 for on, 0 for off. All other values are reserved
  /// \returns a 0 int on success, or non-zero on failure
  ///
  /// \since This function is available since SDL 2.0.18.
  int SDL_RenderSetVSync1(
    ffi.Pointer<SDL_Renderer> renderer,
    int vsync,
  ) {
    return _SDL_RenderSetVSync1(
      renderer,
      vsync,
    );
  }

  late final _SDL_RenderSetVSync1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SDL_Renderer>, ffi.Int)>>('SDL_RenderSetVSync');
  late final _SDL_RenderSetVSync1 = _SDL_RenderSetVSync1Ptr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// Set a callback for every Windows message, run before TranslateMessage().
  ///
  /// \param callback The SDL_WindowsMessageHook function to call.
  /// \param userdata a pointer to pass to every iteration of `callback`
  ///
  /// \since This function is available since SDL 2.0.4.
  void SDL_SetWindowsMessageHook1(
    SDL_WindowsMessageHook callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowsMessageHook1(
      callback,
      userdata,
    );
  }

  late final _SDL_SetWindowsMessageHook1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_WindowsMessageHook,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowsMessageHook');
  late final _SDL_SetWindowsMessageHook1 =
      _SDL_SetWindowsMessageHook1Ptr.asFunction<
          void Function(SDL_WindowsMessageHook, ffi.Pointer<ffi.Void>)>();

  /// Get the D3D9 adapter index that matches the specified display index.
  ///
  /// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and
  /// controls on which monitor a full screen application will appear.
  ///
  /// \param displayIndex the display index for which to get the D3D9 adapter
  /// index
  /// \returns the D3D9 adapter index on success or a negative error code on
  /// failure; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  int SDL_Direct3D9GetAdapterIndex1(
    int displayIndex,
  ) {
    return _SDL_Direct3D9GetAdapterIndex1(
      displayIndex,
    );
  }

  late final _SDL_Direct3D9GetAdapterIndex1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'SDL_Direct3D9GetAdapterIndex');
  late final _SDL_Direct3D9GetAdapterIndex1 =
      _SDL_Direct3D9GetAdapterIndex1Ptr.asFunction<int Function(int)>();

  /// Get the D3D9 device associated with a renderer.
  ///
  /// Once you are done using the device, you should release it to avoid a
  /// resource leak.
  ///
  /// \param renderer the renderer from which to get the associated D3D device
  /// \returns the D3D9 device associated with given renderer or NULL if it is
  /// not a D3D9 renderer; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.1.
  ffi.Pointer<IDirect3DDevice9> SDL_RenderGetD3D9Device1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetD3D9Device1(
      renderer,
    );
  }

  late final _SDL_RenderGetD3D9Device1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<IDirect3DDevice9> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetD3D9Device');
  late final _SDL_RenderGetD3D9Device1 =
      _SDL_RenderGetD3D9Device1Ptr.asFunction<
          ffi.Pointer<IDirect3DDevice9> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the D3D11 device associated with a renderer.
  ///
  /// Once you are done using the device, you should release it to avoid a
  /// resource leak.
  ///
  /// \param renderer the renderer from which to get the associated D3D11 device
  /// \returns the D3D11 device associated with given renderer or NULL if it is
  /// not a D3D11 renderer; call SDL_GetError() for more information.
  ///
  /// \since This function is available since SDL 2.0.16.
  ffi.Pointer<ID3D11Device> SDL_RenderGetD3D11Device1(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetD3D11Device1(
      renderer,
    );
  }

  late final _SDL_RenderGetD3D11Device1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ID3D11Device> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetD3D11Device');
  late final _SDL_RenderGetD3D11Device1 =
      _SDL_RenderGetD3D11Device1Ptr.asFunction<
          ffi.Pointer<ID3D11Device> Function(ffi.Pointer<SDL_Renderer>)>();

  /// Get the DXGI Adapter and Output indices for the specified display index.
  ///
  /// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and
  /// `EnumOutputs` respectively to get the objects required to create a DX10 or
  /// DX11 device and swap chain.
  ///
  /// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it
  /// returns an SDL_bool.
  ///
  /// \param displayIndex the display index for which to get both indices
  /// \param adapterIndex a pointer to be filled in with the adapter index
  /// \param outputIndex a pointer to be filled in with the output index
  /// \returns SDL_TRUE on success or SDL_FALSE on failure; call SDL_GetError()
  /// for more information.
  ///
  /// \since This function is available since SDL 2.0.2.
  int SDL_DXGIGetOutputInfo1(
    int displayIndex,
    ffi.Pointer<ffi.Int> adapterIndex,
    ffi.Pointer<ffi.Int> outputIndex,
  ) {
    return _SDL_DXGIGetOutputInfo1(
      displayIndex,
      adapterIndex,
      outputIndex,
    );
  }

  late final _SDL_DXGIGetOutputInfo1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('SDL_DXGIGetOutputInfo');
  late final _SDL_DXGIGetOutputInfo1 = _SDL_DXGIGetOutputInfo1Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Query if the current device is a tablet.
  ///
  /// If SDL can't determine this, it will return SDL_FALSE.
  ///
  /// \returns SDL_TRUE if the device is a tablet, SDL_FALSE otherwise.
  ///
  /// \since This function is available since SDL 2.0.9.
  int SDL_IsTablet1() {
    return _SDL_IsTablet1();
  }

  late final _SDL_IsTablet1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_IsTablet');
  late final _SDL_IsTablet1 = _SDL_IsTablet1Ptr.asFunction<int Function()>();

  void SDL_OnApplicationWillTerminate1() {
    return _SDL_OnApplicationWillTerminate1();
  }

  late final _SDL_OnApplicationWillTerminate1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillTerminate');
  late final _SDL_OnApplicationWillTerminate1 =
      _SDL_OnApplicationWillTerminate1Ptr.asFunction<void Function()>();

  void SDL_OnApplicationDidReceiveMemoryWarning1() {
    return _SDL_OnApplicationDidReceiveMemoryWarning1();
  }

  late final _SDL_OnApplicationDidReceiveMemoryWarning1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidReceiveMemoryWarning');
  late final _SDL_OnApplicationDidReceiveMemoryWarning1 =
      _SDL_OnApplicationDidReceiveMemoryWarning1Ptr.asFunction<
          void Function()>();

  void SDL_OnApplicationWillResignActive1() {
    return _SDL_OnApplicationWillResignActive1();
  }

  late final _SDL_OnApplicationWillResignActive1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillResignActive');
  late final _SDL_OnApplicationWillResignActive1 =
      _SDL_OnApplicationWillResignActive1Ptr.asFunction<void Function()>();

  void SDL_OnApplicationDidEnterBackground1() {
    return _SDL_OnApplicationDidEnterBackground1();
  }

  late final _SDL_OnApplicationDidEnterBackground1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidEnterBackground');
  late final _SDL_OnApplicationDidEnterBackground1 =
      _SDL_OnApplicationDidEnterBackground1Ptr.asFunction<void Function()>();

  void SDL_OnApplicationWillEnterForeground1() {
    return _SDL_OnApplicationWillEnterForeground1();
  }

  late final _SDL_OnApplicationWillEnterForeground1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillEnterForeground');
  late final _SDL_OnApplicationWillEnterForeground1 =
      _SDL_OnApplicationWillEnterForeground1Ptr.asFunction<void Function()>();

  void SDL_OnApplicationDidBecomeActive1() {
    return _SDL_OnApplicationDidBecomeActive1();
  }

  late final _SDL_OnApplicationDidBecomeActive1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidBecomeActive');
  late final _SDL_OnApplicationDidBecomeActive1 =
      _SDL_OnApplicationDidBecomeActive1Ptr.asFunction<void Function()>();

  /// Get the name of the platform.
  ///
  /// Here are the names returned for some (but not all) supported platforms:
  ///
  /// - "Windows"
  /// - "Mac OS X"
  /// - "Linux"
  /// - "iOS"
  /// - "Android"
  ///
  /// \returns the name of the platform. If the correct platform name is not
  /// available, returns a string beginning with the text "Unknown".
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_GetPlatform29() {
    return _SDL_GetPlatform29();
  }

  late final _SDL_GetPlatform29Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform29 =
      _SDL_GetPlatform29Ptr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc27(
    int size,
  ) {
    return _SDL_malloc27(
      size,
    );
  }

  late final _SDL_malloc27Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'SDL_malloc');
  late final _SDL_malloc27 =
      _SDL_malloc27Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc27(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc27(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('SDL_calloc');
  late final _SDL_calloc27 =
      _SDL_calloc27Ptr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc27(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc27(
      mem,
      size,
    );
  }

  late final _SDL_realloc27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_realloc');
  late final _SDL_realloc27 = _SDL_realloc27Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free27(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free27(
      mem,
    );
  }

  late final _SDL_free27Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free27 =
      _SDL_free27Ptr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Get the current set of SDL memory functions
  ///
  /// \since This function is available since SDL 2.0.7.
  void SDL_GetMemoryFunctions27(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions27(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions27 =
      _SDL_GetMemoryFunctions27Ptr.asFunction<
          void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>();

  /// Replace SDL's memory allocation functions with a custom set
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_SetMemoryFunctions27(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions27(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions27 =
      _SDL_SetMemoryFunctions27Ptr.asFunction<
          int Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>();

  /// Get the number of outstanding (unfreed) allocations
  ///
  /// \since This function is available since SDL 2.0.7.
  int SDL_GetNumAllocations27() {
    return _SDL_GetNumAllocations27();
  }

  late final _SDL_GetNumAllocations27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations27 =
      _SDL_GetNumAllocations27Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> SDL_getenv27(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _SDL_getenv27(
      name,
    );
  }

  late final _SDL_getenv27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_getenv');
  late final _SDL_getenv27 = _SDL_getenv27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int SDL_setenv27(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    int overwrite,
  ) {
    return _SDL_setenv27(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('SDL_setenv');
  late final _SDL_setenv27 = _SDL_setenv27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void SDL_qsort27(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort27(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort27 = _SDL_qsort27Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs27(
    int x,
  ) {
    return _SDL_abs27(
      x,
    );
  }

  late final _SDL_abs27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_abs');
  late final _SDL_abs27 = _SDL_abs27Ptr.asFunction<int Function(int)>();

  int SDL_isalpha27(
    int x,
  ) {
    return _SDL_isalpha27(
      x,
    );
  }

  late final _SDL_isalpha27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalpha');
  late final _SDL_isalpha27 = _SDL_isalpha27Ptr.asFunction<int Function(int)>();

  int SDL_isalnum27(
    int x,
  ) {
    return _SDL_isalnum27(
      x,
    );
  }

  late final _SDL_isalnum27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isalnum');
  late final _SDL_isalnum27 = _SDL_isalnum27Ptr.asFunction<int Function(int)>();

  int SDL_isblank27(
    int x,
  ) {
    return _SDL_isblank27(
      x,
    );
  }

  late final _SDL_isblank27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isblank');
  late final _SDL_isblank27 = _SDL_isblank27Ptr.asFunction<int Function(int)>();

  int SDL_iscntrl27(
    int x,
  ) {
    return _SDL_iscntrl27(
      x,
    );
  }

  late final _SDL_iscntrl27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_iscntrl');
  late final _SDL_iscntrl27 = _SDL_iscntrl27Ptr.asFunction<int Function(int)>();

  int SDL_isdigit27(
    int x,
  ) {
    return _SDL_isdigit27(
      x,
    );
  }

  late final _SDL_isdigit27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isdigit');
  late final _SDL_isdigit27 = _SDL_isdigit27Ptr.asFunction<int Function(int)>();

  int SDL_isxdigit27(
    int x,
  ) {
    return _SDL_isxdigit27(
      x,
    );
  }

  late final _SDL_isxdigit27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isxdigit');
  late final _SDL_isxdigit27 =
      _SDL_isxdigit27Ptr.asFunction<int Function(int)>();

  int SDL_ispunct27(
    int x,
  ) {
    return _SDL_ispunct27(
      x,
    );
  }

  late final _SDL_ispunct27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_ispunct');
  late final _SDL_ispunct27 = _SDL_ispunct27Ptr.asFunction<int Function(int)>();

  int SDL_isspace27(
    int x,
  ) {
    return _SDL_isspace27(
      x,
    );
  }

  late final _SDL_isspace27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isspace');
  late final _SDL_isspace27 = _SDL_isspace27Ptr.asFunction<int Function(int)>();

  int SDL_isupper27(
    int x,
  ) {
    return _SDL_isupper27(
      x,
    );
  }

  late final _SDL_isupper27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isupper');
  late final _SDL_isupper27 = _SDL_isupper27Ptr.asFunction<int Function(int)>();

  int SDL_islower27(
    int x,
  ) {
    return _SDL_islower27(
      x,
    );
  }

  late final _SDL_islower27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_islower');
  late final _SDL_islower27 = _SDL_islower27Ptr.asFunction<int Function(int)>();

  int SDL_isprint27(
    int x,
  ) {
    return _SDL_isprint27(
      x,
    );
  }

  late final _SDL_isprint27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isprint');
  late final _SDL_isprint27 = _SDL_isprint27Ptr.asFunction<int Function(int)>();

  int SDL_isgraph27(
    int x,
  ) {
    return _SDL_isgraph27(
      x,
    );
  }

  late final _SDL_isgraph27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_isgraph');
  late final _SDL_isgraph27 = _SDL_isgraph27Ptr.asFunction<int Function(int)>();

  int SDL_toupper27(
    int x,
  ) {
    return _SDL_toupper27(
      x,
    );
  }

  late final _SDL_toupper27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_toupper');
  late final _SDL_toupper27 = _SDL_toupper27Ptr.asFunction<int Function(int)>();

  int SDL_tolower27(
    int x,
  ) {
    return _SDL_tolower27(
      x,
    );
  }

  late final _SDL_tolower27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('SDL_tolower');
  late final _SDL_tolower27 = _SDL_tolower27Ptr.asFunction<int Function(int)>();

  int SDL_crc3227(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc3227(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc3227Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(
              Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_crc32');
  late final _SDL_crc3227 = _SDL_crc3227Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset27(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset27(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('SDL_memset');
  late final _SDL_memset27 = _SDL_memset27Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy27(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy27(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memcpy');
  late final _SDL_memcpy27 = _SDL_memcpy27Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove27(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove27(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('SDL_memmove');
  late final _SDL_memmove27 = _SDL_memmove27Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp27(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp27(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SDL_memcmp');
  late final _SDL_memcmp27 = _SDL_memcmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen27(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcslen27(
      wstr,
    );
  }

  late final _SDL_wcslen27Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.WChar>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen27 =
      _SDL_wcslen27Ptr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int SDL_wcslcpy27(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy27(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy27 = _SDL_wcslcpy27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcslcat27(
    ffi.Pointer<ffi.WChar> dst,
    ffi.Pointer<ffi.WChar> src,
    int maxlen,
  ) {
    return _SDL_wcslcat27(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcslcat');
  late final _SDL_wcslcat27 = _SDL_wcslcat27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> SDL_wcsdup27(
    ffi.Pointer<ffi.WChar> wstr,
  ) {
    return _SDL_wcsdup27(
      wstr,
    );
  }

  late final _SDL_wcsdup27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('SDL_wcsdup');
  late final _SDL_wcsdup27 = _SDL_wcsdup27Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> SDL_wcsstr27(
    ffi.Pointer<ffi.WChar> haystack,
    ffi.Pointer<ffi.WChar> needle,
  ) {
    return _SDL_wcsstr27(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcsstr');
  late final _SDL_wcsstr27 = _SDL_wcsstr27Ptr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcscmp27(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscmp27(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('SDL_wcscmp');
  late final _SDL_wcscmp27 = _SDL_wcscmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncmp27(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp27(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp27 = _SDL_wcsncmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_wcscasecmp27(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
  ) {
    return _SDL_wcscasecmp27(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp27 = _SDL_wcscasecmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int SDL_wcsncasecmp27(
    ffi.Pointer<ffi.WChar> str1,
    ffi.Pointer<ffi.WChar> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp27(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp27 = _SDL_wcsncasecmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int SDL_strlen27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlen27(
      str,
    );
  }

  late final _SDL_strlen27Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_strlen');
  late final _SDL_strlen27 =
      _SDL_strlen27Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strlcpy27(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcpy27(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcpy');
  late final _SDL_strlcpy27 = _SDL_strlcpy27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_utf8strlcpy27(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy27(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy27 = _SDL_utf8strlcpy27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strlcat27(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int maxlen,
  ) {
    return _SDL_strlcat27(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strlcat');
  late final _SDL_strlcat27 = _SDL_strlcat27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strdup27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strdup27(
      str,
    );
  }

  late final _SDL_strdup27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strdup');
  late final _SDL_strdup27 = _SDL_strdup27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strrev27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strrev27(
      str,
    );
  }

  late final _SDL_strrev27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strrev');
  late final _SDL_strrev27 = _SDL_strrev27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strupr27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strupr27(
      str,
    );
  }

  late final _SDL_strupr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strupr');
  late final _SDL_strupr27 = _SDL_strupr27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strlwr27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_strlwr27(
      str,
    );
  }

  late final _SDL_strlwr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('SDL_strlwr');
  late final _SDL_strlwr27 = _SDL_strlwr27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strchr27(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strchr27(
      str,
      c,
    );
  }

  late final _SDL_strchr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strchr');
  late final _SDL_strchr27 = _SDL_strchr27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strrchr27(
    ffi.Pointer<ffi.Char> str,
    int c,
  ) {
    return _SDL_strrchr27(
      str,
      c,
    );
  }

  late final _SDL_strrchr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_strrchr');
  late final _SDL_strrchr27 = _SDL_strrchr27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_strstr27(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _SDL_strstr27(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strstr');
  late final _SDL_strstr27 = _SDL_strstr27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_strtokr27(
    ffi.Pointer<ffi.Char> s1,
    ffi.Pointer<ffi.Char> s2,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _SDL_strtokr27(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtokr');
  late final _SDL_strtokr27 = _SDL_strtokr27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_utf8strlen27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_utf8strlen27(
      str,
    );
  }

  late final _SDL_utf8strlen27Ptr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen27 =
      _SDL_utf8strlen27Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> SDL_itoa27(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_itoa27(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_itoa');
  late final _SDL_itoa27 = _SDL_itoa27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_uitoa27(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_uitoa27(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_uitoa');
  late final _SDL_uitoa27 = _SDL_uitoa27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ltoa27(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ltoa27(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Long, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ltoa');
  late final _SDL_ltoa27 = _SDL_ltoa27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ultoa27(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ultoa27(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedLong, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ultoa');
  late final _SDL_ultoa27 = _SDL_ultoa27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_lltoa27(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_lltoa27(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Sint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_lltoa');
  late final _SDL_lltoa27 = _SDL_lltoa27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> SDL_ulltoa27(
    int value,
    ffi.Pointer<ffi.Char> str,
    int radix,
  ) {
    return _SDL_ulltoa27(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              Uint64, ffi.Pointer<ffi.Char>, ffi.Int)>>('SDL_ulltoa');
  late final _SDL_ulltoa27 = _SDL_ulltoa27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int SDL_atoi27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atoi27(
      str,
    );
  }

  late final _SDL_atoi27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atoi');
  late final _SDL_atoi27 =
      _SDL_atoi27Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double SDL_atof27(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _SDL_atof27(
      str,
    );
  }

  late final _SDL_atof27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'SDL_atof');
  late final _SDL_atof27 =
      _SDL_atof27Ptr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int SDL_strtol27(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtol27(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtol');
  late final _SDL_strtol27 = _SDL_strtol27Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoul27(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoul27(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoul');
  late final _SDL_strtoul27 = _SDL_strtoul27Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoll27(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoll27(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll27Ptr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoll');
  late final _SDL_strtoll27 = _SDL_strtoll27Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int SDL_strtoull27(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
    int base,
  ) {
    return _SDL_strtoull27(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull27Ptr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('SDL_strtoull');
  late final _SDL_strtoull27 = _SDL_strtoull27Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  double SDL_strtod27(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> endp,
  ) {
    return _SDL_strtod27(
      str,
      endp,
    );
  }

  late final _SDL_strtod27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SDL_strtod');
  late final _SDL_strtod27 = _SDL_strtod27Ptr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int SDL_strcmp27(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcmp27(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcmp');
  late final _SDL_strcmp27 = _SDL_strcmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncmp27(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int maxlen,
  ) {
    return _SDL_strncmp27(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncmp');
  late final _SDL_strncmp27 = _SDL_strncmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_strcasecmp27(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
  ) {
    return _SDL_strcasecmp27(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp27 = _SDL_strcasecmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_strncasecmp27(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    int len,
  ) {
    return _SDL_strncasecmp27(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp27 = _SDL_strncasecmp27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int SDL_sscanf27(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_sscanf27(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_sscanf');
  late final _SDL_sscanf27 = _SDL_sscanf27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_vsscanf27(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf27(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf27 = _SDL_vsscanf27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_snprintf27(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_snprintf27(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('SDL_snprintf');
  late final _SDL_snprintf27 = _SDL_snprintf27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int SDL_vsnprintf27(
    ffi.Pointer<ffi.Char> text,
    int maxlen,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf27(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf27 = _SDL_vsnprintf27Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int SDL_asprintf27(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _SDL_asprintf27(
      strp,
      fmt,
    );
  }

  late final _SDL_asprintf27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('SDL_asprintf');
  late final _SDL_asprintf27 = _SDL_asprintf27Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int SDL_vasprintf27(
    ffi.Pointer<ffi.Pointer<ffi.Char>> strp,
    ffi.Pointer<ffi.Char> fmt,
    va_list ap,
  ) {
    return _SDL_vasprintf27(
      strp,
      fmt,
      ap,
    );
  }

  late final _SDL_vasprintf27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('SDL_vasprintf');
  late final _SDL_vasprintf27 = _SDL_vasprintf27Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  /// Use this function to compute arc cosine of `x`.
  ///
  /// The definition of `y = acos(x)` is `x = cos(y)`.
  ///
  /// Domain: `-1 <= x <= 1`
  ///
  /// Range: `0 <= y <= Pi`
  ///
  /// \param x floating point value, in radians.
  /// \returns arc cosine of `x`.
  ///
  /// \since This function is available since SDL 2.0.2.
  double SDL_acos27(
    double x,
  ) {
    return _SDL_acos27(
      x,
    );
  }

  late final _SDL_acos27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos27 = _SDL_acos27Ptr.asFunction<double Function(double)>();

  double SDL_acosf27(
    double x,
  ) {
    return _SDL_acosf27(
      x,
    );
  }

  late final _SDL_acosf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf27 =
      _SDL_acosf27Ptr.asFunction<double Function(double)>();

  double SDL_asin27(
    double x,
  ) {
    return _SDL_asin27(
      x,
    );
  }

  late final _SDL_asin27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin27 = _SDL_asin27Ptr.asFunction<double Function(double)>();

  double SDL_asinf27(
    double x,
  ) {
    return _SDL_asinf27(
      x,
    );
  }

  late final _SDL_asinf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf27 =
      _SDL_asinf27Ptr.asFunction<double Function(double)>();

  double SDL_atan37(
    double x,
  ) {
    return _SDL_atan37(
      x,
    );
  }

  late final _SDL_atan37Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan37 = _SDL_atan37Ptr.asFunction<double Function(double)>();

  double SDL_atanf27(
    double x,
  ) {
    return _SDL_atanf27(
      x,
    );
  }

  late final _SDL_atanf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf27 =
      _SDL_atanf27Ptr.asFunction<double Function(double)>();

  double SDL_atan227(
    double y,
    double x,
  ) {
    return _SDL_atan227(
      y,
      x,
    );
  }

  late final _SDL_atan227Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan227 =
      _SDL_atan227Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f27(
    double y,
    double x,
  ) {
    return _SDL_atan2f27(
      y,
      x,
    );
  }

  late final _SDL_atan2f27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f27 =
      _SDL_atan2f27Ptr.asFunction<double Function(double, double)>();

  double SDL_ceil27(
    double x,
  ) {
    return _SDL_ceil27(
      x,
    );
  }

  late final _SDL_ceil27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil27 = _SDL_ceil27Ptr.asFunction<double Function(double)>();

  double SDL_ceilf27(
    double x,
  ) {
    return _SDL_ceilf27(
      x,
    );
  }

  late final _SDL_ceilf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf27 =
      _SDL_ceilf27Ptr.asFunction<double Function(double)>();

  double SDL_copysign27(
    double x,
    double y,
  ) {
    return _SDL_copysign27(
      x,
      y,
    );
  }

  late final _SDL_copysign27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign27 =
      _SDL_copysign27Ptr.asFunction<double Function(double, double)>();

  double SDL_copysignf27(
    double x,
    double y,
  ) {
    return _SDL_copysignf27(
      x,
      y,
    );
  }

  late final _SDL_copysignf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf27 =
      _SDL_copysignf27Ptr.asFunction<double Function(double, double)>();

  double SDL_cos27(
    double x,
  ) {
    return _SDL_cos27(
      x,
    );
  }

  late final _SDL_cos27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos27 = _SDL_cos27Ptr.asFunction<double Function(double)>();

  double SDL_cosf27(
    double x,
  ) {
    return _SDL_cosf27(
      x,
    );
  }

  late final _SDL_cosf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf27 = _SDL_cosf27Ptr.asFunction<double Function(double)>();

  double SDL_exp27(
    double x,
  ) {
    return _SDL_exp27(
      x,
    );
  }

  late final _SDL_exp27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp27 = _SDL_exp27Ptr.asFunction<double Function(double)>();

  double SDL_expf27(
    double x,
  ) {
    return _SDL_expf27(
      x,
    );
  }

  late final _SDL_expf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf27 = _SDL_expf27Ptr.asFunction<double Function(double)>();

  double SDL_fabs27(
    double x,
  ) {
    return _SDL_fabs27(
      x,
    );
  }

  late final _SDL_fabs27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs27 = _SDL_fabs27Ptr.asFunction<double Function(double)>();

  double SDL_fabsf27(
    double x,
  ) {
    return _SDL_fabsf27(
      x,
    );
  }

  late final _SDL_fabsf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf27 =
      _SDL_fabsf27Ptr.asFunction<double Function(double)>();

  double SDL_floor27(
    double x,
  ) {
    return _SDL_floor27(
      x,
    );
  }

  late final _SDL_floor27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor27 =
      _SDL_floor27Ptr.asFunction<double Function(double)>();

  double SDL_floorf27(
    double x,
  ) {
    return _SDL_floorf27(
      x,
    );
  }

  late final _SDL_floorf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf27 =
      _SDL_floorf27Ptr.asFunction<double Function(double)>();

  double SDL_trunc27(
    double x,
  ) {
    return _SDL_trunc27(
      x,
    );
  }

  late final _SDL_trunc27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc27 =
      _SDL_trunc27Ptr.asFunction<double Function(double)>();

  double SDL_truncf27(
    double x,
  ) {
    return _SDL_truncf27(
      x,
    );
  }

  late final _SDL_truncf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf27 =
      _SDL_truncf27Ptr.asFunction<double Function(double)>();

  double SDL_fmod27(
    double x,
    double y,
  ) {
    return _SDL_fmod27(
      x,
      y,
    );
  }

  late final _SDL_fmod27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod27 =
      _SDL_fmod27Ptr.asFunction<double Function(double, double)>();

  double SDL_fmodf27(
    double x,
    double y,
  ) {
    return _SDL_fmodf27(
      x,
      y,
    );
  }

  late final _SDL_fmodf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf27 =
      _SDL_fmodf27Ptr.asFunction<double Function(double, double)>();

  double SDL_log28(
    double x,
  ) {
    return _SDL_log28(
      x,
    );
  }

  late final _SDL_log28Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log28 = _SDL_log28Ptr.asFunction<double Function(double)>();

  double SDL_logf27(
    double x,
  ) {
    return _SDL_logf27(
      x,
    );
  }

  late final _SDL_logf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf27 = _SDL_logf27Ptr.asFunction<double Function(double)>();

  double SDL_log1027(
    double x,
  ) {
    return _SDL_log1027(
      x,
    );
  }

  late final _SDL_log1027Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log1027 =
      _SDL_log1027Ptr.asFunction<double Function(double)>();

  double SDL_log10f27(
    double x,
  ) {
    return _SDL_log10f27(
      x,
    );
  }

  late final _SDL_log10f27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f27 =
      _SDL_log10f27Ptr.asFunction<double Function(double)>();

  double SDL_pow27(
    double x,
    double y,
  ) {
    return _SDL_pow27(
      x,
      y,
    );
  }

  late final _SDL_pow27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow27 =
      _SDL_pow27Ptr.asFunction<double Function(double, double)>();

  double SDL_powf27(
    double x,
    double y,
  ) {
    return _SDL_powf27(
      x,
      y,
    );
  }

  late final _SDL_powf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf27 =
      _SDL_powf27Ptr.asFunction<double Function(double, double)>();

  double SDL_round27(
    double x,
  ) {
    return _SDL_round27(
      x,
    );
  }

  late final _SDL_round27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_round');
  late final _SDL_round27 =
      _SDL_round27Ptr.asFunction<double Function(double)>();

  double SDL_roundf27(
    double x,
  ) {
    return _SDL_roundf27(
      x,
    );
  }

  late final _SDL_roundf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_roundf');
  late final _SDL_roundf27 =
      _SDL_roundf27Ptr.asFunction<double Function(double)>();

  int SDL_lround27(
    double x,
  ) {
    return _SDL_lround27(
      x,
    );
  }

  late final _SDL_lround27Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('SDL_lround');
  late final _SDL_lround27 =
      _SDL_lround27Ptr.asFunction<int Function(double)>();

  int SDL_lroundf27(
    double x,
  ) {
    return _SDL_lroundf27(
      x,
    );
  }

  late final _SDL_lroundf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('SDL_lroundf');
  late final _SDL_lroundf27 =
      _SDL_lroundf27Ptr.asFunction<int Function(double)>();

  double SDL_scalbn27(
    double x,
    int n,
  ) {
    return _SDL_scalbn27(
      x,
      n,
    );
  }

  late final _SDL_scalbn27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'SDL_scalbn');
  late final _SDL_scalbn27 =
      _SDL_scalbn27Ptr.asFunction<double Function(double, int)>();

  double SDL_scalbnf27(
    double x,
    int n,
  ) {
    return _SDL_scalbnf27(
      x,
      n,
    );
  }

  late final _SDL_scalbnf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf27 =
      _SDL_scalbnf27Ptr.asFunction<double Function(double, int)>();

  double SDL_sin27(
    double x,
  ) {
    return _SDL_sin27(
      x,
    );
  }

  late final _SDL_sin27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin27 = _SDL_sin27Ptr.asFunction<double Function(double)>();

  double SDL_sinf27(
    double x,
  ) {
    return _SDL_sinf27(
      x,
    );
  }

  late final _SDL_sinf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf27 = _SDL_sinf27Ptr.asFunction<double Function(double)>();

  double SDL_sqrt27(
    double x,
  ) {
    return _SDL_sqrt27(
      x,
    );
  }

  late final _SDL_sqrt27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt27 = _SDL_sqrt27Ptr.asFunction<double Function(double)>();

  double SDL_sqrtf27(
    double x,
  ) {
    return _SDL_sqrtf27(
      x,
    );
  }

  late final _SDL_sqrtf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf27 =
      _SDL_sqrtf27Ptr.asFunction<double Function(double)>();

  double SDL_tan27(
    double x,
  ) {
    return _SDL_tan27(
      x,
    );
  }

  late final _SDL_tan27Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan27 = _SDL_tan27Ptr.asFunction<double Function(double)>();

  double SDL_tanf27(
    double x,
  ) {
    return _SDL_tanf27(
      x,
    );
  }

  late final _SDL_tanf27Ptr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf27 = _SDL_tanf27Ptr.asFunction<double Function(double)>();

  SDL_iconv_t SDL_iconv_open27(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
  ) {
    return _SDL_iconv_open27(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open27Ptr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('SDL_iconv_open');
  late final _SDL_iconv_open27 = _SDL_iconv_open27Ptr.asFunction<
      SDL_iconv_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int SDL_iconv_close27(
    SDL_iconv_t cd,
  ) {
    return _SDL_iconv_close27(
      cd,
    );
  }

  late final _SDL_iconv_close27Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(SDL_iconv_t)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close27 =
      _SDL_iconv_close27Ptr.asFunction<int Function(SDL_iconv_t)>();

  int SDL_iconv27(
    SDL_iconv_t cd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> inbuf,
    ffi.Pointer<ffi.Size> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Char>> outbuf,
    ffi.Pointer<ffi.Size> outbytesleft,
  ) {
    return _SDL_iconv27(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              SDL_iconv_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('SDL_iconv');
  late final _SDL_iconv27 = _SDL_iconv27Ptr.asFunction<
      int Function(
          SDL_iconv_t,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ///
  /// \since This function is available since SDL 2.0.0.
  ffi.Pointer<ffi.Char> SDL_iconv_string27(
    ffi.Pointer<ffi.Char> tocode,
    ffi.Pointer<ffi.Char> fromcode,
    ffi.Pointer<ffi.Char> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string27(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SDL_iconv_string');
  late final _SDL_iconv_string27 = _SDL_iconv_string27Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();
}

typedef uintptr_t = ffi.UnsignedLongLong;

class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

class __crt_locale_data extends ffi.Opaque {}

class __crt_multibyte_data extends ffi.Opaque {}

class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

abstract class SDL_bool {
  static const int SDL_FALSE = 0;
  static const int SDL_TRUE = 1;
}

abstract class SDL_DUMMY_ENUM {
  static const int DUMMY_ENUM_VALUE = 0;
}

typedef SDL_malloc_func
    = ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>;
typedef SDL_calloc_func = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>;
typedef SDL_realloc_func = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)>>;
typedef SDL_free_func
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef Uint32 = ffi.Uint32;
typedef Sint64 = ffi.Int64;
typedef Uint64 = ffi.Uint64;
typedef va_list = ffi.Pointer<ffi.Char>;

class _SDL_iconv_t extends ffi.Opaque {}

typedef SDL_iconv_t = ffi.Pointer<_SDL_iconv_t>;

abstract class SDL_AssertState {
  /// < Retry the assert immediately.
  static const int SDL_ASSERTION_RETRY = 0;

  /// < Make the debugger trigger a breakpoint.
  static const int SDL_ASSERTION_BREAK = 1;

  /// < Terminate the program.
  static const int SDL_ASSERTION_ABORT = 2;

  /// < Ignore the assert.
  static const int SDL_ASSERTION_IGNORE = 3;

  /// < Ignore the assert from now on.
  static const int SDL_ASSERTION_ALWAYS_IGNORE = 4;
}

class SDL_AssertData extends ffi.Struct {
  @ffi.Int()
  external int always_ignore;

  @ffi.UnsignedInt()
  external int trigger_count;

  external ffi.Pointer<ffi.Char> condition;

  external ffi.Pointer<ffi.Char> filename;

  @ffi.Int()
  external int linenum;

  external ffi.Pointer<ffi.Char> function;

  external ffi.Pointer<SDL_AssertData> next;
}

/// A callback that fires when an SDL assertion fails.
///
/// \param data a pointer to the SDL_AssertData structure corresponding to the
/// current assertion
/// \param userdata what was passed as `userdata` to SDL_SetAssertionHandler()
/// \returns an SDL_AssertState value indicating how to handle the failure.
typedef SDL_AssertionHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Void>)>>;
typedef SDL_SpinLock = ffi.Int;

/// \brief A type representing an atomic integer value.  It is a struct
/// so people don't accidentally use numeric operations on it.
class SDL_atomic_t extends ffi.Struct {
  @ffi.Int()
  external int value;
}

abstract class SDL_errorcode {
  static const int SDL_ENOMEM = 0;
  static const int SDL_EFREAD = 1;
  static const int SDL_EFWRITE = 2;
  static const int SDL_EFSEEK = 3;
  static const int SDL_UNSUPPORTED = 4;
  static const int SDL_LASTERROR = 5;
}

class _SETJMP_FLOAT128 extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedLongLong> Part;
}

class _JUMP_BUFFER extends ffi.Struct {
  @ffi.UnsignedLongLong()
  external int Frame;

  @ffi.UnsignedLongLong()
  external int Rbx;

  @ffi.UnsignedLongLong()
  external int Rsp;

  @ffi.UnsignedLongLong()
  external int Rbp;

  @ffi.UnsignedLongLong()
  external int Rsi;

  @ffi.UnsignedLongLong()
  external int Rdi;

  @ffi.UnsignedLongLong()
  external int R12;

  @ffi.UnsignedLongLong()
  external int R13;

  @ffi.UnsignedLongLong()
  external int R14;

  @ffi.UnsignedLongLong()
  external int R15;

  @ffi.UnsignedLongLong()
  external int Rip;

  @ffi.UnsignedLong()
  external int MxCsr;

  @ffi.UnsignedShort()
  external int FpCsr;

  @ffi.UnsignedShort()
  external int Spare;

  external SETJMP_FLOAT128 Xmm6;

  external SETJMP_FLOAT128 Xmm7;

  external SETJMP_FLOAT128 Xmm8;

  external SETJMP_FLOAT128 Xmm9;

  external SETJMP_FLOAT128 Xmm10;

  external SETJMP_FLOAT128 Xmm11;

  external SETJMP_FLOAT128 Xmm12;

  external SETJMP_FLOAT128 Xmm13;

  external SETJMP_FLOAT128 Xmm14;

  external SETJMP_FLOAT128 Xmm15;
}

typedef SETJMP_FLOAT128 = _SETJMP_FLOAT128;

class __m64 extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int m64_u64;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> m64_f32;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> m64_i8;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Short> m64_i16;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> m64_i32;

  @ffi.LongLong()
  external int m64_i64;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedChar> m64_u8;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> m64_u16;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> m64_u32;
}

class __m128 extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Float> m128_f32;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedLongLong> m128_u64;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> m128_i8;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Short> m128_i16;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> m128_i32;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.LongLong> m128_i64;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> m128_u8;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedShort> m128_u16;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedInt> m128_u32;
}

class _heapinfo extends ffi.Struct {
  external ffi.Pointer<ffi.Int> _pentry;

  @ffi.Size()
  external int _size;

  @ffi.Int()
  external int _useflag;
}

class __m128i extends ffi.Union {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> m128i_i8;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Short> m128i_i16;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> m128i_i32;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.LongLong> m128i_i64;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> m128i_u8;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedShort> m128i_u16;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedInt> m128i_u32;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedLongLong> m128i_u64;
}

class __m128d extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Double> m128d_f64;
}

class __m256 extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Float> m256_f32;
}

class __m256d extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> m256d_f64;
}

class __m256i extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> m256i_i8;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Short> m256i_i16;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> m256i_i32;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.LongLong> m256i_i64;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> m256i_u8;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedShort> m256i_u16;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> m256i_u32;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedLongLong> m256i_u64;
}

class __m512 extends ffi.Union {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Float> m512_f32;
}

class __m512d extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Double> m512d_f64;
}

class __m512i extends ffi.Union {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> m512i_i8;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Short> m512i_i16;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int> m512i_i32;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.LongLong> m512i_i64;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> m512i_u8;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedShort> m512i_u16;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedInt> m512i_u32;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedLongLong> m512i_u64;
}

abstract class _MM_BROADCAST32_ENUM {
  static const int _MM_BROADCAST32_NONE = 0;
  static const int _MM_BROADCAST_1X16 = 1;
  static const int _MM_BROADCAST_4X16 = 2;
}

abstract class _MM_BROADCAST64_ENUM {
  static const int _MM_BROADCAST64_NONE = 0;
  static const int _MM_BROADCAST_1X8 = 1;
  static const int _MM_BROADCAST_4X8 = 2;
}

abstract class _MM_ROUND_MODE_ENUM {
  static const int _MM_ROUND_MODE_NEAREST = 0;
  static const int _MM_ROUND_MODE_DOWN = 1;
  static const int _MM_ROUND_MODE_UP = 2;
  static const int _MM_ROUND_MODE_TOWARD_ZERO = 3;
  static const int _MM_ROUND_MODE_DEFAULT = 4;
  static const int _MM_ROUND_MODE_NO_EXC = 8;
}

abstract class _MM_EXP_ADJ_ENUM {
  static const int _MM_EXPADJ_NONE = 0;
  static const int _MM_EXPADJ_4 = 1;
  static const int _MM_EXPADJ_5 = 2;
  static const int _MM_EXPADJ_8 = 3;
  static const int _MM_EXPADJ_16 = 4;
  static const int _MM_EXPADJ_24 = 5;
  static const int _MM_EXPADJ_31 = 6;
  static const int _MM_EXPADJ_32 = 7;
}

abstract class _MM_INDEX_SCALE_ENUM {
  static const int _MM_SCALE_1 = 1;
  static const int _MM_SCALE_2 = 2;
  static const int _MM_SCALE_4 = 4;
  static const int _MM_SCALE_8 = 8;
}

abstract class _MM_PERM_ENUM {
  static const int _MM_PERM_AAAA = 0;
  static const int _MM_PERM_AAAB = 1;
  static const int _MM_PERM_AAAC = 2;
  static const int _MM_PERM_AAAD = 3;
  static const int _MM_PERM_AABA = 4;
  static const int _MM_PERM_AABB = 5;
  static const int _MM_PERM_AABC = 6;
  static const int _MM_PERM_AABD = 7;
  static const int _MM_PERM_AACA = 8;
  static const int _MM_PERM_AACB = 9;
  static const int _MM_PERM_AACC = 10;
  static const int _MM_PERM_AACD = 11;
  static const int _MM_PERM_AADA = 12;
  static const int _MM_PERM_AADB = 13;
  static const int _MM_PERM_AADC = 14;
  static const int _MM_PERM_AADD = 15;
  static const int _MM_PERM_ABAA = 16;
  static const int _MM_PERM_ABAB = 17;
  static const int _MM_PERM_ABAC = 18;
  static const int _MM_PERM_ABAD = 19;
  static const int _MM_PERM_ABBA = 20;
  static const int _MM_PERM_ABBB = 21;
  static const int _MM_PERM_ABBC = 22;
  static const int _MM_PERM_ABBD = 23;
  static const int _MM_PERM_ABCA = 24;
  static const int _MM_PERM_ABCB = 25;
  static const int _MM_PERM_ABCC = 26;
  static const int _MM_PERM_ABCD = 27;
  static const int _MM_PERM_ABDA = 28;
  static const int _MM_PERM_ABDB = 29;
  static const int _MM_PERM_ABDC = 30;
  static const int _MM_PERM_ABDD = 31;
  static const int _MM_PERM_ACAA = 32;
  static const int _MM_PERM_ACAB = 33;
  static const int _MM_PERM_ACAC = 34;
  static const int _MM_PERM_ACAD = 35;
  static const int _MM_PERM_ACBA = 36;
  static const int _MM_PERM_ACBB = 37;
  static const int _MM_PERM_ACBC = 38;
  static const int _MM_PERM_ACBD = 39;
  static const int _MM_PERM_ACCA = 40;
  static const int _MM_PERM_ACCB = 41;
  static const int _MM_PERM_ACCC = 42;
  static const int _MM_PERM_ACCD = 43;
  static const int _MM_PERM_ACDA = 44;
  static const int _MM_PERM_ACDB = 45;
  static const int _MM_PERM_ACDC = 46;
  static const int _MM_PERM_ACDD = 47;
  static const int _MM_PERM_ADAA = 48;
  static const int _MM_PERM_ADAB = 49;
  static const int _MM_PERM_ADAC = 50;
  static const int _MM_PERM_ADAD = 51;
  static const int _MM_PERM_ADBA = 52;
  static const int _MM_PERM_ADBB = 53;
  static const int _MM_PERM_ADBC = 54;
  static const int _MM_PERM_ADBD = 55;
  static const int _MM_PERM_ADCA = 56;
  static const int _MM_PERM_ADCB = 57;
  static const int _MM_PERM_ADCC = 58;
  static const int _MM_PERM_ADCD = 59;
  static const int _MM_PERM_ADDA = 60;
  static const int _MM_PERM_ADDB = 61;
  static const int _MM_PERM_ADDC = 62;
  static const int _MM_PERM_ADDD = 63;
  static const int _MM_PERM_BAAA = 64;
  static const int _MM_PERM_BAAB = 65;
  static const int _MM_PERM_BAAC = 66;
  static const int _MM_PERM_BAAD = 67;
  static const int _MM_PERM_BABA = 68;
  static const int _MM_PERM_BABB = 69;
  static const int _MM_PERM_BABC = 70;
  static const int _MM_PERM_BABD = 71;
  static const int _MM_PERM_BACA = 72;
  static const int _MM_PERM_BACB = 73;
  static const int _MM_PERM_BACC = 74;
  static const int _MM_PERM_BACD = 75;
  static const int _MM_PERM_BADA = 76;
  static const int _MM_PERM_BADB = 77;
  static const int _MM_PERM_BADC = 78;
  static const int _MM_PERM_BADD = 79;
  static const int _MM_PERM_BBAA = 80;
  static const int _MM_PERM_BBAB = 81;
  static const int _MM_PERM_BBAC = 82;
  static const int _MM_PERM_BBAD = 83;
  static const int _MM_PERM_BBBA = 84;
  static const int _MM_PERM_BBBB = 85;
  static const int _MM_PERM_BBBC = 86;
  static const int _MM_PERM_BBBD = 87;
  static const int _MM_PERM_BBCA = 88;
  static const int _MM_PERM_BBCB = 89;
  static const int _MM_PERM_BBCC = 90;
  static const int _MM_PERM_BBCD = 91;
  static const int _MM_PERM_BBDA = 92;
  static const int _MM_PERM_BBDB = 93;
  static const int _MM_PERM_BBDC = 94;
  static const int _MM_PERM_BBDD = 95;
  static const int _MM_PERM_BCAA = 96;
  static const int _MM_PERM_BCAB = 97;
  static const int _MM_PERM_BCAC = 98;
  static const int _MM_PERM_BCAD = 99;
  static const int _MM_PERM_BCBA = 100;
  static const int _MM_PERM_BCBB = 101;
  static const int _MM_PERM_BCBC = 102;
  static const int _MM_PERM_BCBD = 103;
  static const int _MM_PERM_BCCA = 104;
  static const int _MM_PERM_BCCB = 105;
  static const int _MM_PERM_BCCC = 106;
  static const int _MM_PERM_BCCD = 107;
  static const int _MM_PERM_BCDA = 108;
  static const int _MM_PERM_BCDB = 109;
  static const int _MM_PERM_BCDC = 110;
  static const int _MM_PERM_BCDD = 111;
  static const int _MM_PERM_BDAA = 112;
  static const int _MM_PERM_BDAB = 113;
  static const int _MM_PERM_BDAC = 114;
  static const int _MM_PERM_BDAD = 115;
  static const int _MM_PERM_BDBA = 116;
  static const int _MM_PERM_BDBB = 117;
  static const int _MM_PERM_BDBC = 118;
  static const int _MM_PERM_BDBD = 119;
  static const int _MM_PERM_BDCA = 120;
  static const int _MM_PERM_BDCB = 121;
  static const int _MM_PERM_BDCC = 122;
  static const int _MM_PERM_BDCD = 123;
  static const int _MM_PERM_BDDA = 124;
  static const int _MM_PERM_BDDB = 125;
  static const int _MM_PERM_BDDC = 126;
  static const int _MM_PERM_BDDD = 127;
  static const int _MM_PERM_CAAA = 128;
  static const int _MM_PERM_CAAB = 129;
  static const int _MM_PERM_CAAC = 130;
  static const int _MM_PERM_CAAD = 131;
  static const int _MM_PERM_CABA = 132;
  static const int _MM_PERM_CABB = 133;
  static const int _MM_PERM_CABC = 134;
  static const int _MM_PERM_CABD = 135;
  static const int _MM_PERM_CACA = 136;
  static const int _MM_PERM_CACB = 137;
  static const int _MM_PERM_CACC = 138;
  static const int _MM_PERM_CACD = 139;
  static const int _MM_PERM_CADA = 140;
  static const int _MM_PERM_CADB = 141;
  static const int _MM_PERM_CADC = 142;
  static const int _MM_PERM_CADD = 143;
  static const int _MM_PERM_CBAA = 144;
  static const int _MM_PERM_CBAB = 145;
  static const int _MM_PERM_CBAC = 146;
  static const int _MM_PERM_CBAD = 147;
  static const int _MM_PERM_CBBA = 148;
  static const int _MM_PERM_CBBB = 149;
  static const int _MM_PERM_CBBC = 150;
  static const int _MM_PERM_CBBD = 151;
  static const int _MM_PERM_CBCA = 152;
  static const int _MM_PERM_CBCB = 153;
  static const int _MM_PERM_CBCC = 154;
  static const int _MM_PERM_CBCD = 155;
  static const int _MM_PERM_CBDA = 156;
  static const int _MM_PERM_CBDB = 157;
  static const int _MM_PERM_CBDC = 158;
  static const int _MM_PERM_CBDD = 159;
  static const int _MM_PERM_CCAA = 160;
  static const int _MM_PERM_CCAB = 161;
  static const int _MM_PERM_CCAC = 162;
  static const int _MM_PERM_CCAD = 163;
  static const int _MM_PERM_CCBA = 164;
  static const int _MM_PERM_CCBB = 165;
  static const int _MM_PERM_CCBC = 166;
  static const int _MM_PERM_CCBD = 167;
  static const int _MM_PERM_CCCA = 168;
  static const int _MM_PERM_CCCB = 169;
  static const int _MM_PERM_CCCC = 170;
  static const int _MM_PERM_CCCD = 171;
  static const int _MM_PERM_CCDA = 172;
  static const int _MM_PERM_CCDB = 173;
  static const int _MM_PERM_CCDC = 174;
  static const int _MM_PERM_CCDD = 175;
  static const int _MM_PERM_CDAA = 176;
  static const int _MM_PERM_CDAB = 177;
  static const int _MM_PERM_CDAC = 178;
  static const int _MM_PERM_CDAD = 179;
  static const int _MM_PERM_CDBA = 180;
  static const int _MM_PERM_CDBB = 181;
  static const int _MM_PERM_CDBC = 182;
  static const int _MM_PERM_CDBD = 183;
  static const int _MM_PERM_CDCA = 184;
  static const int _MM_PERM_CDCB = 185;
  static const int _MM_PERM_CDCC = 186;
  static const int _MM_PERM_CDCD = 187;
  static const int _MM_PERM_CDDA = 188;
  static const int _MM_PERM_CDDB = 189;
  static const int _MM_PERM_CDDC = 190;
  static const int _MM_PERM_CDDD = 191;
  static const int _MM_PERM_DAAA = 192;
  static const int _MM_PERM_DAAB = 193;
  static const int _MM_PERM_DAAC = 194;
  static const int _MM_PERM_DAAD = 195;
  static const int _MM_PERM_DABA = 196;
  static const int _MM_PERM_DABB = 197;
  static const int _MM_PERM_DABC = 198;
  static const int _MM_PERM_DABD = 199;
  static const int _MM_PERM_DACA = 200;
  static const int _MM_PERM_DACB = 201;
  static const int _MM_PERM_DACC = 202;
  static const int _MM_PERM_DACD = 203;
  static const int _MM_PERM_DADA = 204;
  static const int _MM_PERM_DADB = 205;
  static const int _MM_PERM_DADC = 206;
  static const int _MM_PERM_DADD = 207;
  static const int _MM_PERM_DBAA = 208;
  static const int _MM_PERM_DBAB = 209;
  static const int _MM_PERM_DBAC = 210;
  static const int _MM_PERM_DBAD = 211;
  static const int _MM_PERM_DBBA = 212;
  static const int _MM_PERM_DBBB = 213;
  static const int _MM_PERM_DBBC = 214;
  static const int _MM_PERM_DBBD = 215;
  static const int _MM_PERM_DBCA = 216;
  static const int _MM_PERM_DBCB = 217;
  static const int _MM_PERM_DBCC = 218;
  static const int _MM_PERM_DBCD = 219;
  static const int _MM_PERM_DBDA = 220;
  static const int _MM_PERM_DBDB = 221;
  static const int _MM_PERM_DBDC = 222;
  static const int _MM_PERM_DBDD = 223;
  static const int _MM_PERM_DCAA = 224;
  static const int _MM_PERM_DCAB = 225;
  static const int _MM_PERM_DCAC = 226;
  static const int _MM_PERM_DCAD = 227;
  static const int _MM_PERM_DCBA = 228;
  static const int _MM_PERM_DCBB = 229;
  static const int _MM_PERM_DCBC = 230;
  static const int _MM_PERM_DCBD = 231;
  static const int _MM_PERM_DCCA = 232;
  static const int _MM_PERM_DCCB = 233;
  static const int _MM_PERM_DCCC = 234;
  static const int _MM_PERM_DCCD = 235;
  static const int _MM_PERM_DCDA = 236;
  static const int _MM_PERM_DCDB = 237;
  static const int _MM_PERM_DCDC = 238;
  static const int _MM_PERM_DCDD = 239;
  static const int _MM_PERM_DDAA = 240;
  static const int _MM_PERM_DDAB = 241;
  static const int _MM_PERM_DDAC = 242;
  static const int _MM_PERM_DDAD = 243;
  static const int _MM_PERM_DDBA = 244;
  static const int _MM_PERM_DDBB = 245;
  static const int _MM_PERM_DDBC = 246;
  static const int _MM_PERM_DDBD = 247;
  static const int _MM_PERM_DDCA = 248;
  static const int _MM_PERM_DDCB = 249;
  static const int _MM_PERM_DDCC = 250;
  static const int _MM_PERM_DDCD = 251;
  static const int _MM_PERM_DDDA = 252;
  static const int _MM_PERM_DDDB = 253;
  static const int _MM_PERM_DDDC = 254;
  static const int _MM_PERM_DDDD = 255;
}

abstract class _MM_FIXUPRESULT_ENUM {
  static const int _MM_FIXUP_NO_CHANGE = 0;
  static const int _MM_FIXUP_NEG_INF = 1;
  static const int _MM_FIXUP_NEG_ZERO = 2;
  static const int _MM_FIXUP_POS_ZERO = 3;
  static const int _MM_FIXUP_POS_INF = 4;
  static const int _MM_FIXUP_NAN = 5;
  static const int _MM_FIXUP_MAX_FLOAT = 6;
  static const int _MM_FIXUP_MIN_FLOAT = 7;
}

abstract class _MM_MANTISSA_NORM_ENUM {
  static const int _MM_MANT_NORM_1_2 = 0;
  static const int _MM_MANT_NORM_p5_2 = 1;
  static const int _MM_MANT_NORM_p5_1 = 2;
  static const int _MM_MANT_NORM_p75_1p5 = 3;
}

abstract class _MM_MANTISSA_SIGN_ENUM {
  static const int _MM_MANT_SIGN_src = 0;
  static const int _MM_MANT_SIGN_zero = 1;
  static const int _MM_MANT_SIGN_nan = 2;
}

abstract class _MM_CMPINT_ENUM {
  static const int _MM_CMPINT_EQ = 0;
  static const int _MM_CMPINT_LT = 1;
  static const int _MM_CMPINT_LE = 2;
  static const int _MM_CMPINT_UNUSED = 3;
  static const int _MM_CMPINT_NE = 4;
  static const int _MM_CMPINT_NLT = 5;
  static const int _MM_CMPINT_NLE = 6;
}

class rmp_seg extends ffi.Struct {
  @ffi.UnsignedLongLong()
  external int rmp_gpa;

  @ffi.Char()
  external int rmp_entry;

  @ffi.Char()
  external int rmp_pageSize;

  @ffi.Char()
  external int rmp_pageMark;

  @ffi.Char()
  external int rmp_reserved;

  @ffi.Int()
  external int rmp_ASID;
}

class SDL_mutex extends ffi.Opaque {}

class SDL_semaphore extends ffi.Opaque {}

typedef SDL_sem = SDL_semaphore;

class SDL_cond extends ffi.Opaque {}

class _exception extends ffi.Struct {
  @ffi.Int()
  external int type;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

class _complex extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

class _double_val extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> _Sh;

  @ffi.Double()
  external double _Val;
}

class _float_val extends ffi.Union {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedShort> _Sh;

  @ffi.Float()
  external double _Val;
}

class _ldouble_val extends ffi.Opaque {}

class _float_const extends ffi.Opaque {}

abstract class _crt_argv_mode {
  static const int _crt_argv_no_arguments = 0;
  static const int _crt_argv_unexpanded_arguments = 1;
  static const int _crt_argv_expanded_arguments = 2;
}

abstract class _crt_exit_return_mode {
  static const int _crt_exit_terminate_process = 0;
  static const int _crt_exit_return_to_caller = 1;
}

abstract class _crt_exit_cleanup_mode {
  static const int _crt_exit_full_cleanup = 0;
  static const int _crt_exit_quick_cleanup = 1;
  static const int _crt_exit_no_cleanup = 2;
}

class _EXCEPTION_POINTERS extends ffi.Opaque {}

abstract class _crt_app_type {
  static const int _crt_unknown_app = 0;
  static const int _crt_console_app = 1;
  static const int _crt_gui_app = 2;
}

class _onexit_table_t extends ffi.Struct {
  external ffi.Pointer<_PVFV> _first;

  external ffi.Pointer<_PVFV> _last;

  external ffi.Pointer<_PVFV> _end;
}

typedef _PVFV = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

class SDL_Thread extends ffi.Opaque {}

/// The SDL thread priority.
///
/// SDL will make system changes as necessary in order to apply the thread priority.
/// Code which attempts to control thread state related to priority should be aware
/// that calling SDL_SetThreadPriority may alter such state.
/// SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.
///
/// \note On many systems you require special privileges to set high or time critical priority.
abstract class SDL_ThreadPriority {
  static const int SDL_THREAD_PRIORITY_LOW = 0;
  static const int SDL_THREAD_PRIORITY_NORMAL = 1;
  static const int SDL_THREAD_PRIORITY_HIGH = 2;
  static const int SDL_THREAD_PRIORITY_TIME_CRITICAL = 3;
}

/// The function passed to SDL_CreateThread().
///
/// \param data what was passed as `data` to SDL_CreateThread()
/// \returns a value that can be reported through SDL_WaitThread().
typedef SDL_ThreadFunction
    = ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>;
typedef pfnSDL_CurrentBeginThread = ffi.Pointer<
    ffi.NativeFunction<
        uintptr_t Function(
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedInt,
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>)>>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.UnsignedInt>)>>;
typedef pfnSDL_CurrentEndThread
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>;
typedef SDL_threadID = ffi.UnsignedLong;
typedef SDL_TLSID = ffi.UnsignedInt;

/// This is the read/write operation structure -- very basic.
class SDL_RWops extends ffi.Struct {
  /// Return the size of the file in this rwops, or -1 if unknown
  external ffi
          .Pointer<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>
      size;

  /// Seek to \c offset relative to \c whence, one of stdio's whence values:
  /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
  ///
  /// \return the final offset in the data stream, or -1 on error.
  external ffi.Pointer<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<SDL_RWops>, Sint64, ffi.Int)>> seek;

  /// Read up to \c maxnum objects each of size \c size from the data
  /// stream to the area pointed at by \c ptr.
  ///
  /// \return the number of objects read, or 0 at error or end of file.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>> read;

  /// Write exactly \c num objects each of size \c size from the area
  /// pointed at by \c ptr to data stream.
  ///
  /// \return the number of objects written, or 0 at error or end of file.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Size)>> write;

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// \return 0 if successful or -1 on write error when flushing data.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SDL_RWops>)>>
      close;

  @Uint32()
  external int type;

  external UnnamedUnion1 hidden;
}

class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 windowsio;

  external UnnamedStruct3 mem;

  external UnnamedStruct4 unknown;
}

class UnnamedStruct1 extends ffi.Struct {
  @ffi.Int32()
  external int append;

  external ffi.Pointer<ffi.Void> h;

  external UnnamedStruct2 buffer;
}

class UnnamedStruct2 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int left;
}

class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<Uint8> base;

  external ffi.Pointer<Uint8> here;

  external ffi.Pointer<Uint8> stop;
}

typedef Uint8 = ffi.Uint8;

class UnnamedStruct4 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data1;

  external ffi.Pointer<ffi.Void> data2;
}

typedef Uint16 = ffi.Uint16;

/// The calculated values in this structure are calculated by SDL_OpenAudio().
///
/// For multi-channel audio, the default SDL channel mapping is:
/// 2:  FL FR                       (stereo)
/// 3:  FL FR LFE                   (2.1 surround)
/// 4:  FL FR BL BR                 (quad)
/// 5:  FL FR FC BL BR              (quad + center)
/// 6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)
/// 7:  FL FR FC LFE BC SL SR       (6.1 surround)
/// 8:  FL FR FC LFE BL BR SL SR    (7.1 surround)
class SDL_AudioSpec extends ffi.Struct {
  /// < DSP frequency -- samples per second
  @ffi.Int()
  external int freq;

  /// < Audio data format
  @SDL_AudioFormat()
  external int format;

  /// < Number of channels: 1 mono, 2 stereo
  @Uint8()
  external int channels;

  /// < Audio buffer silence value (calculated)
  @Uint8()
  external int silence;

  /// < Audio buffer size in sample FRAMES (total samples divided by channel count)
  @Uint16()
  external int samples;

  /// < Necessary for some compile environments
  @Uint16()
  external int padding;

  /// < Audio buffer size in bytes (calculated)
  @Uint32()
  external int size;

  /// < Callback that feeds the audio device (NULL to use SDL_QueueAudio()).
  external SDL_AudioCallback callback;

  /// < Userdata passed to callback (ignored for NULL callbacks).
  external ffi.Pointer<ffi.Void> userdata;
}

/// \brief Audio format flags.
///
/// These are what the 16 bits in SDL_AudioFormat currently mean...
/// (Unspecified bits are always zero).
///
/// \verbatim
/// ++-----------------------sample is signed if set
/// ||
/// ||       ++-----------sample is bigendian if set
/// ||       ||
/// ||       ||          ++---sample is float if set
/// ||       ||          ||
/// ||       ||          || +---sample bit size---+
/// ||       ||          || |                     |
/// 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
/// \endverbatim
///
/// There are macros in SDL 2.0 and later to query these bits.
typedef SDL_AudioFormat = Uint16;

/// This function is called when the audio device needs more data.
///
/// \param userdata An application-specific parameter saved in
/// the SDL_AudioSpec structure
/// \param stream A pointer to the audio data buffer.
/// \param len    The length of that buffer in bytes.
///
/// Once the callback returns, the buffer will no longer be valid.
/// Stereo samples are stored in a LRLRLR ordering.
///
/// You can choose to avoid callbacks and use SDL_QueueAudio() instead, if
/// you like. Just open your audio device with a NULL callback.
typedef SDL_AudioCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<Uint8>, ffi.Int)>>;

class SDL_AudioCVT extends ffi.Struct {
  /// < Set to 1 if conversion possible
  @ffi.Int()
  external int needed;

  /// < Source audio format
  @SDL_AudioFormat()
  external int src_format;

  /// < Target audio format
  @SDL_AudioFormat()
  external int dst_format;

  /// < Rate conversion increment
  @ffi.Double()
  external double rate_incr;

  /// < Buffer to hold entire audio data
  external ffi.Pointer<Uint8> buf;

  /// < Length of original audio buffer
  @ffi.Int()
  external int len;

  /// < Length of converted audio buffer
  @ffi.Int()
  external int len_cvt;

  /// < buffer must be len*len_mult big
  @ffi.Int()
  external int len_mult;

  /// < Given len, final size is len*len_ratio
  @ffi.Double()
  external double len_ratio;

  @ffi.Array.multi([10])
  external ffi.Array<SDL_AudioFilter> filters;

  /// < Current audio conversion function
  @ffi.Int()
  external int filter_index;
}

typedef SDL_AudioFilter = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<SDL_AudioCVT>, SDL_AudioFormat)>>;

/// SDL Audio Device IDs.
///
/// A successful call to SDL_OpenAudio() is always device id 1, and legacy
/// SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
/// always returns devices >= 2 on success. The legacy calls are good both
/// for backwards compatibility and when you don't care about multiple,
/// specific, or capture devices.
typedef SDL_AudioDeviceID = Uint32;

abstract class SDL_AudioStatus {
  static const int SDL_AUDIO_STOPPED = 0;
  static const int SDL_AUDIO_PLAYING = 1;
  static const int SDL_AUDIO_PAUSED = 2;
}

class _SDL_AudioStream extends ffi.Opaque {}

typedef SDL_AudioStream = _SDL_AudioStream;

/// Pixel type.
abstract class SDL_PixelType {
  static const int SDL_PIXELTYPE_UNKNOWN = 0;
  static const int SDL_PIXELTYPE_INDEX1 = 1;
  static const int SDL_PIXELTYPE_INDEX4 = 2;
  static const int SDL_PIXELTYPE_INDEX8 = 3;
  static const int SDL_PIXELTYPE_PACKED8 = 4;
  static const int SDL_PIXELTYPE_PACKED16 = 5;
  static const int SDL_PIXELTYPE_PACKED32 = 6;
  static const int SDL_PIXELTYPE_ARRAYU8 = 7;
  static const int SDL_PIXELTYPE_ARRAYU16 = 8;
  static const int SDL_PIXELTYPE_ARRAYU32 = 9;
  static const int SDL_PIXELTYPE_ARRAYF16 = 10;
  static const int SDL_PIXELTYPE_ARRAYF32 = 11;
}

/// Bitmap pixel order, high bit -> low bit.
abstract class SDL_BitmapOrder {
  static const int SDL_BITMAPORDER_NONE = 0;
  static const int SDL_BITMAPORDER_4321 = 1;
  static const int SDL_BITMAPORDER_1234 = 2;
}

/// Packed component order, high bit -> low bit.
abstract class SDL_PackedOrder {
  static const int SDL_PACKEDORDER_NONE = 0;
  static const int SDL_PACKEDORDER_XRGB = 1;
  static const int SDL_PACKEDORDER_RGBX = 2;
  static const int SDL_PACKEDORDER_ARGB = 3;
  static const int SDL_PACKEDORDER_RGBA = 4;
  static const int SDL_PACKEDORDER_XBGR = 5;
  static const int SDL_PACKEDORDER_BGRX = 6;
  static const int SDL_PACKEDORDER_ABGR = 7;
  static const int SDL_PACKEDORDER_BGRA = 8;
}

/// Array component order, low byte -> high byte.
abstract class SDL_ArrayOrder {
  static const int SDL_ARRAYORDER_NONE = 0;
  static const int SDL_ARRAYORDER_RGB = 1;
  static const int SDL_ARRAYORDER_RGBA = 2;
  static const int SDL_ARRAYORDER_ARGB = 3;
  static const int SDL_ARRAYORDER_BGR = 4;
  static const int SDL_ARRAYORDER_BGRA = 5;
  static const int SDL_ARRAYORDER_ABGR = 6;
}

/// Packed component layout.
abstract class SDL_PackedLayout {
  static const int SDL_PACKEDLAYOUT_NONE = 0;
  static const int SDL_PACKEDLAYOUT_332 = 1;
  static const int SDL_PACKEDLAYOUT_4444 = 2;
  static const int SDL_PACKEDLAYOUT_1555 = 3;
  static const int SDL_PACKEDLAYOUT_5551 = 4;
  static const int SDL_PACKEDLAYOUT_565 = 5;
  static const int SDL_PACKEDLAYOUT_8888 = 6;
  static const int SDL_PACKEDLAYOUT_2101010 = 7;
  static const int SDL_PACKEDLAYOUT_1010102 = 8;
}

abstract class SDL_PixelFormatEnum {
  static const int SDL_PIXELFORMAT_UNKNOWN = 0;
  static const int SDL_PIXELFORMAT_INDEX1LSB = 286261504;
  static const int SDL_PIXELFORMAT_INDEX1MSB = 287310080;
  static const int SDL_PIXELFORMAT_INDEX4LSB = 303039488;
  static const int SDL_PIXELFORMAT_INDEX4MSB = 304088064;
  static const int SDL_PIXELFORMAT_INDEX8 = 318769153;
  static const int SDL_PIXELFORMAT_RGB332 = 336660481;
  static const int SDL_PIXELFORMAT_XRGB4444 = 353504258;
  static const int SDL_PIXELFORMAT_RGB444 = 353504258;
  static const int SDL_PIXELFORMAT_XBGR4444 = 357698562;
  static const int SDL_PIXELFORMAT_BGR444 = 357698562;
  static const int SDL_PIXELFORMAT_XRGB1555 = 353570562;
  static const int SDL_PIXELFORMAT_RGB555 = 353570562;
  static const int SDL_PIXELFORMAT_XBGR1555 = 357764866;
  static const int SDL_PIXELFORMAT_BGR555 = 357764866;
  static const int SDL_PIXELFORMAT_ARGB4444 = 355602434;
  static const int SDL_PIXELFORMAT_RGBA4444 = 356651010;
  static const int SDL_PIXELFORMAT_ABGR4444 = 359796738;
  static const int SDL_PIXELFORMAT_BGRA4444 = 360845314;
  static const int SDL_PIXELFORMAT_ARGB1555 = 355667970;
  static const int SDL_PIXELFORMAT_RGBA5551 = 356782082;
  static const int SDL_PIXELFORMAT_ABGR1555 = 359862274;
  static const int SDL_PIXELFORMAT_BGRA5551 = 360976386;
  static const int SDL_PIXELFORMAT_RGB565 = 353701890;
  static const int SDL_PIXELFORMAT_BGR565 = 357896194;
  static const int SDL_PIXELFORMAT_RGB24 = 386930691;
  static const int SDL_PIXELFORMAT_BGR24 = 390076419;
  static const int SDL_PIXELFORMAT_XRGB8888 = 370546692;
  static const int SDL_PIXELFORMAT_RGB888 = 370546692;
  static const int SDL_PIXELFORMAT_RGBX8888 = 371595268;
  static const int SDL_PIXELFORMAT_XBGR8888 = 374740996;
  static const int SDL_PIXELFORMAT_BGR888 = 374740996;
  static const int SDL_PIXELFORMAT_BGRX8888 = 375789572;
  static const int SDL_PIXELFORMAT_ARGB8888 = 372645892;
  static const int SDL_PIXELFORMAT_RGBA8888 = 373694468;
  static const int SDL_PIXELFORMAT_ABGR8888 = 376840196;
  static const int SDL_PIXELFORMAT_BGRA8888 = 377888772;
  static const int SDL_PIXELFORMAT_ARGB2101010 = 372711428;
  static const int SDL_PIXELFORMAT_RGBA32 = 376840196;
  static const int SDL_PIXELFORMAT_ARGB32 = 377888772;
  static const int SDL_PIXELFORMAT_BGRA32 = 372645892;
  static const int SDL_PIXELFORMAT_ABGR32 = 373694468;

  /// < Planar mode: Y + V + U  (3 planes)
  static const int SDL_PIXELFORMAT_YV12 = 842094169;

  /// < Planar mode: Y + U + V  (3 planes)
  static const int SDL_PIXELFORMAT_IYUV = 1448433993;

  /// < Packed mode: Y0+U0+Y1+V0 (1 plane)
  static const int SDL_PIXELFORMAT_YUY2 = 844715353;

  /// < Packed mode: U0+Y0+V0+Y1 (1 plane)
  static const int SDL_PIXELFORMAT_UYVY = 1498831189;

  /// < Packed mode: Y0+V0+Y1+U0 (1 plane)
  static const int SDL_PIXELFORMAT_YVYU = 1431918169;

  /// < Planar mode: Y + U/V interleaved  (2 planes)
  static const int SDL_PIXELFORMAT_NV12 = 842094158;

  /// < Planar mode: Y + V/U interleaved  (2 planes)
  static const int SDL_PIXELFORMAT_NV21 = 825382478;

  /// < Android video texture format
  static const int SDL_PIXELFORMAT_EXTERNAL_OES = 542328143;
}

/// The bits of this structure can be directly reinterpreted as an integer-packed
/// color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888
/// on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems).
class SDL_Color extends ffi.Struct {
  @Uint8()
  external int r;

  @Uint8()
  external int g;

  @Uint8()
  external int b;

  @Uint8()
  external int a;
}

class SDL_Palette extends ffi.Struct {
  @ffi.Int()
  external int ncolors;

  external ffi.Pointer<SDL_Color> colors;

  @Uint32()
  external int version;

  @ffi.Int()
  external int refcount;
}

/// \note Everything in the pixel format structure is read-only.
class SDL_PixelFormat extends ffi.Struct {
  @Uint32()
  external int format;

  external ffi.Pointer<SDL_Palette> palette;

  @Uint8()
  external int BitsPerPixel;

  @Uint8()
  external int BytesPerPixel;

  @ffi.Array.multi([2])
  external ffi.Array<Uint8> padding;

  @Uint32()
  external int Rmask;

  @Uint32()
  external int Gmask;

  @Uint32()
  external int Bmask;

  @Uint32()
  external int Amask;

  @Uint8()
  external int Rloss;

  @Uint8()
  external int Gloss;

  @Uint8()
  external int Bloss;

  @Uint8()
  external int Aloss;

  @Uint8()
  external int Rshift;

  @Uint8()
  external int Gshift;

  @Uint8()
  external int Bshift;

  @Uint8()
  external int Ashift;

  @ffi.Int()
  external int refcount;

  external ffi.Pointer<SDL_PixelFormat> next;
}

/// The structure that defines a point (integer)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
class SDL_Point extends ffi.Struct {
  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;
}

/// The structure that defines a point (floating point)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
class SDL_FPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

/// A rectangle, with the origin at the upper left (integer).
///
/// \sa SDL_RectEmpty
/// \sa SDL_RectEquals
/// \sa SDL_HasIntersection
/// \sa SDL_IntersectRect
/// \sa SDL_UnionRect
/// \sa SDL_EnclosePoints
class SDL_Rect extends ffi.Struct {
  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;

  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;
}

/// A rectangle, with the origin at the upper left (floating point).
class SDL_FRect extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;
}

/// \brief The blend mode used in SDL_RenderCopy() and drawing operations.
abstract class SDL_BlendMode {
  /// < no blending
  /// dstRGBA = srcRGBA
  static const int SDL_BLENDMODE_NONE = 0;

  /// < alpha blending
  /// dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
  /// dstA = srcA + (dstA * (1-srcA))
  static const int SDL_BLENDMODE_BLEND = 1;

  /// < additive blending
  /// dstRGB = (srcRGB * srcA) + dstRGB
  /// dstA = dstA
  static const int SDL_BLENDMODE_ADD = 2;

  /// < color modulate
  /// dstRGB = srcRGB * dstRGB
  /// dstA = dstA
  static const int SDL_BLENDMODE_MOD = 4;

  /// < color multiply
  /// dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
  /// dstA = (srcA * dstA) + (dstA * (1-srcA))
  static const int SDL_BLENDMODE_MUL = 8;
  static const int SDL_BLENDMODE_INVALID = 2147483647;
}

/// \brief The blend operation used when combining source and destination pixel components
abstract class SDL_BlendOperation {
  /// < dst + src: supported by all renderers
  static const int SDL_BLENDOPERATION_ADD = 1;

  /// < dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES
  static const int SDL_BLENDOPERATION_SUBTRACT = 2;

  /// < src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES
  static const int SDL_BLENDOPERATION_REV_SUBTRACT = 3;

  /// < min(dst, src) : supported by D3D11
  static const int SDL_BLENDOPERATION_MINIMUM = 4;

  /// < max(dst, src) : supported by D3D11
  static const int SDL_BLENDOPERATION_MAXIMUM = 5;
}

/// \brief The normalized factor used to multiply pixel components
abstract class SDL_BlendFactor {
  /// < 0, 0, 0, 0
  static const int SDL_BLENDFACTOR_ZERO = 1;

  /// < 1, 1, 1, 1
  static const int SDL_BLENDFACTOR_ONE = 2;

  /// < srcR, srcG, srcB, srcA
  static const int SDL_BLENDFACTOR_SRC_COLOR = 3;

  /// < 1-srcR, 1-srcG, 1-srcB, 1-srcA
  static const int SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4;

  /// < srcA, srcA, srcA, srcA
  static const int SDL_BLENDFACTOR_SRC_ALPHA = 5;

  /// < 1-srcA, 1-srcA, 1-srcA, 1-srcA
  static const int SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6;

  /// < dstR, dstG, dstB, dstA
  static const int SDL_BLENDFACTOR_DST_COLOR = 7;

  /// < 1-dstR, 1-dstG, 1-dstB, 1-dstA
  static const int SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8;

  /// < dstA, dstA, dstA, dstA
  static const int SDL_BLENDFACTOR_DST_ALPHA = 9;

  /// < 1-dstA, 1-dstA, 1-dstA, 1-dstA
  static const int SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10;
}

/// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
/// which, if not NULL, contains the raw pixel data for the surface.
class SDL_Surface extends ffi.Struct {
  /// < Read-only
  @Uint32()
  external int flags;

  /// < Read-only
  external ffi.Pointer<SDL_PixelFormat> format;

  /// < Read-only
  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;

  /// < Read-only
  @ffi.Int()
  external int pitch;

  /// < Read-write
  external ffi.Pointer<ffi.Void> pixels;

  /// < Read-write
  external ffi.Pointer<ffi.Void> userdata;

  /// < Read-only
  @ffi.Int()
  external int locked;

  /// < Private
  external ffi.Pointer<ffi.Void> list_blitmap;

  /// < Read-only
  external SDL_Rect clip_rect;

  /// < Private
  external ffi.Pointer<SDL_BlitMap> map;

  /// < Read-mostly
  @ffi.Int()
  external int refcount;
}

class SDL_BlitMap extends ffi.Opaque {}

/// \brief The formula used for converting between YUV and RGB
abstract class SDL_YUV_CONVERSION_MODE {
  /// < Full range JPEG
  static const int SDL_YUV_CONVERSION_JPEG = 0;

  /// < BT.601 (the default)
  static const int SDL_YUV_CONVERSION_BT601 = 1;

  /// < BT.709
  static const int SDL_YUV_CONVERSION_BT709 = 2;

  /// < BT.601 for SD content, BT.709 for HD content
  static const int SDL_YUV_CONVERSION_AUTOMATIC = 3;
}

/// \brief  The structure that defines a display mode
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
/// \sa SDL_GetDesktopDisplayMode()
/// \sa SDL_GetCurrentDisplayMode()
/// \sa SDL_GetClosestDisplayMode()
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode()
class SDL_DisplayMode extends ffi.Struct {
  /// < pixel format
  @Uint32()
  external int format;

  /// < width, in screen coordinates
  @ffi.Int()
  external int w;

  /// < height, in screen coordinates
  @ffi.Int()
  external int h;

  /// < refresh rate (or zero for unspecified)
  @ffi.Int()
  external int refresh_rate;

  /// < driver-specific data, initialize to 0
  external ffi.Pointer<ffi.Void> driverdata;
}

class SDL_Window extends ffi.Opaque {}

/// \brief The flags on a window
///
/// \sa SDL_GetWindowFlags()
abstract class SDL_WindowFlags {
  /// < fullscreen window
  static const int SDL_WINDOW_FULLSCREEN = 1;

  /// < window usable with OpenGL context
  static const int SDL_WINDOW_OPENGL = 2;

  /// < window is visible
  static const int SDL_WINDOW_SHOWN = 4;

  /// < window is not visible
  static const int SDL_WINDOW_HIDDEN = 8;

  /// < no window decoration
  static const int SDL_WINDOW_BORDERLESS = 16;

  /// < window can be resized
  static const int SDL_WINDOW_RESIZABLE = 32;

  /// < window is minimized
  static const int SDL_WINDOW_MINIMIZED = 64;

  /// < window is maximized
  static const int SDL_WINDOW_MAXIMIZED = 128;

  /// < window has grabbed mouse input
  static const int SDL_WINDOW_MOUSE_GRABBED = 256;

  /// < window has input focus
  static const int SDL_WINDOW_INPUT_FOCUS = 512;

  /// < window has mouse focus
  static const int SDL_WINDOW_MOUSE_FOCUS = 1024;
  static const int SDL_WINDOW_FULLSCREEN_DESKTOP = 4097;

  /// < window not created by SDL
  static const int SDL_WINDOW_FOREIGN = 2048;

  /// < window should be created in high-DPI mode if supported.
  /// On macOS NSHighResolutionCapable must be set true in the
  /// application's Info.plist for this to have any effect.
  static const int SDL_WINDOW_ALLOW_HIGHDPI = 8192;

  /// < window has mouse captured (unrelated to MOUSE_GRABBED)
  static const int SDL_WINDOW_MOUSE_CAPTURE = 16384;

  /// < window should always be above others
  static const int SDL_WINDOW_ALWAYS_ON_TOP = 32768;

  /// < window should not be added to the taskbar
  static const int SDL_WINDOW_SKIP_TASKBAR = 65536;

  /// < window should be treated as a utility window
  static const int SDL_WINDOW_UTILITY = 131072;

  /// < window should be treated as a tooltip
  static const int SDL_WINDOW_TOOLTIP = 262144;

  /// < window should be treated as a popup menu
  static const int SDL_WINDOW_POPUP_MENU = 524288;

  /// < window has grabbed keyboard input
  static const int SDL_WINDOW_KEYBOARD_GRABBED = 1048576;

  /// < window usable for Vulkan surface
  static const int SDL_WINDOW_VULKAN = 268435456;

  /// < window usable for Metal view
  static const int SDL_WINDOW_METAL = 536870912;

  /// < equivalent to SDL_WINDOW_MOUSE_GRABBED for compatibility
  static const int SDL_WINDOW_INPUT_GRABBED = 256;
}

/// \brief Event subtype for window events
abstract class SDL_WindowEventID {
  /// < Never used
  static const int SDL_WINDOWEVENT_NONE = 0;

  /// < Window has been shown
  static const int SDL_WINDOWEVENT_SHOWN = 1;

  /// < Window has been hidden
  static const int SDL_WINDOWEVENT_HIDDEN = 2;

  /// < Window has been exposed and should be
  /// redrawn
  static const int SDL_WINDOWEVENT_EXPOSED = 3;

  /// < Window has been moved to data1, data2
  static const int SDL_WINDOWEVENT_MOVED = 4;

  /// < Window has been resized to data1xdata2
  static const int SDL_WINDOWEVENT_RESIZED = 5;

  /// < The window size has changed, either as
  /// a result of an API call or through the
  /// system or user changing the window size.
  static const int SDL_WINDOWEVENT_SIZE_CHANGED = 6;

  /// < Window has been minimized
  static const int SDL_WINDOWEVENT_MINIMIZED = 7;

  /// < Window has been maximized
  static const int SDL_WINDOWEVENT_MAXIMIZED = 8;

  /// < Window has been restored to normal size
  /// and position
  static const int SDL_WINDOWEVENT_RESTORED = 9;

  /// < Window has gained mouse focus
  static const int SDL_WINDOWEVENT_ENTER = 10;

  /// < Window has lost mouse focus
  static const int SDL_WINDOWEVENT_LEAVE = 11;

  /// < Window has gained keyboard focus
  static const int SDL_WINDOWEVENT_FOCUS_GAINED = 12;

  /// < Window has lost keyboard focus
  static const int SDL_WINDOWEVENT_FOCUS_LOST = 13;

  /// < The window manager requests that the window be closed
  static const int SDL_WINDOWEVENT_CLOSE = 14;

  /// < Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)
  static const int SDL_WINDOWEVENT_TAKE_FOCUS = 15;

  /// < Window had a hit test that wasn't SDL_HITTEST_NORMAL.
  static const int SDL_WINDOWEVENT_HIT_TEST = 16;

  /// < The ICC profile of the window's display has changed.
  static const int SDL_WINDOWEVENT_ICCPROF_CHANGED = 17;

  /// < Window has been moved to display data1.
  static const int SDL_WINDOWEVENT_DISPLAY_CHANGED = 18;
}

/// \brief Event subtype for display events
abstract class SDL_DisplayEventID {
  /// < Never used
  static const int SDL_DISPLAYEVENT_NONE = 0;

  /// < Display orientation has changed to data1
  static const int SDL_DISPLAYEVENT_ORIENTATION = 1;

  /// < Display has been added to the system
  static const int SDL_DISPLAYEVENT_CONNECTED = 2;

  /// < Display has been removed from the system
  static const int SDL_DISPLAYEVENT_DISCONNECTED = 3;
}

/// \brief Display orientation
abstract class SDL_DisplayOrientation {
  /// < The display orientation can't be determined
  static const int SDL_ORIENTATION_UNKNOWN = 0;

  /// < The display is in landscape mode, with the right side up, relative to portrait mode
  static const int SDL_ORIENTATION_LANDSCAPE = 1;

  /// < The display is in landscape mode, with the left side up, relative to portrait mode
  static const int SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2;

  /// < The display is in portrait mode
  static const int SDL_ORIENTATION_PORTRAIT = 3;

  /// < The display is in portrait mode, upside down
  static const int SDL_ORIENTATION_PORTRAIT_FLIPPED = 4;
}

/// \brief Window flash operation
abstract class SDL_FlashOperation {
  /// < Cancel any window flash state
  static const int SDL_FLASH_CANCEL = 0;

  /// < Flash the window briefly to get attention
  static const int SDL_FLASH_BRIEFLY = 1;

  /// < Flash the window until it gets focus
  static const int SDL_FLASH_UNTIL_FOCUSED = 2;
}

/// \brief OpenGL configuration attributes
abstract class SDL_GLattr {
  static const int SDL_GL_RED_SIZE = 0;
  static const int SDL_GL_GREEN_SIZE = 1;
  static const int SDL_GL_BLUE_SIZE = 2;
  static const int SDL_GL_ALPHA_SIZE = 3;
  static const int SDL_GL_BUFFER_SIZE = 4;
  static const int SDL_GL_DOUBLEBUFFER = 5;
  static const int SDL_GL_DEPTH_SIZE = 6;
  static const int SDL_GL_STENCIL_SIZE = 7;
  static const int SDL_GL_ACCUM_RED_SIZE = 8;
  static const int SDL_GL_ACCUM_GREEN_SIZE = 9;
  static const int SDL_GL_ACCUM_BLUE_SIZE = 10;
  static const int SDL_GL_ACCUM_ALPHA_SIZE = 11;
  static const int SDL_GL_STEREO = 12;
  static const int SDL_GL_MULTISAMPLEBUFFERS = 13;
  static const int SDL_GL_MULTISAMPLESAMPLES = 14;
  static const int SDL_GL_ACCELERATED_VISUAL = 15;
  static const int SDL_GL_RETAINED_BACKING = 16;
  static const int SDL_GL_CONTEXT_MAJOR_VERSION = 17;
  static const int SDL_GL_CONTEXT_MINOR_VERSION = 18;
  static const int SDL_GL_CONTEXT_EGL = 19;
  static const int SDL_GL_CONTEXT_FLAGS = 20;
  static const int SDL_GL_CONTEXT_PROFILE_MASK = 21;
  static const int SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22;
  static const int SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23;
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24;
  static const int SDL_GL_CONTEXT_RESET_NOTIFICATION = 25;
  static const int SDL_GL_CONTEXT_NO_ERROR = 26;
}

abstract class SDL_GLprofile {
  static const int SDL_GL_CONTEXT_PROFILE_CORE = 1;
  static const int SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2;

  /// < GLX_CONTEXT_ES2_PROFILE_BIT_EXT
  static const int SDL_GL_CONTEXT_PROFILE_ES = 4;
}

abstract class SDL_GLcontextFlag {
  static const int SDL_GL_CONTEXT_DEBUG_FLAG = 1;
  static const int SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2;
  static const int SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4;
  static const int SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8;
}

abstract class SDL_GLcontextReleaseFlag {
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0;
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1;
}

abstract class SDL_GLContextResetNotification {
  static const int SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0;
  static const int SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1;
}

/// Possible return values from the SDL_HitTest callback.
///
/// \sa SDL_HitTest
abstract class SDL_HitTestResult {
  /// < Region is normal. No special properties.
  static const int SDL_HITTEST_NORMAL = 0;

  /// < Region can drag entire window.
  static const int SDL_HITTEST_DRAGGABLE = 1;
  static const int SDL_HITTEST_RESIZE_TOPLEFT = 2;
  static const int SDL_HITTEST_RESIZE_TOP = 3;
  static const int SDL_HITTEST_RESIZE_TOPRIGHT = 4;
  static const int SDL_HITTEST_RESIZE_RIGHT = 5;
  static const int SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6;
  static const int SDL_HITTEST_RESIZE_BOTTOM = 7;
  static const int SDL_HITTEST_RESIZE_BOTTOMLEFT = 8;
  static const int SDL_HITTEST_RESIZE_LEFT = 9;
}

/// Callback used for hit-testing.
///
/// \param win the SDL_Window where hit-testing was set on
/// \param area an SDL_Point which should be hit-tested
/// \param data what was passed as `callback_data` to SDL_SetWindowHitTest()
/// \return an SDL_HitTestResult value.
///
/// \sa SDL_SetWindowHitTest
typedef SDL_HitTest = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Point>,
            ffi.Pointer<ffi.Void>)>>;

/// \brief An opaque handle to an OpenGL context.
typedef SDL_GLContext = ffi.Pointer<ffi.Void>;

/// \brief The SDL keyboard scancode representation.
///
/// Values of this type are used to represent keyboard keys, among other places
/// in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
/// SDL_Event structure.
///
/// The values in this enumeration are based on the USB usage page standard:
/// https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
abstract class SDL_Scancode {
  static const int SDL_SCANCODE_UNKNOWN = 0;
  static const int SDL_SCANCODE_A = 4;
  static const int SDL_SCANCODE_B = 5;
  static const int SDL_SCANCODE_C = 6;
  static const int SDL_SCANCODE_D = 7;
  static const int SDL_SCANCODE_E = 8;
  static const int SDL_SCANCODE_F = 9;
  static const int SDL_SCANCODE_G = 10;
  static const int SDL_SCANCODE_H = 11;
  static const int SDL_SCANCODE_I = 12;
  static const int SDL_SCANCODE_J = 13;
  static const int SDL_SCANCODE_K = 14;
  static const int SDL_SCANCODE_L = 15;
  static const int SDL_SCANCODE_M = 16;
  static const int SDL_SCANCODE_N = 17;
  static const int SDL_SCANCODE_O = 18;
  static const int SDL_SCANCODE_P = 19;
  static const int SDL_SCANCODE_Q = 20;
  static const int SDL_SCANCODE_R = 21;
  static const int SDL_SCANCODE_S = 22;
  static const int SDL_SCANCODE_T = 23;
  static const int SDL_SCANCODE_U = 24;
  static const int SDL_SCANCODE_V = 25;
  static const int SDL_SCANCODE_W = 26;
  static const int SDL_SCANCODE_X = 27;
  static const int SDL_SCANCODE_Y = 28;
  static const int SDL_SCANCODE_Z = 29;
  static const int SDL_SCANCODE_1 = 30;
  static const int SDL_SCANCODE_2 = 31;
  static const int SDL_SCANCODE_3 = 32;
  static const int SDL_SCANCODE_4 = 33;
  static const int SDL_SCANCODE_5 = 34;
  static const int SDL_SCANCODE_6 = 35;
  static const int SDL_SCANCODE_7 = 36;
  static const int SDL_SCANCODE_8 = 37;
  static const int SDL_SCANCODE_9 = 38;
  static const int SDL_SCANCODE_0 = 39;
  static const int SDL_SCANCODE_RETURN = 40;
  static const int SDL_SCANCODE_ESCAPE = 41;
  static const int SDL_SCANCODE_BACKSPACE = 42;
  static const int SDL_SCANCODE_TAB = 43;
  static const int SDL_SCANCODE_SPACE = 44;
  static const int SDL_SCANCODE_MINUS = 45;
  static const int SDL_SCANCODE_EQUALS = 46;
  static const int SDL_SCANCODE_LEFTBRACKET = 47;
  static const int SDL_SCANCODE_RIGHTBRACKET = 48;

  /// < Located at the lower left of the return
  /// key on ISO keyboards and at the right end
  /// of the QWERTY row on ANSI keyboards.
  /// Produces REVERSE SOLIDUS (backslash) and
  /// VERTICAL LINE in a US layout, REVERSE
  /// SOLIDUS and VERTICAL LINE in a UK Mac
  /// layout, NUMBER SIGN and TILDE in a UK
  /// Windows layout, DOLLAR SIGN and POUND SIGN
  /// in a Swiss German layout, NUMBER SIGN and
  /// APOSTROPHE in a German layout, GRAVE
  /// ACCENT and POUND SIGN in a French Mac
  /// layout, and ASTERISK and MICRO SIGN in a
  /// French Windows layout.
  static const int SDL_SCANCODE_BACKSLASH = 49;

  /// < ISO USB keyboards actually use this code
  /// instead of 49 for the same key, but all
  /// OSes I've seen treat the two codes
  /// identically. So, as an implementor, unless
  /// your keyboard generates both of those
  /// codes and your OS treats them differently,
  /// you should generate SDL_SCANCODE_BACKSLASH
  /// instead of this code. As a user, you
  /// should not rely on this code because SDL
  /// will never generate it with most (all?)
  /// keyboards.
  static const int SDL_SCANCODE_NONUSHASH = 50;
  static const int SDL_SCANCODE_SEMICOLON = 51;
  static const int SDL_SCANCODE_APOSTROPHE = 52;

  /// < Located in the top left corner (on both ANSI
  /// and ISO keyboards). Produces GRAVE ACCENT and
  /// TILDE in a US Windows layout and in US and UK
  /// Mac layouts on ANSI keyboards, GRAVE ACCENT
  /// and NOT SIGN in a UK Windows layout, SECTION
  /// SIGN and PLUS-MINUS SIGN in US and UK Mac
  /// layouts on ISO keyboards, SECTION SIGN and
  /// DEGREE SIGN in a Swiss German layout (Mac:
  /// only on ISO keyboards), CIRCUMFLEX ACCENT and
  /// DEGREE SIGN in a German layout (Mac: only on
  /// ISO keyboards), SUPERSCRIPT TWO and TILDE in a
  /// French Windows layout, COMMERCIAL AT and
  /// NUMBER SIGN in a French Mac layout on ISO
  /// keyboards, and LESS-THAN SIGN and GREATER-THAN
  /// SIGN in a Swiss German, German, or French Mac
  /// layout on ANSI keyboards.
  static const int SDL_SCANCODE_GRAVE = 53;
  static const int SDL_SCANCODE_COMMA = 54;
  static const int SDL_SCANCODE_PERIOD = 55;
  static const int SDL_SCANCODE_SLASH = 56;
  static const int SDL_SCANCODE_CAPSLOCK = 57;
  static const int SDL_SCANCODE_F1 = 58;
  static const int SDL_SCANCODE_F2 = 59;
  static const int SDL_SCANCODE_F3 = 60;
  static const int SDL_SCANCODE_F4 = 61;
  static const int SDL_SCANCODE_F5 = 62;
  static const int SDL_SCANCODE_F6 = 63;
  static const int SDL_SCANCODE_F7 = 64;
  static const int SDL_SCANCODE_F8 = 65;
  static const int SDL_SCANCODE_F9 = 66;
  static const int SDL_SCANCODE_F10 = 67;
  static const int SDL_SCANCODE_F11 = 68;
  static const int SDL_SCANCODE_F12 = 69;
  static const int SDL_SCANCODE_PRINTSCREEN = 70;
  static const int SDL_SCANCODE_SCROLLLOCK = 71;
  static const int SDL_SCANCODE_PAUSE = 72;

  /// < insert on PC, help on some Mac keyboards (but
  /// does send code 73, not 117)
  static const int SDL_SCANCODE_INSERT = 73;
  static const int SDL_SCANCODE_HOME = 74;
  static const int SDL_SCANCODE_PAGEUP = 75;
  static const int SDL_SCANCODE_DELETE = 76;
  static const int SDL_SCANCODE_END = 77;
  static const int SDL_SCANCODE_PAGEDOWN = 78;
  static const int SDL_SCANCODE_RIGHT = 79;
  static const int SDL_SCANCODE_LEFT = 80;
  static const int SDL_SCANCODE_DOWN = 81;
  static const int SDL_SCANCODE_UP = 82;

  /// < num lock on PC, clear on Mac keyboards
  static const int SDL_SCANCODE_NUMLOCKCLEAR = 83;
  static const int SDL_SCANCODE_KP_DIVIDE = 84;
  static const int SDL_SCANCODE_KP_MULTIPLY = 85;
  static const int SDL_SCANCODE_KP_MINUS = 86;
  static const int SDL_SCANCODE_KP_PLUS = 87;
  static const int SDL_SCANCODE_KP_ENTER = 88;
  static const int SDL_SCANCODE_KP_1 = 89;
  static const int SDL_SCANCODE_KP_2 = 90;
  static const int SDL_SCANCODE_KP_3 = 91;
  static const int SDL_SCANCODE_KP_4 = 92;
  static const int SDL_SCANCODE_KP_5 = 93;
  static const int SDL_SCANCODE_KP_6 = 94;
  static const int SDL_SCANCODE_KP_7 = 95;
  static const int SDL_SCANCODE_KP_8 = 96;
  static const int SDL_SCANCODE_KP_9 = 97;
  static const int SDL_SCANCODE_KP_0 = 98;
  static const int SDL_SCANCODE_KP_PERIOD = 99;

  /// < This is the additional key that ISO
  /// keyboards have over ANSI ones,
  /// located between left shift and Y.
  /// Produces GRAVE ACCENT and TILDE in a
  /// US or UK Mac layout, REVERSE SOLIDUS
  /// (backslash) and VERTICAL LINE in a
  /// US or UK Windows layout, and
  /// LESS-THAN SIGN and GREATER-THAN SIGN
  /// in a Swiss German, German, or French
  /// layout.
  static const int SDL_SCANCODE_NONUSBACKSLASH = 100;

  /// < windows contextual menu, compose
  static const int SDL_SCANCODE_APPLICATION = 101;

  /// < The USB document says this is a status flag,
  /// not a physical key - but some Mac keyboards
  /// do have a power key.
  static const int SDL_SCANCODE_POWER = 102;
  static const int SDL_SCANCODE_KP_EQUALS = 103;
  static const int SDL_SCANCODE_F13 = 104;
  static const int SDL_SCANCODE_F14 = 105;
  static const int SDL_SCANCODE_F15 = 106;
  static const int SDL_SCANCODE_F16 = 107;
  static const int SDL_SCANCODE_F17 = 108;
  static const int SDL_SCANCODE_F18 = 109;
  static const int SDL_SCANCODE_F19 = 110;
  static const int SDL_SCANCODE_F20 = 111;
  static const int SDL_SCANCODE_F21 = 112;
  static const int SDL_SCANCODE_F22 = 113;
  static const int SDL_SCANCODE_F23 = 114;
  static const int SDL_SCANCODE_F24 = 115;
  static const int SDL_SCANCODE_EXECUTE = 116;
  static const int SDL_SCANCODE_HELP = 117;
  static const int SDL_SCANCODE_MENU = 118;
  static const int SDL_SCANCODE_SELECT = 119;
  static const int SDL_SCANCODE_STOP = 120;

  /// < redo
  static const int SDL_SCANCODE_AGAIN = 121;
  static const int SDL_SCANCODE_UNDO = 122;
  static const int SDL_SCANCODE_CUT = 123;
  static const int SDL_SCANCODE_COPY = 124;
  static const int SDL_SCANCODE_PASTE = 125;
  static const int SDL_SCANCODE_FIND = 126;
  static const int SDL_SCANCODE_MUTE = 127;
  static const int SDL_SCANCODE_VOLUMEUP = 128;
  static const int SDL_SCANCODE_VOLUMEDOWN = 129;
  static const int SDL_SCANCODE_KP_COMMA = 133;
  static const int SDL_SCANCODE_KP_EQUALSAS400 = 134;

  /// < used on Asian keyboards, see
  /// footnotes in USB doc
  static const int SDL_SCANCODE_INTERNATIONAL1 = 135;
  static const int SDL_SCANCODE_INTERNATIONAL2 = 136;

  /// < Yen
  static const int SDL_SCANCODE_INTERNATIONAL3 = 137;
  static const int SDL_SCANCODE_INTERNATIONAL4 = 138;
  static const int SDL_SCANCODE_INTERNATIONAL5 = 139;
  static const int SDL_SCANCODE_INTERNATIONAL6 = 140;
  static const int SDL_SCANCODE_INTERNATIONAL7 = 141;
  static const int SDL_SCANCODE_INTERNATIONAL8 = 142;
  static const int SDL_SCANCODE_INTERNATIONAL9 = 143;

  /// < Hangul/English toggle
  static const int SDL_SCANCODE_LANG1 = 144;

  /// < Hanja conversion
  static const int SDL_SCANCODE_LANG2 = 145;

  /// < Katakana
  static const int SDL_SCANCODE_LANG3 = 146;

  /// < Hiragana
  static const int SDL_SCANCODE_LANG4 = 147;

  /// < Zenkaku/Hankaku
  static const int SDL_SCANCODE_LANG5 = 148;

  /// < reserved
  static const int SDL_SCANCODE_LANG6 = 149;

  /// < reserved
  static const int SDL_SCANCODE_LANG7 = 150;

  /// < reserved
  static const int SDL_SCANCODE_LANG8 = 151;

  /// < reserved
  static const int SDL_SCANCODE_LANG9 = 152;

  /// < Erase-Eaze
  static const int SDL_SCANCODE_ALTERASE = 153;
  static const int SDL_SCANCODE_SYSREQ = 154;
  static const int SDL_SCANCODE_CANCEL = 155;
  static const int SDL_SCANCODE_CLEAR = 156;
  static const int SDL_SCANCODE_PRIOR = 157;
  static const int SDL_SCANCODE_RETURN2 = 158;
  static const int SDL_SCANCODE_SEPARATOR = 159;
  static const int SDL_SCANCODE_OUT = 160;
  static const int SDL_SCANCODE_OPER = 161;
  static const int SDL_SCANCODE_CLEARAGAIN = 162;
  static const int SDL_SCANCODE_CRSEL = 163;
  static const int SDL_SCANCODE_EXSEL = 164;
  static const int SDL_SCANCODE_KP_00 = 176;
  static const int SDL_SCANCODE_KP_000 = 177;
  static const int SDL_SCANCODE_THOUSANDSSEPARATOR = 178;
  static const int SDL_SCANCODE_DECIMALSEPARATOR = 179;
  static const int SDL_SCANCODE_CURRENCYUNIT = 180;
  static const int SDL_SCANCODE_CURRENCYSUBUNIT = 181;
  static const int SDL_SCANCODE_KP_LEFTPAREN = 182;
  static const int SDL_SCANCODE_KP_RIGHTPAREN = 183;
  static const int SDL_SCANCODE_KP_LEFTBRACE = 184;
  static const int SDL_SCANCODE_KP_RIGHTBRACE = 185;
  static const int SDL_SCANCODE_KP_TAB = 186;
  static const int SDL_SCANCODE_KP_BACKSPACE = 187;
  static const int SDL_SCANCODE_KP_A = 188;
  static const int SDL_SCANCODE_KP_B = 189;
  static const int SDL_SCANCODE_KP_C = 190;
  static const int SDL_SCANCODE_KP_D = 191;
  static const int SDL_SCANCODE_KP_E = 192;
  static const int SDL_SCANCODE_KP_F = 193;
  static const int SDL_SCANCODE_KP_XOR = 194;
  static const int SDL_SCANCODE_KP_POWER = 195;
  static const int SDL_SCANCODE_KP_PERCENT = 196;
  static const int SDL_SCANCODE_KP_LESS = 197;
  static const int SDL_SCANCODE_KP_GREATER = 198;
  static const int SDL_SCANCODE_KP_AMPERSAND = 199;
  static const int SDL_SCANCODE_KP_DBLAMPERSAND = 200;
  static const int SDL_SCANCODE_KP_VERTICALBAR = 201;
  static const int SDL_SCANCODE_KP_DBLVERTICALBAR = 202;
  static const int SDL_SCANCODE_KP_COLON = 203;
  static const int SDL_SCANCODE_KP_HASH = 204;
  static const int SDL_SCANCODE_KP_SPACE = 205;
  static const int SDL_SCANCODE_KP_AT = 206;
  static const int SDL_SCANCODE_KP_EXCLAM = 207;
  static const int SDL_SCANCODE_KP_MEMSTORE = 208;
  static const int SDL_SCANCODE_KP_MEMRECALL = 209;
  static const int SDL_SCANCODE_KP_MEMCLEAR = 210;
  static const int SDL_SCANCODE_KP_MEMADD = 211;
  static const int SDL_SCANCODE_KP_MEMSUBTRACT = 212;
  static const int SDL_SCANCODE_KP_MEMMULTIPLY = 213;
  static const int SDL_SCANCODE_KP_MEMDIVIDE = 214;
  static const int SDL_SCANCODE_KP_PLUSMINUS = 215;
  static const int SDL_SCANCODE_KP_CLEAR = 216;
  static const int SDL_SCANCODE_KP_CLEARENTRY = 217;
  static const int SDL_SCANCODE_KP_BINARY = 218;
  static const int SDL_SCANCODE_KP_OCTAL = 219;
  static const int SDL_SCANCODE_KP_DECIMAL = 220;
  static const int SDL_SCANCODE_KP_HEXADECIMAL = 221;
  static const int SDL_SCANCODE_LCTRL = 224;
  static const int SDL_SCANCODE_LSHIFT = 225;

  /// < alt, option
  static const int SDL_SCANCODE_LALT = 226;

  /// < windows, command (apple), meta
  static const int SDL_SCANCODE_LGUI = 227;
  static const int SDL_SCANCODE_RCTRL = 228;
  static const int SDL_SCANCODE_RSHIFT = 229;

  /// < alt gr, option
  static const int SDL_SCANCODE_RALT = 230;

  /// < windows, command (apple), meta
  static const int SDL_SCANCODE_RGUI = 231;

  /// < I'm not sure if this is really not covered
  /// by any of the above, but since there's a
  /// special KMOD_MODE for it I'm adding it here
  static const int SDL_SCANCODE_MODE = 257;
  static const int SDL_SCANCODE_AUDIONEXT = 258;
  static const int SDL_SCANCODE_AUDIOPREV = 259;
  static const int SDL_SCANCODE_AUDIOSTOP = 260;
  static const int SDL_SCANCODE_AUDIOPLAY = 261;
  static const int SDL_SCANCODE_AUDIOMUTE = 262;
  static const int SDL_SCANCODE_MEDIASELECT = 263;
  static const int SDL_SCANCODE_WWW = 264;
  static const int SDL_SCANCODE_MAIL = 265;
  static const int SDL_SCANCODE_CALCULATOR = 266;
  static const int SDL_SCANCODE_COMPUTER = 267;
  static const int SDL_SCANCODE_AC_SEARCH = 268;
  static const int SDL_SCANCODE_AC_HOME = 269;
  static const int SDL_SCANCODE_AC_BACK = 270;
  static const int SDL_SCANCODE_AC_FORWARD = 271;
  static const int SDL_SCANCODE_AC_STOP = 272;
  static const int SDL_SCANCODE_AC_REFRESH = 273;
  static const int SDL_SCANCODE_AC_BOOKMARKS = 274;
  static const int SDL_SCANCODE_BRIGHTNESSDOWN = 275;
  static const int SDL_SCANCODE_BRIGHTNESSUP = 276;

  /// < display mirroring/dual display
  /// switch, video mode switch
  static const int SDL_SCANCODE_DISPLAYSWITCH = 277;
  static const int SDL_SCANCODE_KBDILLUMTOGGLE = 278;
  static const int SDL_SCANCODE_KBDILLUMDOWN = 279;
  static const int SDL_SCANCODE_KBDILLUMUP = 280;
  static const int SDL_SCANCODE_EJECT = 281;
  static const int SDL_SCANCODE_SLEEP = 282;
  static const int SDL_SCANCODE_APP1 = 283;
  static const int SDL_SCANCODE_APP2 = 284;
  static const int SDL_SCANCODE_AUDIOREWIND = 285;
  static const int SDL_SCANCODE_AUDIOFASTFORWARD = 286;

  /// < not a key, just marks the number of scancodes
  /// for array bounds
  static const int SDL_NUM_SCANCODES = 512;
}

abstract class SDL_KeyCode {
  static const int SDLK_UNKNOWN = 0;
  static const int SDLK_RETURN = 13;
  static const int SDLK_ESCAPE = 27;
  static const int SDLK_BACKSPACE = 8;
  static const int SDLK_TAB = 9;
  static const int SDLK_SPACE = 32;
  static const int SDLK_EXCLAIM = 33;
  static const int SDLK_QUOTEDBL = 34;
  static const int SDLK_HASH = 35;
  static const int SDLK_PERCENT = 37;
  static const int SDLK_DOLLAR = 36;
  static const int SDLK_AMPERSAND = 38;
  static const int SDLK_QUOTE = 39;
  static const int SDLK_LEFTPAREN = 40;
  static const int SDLK_RIGHTPAREN = 41;
  static const int SDLK_ASTERISK = 42;
  static const int SDLK_PLUS = 43;
  static const int SDLK_COMMA = 44;
  static const int SDLK_MINUS = 45;
  static const int SDLK_PERIOD = 46;
  static const int SDLK_SLASH = 47;
  static const int SDLK_0 = 48;
  static const int SDLK_1 = 49;
  static const int SDLK_2 = 50;
  static const int SDLK_3 = 51;
  static const int SDLK_4 = 52;
  static const int SDLK_5 = 53;
  static const int SDLK_6 = 54;
  static const int SDLK_7 = 55;
  static const int SDLK_8 = 56;
  static const int SDLK_9 = 57;
  static const int SDLK_COLON = 58;
  static const int SDLK_SEMICOLON = 59;
  static const int SDLK_LESS = 60;
  static const int SDLK_EQUALS = 61;
  static const int SDLK_GREATER = 62;
  static const int SDLK_QUESTION = 63;
  static const int SDLK_AT = 64;
  static const int SDLK_LEFTBRACKET = 91;
  static const int SDLK_BACKSLASH = 92;
  static const int SDLK_RIGHTBRACKET = 93;
  static const int SDLK_CARET = 94;
  static const int SDLK_UNDERSCORE = 95;
  static const int SDLK_BACKQUOTE = 96;
  static const int SDLK_a = 97;
  static const int SDLK_b = 98;
  static const int SDLK_c = 99;
  static const int SDLK_d = 100;
  static const int SDLK_e = 101;
  static const int SDLK_f = 102;
  static const int SDLK_g = 103;
  static const int SDLK_h = 104;
  static const int SDLK_i = 105;
  static const int SDLK_j = 106;
  static const int SDLK_k = 107;
  static const int SDLK_l = 108;
  static const int SDLK_m = 109;
  static const int SDLK_n = 110;
  static const int SDLK_o = 111;
  static const int SDLK_p = 112;
  static const int SDLK_q = 113;
  static const int SDLK_r = 114;
  static const int SDLK_s = 115;
  static const int SDLK_t = 116;
  static const int SDLK_u = 117;
  static const int SDLK_v = 118;
  static const int SDLK_w = 119;
  static const int SDLK_x = 120;
  static const int SDLK_y = 121;
  static const int SDLK_z = 122;
  static const int SDLK_CAPSLOCK = 1073741881;
  static const int SDLK_F1 = 1073741882;
  static const int SDLK_F2 = 1073741883;
  static const int SDLK_F3 = 1073741884;
  static const int SDLK_F4 = 1073741885;
  static const int SDLK_F5 = 1073741886;
  static const int SDLK_F6 = 1073741887;
  static const int SDLK_F7 = 1073741888;
  static const int SDLK_F8 = 1073741889;
  static const int SDLK_F9 = 1073741890;
  static const int SDLK_F10 = 1073741891;
  static const int SDLK_F11 = 1073741892;
  static const int SDLK_F12 = 1073741893;
  static const int SDLK_PRINTSCREEN = 1073741894;
  static const int SDLK_SCROLLLOCK = 1073741895;
  static const int SDLK_PAUSE = 1073741896;
  static const int SDLK_INSERT = 1073741897;
  static const int SDLK_HOME = 1073741898;
  static const int SDLK_PAGEUP = 1073741899;
  static const int SDLK_DELETE = 127;
  static const int SDLK_END = 1073741901;
  static const int SDLK_PAGEDOWN = 1073741902;
  static const int SDLK_RIGHT = 1073741903;
  static const int SDLK_LEFT = 1073741904;
  static const int SDLK_DOWN = 1073741905;
  static const int SDLK_UP = 1073741906;
  static const int SDLK_NUMLOCKCLEAR = 1073741907;
  static const int SDLK_KP_DIVIDE = 1073741908;
  static const int SDLK_KP_MULTIPLY = 1073741909;
  static const int SDLK_KP_MINUS = 1073741910;
  static const int SDLK_KP_PLUS = 1073741911;
  static const int SDLK_KP_ENTER = 1073741912;
  static const int SDLK_KP_1 = 1073741913;
  static const int SDLK_KP_2 = 1073741914;
  static const int SDLK_KP_3 = 1073741915;
  static const int SDLK_KP_4 = 1073741916;
  static const int SDLK_KP_5 = 1073741917;
  static const int SDLK_KP_6 = 1073741918;
  static const int SDLK_KP_7 = 1073741919;
  static const int SDLK_KP_8 = 1073741920;
  static const int SDLK_KP_9 = 1073741921;
  static const int SDLK_KP_0 = 1073741922;
  static const int SDLK_KP_PERIOD = 1073741923;
  static const int SDLK_APPLICATION = 1073741925;
  static const int SDLK_POWER = 1073741926;
  static const int SDLK_KP_EQUALS = 1073741927;
  static const int SDLK_F13 = 1073741928;
  static const int SDLK_F14 = 1073741929;
  static const int SDLK_F15 = 1073741930;
  static const int SDLK_F16 = 1073741931;
  static const int SDLK_F17 = 1073741932;
  static const int SDLK_F18 = 1073741933;
  static const int SDLK_F19 = 1073741934;
  static const int SDLK_F20 = 1073741935;
  static const int SDLK_F21 = 1073741936;
  static const int SDLK_F22 = 1073741937;
  static const int SDLK_F23 = 1073741938;
  static const int SDLK_F24 = 1073741939;
  static const int SDLK_EXECUTE = 1073741940;
  static const int SDLK_HELP = 1073741941;
  static const int SDLK_MENU = 1073741942;
  static const int SDLK_SELECT = 1073741943;
  static const int SDLK_STOP = 1073741944;
  static const int SDLK_AGAIN = 1073741945;
  static const int SDLK_UNDO = 1073741946;
  static const int SDLK_CUT = 1073741947;
  static const int SDLK_COPY = 1073741948;
  static const int SDLK_PASTE = 1073741949;
  static const int SDLK_FIND = 1073741950;
  static const int SDLK_MUTE = 1073741951;
  static const int SDLK_VOLUMEUP = 1073741952;
  static const int SDLK_VOLUMEDOWN = 1073741953;
  static const int SDLK_KP_COMMA = 1073741957;
  static const int SDLK_KP_EQUALSAS400 = 1073741958;
  static const int SDLK_ALTERASE = 1073741977;
  static const int SDLK_SYSREQ = 1073741978;
  static const int SDLK_CANCEL = 1073741979;
  static const int SDLK_CLEAR = 1073741980;
  static const int SDLK_PRIOR = 1073741981;
  static const int SDLK_RETURN2 = 1073741982;
  static const int SDLK_SEPARATOR = 1073741983;
  static const int SDLK_OUT = 1073741984;
  static const int SDLK_OPER = 1073741985;
  static const int SDLK_CLEARAGAIN = 1073741986;
  static const int SDLK_CRSEL = 1073741987;
  static const int SDLK_EXSEL = 1073741988;
  static const int SDLK_KP_00 = 1073742000;
  static const int SDLK_KP_000 = 1073742001;
  static const int SDLK_THOUSANDSSEPARATOR = 1073742002;
  static const int SDLK_DECIMALSEPARATOR = 1073742003;
  static const int SDLK_CURRENCYUNIT = 1073742004;
  static const int SDLK_CURRENCYSUBUNIT = 1073742005;
  static const int SDLK_KP_LEFTPAREN = 1073742006;
  static const int SDLK_KP_RIGHTPAREN = 1073742007;
  static const int SDLK_KP_LEFTBRACE = 1073742008;
  static const int SDLK_KP_RIGHTBRACE = 1073742009;
  static const int SDLK_KP_TAB = 1073742010;
  static const int SDLK_KP_BACKSPACE = 1073742011;
  static const int SDLK_KP_A = 1073742012;
  static const int SDLK_KP_B = 1073742013;
  static const int SDLK_KP_C = 1073742014;
  static const int SDLK_KP_D = 1073742015;
  static const int SDLK_KP_E = 1073742016;
  static const int SDLK_KP_F = 1073742017;
  static const int SDLK_KP_XOR = 1073742018;
  static const int SDLK_KP_POWER = 1073742019;
  static const int SDLK_KP_PERCENT = 1073742020;
  static const int SDLK_KP_LESS = 1073742021;
  static const int SDLK_KP_GREATER = 1073742022;
  static const int SDLK_KP_AMPERSAND = 1073742023;
  static const int SDLK_KP_DBLAMPERSAND = 1073742024;
  static const int SDLK_KP_VERTICALBAR = 1073742025;
  static const int SDLK_KP_DBLVERTICALBAR = 1073742026;
  static const int SDLK_KP_COLON = 1073742027;
  static const int SDLK_KP_HASH = 1073742028;
  static const int SDLK_KP_SPACE = 1073742029;
  static const int SDLK_KP_AT = 1073742030;
  static const int SDLK_KP_EXCLAM = 1073742031;
  static const int SDLK_KP_MEMSTORE = 1073742032;
  static const int SDLK_KP_MEMRECALL = 1073742033;
  static const int SDLK_KP_MEMCLEAR = 1073742034;
  static const int SDLK_KP_MEMADD = 1073742035;
  static const int SDLK_KP_MEMSUBTRACT = 1073742036;
  static const int SDLK_KP_MEMMULTIPLY = 1073742037;
  static const int SDLK_KP_MEMDIVIDE = 1073742038;
  static const int SDLK_KP_PLUSMINUS = 1073742039;
  static const int SDLK_KP_CLEAR = 1073742040;
  static const int SDLK_KP_CLEARENTRY = 1073742041;
  static const int SDLK_KP_BINARY = 1073742042;
  static const int SDLK_KP_OCTAL = 1073742043;
  static const int SDLK_KP_DECIMAL = 1073742044;
  static const int SDLK_KP_HEXADECIMAL = 1073742045;
  static const int SDLK_LCTRL = 1073742048;
  static const int SDLK_LSHIFT = 1073742049;
  static const int SDLK_LALT = 1073742050;
  static const int SDLK_LGUI = 1073742051;
  static const int SDLK_RCTRL = 1073742052;
  static const int SDLK_RSHIFT = 1073742053;
  static const int SDLK_RALT = 1073742054;
  static const int SDLK_RGUI = 1073742055;
  static const int SDLK_MODE = 1073742081;
  static const int SDLK_AUDIONEXT = 1073742082;
  static const int SDLK_AUDIOPREV = 1073742083;
  static const int SDLK_AUDIOSTOP = 1073742084;
  static const int SDLK_AUDIOPLAY = 1073742085;
  static const int SDLK_AUDIOMUTE = 1073742086;
  static const int SDLK_MEDIASELECT = 1073742087;
  static const int SDLK_WWW = 1073742088;
  static const int SDLK_MAIL = 1073742089;
  static const int SDLK_CALCULATOR = 1073742090;
  static const int SDLK_COMPUTER = 1073742091;
  static const int SDLK_AC_SEARCH = 1073742092;
  static const int SDLK_AC_HOME = 1073742093;
  static const int SDLK_AC_BACK = 1073742094;
  static const int SDLK_AC_FORWARD = 1073742095;
  static const int SDLK_AC_STOP = 1073742096;
  static const int SDLK_AC_REFRESH = 1073742097;
  static const int SDLK_AC_BOOKMARKS = 1073742098;
  static const int SDLK_BRIGHTNESSDOWN = 1073742099;
  static const int SDLK_BRIGHTNESSUP = 1073742100;
  static const int SDLK_DISPLAYSWITCH = 1073742101;
  static const int SDLK_KBDILLUMTOGGLE = 1073742102;
  static const int SDLK_KBDILLUMDOWN = 1073742103;
  static const int SDLK_KBDILLUMUP = 1073742104;
  static const int SDLK_EJECT = 1073742105;
  static const int SDLK_SLEEP = 1073742106;
  static const int SDLK_APP1 = 1073742107;
  static const int SDLK_APP2 = 1073742108;
  static const int SDLK_AUDIOREWIND = 1073742109;
  static const int SDLK_AUDIOFASTFORWARD = 1073742110;
}

/// \brief Enumeration of valid key mods (possibly OR'd together).
abstract class SDL_Keymod {
  static const int KMOD_NONE = 0;
  static const int KMOD_LSHIFT = 1;
  static const int KMOD_RSHIFT = 2;
  static const int KMOD_LCTRL = 64;
  static const int KMOD_RCTRL = 128;
  static const int KMOD_LALT = 256;
  static const int KMOD_RALT = 512;
  static const int KMOD_LGUI = 1024;
  static const int KMOD_RGUI = 2048;
  static const int KMOD_NUM = 4096;
  static const int KMOD_CAPS = 8192;
  static const int KMOD_MODE = 16384;
  static const int KMOD_SCROLL = 32768;
  static const int KMOD_CTRL = 192;
  static const int KMOD_SHIFT = 3;
  static const int KMOD_ALT = 768;
  static const int KMOD_GUI = 3072;
  static const int KMOD_RESERVED = 32768;
}

/// \brief The SDL keysym structure, used in key events.
///
/// \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
class SDL_Keysym extends ffi.Struct {
  /// < SDL physical key code - see ::SDL_Scancode for details
  @ffi.Int32()
  external int scancode;

  /// < SDL virtual key code - see ::SDL_Keycode for details
  @SDL_Keycode()
  external int sym;

  /// < current key modifiers
  @Uint16()
  external int mod;

  @Uint32()
  external int unused;
}

/// \brief The SDL virtual key representation.
///
/// Values of this type are used to represent keyboard keys using the current
/// layout of the keyboard.  These values include Unicode values representing
/// the unmodified character that would be generated by pressing the key, or
/// an SDLK_* constant for those keys that do not generate characters.
///
/// A special exception is the number keys at the top of the keyboard which
/// always map to SDLK_0...SDLK_9, regardless of layout.
typedef SDL_Keycode = Sint32;
typedef Sint32 = ffi.Int32;

class SDL_Cursor extends ffi.Opaque {}

/// \brief Cursor types for SDL_CreateSystemCursor().
abstract class SDL_SystemCursor {
  /// < Arrow
  static const int SDL_SYSTEM_CURSOR_ARROW = 0;

  /// < I-beam
  static const int SDL_SYSTEM_CURSOR_IBEAM = 1;

  /// < Wait
  static const int SDL_SYSTEM_CURSOR_WAIT = 2;

  /// < Crosshair
  static const int SDL_SYSTEM_CURSOR_CROSSHAIR = 3;

  /// < Small wait cursor (or Wait if not available)
  static const int SDL_SYSTEM_CURSOR_WAITARROW = 4;

  /// < Double arrow pointing northwest and southeast
  static const int SDL_SYSTEM_CURSOR_SIZENWSE = 5;

  /// < Double arrow pointing northeast and southwest
  static const int SDL_SYSTEM_CURSOR_SIZENESW = 6;

  /// < Double arrow pointing west and east
  static const int SDL_SYSTEM_CURSOR_SIZEWE = 7;

  /// < Double arrow pointing north and south
  static const int SDL_SYSTEM_CURSOR_SIZENS = 8;

  /// < Four pointed arrow pointing north, south, east, and west
  static const int SDL_SYSTEM_CURSOR_SIZEALL = 9;

  /// < Slashed circle or crossbones
  static const int SDL_SYSTEM_CURSOR_NO = 10;

  /// < Hand
  static const int SDL_SYSTEM_CURSOR_HAND = 11;
  static const int SDL_NUM_SYSTEM_CURSORS = 12;
}

/// \brief Scroll direction types for the Scroll event
abstract class SDL_MouseWheelDirection {
  /// < The scroll direction is normal
  static const int SDL_MOUSEWHEEL_NORMAL = 0;

  /// < The scroll direction is flipped / natural
  static const int SDL_MOUSEWHEEL_FLIPPED = 1;
}

/// The joystick structure used to identify an SDL joystick
class _SDL_Joystick extends ffi.Opaque {}

class SDL_JoystickGUID extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<Uint8> data;
}

abstract class SDL_JoystickType {
  static const int SDL_JOYSTICK_TYPE_UNKNOWN = 0;
  static const int SDL_JOYSTICK_TYPE_GAMECONTROLLER = 1;
  static const int SDL_JOYSTICK_TYPE_WHEEL = 2;
  static const int SDL_JOYSTICK_TYPE_ARCADE_STICK = 3;
  static const int SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4;
  static const int SDL_JOYSTICK_TYPE_DANCE_PAD = 5;
  static const int SDL_JOYSTICK_TYPE_GUITAR = 6;
  static const int SDL_JOYSTICK_TYPE_DRUM_KIT = 7;
  static const int SDL_JOYSTICK_TYPE_ARCADE_PAD = 8;
  static const int SDL_JOYSTICK_TYPE_THROTTLE = 9;
}

abstract class SDL_JoystickPowerLevel {
  static const int SDL_JOYSTICK_POWER_UNKNOWN = -1;
  static const int SDL_JOYSTICK_POWER_EMPTY = 0;
  static const int SDL_JOYSTICK_POWER_LOW = 1;
  static const int SDL_JOYSTICK_POWER_MEDIUM = 2;
  static const int SDL_JOYSTICK_POWER_FULL = 3;
  static const int SDL_JOYSTICK_POWER_WIRED = 4;
  static const int SDL_JOYSTICK_POWER_MAX = 5;
}

/// This is a unique ID for a joystick for the time it is connected to the system,
/// and is never reused for the lifetime of the application. If the joystick is
/// disconnected and reconnected, it will get a new ID.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
typedef SDL_JoystickID = Sint32;
typedef SDL_Joystick = _SDL_Joystick;
typedef Sint16 = ffi.Int16;

/// \brief SDL_sensor.h
///
/// In order to use these functions, SDL_Init() must have been called
/// with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system
/// for sensors, and load appropriate drivers.
class _SDL_Sensor extends ffi.Opaque {}

abstract class SDL_SensorType {
  /// < Returned for an invalid sensor
  static const int SDL_SENSOR_INVALID = -1;

  /// < Unknown sensor type
  static const int SDL_SENSOR_UNKNOWN = 0;

  /// < Accelerometer
  static const int SDL_SENSOR_ACCEL = 1;

  /// < Gyroscope
  static const int SDL_SENSOR_GYRO = 2;
}

/// This is a unique ID for a sensor for the time it is connected to the system,
/// and is never reused for the lifetime of the application.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
typedef SDL_SensorID = Sint32;
typedef SDL_Sensor = _SDL_Sensor;

/// The gamecontroller structure used to identify an SDL game controller
class _SDL_GameController extends ffi.Opaque {}

abstract class SDL_GameControllerType {
  static const int SDL_CONTROLLER_TYPE_UNKNOWN = 0;
  static const int SDL_CONTROLLER_TYPE_XBOX360 = 1;
  static const int SDL_CONTROLLER_TYPE_XBOXONE = 2;
  static const int SDL_CONTROLLER_TYPE_PS3 = 3;
  static const int SDL_CONTROLLER_TYPE_PS4 = 4;
  static const int SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO = 5;
  static const int SDL_CONTROLLER_TYPE_VIRTUAL = 6;
  static const int SDL_CONTROLLER_TYPE_PS5 = 7;
  static const int SDL_CONTROLLER_TYPE_AMAZON_LUNA = 8;
  static const int SDL_CONTROLLER_TYPE_GOOGLE_STADIA = 9;
}

abstract class SDL_GameControllerBindType {
  static const int SDL_CONTROLLER_BINDTYPE_NONE = 0;
  static const int SDL_CONTROLLER_BINDTYPE_BUTTON = 1;
  static const int SDL_CONTROLLER_BINDTYPE_AXIS = 2;
  static const int SDL_CONTROLLER_BINDTYPE_HAT = 3;
}

/// Get the SDL joystick layer binding for this controller button/axis mapping
class SDL_GameControllerButtonBind extends ffi.Struct {
  @ffi.Int32()
  external int bindType;

  external UnnamedUnion2 value;
}

class UnnamedUnion2 extends ffi.Union {
  @ffi.Int()
  external int button;

  @ffi.Int()
  external int axis;

  external UnnamedStruct5 hat;
}

class UnnamedStruct5 extends ffi.Struct {
  @ffi.Int()
  external int hat;

  @ffi.Int()
  external int hat_mask;
}

typedef SDL_GameController = _SDL_GameController;

/// The list of axes available from a controller
///
/// Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,
/// and are centered within ~8000 of zero, though advanced UI will allow users to set
/// or autodetect the dead zone, which varies between controllers.
///
/// Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX.
abstract class SDL_GameControllerAxis {
  static const int SDL_CONTROLLER_AXIS_INVALID = -1;
  static const int SDL_CONTROLLER_AXIS_LEFTX = 0;
  static const int SDL_CONTROLLER_AXIS_LEFTY = 1;
  static const int SDL_CONTROLLER_AXIS_RIGHTX = 2;
  static const int SDL_CONTROLLER_AXIS_RIGHTY = 3;
  static const int SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4;
  static const int SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5;
  static const int SDL_CONTROLLER_AXIS_MAX = 6;
}

/// The list of buttons available from a controller
abstract class SDL_GameControllerButton {
  static const int SDL_CONTROLLER_BUTTON_INVALID = -1;
  static const int SDL_CONTROLLER_BUTTON_A = 0;
  static const int SDL_CONTROLLER_BUTTON_B = 1;
  static const int SDL_CONTROLLER_BUTTON_X = 2;
  static const int SDL_CONTROLLER_BUTTON_Y = 3;
  static const int SDL_CONTROLLER_BUTTON_BACK = 4;
  static const int SDL_CONTROLLER_BUTTON_GUIDE = 5;
  static const int SDL_CONTROLLER_BUTTON_START = 6;
  static const int SDL_CONTROLLER_BUTTON_LEFTSTICK = 7;
  static const int SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8;
  static const int SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9;
  static const int SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10;
  static const int SDL_CONTROLLER_BUTTON_DPAD_UP = 11;
  static const int SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12;
  static const int SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13;
  static const int SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14;
  static const int SDL_CONTROLLER_BUTTON_MISC1 = 15;
  static const int SDL_CONTROLLER_BUTTON_PADDLE1 = 16;
  static const int SDL_CONTROLLER_BUTTON_PADDLE2 = 17;
  static const int SDL_CONTROLLER_BUTTON_PADDLE3 = 18;
  static const int SDL_CONTROLLER_BUTTON_PADDLE4 = 19;
  static const int SDL_CONTROLLER_BUTTON_TOUCHPAD = 20;
  static const int SDL_CONTROLLER_BUTTON_MAX = 21;
}

abstract class SDL_TouchDeviceType {
  static const int SDL_TOUCH_DEVICE_INVALID = -1;
  static const int SDL_TOUCH_DEVICE_DIRECT = 0;
  static const int SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1;
  static const int SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2;
}

class SDL_Finger extends ffi.Struct {
  @SDL_FingerID()
  external int id;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double pressure;
}

typedef SDL_FingerID = Sint64;
typedef SDL_TouchID = Sint64;
typedef SDL_GestureID = Sint64;

/// The types of events that can be delivered.
abstract class SDL_EventType {
  /// < Unused (do not remove)
  static const int SDL_FIRSTEVENT = 0;

  /// < User-requested quit
  static const int SDL_QUIT = 256;

  /// < The application is being terminated by the OS
  /// Called on iOS in applicationWillTerminate()
  /// Called on Android in onDestroy()
  static const int SDL_APP_TERMINATING = 257;

  /// < The application is low on memory, free memory if possible.
  /// Called on iOS in applicationDidReceiveMemoryWarning()
  /// Called on Android in onLowMemory()
  static const int SDL_APP_LOWMEMORY = 258;

  /// < The application is about to enter the background
  /// Called on iOS in applicationWillResignActive()
  /// Called on Android in onPause()
  static const int SDL_APP_WILLENTERBACKGROUND = 259;

  /// < The application did enter the background and may not get CPU for some time
  /// Called on iOS in applicationDidEnterBackground()
  /// Called on Android in onPause()
  static const int SDL_APP_DIDENTERBACKGROUND = 260;

  /// < The application is about to enter the foreground
  /// Called on iOS in applicationWillEnterForeground()
  /// Called on Android in onResume()
  static const int SDL_APP_WILLENTERFOREGROUND = 261;

  /// < The application is now interactive
  /// Called on iOS in applicationDidBecomeActive()
  /// Called on Android in onResume()
  static const int SDL_APP_DIDENTERFOREGROUND = 262;

  /// < The user's locale preferences have changed.
  static const int SDL_LOCALECHANGED = 263;

  /// < Display state change
  static const int SDL_DISPLAYEVENT = 336;

  /// < Window state change
  static const int SDL_WINDOWEVENT = 512;

  /// < System specific event
  static const int SDL_SYSWMEVENT = 513;

  /// < Key pressed
  static const int SDL_KEYDOWN = 768;

  /// < Key released
  static const int SDL_KEYUP = 769;

  /// < Keyboard text editing (composition)
  static const int SDL_TEXTEDITING = 770;

  /// < Keyboard text input
  static const int SDL_TEXTINPUT = 771;

  /// < Keymap changed due to a system event such as an
  /// input language or keyboard layout change.
  static const int SDL_KEYMAPCHANGED = 772;

  /// < Mouse moved
  static const int SDL_MOUSEMOTION = 1024;

  /// < Mouse button pressed
  static const int SDL_MOUSEBUTTONDOWN = 1025;

  /// < Mouse button released
  static const int SDL_MOUSEBUTTONUP = 1026;

  /// < Mouse wheel motion
  static const int SDL_MOUSEWHEEL = 1027;

  /// < Joystick axis motion
  static const int SDL_JOYAXISMOTION = 1536;

  /// < Joystick trackball motion
  static const int SDL_JOYBALLMOTION = 1537;

  /// < Joystick hat position change
  static const int SDL_JOYHATMOTION = 1538;

  /// < Joystick button pressed
  static const int SDL_JOYBUTTONDOWN = 1539;

  /// < Joystick button released
  static const int SDL_JOYBUTTONUP = 1540;

  /// < A new joystick has been inserted into the system
  static const int SDL_JOYDEVICEADDED = 1541;

  /// < An opened joystick has been removed
  static const int SDL_JOYDEVICEREMOVED = 1542;

  /// < Game controller axis motion
  static const int SDL_CONTROLLERAXISMOTION = 1616;

  /// < Game controller button pressed
  static const int SDL_CONTROLLERBUTTONDOWN = 1617;

  /// < Game controller button released
  static const int SDL_CONTROLLERBUTTONUP = 1618;

  /// < A new Game controller has been inserted into the system
  static const int SDL_CONTROLLERDEVICEADDED = 1619;

  /// < An opened Game controller has been removed
  static const int SDL_CONTROLLERDEVICEREMOVED = 1620;

  /// < The controller mapping was updated
  static const int SDL_CONTROLLERDEVICEREMAPPED = 1621;

  /// < Game controller touchpad was touched
  static const int SDL_CONTROLLERTOUCHPADDOWN = 1622;

  /// < Game controller touchpad finger was moved
  static const int SDL_CONTROLLERTOUCHPADMOTION = 1623;

  /// < Game controller touchpad finger was lifted
  static const int SDL_CONTROLLERTOUCHPADUP = 1624;

  /// < Game controller sensor was updated
  static const int SDL_CONTROLLERSENSORUPDATE = 1625;
  static const int SDL_FINGERDOWN = 1792;
  static const int SDL_FINGERUP = 1793;
  static const int SDL_FINGERMOTION = 1794;
  static const int SDL_DOLLARGESTURE = 2048;
  static const int SDL_DOLLARRECORD = 2049;
  static const int SDL_MULTIGESTURE = 2050;

  /// < The clipboard changed
  static const int SDL_CLIPBOARDUPDATE = 2304;

  /// < The system requests a file open
  static const int SDL_DROPFILE = 4096;

  /// < text/plain drag-and-drop event
  static const int SDL_DROPTEXT = 4097;

  /// < A new set of drops is beginning (NULL filename)
  static const int SDL_DROPBEGIN = 4098;

  /// < Current set of drops is now complete (NULL filename)
  static const int SDL_DROPCOMPLETE = 4099;

  /// < A new audio device is available
  static const int SDL_AUDIODEVICEADDED = 4352;

  /// < An audio device has been removed.
  static const int SDL_AUDIODEVICEREMOVED = 4353;

  /// < A sensor was updated
  static const int SDL_SENSORUPDATE = 4608;

  /// < The render targets have been reset and their contents need to be updated
  static const int SDL_RENDER_TARGETS_RESET = 8192;

  /// < The device has been reset and all textures need to be recreated
  static const int SDL_RENDER_DEVICE_RESET = 8193;

  /// < Signals the end of an event poll cycle
  static const int SDL_POLLSENTINEL = 32512;

  /// Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
  /// and should be allocated with SDL_RegisterEvents()
  static const int SDL_USEREVENT = 32768;

  /// This last event is only for bounding internal arrays
  static const int SDL_LASTEVENT = 65535;
}

/// \brief Fields shared by every event
class SDL_CommonEvent extends ffi.Struct {
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief Display state change event data (event.display.*)
class SDL_DisplayEvent extends ffi.Struct {
  /// < ::SDL_DISPLAYEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated display index
  @Uint32()
  external int display;

  /// < ::SDL_DisplayEventID
  @Uint8()
  external int event;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < event dependent data
  @Sint32()
  external int data1;
}

/// \brief Window state change event data (event.window.*)
class SDL_WindowEvent extends ffi.Struct {
  /// < ::SDL_WINDOWEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated window
  @Uint32()
  external int windowID;

  /// < ::SDL_WindowEventID
  @Uint8()
  external int event;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < event dependent data
  @Sint32()
  external int data1;

  /// < event dependent data
  @Sint32()
  external int data2;
}

/// \brief Keyboard button event structure (event.key.*)
class SDL_KeyboardEvent extends ffi.Struct {
  /// < ::SDL_KEYDOWN or ::SDL_KEYUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  /// < Non-zero if this is a key repeat
  @Uint8()
  external int repeat;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The key that was pressed or released
  external SDL_Keysym keysym;
}

/// \brief Keyboard text editing event structure (event.edit.*)
class SDL_TextEditingEvent extends ffi.Struct {
  /// < ::SDL_TEXTEDITING
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> text;

  /// < The start cursor of selected editing text
  @Sint32()
  external int start;

  /// < The length of selected editing text
  @Sint32()
  external int length;
}

/// \brief Keyboard text input event structure (event.text.*)
class SDL_TextInputEvent extends ffi.Struct {
  /// < ::SDL_TEXTINPUT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> text;
}

/// \brief Mouse motion event structure (event.motion.*)
class SDL_MouseMotionEvent extends ffi.Struct {
  /// < ::SDL_MOUSEMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The current button state
  @Uint32()
  external int state;

  /// < X coordinate, relative to window
  @Sint32()
  external int x;

  /// < Y coordinate, relative to window
  @Sint32()
  external int y;

  /// < The relative motion in the X direction
  @Sint32()
  external int xrel;

  /// < The relative motion in the Y direction
  @Sint32()
  external int yrel;
}

/// \brief Mouse button event structure (event.button.*)
class SDL_MouseButtonEvent extends ffi.Struct {
  /// < ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The mouse button index
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  /// < 1 for single-click, 2 for double-click, etc.
  @Uint8()
  external int clicks;

  @Uint8()
  external int padding1;

  /// < X coordinate, relative to window
  @Sint32()
  external int x;

  /// < Y coordinate, relative to window
  @Sint32()
  external int y;
}

/// \brief Mouse wheel event structure (event.wheel.*)
class SDL_MouseWheelEvent extends ffi.Struct {
  /// < ::SDL_MOUSEWHEEL
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The amount scrolled horizontally, positive to the right and negative to the left
  @Sint32()
  external int x;

  /// < The amount scrolled vertically, positive away from the user and negative toward the user
  @Sint32()
  external int y;

  /// < Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back
  @Uint32()
  external int direction;

  /// < The amount scrolled horizontally, positive to the right and negative to the left, with float precision (added in 2.0.18)
  @ffi.Float()
  external double preciseX;

  /// < The amount scrolled vertically, positive away from the user and negative toward the user, with float precision (added in 2.0.18)
  @ffi.Float()
  external double preciseY;
}

/// \brief Joystick axis motion event structure (event.jaxis.*)
class SDL_JoyAxisEvent extends ffi.Struct {
  /// < ::SDL_JOYAXISMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick axis index
  @Uint8()
  external int axis;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @Sint16()
  external int value;

  @Uint16()
  external int padding4;
}

/// \brief Joystick trackball motion event structure (event.jball.*)
class SDL_JoyBallEvent extends ffi.Struct {
  /// < ::SDL_JOYBALLMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick trackball index
  @Uint8()
  external int ball;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The relative motion in the X direction
  @Sint16()
  external int xrel;

  /// < The relative motion in the Y direction
  @Sint16()
  external int yrel;
}

/// \brief Joystick hat position change event structure (event.jhat.*)
class SDL_JoyHatEvent extends ffi.Struct {
  /// < ::SDL_JOYHATMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick hat index
  @Uint8()
  external int hat;

  /// < The hat position value.
  /// \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
  /// \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
  /// \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
  ///
  /// Note that zero means the POV is centered.
  @Uint8()
  external int value;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Joystick button event structure (event.jbutton.*)
class SDL_JoyButtonEvent extends ffi.Struct {
  /// < ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick button index
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Joystick device event structure (event.jdevice.*)
class SDL_JoyDeviceEvent extends ffi.Struct {
  /// < ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED event
  @Sint32()
  external int which;
}

/// \brief Game controller axis motion event structure (event.caxis.*)
class SDL_ControllerAxisEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERAXISMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The controller axis (SDL_GameControllerAxis)
  @Uint8()
  external int axis;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @Sint16()
  external int value;

  @Uint16()
  external int padding4;
}

/// \brief Game controller button event structure (event.cbutton.*)
class SDL_ControllerButtonEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The controller button (SDL_GameControllerButton)
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Controller device event structure (event.cdevice.*)
class SDL_ControllerDeviceEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event
  @Sint32()
  external int which;
}

/// \brief Game controller touchpad event structure (event.ctouchpad.*)
class SDL_ControllerTouchpadEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERTOUCHPADDOWN or ::SDL_CONTROLLERTOUCHPADMOTION or ::SDL_CONTROLLERTOUCHPADUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The index of the touchpad
  @Sint32()
  external int touchpad;

  /// < The index of the finger on the touchpad
  @Sint32()
  external int finger;

  /// < Normalized in the range 0...1 with 0 being on the left
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1 with 0 being at the top
  @ffi.Float()
  external double y;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;
}

/// \brief Game controller sensor event structure (event.csensor.*)
class SDL_ControllerSensorEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERSENSORUPDATE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The type of the sensor, one of the values of ::SDL_SensorType
  @Sint32()
  external int sensor;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Float> data;
}

/// \brief Audio device event structure (event.adevice.*)
class SDL_AudioDeviceEvent extends ffi.Struct {
  /// < ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event
  @Uint32()
  external int which;

  /// < zero if an output device, non-zero if a capture device.
  @Uint8()
  external int iscapture;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;
}

/// \brief Touch finger event structure (event.tfinger.*)
class SDL_TouchFingerEvent extends ffi.Struct {
  /// < ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @SDL_FingerID()
  external int fingerId;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double y;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dx;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dy;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;

  /// < The window underneath the finger, if any
  @Uint32()
  external int windowID;
}

/// \brief Multiple Finger Gesture Event (event.mgesture.*)
class SDL_MultiGestureEvent extends ffi.Struct {
  /// < ::SDL_MULTIGESTURE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @ffi.Float()
  external double dTheta;

  @ffi.Float()
  external double dDist;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @Uint16()
  external int numFingers;

  @Uint16()
  external int padding;
}

/// \brief Dollar Gesture Event (event.dgesture.*)
class SDL_DollarGestureEvent extends ffi.Struct {
  /// < ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @SDL_GestureID()
  external int gestureId;

  @Uint32()
  external int numFingers;

  @ffi.Float()
  external double error;

  /// < Normalized center of gesture
  @ffi.Float()
  external double x;

  /// < Normalized center of gesture
  @ffi.Float()
  external double y;
}

/// \brief An event used to request a file open by the system (event.drop.*)
/// This event is enabled by default, you can disable it with SDL_EventState().
/// \note If this event is enabled, you must free the filename in the event.
class SDL_DropEvent extends ffi.Struct {
  /// < ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The file name, which should be freed with SDL_free(), is NULL on begin/complete
  external ffi.Pointer<ffi.Char> file;

  /// < The window that was dropped on, if any
  @Uint32()
  external int windowID;
}

/// \brief Sensor event structure (event.sensor.*)
class SDL_SensorEvent extends ffi.Struct {
  /// < ::SDL_SENSORUPDATE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The instance ID of the sensor
  @Sint32()
  external int which;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Float> data;
}

/// \brief The "quit requested" event
class SDL_QuitEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief OS Specific event
class SDL_OSEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief A user-defined event type (event.user.*)
class SDL_UserEvent extends ffi.Struct {
  /// < ::SDL_USEREVENT through ::SDL_LASTEVENT-1
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated window if any
  @Uint32()
  external int windowID;

  /// < User defined event code
  @Sint32()
  external int code;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data1;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data2;
}

class SDL_SysWMmsg extends ffi.Opaque {}

/// \brief A video driver dependent system event (event.syswm.*)
/// This event is disabled by default, you can enable it with SDL_EventState()
///
/// \note If you want to use this event, you should include SDL_syswm.h.
class SDL_SysWMEvent extends ffi.Struct {
  /// < ::SDL_SYSWMEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < driver dependent data, defined in SDL_syswm.h
  external ffi.Pointer<SDL_SysWMmsg> msg;
}

/// \brief General event structure
class SDL_Event extends ffi.Union {
  /// < Event type, shared with all events
  @Uint32()
  external int type;

  /// < Common event data
  external SDL_CommonEvent common;

  /// < Display event data
  external SDL_DisplayEvent display;

  /// < Window event data
  external SDL_WindowEvent window;

  /// < Keyboard event data
  external SDL_KeyboardEvent key;

  /// < Text editing event data
  external SDL_TextEditingEvent edit;

  /// < Text input event data
  external SDL_TextInputEvent text;

  /// < Mouse motion event data
  external SDL_MouseMotionEvent motion;

  /// < Mouse button event data
  external SDL_MouseButtonEvent button;

  /// < Mouse wheel event data
  external SDL_MouseWheelEvent wheel;

  /// < Joystick axis event data
  external SDL_JoyAxisEvent jaxis;

  /// < Joystick ball event data
  external SDL_JoyBallEvent jball;

  /// < Joystick hat event data
  external SDL_JoyHatEvent jhat;

  /// < Joystick button event data
  external SDL_JoyButtonEvent jbutton;

  /// < Joystick device change event data
  external SDL_JoyDeviceEvent jdevice;

  /// < Game Controller axis event data
  external SDL_ControllerAxisEvent caxis;

  /// < Game Controller button event data
  external SDL_ControllerButtonEvent cbutton;

  /// < Game Controller device event data
  external SDL_ControllerDeviceEvent cdevice;

  /// < Game Controller touchpad event data
  external SDL_ControllerTouchpadEvent ctouchpad;

  /// < Game Controller sensor event data
  external SDL_ControllerSensorEvent csensor;

  /// < Audio device event data
  external SDL_AudioDeviceEvent adevice;

  /// < Sensor event data
  external SDL_SensorEvent sensor;

  /// < Quit request event data
  external SDL_QuitEvent quit;

  /// < Custom event data
  external SDL_UserEvent user;

  /// < System dependent window event data
  external SDL_SysWMEvent syswm;

  /// < Touch finger event data
  external SDL_TouchFingerEvent tfinger;

  /// < Gesture event data
  external SDL_MultiGestureEvent mgesture;

  /// < Gesture event data
  external SDL_DollarGestureEvent dgesture;

  /// < Drag and drop event data
  external SDL_DropEvent drop;

  @ffi.Array.multi([56])
  external ffi.Array<Uint8> padding;
}

abstract class SDL_eventaction {
  static const int SDL_ADDEVENT = 0;
  static const int SDL_PEEKEVENT = 1;
  static const int SDL_GETEVENT = 2;
}

/// A function pointer used for callbacks that watch the event queue.
///
/// \param userdata what was passed as `userdata` to SDL_SetEventFilter()
/// or SDL_AddEventWatch, etc
/// \param event the event that triggered the callback
/// \returns 1 to permit event to be added to the queue, and 0 to disallow
/// it. When used with SDL_AddEventWatch, the return value is ignored.
///
/// \sa SDL_SetEventFilter
/// \sa SDL_AddEventWatch
typedef SDL_EventFilter = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<SDL_Event>)>>;

/// \typedef SDL_Haptic
///
/// \brief The haptic structure used to identify an SDL haptic.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticOpenFromJoystick
/// \sa SDL_HapticClose
class _SDL_Haptic extends ffi.Opaque {}

/// \brief Structure that represents a haptic direction.
///
/// This is the direction where the force comes from,
/// instead of the direction in which the force is exerted.
///
/// Directions can be specified by:
/// - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
/// - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
/// - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
///
/// Cardinal directions of the haptic device are relative to the positioning
/// of the device.  North is considered to be away from the user.
///
/// The following diagram represents the cardinal directions:
/// \verbatim
/// .--.
/// |__| .-------.
/// |=.| |.-----.|
/// |--| ||     ||
/// |  | |'-----'|
/// |__|~')_____('
/// [ COMPUTER ]
///
///
/// North (0,-1)
/// ^
/// |
/// |
/// (-1,0)  West <----[ HAPTIC ]----> East (1,0)
/// |
/// |
/// v
/// South (0,1)
///
///
/// [ USER ]
/// \|||/
/// (o o)
/// ---ooO-(_)-Ooo---
/// \endverbatim
///
/// If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
/// degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
/// the first \c dir parameter.  The cardinal directions would be:
/// - North: 0 (0 degrees)
/// - East: 9000 (90 degrees)
/// - South: 18000 (180 degrees)
/// - West: 27000 (270 degrees)
///
/// If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
/// (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
/// the first three \c dir parameters.  The cardinal directions would be:
/// - North:  0,-1, 0
/// - East:   1, 0, 0
/// - South:  0, 1, 0
/// - West:  -1, 0, 0
///
/// The Z axis represents the height of the effect if supported, otherwise
/// it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
/// can use any multiple you want, only the direction matters.
///
/// If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
/// The first two \c dir parameters are used.  The \c dir parameters are as
/// follows (all values are in hundredths of degrees):
/// - Degrees from (1, 0) rotated towards (0, 1).
/// - Degrees towards (0, 0, 1) (device needs at least 3 axes).
///
///
/// Example of force coming from the south with all encodings (force coming
/// from the south means the user will have to pull the stick to counteract):
/// \code
/// SDL_HapticDirection direction;
///
/// // Cartesian directions
/// direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
/// direction.dir[0] = 0; // X position
/// direction.dir[1] = 1; // Y position
/// // Assuming the device has 2 axes, we don't need to specify third parameter.
///
/// // Polar directions
/// direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
/// direction.dir[0] = 18000; // Polar only uses first parameter
///
/// // Spherical coordinates
/// direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
/// direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
/// \endcode
///
/// \sa SDL_HAPTIC_POLAR
/// \sa SDL_HAPTIC_CARTESIAN
/// \sa SDL_HAPTIC_SPHERICAL
/// \sa SDL_HAPTIC_STEERING_AXIS
/// \sa SDL_HapticEffect
/// \sa SDL_HapticNumAxes
class SDL_HapticDirection extends ffi.Struct {
  /// < The type of encoding.
  @Uint8()
  external int type;

  @ffi.Array.multi([3])
  external ffi.Array<Sint32> dir;
}

/// \brief A structure containing a template for a Constant effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.
///
/// A constant effect applies a constant force in the specified direction
/// to the joystick.
///
/// \sa SDL_HAPTIC_CONSTANT
/// \sa SDL_HapticEffect
class SDL_HapticConstant extends ffi.Struct {
  /// < ::SDL_HAPTIC_CONSTANT
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Strength of the constant effect.
  @Sint16()
  external int level;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief A structure containing a template for a Periodic effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SINE
/// - ::SDL_HAPTIC_LEFTRIGHT
/// - ::SDL_HAPTIC_TRIANGLE
/// - ::SDL_HAPTIC_SAWTOOTHUP
/// - ::SDL_HAPTIC_SAWTOOTHDOWN
///
/// A periodic effect consists in a wave-shaped effect that repeats itself
/// over time.  The type determines the shape of the wave and the parameters
/// determine the dimensions of the wave.
///
/// Phase is given by hundredth of a degree meaning that giving the phase a value
/// of 9000 will displace it 25% of its period.  Here are sample values:
/// -     0: No phase displacement.
/// -  9000: Displaced 25% of its period.
/// - 18000: Displaced 50% of its period.
/// - 27000: Displaced 75% of its period.
/// - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
///
/// Examples:
/// \verbatim
/// SDL_HAPTIC_SINE
/// __      __      __      __
/// /  \    /  \    /  \    /
/// /    \__/    \__/    \__/
///
/// SDL_HAPTIC_SQUARE
/// __    __    __    __    __
/// |  |  |  |  |  |  |  |  |  |
/// |  |__|  |__|  |__|  |__|  |
///
/// SDL_HAPTIC_TRIANGLE
/// /\    /\    /\    /\    /\
/// /  \  /  \  /  \  /  \  /
/// /    \/    \/    \/    \/
///
/// SDL_HAPTIC_SAWTOOTHUP
/// /|  /|  /|  /|  /|  /|  /|
/// / | / | / | / | / | / | / |
/// /  |/  |/  |/  |/  |/  |/  |
///
/// SDL_HAPTIC_SAWTOOTHDOWN
/// \  |\  |\  |\  |\  |\  |\  |
/// \ | \ | \ | \ | \ | \ | \ |
/// \|  \|  \|  \|  \|  \|  \|
/// \endverbatim
///
/// \sa SDL_HAPTIC_SINE
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HAPTIC_TRIANGLE
/// \sa SDL_HAPTIC_SAWTOOTHUP
/// \sa SDL_HAPTIC_SAWTOOTHDOWN
/// \sa SDL_HapticEffect
class SDL_HapticPeriodic extends ffi.Struct {
  /// < ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,
  /// ::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or
  /// ::SDL_HAPTIC_SAWTOOTHDOWN
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Period of the wave.
  @Uint16()
  external int period;

  /// < Peak value; if negative, equivalent to 180 degrees extra phase shift.
  @Sint16()
  external int magnitude;

  /// < Mean value of the wave.
  @Sint16()
  external int offset;

  /// < Positive phase shift given by hundredth of a degree.
  @Uint16()
  external int phase;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief A structure containing a template for a Condition effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SPRING: Effect based on axes position.
/// - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
/// - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
/// - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
///
/// Direction is handled by condition internals instead of a direction member.
/// The condition effect specific members have three parameters.  The first
/// refers to the X axis, the second refers to the Y axis and the third
/// refers to the Z axis.  The right terms refer to the positive side of the
/// axis and the left terms refer to the negative side of the axis.  Please
/// refer to the ::SDL_HapticDirection diagram for which side is positive and
/// which is negative.
///
/// \sa SDL_HapticDirection
/// \sa SDL_HAPTIC_SPRING
/// \sa SDL_HAPTIC_DAMPER
/// \sa SDL_HAPTIC_INERTIA
/// \sa SDL_HAPTIC_FRICTION
/// \sa SDL_HapticEffect
class SDL_HapticCondition extends ffi.Struct {
  /// < ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,
  /// ::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION
  @Uint16()
  external int type;

  /// < Direction of the effect - Not used ATM.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  @ffi.Array.multi([3])
  external ffi.Array<Uint16> right_sat;

  @ffi.Array.multi([3])
  external ffi.Array<Uint16> left_sat;

  @ffi.Array.multi([3])
  external ffi.Array<Sint16> right_coeff;

  @ffi.Array.multi([3])
  external ffi.Array<Sint16> left_coeff;

  @ffi.Array.multi([3])
  external ffi.Array<Uint16> deadband;

  @ffi.Array.multi([3])
  external ffi.Array<Sint16> center;
}

/// \brief A structure containing a template for a Ramp effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
///
/// The ramp effect starts at start strength and ends at end strength.
/// It augments in linear fashion.  If you use attack and fade with a ramp
/// the effects get added to the ramp effect making the effect become
/// quadratic instead of linear.
///
/// \sa SDL_HAPTIC_RAMP
/// \sa SDL_HapticEffect
class SDL_HapticRamp extends ffi.Struct {
  /// < ::SDL_HAPTIC_RAMP
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Beginning strength level.
  @Sint16()
  external int start;

  /// < Ending strength level.
  @Sint16()
  external int end;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief A structure containing a template for a Left/Right effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
///
/// The Left/Right effect is used to explicitly control the large and small
/// motors, commonly found in modern game controllers. The small (right) motor
/// is high frequency, and the large (left) motor is low frequency.
///
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HapticEffect
class SDL_HapticLeftRight extends ffi.Struct {
  /// < ::SDL_HAPTIC_LEFTRIGHT
  @Uint16()
  external int type;

  /// < Duration of the effect in milliseconds.
  @Uint32()
  external int length;

  /// < Control of the large controller motor.
  @Uint16()
  external int large_magnitude;

  /// < Control of the small controller motor.
  @Uint16()
  external int small_magnitude;
}

/// \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.
///
/// A custom force feedback effect is much like a periodic effect, where the
/// application can define its exact shape.  You will have to allocate the
/// data yourself.  Data should consist of channels * samples Uint16 samples.
///
/// If channels is one, the effect is rotated using the defined direction.
/// Otherwise it uses the samples in data for the different axes.
///
/// \sa SDL_HAPTIC_CUSTOM
/// \sa SDL_HapticEffect
class SDL_HapticCustom extends ffi.Struct {
  /// < ::SDL_HAPTIC_CUSTOM
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Axes to use, minimum of one.
  @Uint8()
  external int channels;

  /// < Sample periods.
  @Uint16()
  external int period;

  /// < Amount of samples.
  @Uint16()
  external int samples;

  /// < Should contain channels*samples items.
  external ffi.Pointer<Uint16> data;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief The generic template for any haptic effect.
///
/// All values max at 32767 (0x7FFF).  Signed values also can be negative.
/// Time values unless specified otherwise are in milliseconds.
///
/// You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767
/// value.  Neither delay, interval, attack_length nor fade_length support
/// ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
///
/// Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of
/// ::SDL_HAPTIC_INFINITY.
///
/// Button triggers may not be supported on all devices, it is advised to not
/// use them if possible.  Buttons start at index 1 instead of index 0 like
/// the joystick.
///
/// If both attack_length and fade_level are 0, the envelope is not used,
/// otherwise both values are used.
///
/// Common parts:
/// \code
/// // Replay - All effects have this
/// Uint32 length;        // Duration of effect (ms).
/// Uint16 delay;         // Delay before starting effect.
///
/// // Trigger - All effects have this
/// Uint16 button;        // Button that triggers effect.
/// Uint16 interval;      // How soon before effect can be triggered again.
///
/// // Envelope - All effects except condition effects have this
/// Uint16 attack_length; // Duration of the attack (ms).
/// Uint16 attack_level;  // Level at the start of the attack.
/// Uint16 fade_length;   // Duration of the fade out (ms).
/// Uint16 fade_level;    // Level at the end of the fade.
/// \endcode
///
///
/// Here we have an example of a constant effect evolution in time:
/// \verbatim
/// Strength
/// ^
/// |
/// |    effect level -->  _________________
/// |                     /                 \
/// |                    /                   \
/// |                   /                     \
/// |                  /                       \
/// | attack_level --> |                        \
/// |                  |                        |  <---  fade_level
/// |
/// +--------------------------------------------------> Time
/// [--]                 [---]
/// attack_length        fade_length
///
/// [------------------][-----------------------]
/// delay               length
/// \endverbatim
///
/// Note either the attack_level or the fade_level may be above the actual
/// effect level.
///
/// \sa SDL_HapticConstant
/// \sa SDL_HapticPeriodic
/// \sa SDL_HapticCondition
/// \sa SDL_HapticRamp
/// \sa SDL_HapticLeftRight
/// \sa SDL_HapticCustom
class SDL_HapticEffect extends ffi.Union {
  /// < Effect type.
  @Uint16()
  external int type;

  /// < Constant effect.
  external SDL_HapticConstant constant;

  /// < Periodic effect.
  external SDL_HapticPeriodic periodic;

  /// < Condition effect.
  external SDL_HapticCondition condition;

  /// < Ramp effect.
  external SDL_HapticRamp ramp;

  /// < Left/Right effect.
  external SDL_HapticLeftRight leftright;

  /// < Custom effect.
  external SDL_HapticCustom custom;
}

typedef SDL_Haptic = _SDL_Haptic;

/// \brief  A handle representing an open HID device
class SDL_hid_device_ extends ffi.Opaque {}

/// hidapi info structure */
/// /**
/// \brief  Information about a connected HID device
class SDL_hid_device_info extends ffi.Struct {
  /// Platform-specific device path
  external ffi.Pointer<ffi.Char> path;

  /// Device Vendor ID
  @ffi.UnsignedShort()
  external int vendor_id;

  /// Device Product ID
  @ffi.UnsignedShort()
  external int product_id;

  /// Serial Number
  external ffi.Pointer<ffi.WChar> serial_number;

  /// Device Release Number in binary-coded decimal,
  /// also known as Device Version Number
  @ffi.UnsignedShort()
  external int release_number;

  /// Manufacturer String
  external ffi.Pointer<ffi.WChar> manufacturer_string;

  /// Product string
  external ffi.Pointer<ffi.WChar> product_string;

  /// Usage Page for this Device/Interface
  /// (Windows/Mac only).
  @ffi.UnsignedShort()
  external int usage_page;

  /// Usage for this Device/Interface
  /// (Windows/Mac only).
  @ffi.UnsignedShort()
  external int usage;

  /// The USB interface which this logical device
  /// represents.
  ///
  /// Valid on both Linux implementations in all cases.
  /// Valid on the Windows implementation only if the device
  /// contains more than one interface.
  @ffi.Int()
  external int interface_number;

  /// Additional information about the USB interface.
  /// Valid on libusb and Android implementations.
  @ffi.Int()
  external int interface_class;

  @ffi.Int()
  external int interface_subclass;

  @ffi.Int()
  external int interface_protocol;

  /// Pointer to the next device
  external ffi.Pointer<SDL_hid_device_info> next;
}

typedef SDL_hid_device = SDL_hid_device_;

/// \brief  An enumeration of hint priorities
abstract class SDL_HintPriority {
  static const int SDL_HINT_DEFAULT = 0;
  static const int SDL_HINT_NORMAL = 1;
  static const int SDL_HINT_OVERRIDE = 2;
}

/// Type definition of the hint callback function.
///
/// \param userdata what was passed as `userdata` to SDL_AddHintCallback()
/// \param name what was passed as `name` to SDL_AddHintCallback()
/// \param oldValue the previous hint value
/// \param newValue the new value hint is to be set to
typedef SDL_HintCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>;

/// \brief The predefined log categories
///
/// By default the application category is enabled at the INFO level,
/// the assert category is enabled at the WARN level, test is enabled
/// at the VERBOSE level and all other categories are enabled at the
/// CRITICAL level.
abstract class SDL_LogCategory {
  static const int SDL_LOG_CATEGORY_APPLICATION = 0;
  static const int SDL_LOG_CATEGORY_ERROR = 1;
  static const int SDL_LOG_CATEGORY_ASSERT = 2;
  static const int SDL_LOG_CATEGORY_SYSTEM = 3;
  static const int SDL_LOG_CATEGORY_AUDIO = 4;
  static const int SDL_LOG_CATEGORY_VIDEO = 5;
  static const int SDL_LOG_CATEGORY_RENDER = 6;
  static const int SDL_LOG_CATEGORY_INPUT = 7;
  static const int SDL_LOG_CATEGORY_TEST = 8;
  static const int SDL_LOG_CATEGORY_RESERVED1 = 9;
  static const int SDL_LOG_CATEGORY_RESERVED2 = 10;
  static const int SDL_LOG_CATEGORY_RESERVED3 = 11;
  static const int SDL_LOG_CATEGORY_RESERVED4 = 12;
  static const int SDL_LOG_CATEGORY_RESERVED5 = 13;
  static const int SDL_LOG_CATEGORY_RESERVED6 = 14;
  static const int SDL_LOG_CATEGORY_RESERVED7 = 15;
  static const int SDL_LOG_CATEGORY_RESERVED8 = 16;
  static const int SDL_LOG_CATEGORY_RESERVED9 = 17;
  static const int SDL_LOG_CATEGORY_RESERVED10 = 18;
  static const int SDL_LOG_CATEGORY_CUSTOM = 19;
}

/// \brief The predefined log priorities
abstract class SDL_LogPriority {
  static const int SDL_LOG_PRIORITY_VERBOSE = 1;
  static const int SDL_LOG_PRIORITY_DEBUG = 2;
  static const int SDL_LOG_PRIORITY_INFO = 3;
  static const int SDL_LOG_PRIORITY_WARN = 4;
  static const int SDL_LOG_PRIORITY_ERROR = 5;
  static const int SDL_LOG_PRIORITY_CRITICAL = 6;
  static const int SDL_NUM_LOG_PRIORITIES = 7;
}

/// The prototype for the log output callback function.
///
/// This function is called by SDL when there is new text to be logged.
///
/// \param userdata what was passed as `userdata` to SDL_LogSetOutputFunction()
/// \param category the category of the message
/// \param priority the priority of the message
/// \param message the message being output
typedef SDL_LogOutputFunction = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int32, ffi.Pointer<ffi.Char>)>>;

/// SDL_MessageBox flags. If supported will display warning icon, etc.
abstract class SDL_MessageBoxFlags {
  /// < error dialog
  static const int SDL_MESSAGEBOX_ERROR = 16;

  /// < warning dialog
  static const int SDL_MESSAGEBOX_WARNING = 32;

  /// < informational dialog
  static const int SDL_MESSAGEBOX_INFORMATION = 64;

  /// < buttons placed left to right
  static const int SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = 128;

  /// < buttons placed right to left
  static const int SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = 256;
}

/// Flags for SDL_MessageBoxButtonData.
abstract class SDL_MessageBoxButtonFlags {
  /// < Marks the default button when return is hit
  static const int SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1;

  /// < Marks the default button when escape is hit
  static const int SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2;
}

/// Individual button data.
class SDL_MessageBoxButtonData extends ffi.Struct {
  /// < ::SDL_MessageBoxButtonFlags
  @Uint32()
  external int flags;

  /// < User defined button id (value returned via SDL_ShowMessageBox)
  @ffi.Int()
  external int buttonid;

  /// < The UTF-8 button text
  external ffi.Pointer<ffi.Char> text;
}

/// RGB value used in a message box color scheme
class SDL_MessageBoxColor extends ffi.Struct {
  @Uint8()
  external int r;

  @Uint8()
  external int g;

  @Uint8()
  external int b;
}

abstract class SDL_MessageBoxColorType {
  static const int SDL_MESSAGEBOX_COLOR_BACKGROUND = 0;
  static const int SDL_MESSAGEBOX_COLOR_TEXT = 1;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4;
  static const int SDL_MESSAGEBOX_COLOR_MAX = 5;
}

/// A set of colors to use for message box dialogs
class SDL_MessageBoxColorScheme extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<SDL_MessageBoxColor> colors;
}

/// MessageBox structure containing title, text, window, etc.
class SDL_MessageBoxData extends ffi.Struct {
  /// < ::SDL_MessageBoxFlags
  @Uint32()
  external int flags;

  /// < Parent window, can be NULL
  external ffi.Pointer<SDL_Window> window;

  /// < UTF-8 title
  external ffi.Pointer<ffi.Char> title;

  /// < UTF-8 message text
  external ffi.Pointer<ffi.Char> message;

  @ffi.Int()
  external int numbuttons;

  external ffi.Pointer<SDL_MessageBoxButtonData> buttons;

  /// < ::SDL_MessageBoxColorScheme, can be NULL to use system settings
  external ffi.Pointer<SDL_MessageBoxColorScheme> colorScheme;
}

/// \brief A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS).
///
/// \note This can be cast directly to an NSView or UIView.
typedef SDL_MetalView = ffi.Pointer<ffi.Void>;

/// The basic state for the system's power supply.
abstract class SDL_PowerState {
  /// < cannot determine power status
  static const int SDL_POWERSTATE_UNKNOWN = 0;

  /// < Not plugged in, running on the battery
  static const int SDL_POWERSTATE_ON_BATTERY = 1;

  /// < Plugged in, no battery available
  static const int SDL_POWERSTATE_NO_BATTERY = 2;

  /// < Plugged in, charging battery
  static const int SDL_POWERSTATE_CHARGING = 3;

  /// < Plugged in, battery charged
  static const int SDL_POWERSTATE_CHARGED = 4;
}

/// Flags used when creating a rendering context
abstract class SDL_RendererFlags {
  /// < The renderer is a software fallback
  static const int SDL_RENDERER_SOFTWARE = 1;

  /// < The renderer uses hardware
  /// acceleration
  static const int SDL_RENDERER_ACCELERATED = 2;

  /// < Present is synchronized
  /// with the refresh rate
  static const int SDL_RENDERER_PRESENTVSYNC = 4;

  /// < The renderer supports
  /// rendering to texture
  static const int SDL_RENDERER_TARGETTEXTURE = 8;
}

/// Information on the capabilities of a render driver or context.
class SDL_RendererInfo extends ffi.Struct {
  /// < The name of the renderer
  external ffi.Pointer<ffi.Char> name;

  /// < Supported ::SDL_RendererFlags
  @Uint32()
  external int flags;

  /// < The number of available texture formats
  @Uint32()
  external int num_texture_formats;

  @ffi.Array.multi([16])
  external ffi.Array<Uint32> texture_formats;

  /// < The maximum texture width
  @ffi.Int()
  external int max_texture_width;

  /// < The maximum texture height
  @ffi.Int()
  external int max_texture_height;
}

/// Vertex structure
class SDL_Vertex extends ffi.Struct {
  /// < Vertex position, in SDL_Renderer coordinates
  external SDL_FPoint position;

  /// < Vertex color
  external SDL_Color color;

  /// < Normalized texture coordinates, if needed
  external SDL_FPoint tex_coord;
}

/// The scaling mode for a texture.
abstract class SDL_ScaleMode {
  /// < nearest pixel sampling
  static const int SDL_ScaleModeNearest = 0;

  /// < linear filtering
  static const int SDL_ScaleModeLinear = 1;

  /// < anisotropic filtering
  static const int SDL_ScaleModeBest = 2;
}

/// The access pattern allowed for a texture.
abstract class SDL_TextureAccess {
  /// < Changes rarely, not lockable
  static const int SDL_TEXTUREACCESS_STATIC = 0;

  /// < Changes frequently, lockable
  static const int SDL_TEXTUREACCESS_STREAMING = 1;

  /// < Texture can be used as a render target
  static const int SDL_TEXTUREACCESS_TARGET = 2;
}

/// The texture channel modulation used in SDL_RenderCopy().
abstract class SDL_TextureModulate {
  /// < No modulation
  static const int SDL_TEXTUREMODULATE_NONE = 0;

  /// < srcC = srcC * color
  static const int SDL_TEXTUREMODULATE_COLOR = 1;

  /// < srcA = srcA * alpha
  static const int SDL_TEXTUREMODULATE_ALPHA = 2;
}

/// Flip constants for SDL_RenderCopyEx
abstract class SDL_RendererFlip {
  /// < Do not flip
  static const int SDL_FLIP_NONE = 0;

  /// < flip horizontally
  static const int SDL_FLIP_HORIZONTAL = 1;

  /// < flip vertically
  static const int SDL_FLIP_VERTICAL = 2;
}

/// A structure representing rendering state
class SDL_Renderer extends ffi.Opaque {}

/// An efficient driver-specific representation of pixel data
class SDL_Texture extends ffi.Opaque {}

/// \brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union.
abstract class WindowShapeMode {
  /// \brief The default mode, a binarized alpha cutoff of 1.
  static const int ShapeModeDefault = 0;

  /// \brief A binarized alpha cutoff with a given integer value.
  static const int ShapeModeBinarizeAlpha = 1;

  /// \brief A binarized alpha cutoff with a given integer value, but with the opposite comparison.
  static const int ShapeModeReverseBinarizeAlpha = 2;

  /// \brief A color key is applied.
  static const int ShapeModeColorKey = 3;
}

/// \brief A union containing parameters for shaped windows.
class SDL_WindowShapeParams extends ffi.Union {
  /// \brief A cutoff alpha value for binarization of the window shape's alpha channel.
  @Uint8()
  external int binarizationCutoff;

  external SDL_Color colorKey;
}

/// \brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents.
class SDL_WindowShapeMode extends ffi.Struct {
  /// \brief The mode of these window-shape parameters.
  @ffi.Int32()
  external int mode;

  /// \brief Window-shape parameters.
  external SDL_WindowShapeParams parameters;
}

typedef SDL_WindowsMessageHook = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
            ffi.UnsignedInt, Uint64, Sint64)>>;

class IDirect3DDevice9 extends ffi.Opaque {}

class ID3D11Device extends ffi.Opaque {}

/// Definition of the timer ID type.
typedef SDL_TimerID = ffi.Int;

/// Function prototype for the timer callback function.
///
/// The callback function is passed the current timer interval and returns
/// the next timer interval. If the returned value is the same as the one
/// passed in, the periodic alarm continues, otherwise a new alarm is
/// scheduled. If the callback returns 0, the periodic alarm is cancelled.
typedef SDL_TimerCallback = ffi.Pointer<
    ffi.NativeFunction<Uint32 Function(Uint32, ffi.Pointer<ffi.Void>)>>;

/// Information about the version of SDL in use.
///
/// Represents the library's version as three levels: major revision
/// (increments with massive changes, additions, and enhancements),
/// minor revision (increments with backwards-compatible changes to the
/// major revision), and patchlevel (increments with fixes to the minor
/// revision).
///
/// \sa SDL_VERSION
/// \sa SDL_GetVersion
class SDL_version extends ffi.Struct {
  /// < major version
  @Uint8()
  external int major;

  /// < minor version
  @Uint8()
  external int minor;

  /// < update version
  @Uint8()
  external int patch;
}

class SDL_Locale extends ffi.Struct {
  /// < A language name, like "en" for English.
  external ffi.Pointer<ffi.Char> language;

  /// < A country, like "US" for America. Can be NULL.
  external ffi.Pointer<ffi.Char> country;
}

const int HAVE_WINAPIFAMILY_H = 1;

const int WINAPI_PARTITION_SERVER = 0;

const int WINAPI_PARTITION_PKG_WINTRUST = 0;

const int WINAPI_PARTITION_PKG_WEBSERVICES = 0;

const int WINAPI_PARTITION_PKG_EVENTLOGSERVICE = 0;

const int WINAPI_PARTITION_PKG_VHD = 0;

const int WINAPI_PARTITION_PKG_PERFCOUNTER = 0;

const int WINAPI_PARTITION_PKG_SECURESTARTUP = 0;

const int WINAPI_PARTITION_PKG_REMOTEFS = 0;

const int WINAPI_PARTITION_PKG_BOOTABLESKU = 0;

const int WINAPI_PARTITION_PKG_CMDTOOLS = 0;

const int WINAPI_PARTITION_PKG_DISM = 0;

const int WINAPI_PARTITION_PKG_CORESETUP = 0;

const int WINAPI_PARTITION_PKG_APPRUNTIME = 0;

const int WINAPI_PARTITION_PKG_ESENT = 0;

const int WINAPI_PARTITION_PKG_WINMGMT = 0;

const int WINAPI_PARTITION_PKG_WNV = 0;

const int WINAPI_PARTITION_PKG_CLUSTER = 0;

const int WINAPI_PARTITION_PKG_VSS = 0;

const int WINAPI_PARTITION_PKG_TRAFFIC = 0;

const int WINAPI_PARTITION_PKG_ISCSI = 0;

const int WINAPI_PARTITION_PKG_STORAGE = 0;

const int WINAPI_PARTITION_PKG_MPSSVC = 0;

const int WINAPI_PARTITION_PKG_APPXDEPLOYMENT = 0;

const int WINAPI_PARTITION_PKG_WER = 0;

const int WINAPI_FAMILY_PC_APP = 2;

const int WINAPI_FAMILY_PHONE_APP = 3;

const int WINAPI_FAMILY_SYSTEM = 4;

const int WINAPI_FAMILY_SERVER = 5;

const int WINAPI_FAMILY_GAMES = 6;

const int WINAPI_FAMILY_DESKTOP_APP = 100;

const int WINAPI_FAMILY_APP = 2;

const int WINAPI_FAMILY = 100;

const int WINAPI_PARTITION_DESKTOP = 1;

const int WINAPI_PARTITION_APP = 1;

const int WINAPI_PARTITION_PC_APP = 1;

const int WINAPI_PARTITION_PHONE_APP = 0;

const int WINAPI_PARTITION_GAMES = 1;

const int WINAPI_PARTITION_SYSTEM = 0;

const int WINAPI_PARTITION_PHONE = 0;

const int WINAPI_FAMILY_WINRT = 0;

const int __WINDOWS__ = 1;

const int __WIN32__ = 1;

const int NULL = 0;

const int HAVE_WINSDKVER_H = 1;

const int _WIN32_MAXVER = 2560;

const int _WIN32_WINDOWS_MAXVER = 2560;

const int NTDDI_MAXVER = 2560;

const int _WIN32_IE_MAXVER = 2560;

const int _WIN32_WINNT_MAXVER = 2560;

const int WINVER_MAXVER = 2560;

const int HAVE_STDINT_H = 1;

const int SIZEOF_VOIDP = 8;

const int HAVE_DDRAW_H = 1;

const int HAVE_DINPUT_H = 1;

const int HAVE_DSOUND_H = 1;

const int HAVE_DXGI_H = 1;

const int HAVE_XINPUT_H = 1;

const int HAVE_WINDOWS_GAMING_INPUT_H = 1;

const int HAVE_D3D11_H = 1;

const int HAVE_MMDEVICEAPI_H = 1;

const int HAVE_AUDIOCLIENT_H = 1;

const int HAVE_TPCSHRD_H = 1;

const int HAVE_SENSORSAPI_H = 1;

const int HAVE_IMMINTRIN_H = 1;

const int HAVE_STDARG_H = 1;

const int HAVE_STDDEF_H = 1;

const int SDL_AUDIO_DRIVER_WASAPI = 1;

const int SDL_AUDIO_DRIVER_DSOUND = 1;

const int SDL_AUDIO_DRIVER_WINMM = 1;

const int SDL_AUDIO_DRIVER_DISK = 1;

const int SDL_AUDIO_DRIVER_DUMMY = 1;

const int SDL_JOYSTICK_DINPUT = 1;

const int SDL_JOYSTICK_HIDAPI = 1;

const int SDL_JOYSTICK_RAWINPUT = 1;

const int SDL_JOYSTICK_VIRTUAL = 1;

const int SDL_JOYSTICK_WGI = 1;

const int SDL_JOYSTICK_XINPUT = 1;

const int SDL_HAPTIC_DINPUT = 1;

const int SDL_HAPTIC_XINPUT = 1;

const int SDL_SENSOR_WINDOWS = 1;

const int SDL_LOADSO_WINDOWS = 1;

const int SDL_THREAD_GENERIC_COND_SUFFIX = 1;

const int SDL_THREAD_WINDOWS = 1;

const int SDL_TIMER_WINDOWS = 1;

const int SDL_VIDEO_DRIVER_DUMMY = 1;

const int SDL_VIDEO_DRIVER_WINDOWS = 1;

const int SDL_VIDEO_RENDER_D3D = 1;

const int SDL_VIDEO_RENDER_D3D11 = 1;

const int SDL_VIDEO_OPENGL = 1;

const int SDL_VIDEO_OPENGL_WGL = 1;

const int SDL_VIDEO_RENDER_OGL = 1;

const int SDL_VIDEO_RENDER_OGL_ES2 = 1;

const int SDL_VIDEO_OPENGL_ES2 = 1;

const int SDL_VIDEO_OPENGL_EGL = 1;

const int SDL_VIDEO_VULKAN = 1;

const int SDL_POWER_WINDOWS = 1;

const int SDL_FILESYSTEM_WINDOWS = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int SDL_MAX_SINT8 = 127;

const int SDL_MIN_SINT8 = -128;

const int SDL_MAX_UINT8 = 255;

const int SDL_MIN_UINT8 = 0;

const int SDL_MAX_SINT16 = 32767;

const int SDL_MIN_SINT16 = -32768;

const int SDL_MAX_UINT16 = 65535;

const int SDL_MIN_UINT16 = 0;

const int SDL_MAX_SINT32 = 2147483647;

const int SDL_MIN_SINT32 = -2147483648;

const int SDL_MAX_UINT32 = 4294967295;

const int SDL_MIN_UINT32 = 0;

const int SDL_MAX_SINT64 = 9223372036854775807;

const int SDL_MIN_SINT64 = -9223372036854775808;

const int SDL_MAX_UINT64 = -1;

const int SDL_MIN_UINT64 = 0;

const String SDL_PRIs64 = 'I64d';

const String SDL_PRIu64 = 'I64u';

const String SDL_PRIx64 = 'I64x';

const String SDL_PRIX64 = 'I64X';

const String SDL_PRIs32 = 'd';

const String SDL_PRIu32 = 'u';

const String SDL_PRIx32 = 'x';

const String SDL_PRIX32 = 'X';

const double M_PI = 3.141592653589793;

const int SDL_ICONV_ERROR = -1;

const int SDL_ICONV_E2BIG = -2;

const int SDL_ICONV_EILSEQ = -3;

const int SDL_ICONV_EINVAL = -4;

const int SDL_ASSERT_LEVEL = 1;

const String SDL_FILE = 'temp_for_macros.hpp';

const int SDL_LINE = 592;

const int SDL_NULL_WHILE_LOOP_CONDITION = 0;

const int _JBLEN = 16;

const int _HEAP_MAXREQ = -32;

const int _HEAPEMPTY = -1;

const int _HEAPOK = -2;

const int _HEAPBADBEGIN = -3;

const int _HEAPBADNODE = -4;

const int _HEAPEND = -5;

const int _HEAPBADPTR = -6;

const int _FREEENTRY = 0;

const int _USEDENTRY = 1;

const int _ALLOCA_S_THRESHOLD = 1024;

const int _ALLOCA_S_STACK_MARKER = 52428;

const int _ALLOCA_S_HEAP_MARKER = 56797;

const int _ALLOCA_S_MARKER_SIZE = 16;

const int _MM_HINT_NTA = 0;

const int _MM_HINT_T0 = 1;

const int _MM_HINT_T1 = 2;

const int _MM_HINT_T2 = 3;

const int _MM_HINT_ENTA = 4;

const int _MM_EXCEPT_MASK = 63;

const int _MM_EXCEPT_INVALID = 1;

const int _MM_EXCEPT_DENORM = 2;

const int _MM_EXCEPT_DIV_ZERO = 4;

const int _MM_EXCEPT_OVERFLOW = 8;

const int _MM_EXCEPT_UNDERFLOW = 16;

const int _MM_EXCEPT_INEXACT = 32;

const int _MM_MASK_MASK = 8064;

const int _MM_MASK_INVALID = 128;

const int _MM_MASK_DENORM = 256;

const int _MM_MASK_DIV_ZERO = 512;

const int _MM_MASK_OVERFLOW = 1024;

const int _MM_MASK_UNDERFLOW = 2048;

const int _MM_MASK_INEXACT = 4096;

const int _MM_ROUND_MASK = 24576;

const int _MM_ROUND_NEAREST = 0;

const int _MM_ROUND_DOWN = 8192;

const int _MM_ROUND_UP = 16384;

const int _MM_ROUND_TOWARD_ZERO = 24576;

const int _MM_FLUSH_ZERO_MASK = 32768;

const int _MM_FLUSH_ZERO_ON = 32768;

const int _MM_FLUSH_ZERO_OFF = 0;

const int _MM_DENORMALS_ZERO_MASK = 64;

const int _MM_DENORMALS_ZERO_ON = 64;

const int _MM_DENORMALS_ZERO_OFF = 0;

const int _MM_FROUND_TO_NEAREST_INT = 0;

const int _MM_FROUND_TO_NEG_INF = 1;

const int _MM_FROUND_TO_POS_INF = 2;

const int _MM_FROUND_TO_ZERO = 3;

const int _MM_FROUND_CUR_DIRECTION = 4;

const int _MM_FROUND_RAISE_EXC = 0;

const int _MM_FROUND_NO_EXC = 8;

const int _MM_FROUND_NINT = 0;

const int _MM_FROUND_FLOOR = 1;

const int _MM_FROUND_CEIL = 2;

const int _MM_FROUND_TRUNC = 3;

const int _MM_FROUND_RINT = 4;

const int _MM_FROUND_NEARBYINT = 12;

const int _SIDD_UBYTE_OPS = 0;

const int _SIDD_UWORD_OPS = 1;

const int _SIDD_SBYTE_OPS = 2;

const int _SIDD_SWORD_OPS = 3;

const int _SIDD_CMP_EQUAL_ANY = 0;

const int _SIDD_CMP_RANGES = 4;

const int _SIDD_CMP_EQUAL_EACH = 8;

const int _SIDD_CMP_EQUAL_ORDERED = 12;

const int _SIDD_POSITIVE_POLARITY = 0;

const int _SIDD_NEGATIVE_POLARITY = 16;

const int _SIDD_MASKED_POSITIVE_POLARITY = 32;

const int _SIDD_MASKED_NEGATIVE_POLARITY = 48;

const int _SIDD_LEAST_SIGNIFICANT = 0;

const int _SIDD_MOST_SIGNIFICANT = 64;

const int _SIDD_BIT_MASK = 0;

const int _SIDD_UNIT_MASK = 64;

const int _CMP_EQ_OQ = 0;

const int _CMP_LT_OS = 1;

const int _CMP_LE_OS = 2;

const int _CMP_UNORD_Q = 3;

const int _CMP_NEQ_UQ = 4;

const int _CMP_NLT_US = 5;

const int _CMP_NLE_US = 6;

const int _CMP_ORD_Q = 7;

const int _CMP_EQ_UQ = 8;

const int _CMP_NGE_US = 9;

const int _CMP_NGT_US = 10;

const int _CMP_FALSE_OQ = 11;

const int _CMP_NEQ_OQ = 12;

const int _CMP_GE_OS = 13;

const int _CMP_GT_OS = 14;

const int _CMP_TRUE_UQ = 15;

const int _CMP_EQ_OS = 16;

const int _CMP_LT_OQ = 17;

const int _CMP_LE_OQ = 18;

const int _CMP_UNORD_S = 19;

const int _CMP_NEQ_US = 20;

const int _CMP_NLT_UQ = 21;

const int _CMP_NLE_UQ = 22;

const int _CMP_ORD_S = 23;

const int _CMP_EQ_US = 24;

const int _CMP_NGE_UQ = 25;

const int _CMP_NGT_UQ = 26;

const int _CMP_FALSE_OS = 27;

const int _CMP_NEQ_OS = 28;

const int _CMP_GE_OQ = 29;

const int _CMP_GT_OQ = 30;

const int _CMP_TRUE_US = 31;

const int _XCR_XFEATURE_ENABLED_MASK = 0;

const int _XBEGIN_STARTED = 4294967295;

const int _XABORT_EXPLICIT = 1;

const int _XABORT_RETRY = 2;

const int _XABORT_CONFLICT = 4;

const int _XABORT_CAPACITY = 8;

const int _XABORT_DEBUG = 16;

const int _XABORT_NESTED = 32;

const int _MM_K0_REG8 = 255;

const int _MM_K0_REG16 = 65535;

const int _MM_K0_REG32 = 4294967295;

const int _MM_K0_REG64 = -1;

const int _MM_BROADCAST_16X16 = 0;

const int _MM_BROADCAST_8X8 = 0;

const int _MM_CMPINT_GE = 5;

const int _MM_CMPINT_GT = 6;

const int _MM_PCOMCTRL_LT = 0;

const int _MM_PCOMCTRL_LE = 1;

const int _MM_PCOMCTRL_GT = 2;

const int _MM_PCOMCTRL_GE = 3;

const int _MM_PCOMCTRL_EQ = 4;

const int _MM_PCOMCTRL_NEQ = 5;

const int _MM_PCOMCTRL_FALSE = 6;

const int _MM_PCOMCTRL_TRUE = 7;

const int _MM_PERMUTE2_COPY = 0;

const int _MM_PERMUTE2_ZEROIF1 = 2;

const int _MM_PERMUTE2_ZEROIF0 = 3;

const int SDL_LIL_ENDIAN = 1234;

const int SDL_BIG_ENDIAN = 4321;

const int SDL_BYTEORDER = 1234;

const int SDL_MUTEX_TIMEDOUT = 1;

const int SDL_MUTEX_MAXWAIT = 4294967295;

const int _DOMAIN = 1;

const int _SING = 2;

const int _OVERFLOW = 3;

const int _UNDERFLOW = 4;

const int _TLOSS = 5;

const int _PLOSS = 6;

const double _HUGE_ENUF = 1e+300;

const double INFINITY = double.infinity;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double NAN = double.nan;

const int _DENORM = -2;

const int _FINITE = -1;

const int _INFCODE = 1;

const int _NANCODE = 2;

const int FP_INFINITE = 1;

const int FP_NAN = 2;

const int FP_NORMAL = -1;

const int FP_SUBNORMAL = -2;

const int FP_ZERO = 0;

const int _C2 = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = 2147483647;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const int math_errhandling = 3;

const int _FE_DIVBYZERO = 4;

const int _FE_INEXACT = 32;

const int _FE_INVALID = 1;

const int _FE_OVERFLOW = 8;

const int _FE_UNDERFLOW = 16;

const int _D0_C = 3;

const int _D1_C = 2;

const int _D2_C = 1;

const int _D3_C = 0;

const int _DBIAS = 1022;

const int _DOFF = 4;

const int _F0_C = 1;

const int _F1_C = 0;

const int _FBIAS = 126;

const int _FOFF = 7;

const int _FRND = 1;

const int _L0_C = 3;

const int _L1_C = 2;

const int _L2_C = 1;

const int _L3_C = 0;

const int _LBIAS = 1022;

const int _LOFF = 4;

const int _DFRAC = 15;

const int _DMASK = 32752;

const int _DMAX = 2047;

const int _DSIGN = 32768;

const int _FFRAC = 127;

const int _FMASK = 32640;

const int _FMAX = 255;

const int _FSIGN = 32768;

const int _LFRAC = 65535;

const int _LMASK = 32767;

const int _LMAX = 32767;

const int _LSIGN = 32768;

const int _DHUGE_EXP = 1842;

const int _FHUGE_EXP = 229;

const int _LHUGE_EXP = 29490;

const int _FP_LT = 1;

const int _FP_EQ = 2;

const int _FP_GT = 4;

const int DOMAIN = 1;

const int SING = 2;

const int OVERFLOW = 3;

const int UNDERFLOW = 4;

const int TLOSS = 5;

const int PLOSS = 6;

const int _P_WAIT = 0;

const int _P_NOWAIT = 1;

const int _OLD_P_OVERLAY = 2;

const int _P_NOWAITO = 3;

const int _P_DETACH = 4;

const int _P_OVERLAY = 2;

const int _WAIT_CHILD = 0;

const int _WAIT_GRANDCHILD = 1;

const int P_WAIT = 0;

const int P_NOWAIT = 1;

const int P_OVERLAY = 2;

const int OLD_P_OVERLAY = 2;

const int P_NOWAITO = 3;

const int P_DETACH = 4;

const int WAIT_CHILD = 0;

const int WAIT_GRANDCHILD = 1;

const int SDL_RWOPS_UNKNOWN = 0;

const int SDL_RWOPS_WINFILE = 1;

const int SDL_RWOPS_STDFILE = 2;

const int SDL_RWOPS_JNIFILE = 3;

const int SDL_RWOPS_MEMORY = 4;

const int SDL_RWOPS_MEMORY_RO = 5;

const int RW_SEEK_SET = 0;

const int RW_SEEK_CUR = 1;

const int RW_SEEK_END = 2;

const int SDL_AUDIO_MASK_BITSIZE = 255;

const int SDL_AUDIO_MASK_DATATYPE = 256;

const int SDL_AUDIO_MASK_ENDIAN = 4096;

const int SDL_AUDIO_MASK_SIGNED = 32768;

const int AUDIO_U8 = 8;

const int AUDIO_S8 = 32776;

const int AUDIO_U16LSB = 16;

const int AUDIO_S16LSB = 32784;

const int AUDIO_U16MSB = 4112;

const int AUDIO_S16MSB = 36880;

const int AUDIO_U16 = 16;

const int AUDIO_S16 = 32784;

const int AUDIO_S32LSB = 32800;

const int AUDIO_S32MSB = 36896;

const int AUDIO_S32 = 32800;

const int AUDIO_F32LSB = 33056;

const int AUDIO_F32MSB = 37152;

const int AUDIO_F32 = 33056;

const int AUDIO_U16SYS = 16;

const int AUDIO_S16SYS = 32784;

const int AUDIO_S32SYS = 32800;

const int AUDIO_F32SYS = 33056;

const int SDL_AUDIO_ALLOW_FREQUENCY_CHANGE = 1;

const int SDL_AUDIO_ALLOW_FORMAT_CHANGE = 2;

const int SDL_AUDIO_ALLOW_CHANNELS_CHANGE = 4;

const int SDL_AUDIO_ALLOW_SAMPLES_CHANGE = 8;

const int SDL_AUDIO_ALLOW_ANY_CHANGE = 15;

const int SDL_AUDIOCVT_MAX_FILTERS = 9;

const int SDL_MIX_MAXVOLUME = 128;

const int SDL_CACHELINE_SIZE = 128;

const int SDL_ALPHA_OPAQUE = 255;

const int SDL_ALPHA_TRANSPARENT = 0;

const int SDL_SWSURFACE = 0;

const int SDL_PREALLOC = 1;

const int SDL_RLEACCEL = 2;

const int SDL_DONTFREE = 4;

const int SDL_SIMD_ALIGNED = 8;

const int SDL_WINDOWPOS_UNDEFINED_MASK = 536805376;

const int SDL_WINDOWPOS_UNDEFINED = 536805376;

const int SDL_WINDOWPOS_CENTERED_MASK = 805240832;

const int SDL_WINDOWPOS_CENTERED = 805240832;

const int SDLK_SCANCODE_MASK = 1073741824;

const int SDL_BUTTON_LEFT = 1;

const int SDL_BUTTON_MIDDLE = 2;

const int SDL_BUTTON_RIGHT = 3;

const int SDL_BUTTON_X1 = 4;

const int SDL_BUTTON_X2 = 5;

const int SDL_BUTTON_LMASK = 1;

const int SDL_BUTTON_MMASK = 2;

const int SDL_BUTTON_RMASK = 4;

const int SDL_BUTTON_X1MASK = 8;

const int SDL_BUTTON_X2MASK = 16;

const double SDL_IPHONE_MAX_GFORCE = 5.0;

const int SDL_JOYSTICK_AXIS_MAX = 32767;

const int SDL_JOYSTICK_AXIS_MIN = -32768;

const int SDL_HAT_CENTERED = 0;

const int SDL_HAT_UP = 1;

const int SDL_HAT_RIGHT = 2;

const int SDL_HAT_DOWN = 4;

const int SDL_HAT_LEFT = 8;

const int SDL_HAT_RIGHTUP = 3;

const int SDL_HAT_RIGHTDOWN = 6;

const int SDL_HAT_LEFTUP = 9;

const int SDL_HAT_LEFTDOWN = 12;

const double SDL_STANDARD_GRAVITY = 9.806650161743164;

const int SDL_TOUCH_MOUSEID = 4294967295;

const int SDL_MOUSE_TOUCHID = -1;

const int SDL_RELEASED = 0;

const int SDL_PRESSED = 1;

const int SDL_TEXTEDITINGEVENT_TEXT_SIZE = 32;

const int SDL_TEXTINPUTEVENT_TEXT_SIZE = 32;

const int SDL_QUERY = -1;

const int SDL_IGNORE = 0;

const int SDL_DISABLE = 0;

const int SDL_ENABLE = 1;

const int SDL_HAPTIC_CONSTANT = 1;

const int SDL_HAPTIC_SINE = 2;

const int SDL_HAPTIC_LEFTRIGHT = 4;

const int SDL_HAPTIC_TRIANGLE = 8;

const int SDL_HAPTIC_SAWTOOTHUP = 16;

const int SDL_HAPTIC_SAWTOOTHDOWN = 32;

const int SDL_HAPTIC_RAMP = 64;

const int SDL_HAPTIC_SPRING = 128;

const int SDL_HAPTIC_DAMPER = 256;

const int SDL_HAPTIC_INERTIA = 512;

const int SDL_HAPTIC_FRICTION = 1024;

const int SDL_HAPTIC_CUSTOM = 2048;

const int SDL_HAPTIC_GAIN = 4096;

const int SDL_HAPTIC_AUTOCENTER = 8192;

const int SDL_HAPTIC_STATUS = 16384;

const int SDL_HAPTIC_PAUSE = 32768;

const int SDL_HAPTIC_POLAR = 0;

const int SDL_HAPTIC_CARTESIAN = 1;

const int SDL_HAPTIC_SPHERICAL = 2;

const int SDL_HAPTIC_STEERING_AXIS = 3;

const int SDL_HAPTIC_INFINITY = 4294967295;

const String SDL_HINT_ACCELEROMETER_AS_JOYSTICK =
    'SDL_ACCELEROMETER_AS_JOYSTICK';

const String SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED =
    'SDL_ALLOW_ALT_TAB_WHILE_GRABBED';

const String SDL_HINT_ALLOW_TOPMOST = 'SDL_ALLOW_TOPMOST';

const String SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION =
    'SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION';

const String SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION =
    'SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION';

const String SDL_HINT_ANDROID_BLOCK_ON_PAUSE = 'SDL_ANDROID_BLOCK_ON_PAUSE';

const String SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO =
    'SDL_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO';

const String SDL_HINT_ANDROID_TRAP_BACK_BUTTON = 'SDL_ANDROID_TRAP_BACK_BUTTON';

const String SDL_HINT_APP_NAME = 'SDL_APP_NAME';

const String SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS =
    'SDL_APPLE_TV_CONTROLLER_UI_EVENTS';

const String SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION =
    'SDL_APPLE_TV_REMOTE_ALLOW_ROTATION';

const String SDL_HINT_AUDIO_CATEGORY = 'SDL_AUDIO_CATEGORY';

const String SDL_HINT_AUDIO_DEVICE_APP_NAME = 'SDL_AUDIO_DEVICE_APP_NAME';

const String SDL_HINT_AUDIO_DEVICE_STREAM_NAME = 'SDL_AUDIO_DEVICE_STREAM_NAME';

const String SDL_HINT_AUDIO_DEVICE_STREAM_ROLE = 'SDL_AUDIO_DEVICE_STREAM_ROLE';

const String SDL_HINT_AUDIO_RESAMPLING_MODE = 'SDL_AUDIO_RESAMPLING_MODE';

const String SDL_HINT_AUTO_UPDATE_JOYSTICKS = 'SDL_AUTO_UPDATE_JOYSTICKS';

const String SDL_HINT_AUTO_UPDATE_SENSORS = 'SDL_AUTO_UPDATE_SENSORS';

const String SDL_HINT_BMP_SAVE_LEGACY_FORMAT = 'SDL_BMP_SAVE_LEGACY_FORMAT';

const String SDL_HINT_DISPLAY_USABLE_BOUNDS = 'SDL_DISPLAY_USABLE_BOUNDS';

const String SDL_HINT_EMSCRIPTEN_ASYNCIFY = 'SDL_EMSCRIPTEN_ASYNCIFY';

const String SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT =
    'SDL_EMSCRIPTEN_KEYBOARD_ELEMENT';

const String SDL_HINT_ENABLE_STEAM_CONTROLLERS = 'SDL_ENABLE_STEAM_CONTROLLERS';

const String SDL_HINT_EVENT_LOGGING = 'SDL_EVENT_LOGGING';

const String SDL_HINT_FRAMEBUFFER_ACCELERATION = 'SDL_FRAMEBUFFER_ACCELERATION';

const String SDL_HINT_GAMECONTROLLERCONFIG = 'SDL_GAMECONTROLLERCONFIG';

const String SDL_HINT_GAMECONTROLLERCONFIG_FILE =
    'SDL_GAMECONTROLLERCONFIG_FILE';

const String SDL_HINT_GAMECONTROLLERTYPE = 'SDL_GAMECONTROLLERTYPE';

const String SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES =
    'SDL_GAMECONTROLLER_IGNORE_DEVICES';

const String SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT =
    'SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT';

const String SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS =
    'SDL_GAMECONTROLLER_USE_BUTTON_LABELS';

const String SDL_HINT_GRAB_KEYBOARD = 'SDL_GRAB_KEYBOARD';

const String SDL_HINT_IDLE_TIMER_DISABLED = 'SDL_IOS_IDLE_TIMER_DISABLED';

const String SDL_HINT_IME_INTERNAL_EDITING = 'SDL_IME_INTERNAL_EDITING';

const String SDL_HINT_IME_SHOW_UI = 'SDL_IME_SHOW_UI';

const String SDL_HINT_IOS_HIDE_HOME_INDICATOR = 'SDL_IOS_HIDE_HOME_INDICATOR';

const String SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS =
    'SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS';

const String SDL_HINT_JOYSTICK_HIDAPI = 'SDL_JOYSTICK_HIDAPI';

const String SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE = 'SDL_JOYSTICK_HIDAPI_GAMECUBE';

const String SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS = 'SDL_JOYSTICK_HIDAPI_JOY_CONS';

const String SDL_HINT_JOYSTICK_HIDAPI_LUNA = 'SDL_JOYSTICK_HIDAPI_LUNA';

const String SDL_HINT_JOYSTICK_HIDAPI_PS4 = 'SDL_JOYSTICK_HIDAPI_PS4';

const String SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE =
    'SDL_JOYSTICK_HIDAPI_PS4_RUMBLE';

const String SDL_HINT_JOYSTICK_HIDAPI_PS5 = 'SDL_JOYSTICK_HIDAPI_PS5';

const String SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED =
    'SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED';

const String SDL_HINT_JOYSTICK_HIDAPI_PS5_RUMBLE =
    'SDL_JOYSTICK_HIDAPI_PS5_RUMBLE';

const String SDL_HINT_JOYSTICK_HIDAPI_STADIA = 'SDL_JOYSTICK_HIDAPI_STADIA';

const String SDL_HINT_JOYSTICK_HIDAPI_STEAM = 'SDL_JOYSTICK_HIDAPI_STEAM';

const String SDL_HINT_JOYSTICK_HIDAPI_SWITCH = 'SDL_JOYSTICK_HIDAPI_SWITCH';

const String SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED =
    'SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED';

const String SDL_HINT_JOYSTICK_HIDAPI_XBOX = 'SDL_JOYSTICK_HIDAPI_XBOX';

const String SDL_HINT_JOYSTICK_RAWINPUT = 'SDL_JOYSTICK_RAWINPUT';

const String SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT =
    'SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT';

const String SDL_HINT_JOYSTICK_THREAD = 'SDL_JOYSTICK_THREAD';

const String SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER =
    'SDL_KMSDRM_REQUIRE_DRM_MASTER';

const String SDL_HINT_JOYSTICK_DEVICE = 'SDL_JOYSTICK_DEVICE';

const String SDL_HINT_LINUX_JOYSTICK_CLASSIC = 'SDL_LINUX_JOYSTICK_CLASSIC';

const String SDL_HINT_LINUX_JOYSTICK_DEADZONES = 'SDL_LINUX_JOYSTICK_DEADZONES';

const String SDL_HINT_MAC_BACKGROUND_APP = 'SDL_MAC_BACKGROUND_APP';

const String SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK =
    'SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK';

const String SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS =
    'SDL_MOUSE_DOUBLE_CLICK_RADIUS';

const String SDL_HINT_MOUSE_DOUBLE_CLICK_TIME = 'SDL_MOUSE_DOUBLE_CLICK_TIME';

const String SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH = 'SDL_MOUSE_FOCUS_CLICKTHROUGH';

const String SDL_HINT_MOUSE_NORMAL_SPEED_SCALE = 'SDL_MOUSE_NORMAL_SPEED_SCALE';

const String SDL_HINT_MOUSE_RELATIVE_MODE_WARP = 'SDL_MOUSE_RELATIVE_MODE_WARP';

const String SDL_HINT_MOUSE_RELATIVE_SCALING = 'SDL_MOUSE_RELATIVE_SCALING';

const String SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE =
    'SDL_MOUSE_RELATIVE_SPEED_SCALE';

const String SDL_HINT_MOUSE_TOUCH_EVENTS = 'SDL_MOUSE_TOUCH_EVENTS';

const String SDL_HINT_NO_SIGNAL_HANDLERS = 'SDL_NO_SIGNAL_HANDLERS';

const String SDL_HINT_OPENGL_ES_DRIVER = 'SDL_OPENGL_ES_DRIVER';

const String SDL_HINT_ORIENTATIONS = 'SDL_IOS_ORIENTATIONS';

const String SDL_HINT_POLL_SENTINEL = 'SDL_POLL_SENTINEL';

const String SDL_HINT_PREFERRED_LOCALES = 'SDL_PREFERRED_LOCALES';

const String SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION =
    'SDL_QTWAYLAND_CONTENT_ORIENTATION';

const String SDL_HINT_QTWAYLAND_WINDOW_FLAGS = 'SDL_QTWAYLAND_WINDOW_FLAGS';

const String SDL_HINT_RENDER_BATCHING = 'SDL_RENDER_BATCHING';

const String SDL_HINT_RENDER_LINE_METHOD = 'SDL_RENDER_LINE_METHOD';

const String SDL_HINT_RENDER_DIRECT3D11_DEBUG = 'SDL_RENDER_DIRECT3D11_DEBUG';

const String SDL_HINT_RENDER_DIRECT3D_THREADSAFE =
    'SDL_RENDER_DIRECT3D_THREADSAFE';

const String SDL_HINT_RENDER_DRIVER = 'SDL_RENDER_DRIVER';

const String SDL_HINT_RENDER_LOGICAL_SIZE_MODE = 'SDL_RENDER_LOGICAL_SIZE_MODE';

const String SDL_HINT_RENDER_OPENGL_SHADERS = 'SDL_RENDER_OPENGL_SHADERS';

const String SDL_HINT_RENDER_SCALE_QUALITY = 'SDL_RENDER_SCALE_QUALITY';

const String SDL_HINT_RENDER_VSYNC = 'SDL_RENDER_VSYNC';

const String SDL_HINT_RETURN_KEY_HIDES_IME = 'SDL_RETURN_KEY_HIDES_IME';

const String SDL_HINT_RPI_VIDEO_LAYER = 'SDL_RPI_VIDEO_LAYER';

const String SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME =
    'SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME';

const String SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL =
    'SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL';

const String SDL_HINT_THREAD_PRIORITY_POLICY = 'SDL_THREAD_PRIORITY_POLICY';

const String SDL_HINT_THREAD_STACK_SIZE = 'SDL_THREAD_STACK_SIZE';

const String SDL_HINT_TIMER_RESOLUTION = 'SDL_TIMER_RESOLUTION';

const String SDL_HINT_TOUCH_MOUSE_EVENTS = 'SDL_TOUCH_MOUSE_EVENTS';

const String SDL_HINT_TV_REMOTE_AS_JOYSTICK = 'SDL_TV_REMOTE_AS_JOYSTICK';

const String SDL_HINT_VIDEO_ALLOW_SCREENSAVER = 'SDL_VIDEO_ALLOW_SCREENSAVER';

const String SDL_HINT_VIDEO_DOUBLE_BUFFER = 'SDL_VIDEO_DOUBLE_BUFFER';

const String SDL_HINT_VIDEO_EGL_ALLOW_TRANSPARENCY =
    'SDL_VIDEO_EGL_ALLOW_TRANSPARENCY';

const String SDL_HINT_VIDEO_EXTERNAL_CONTEXT = 'SDL_VIDEO_EXTERNAL_CONTEXT';

const String SDL_HINT_VIDEO_HIGHDPI_DISABLED = 'SDL_VIDEO_HIGHDPI_DISABLED';

const String SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES =
    'SDL_VIDEO_MAC_FULLSCREEN_SPACES';

const String SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS =
    'SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS';

const String SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR =
    'SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR';

const String SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT =
    'SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT';

const String SDL_HINT_VIDEO_WIN_D3DCOMPILER = 'SDL_VIDEO_WIN_D3DCOMPILER';

const String SDL_HINT_VIDEO_X11_FORCE_EGL = 'SDL_VIDEO_X11_FORCE_EGL';

const String SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR =
    'SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR';

const String SDL_HINT_VIDEO_X11_NET_WM_PING = 'SDL_VIDEO_X11_NET_WM_PING';

const String SDL_HINT_VIDEO_X11_WINDOW_VISUALID =
    'SDL_VIDEO_X11_WINDOW_VISUALID';

const String SDL_HINT_VIDEO_X11_XINERAMA = 'SDL_VIDEO_X11_XINERAMA';

const String SDL_HINT_VIDEO_X11_XRANDR = 'SDL_VIDEO_X11_XRANDR';

const String SDL_HINT_VIDEO_X11_XVIDMODE = 'SDL_VIDEO_X11_XVIDMODE';

const String SDL_HINT_WAVE_FACT_CHUNK = 'SDL_WAVE_FACT_CHUNK';

const String SDL_HINT_WAVE_RIFF_CHUNK_SIZE = 'SDL_WAVE_RIFF_CHUNK_SIZE';

const String SDL_HINT_WAVE_TRUNCATION = 'SDL_WAVE_TRUNCATION';

const String SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING =
    'SDL_WINDOWS_DISABLE_THREAD_NAMING';

const String SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP =
    'SDL_WINDOWS_ENABLE_MESSAGELOOP';

const String SDL_HINT_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS =
    'SDL_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS';

const String SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL =
    'SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL';

const String SDL_HINT_WINDOWS_INTRESOURCE_ICON = 'SDL_WINDOWS_INTRESOURCE_ICON';

const String SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL =
    'SDL_WINDOWS_INTRESOURCE_ICON_SMALL';

const String SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4 =
    'SDL_WINDOWS_NO_CLOSE_ON_ALT_F4';

const String SDL_HINT_WINDOWS_USE_D3D9EX = 'SDL_WINDOWS_USE_D3D9EX';

const String SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN =
    'SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN';

const String SDL_HINT_WINDOW_NO_ACTIVATION_WHEN_SHOWN =
    'SDL_WINDOW_NO_ACTIVATION_WHEN_SHOWN';

const String SDL_HINT_WINRT_HANDLE_BACK_BUTTON = 'SDL_WINRT_HANDLE_BACK_BUTTON';

const String SDL_HINT_WINRT_PRIVACY_POLICY_LABEL =
    'SDL_WINRT_PRIVACY_POLICY_LABEL';

const String SDL_HINT_WINRT_PRIVACY_POLICY_URL = 'SDL_WINRT_PRIVACY_POLICY_URL';

const String SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT =
    'SDL_X11_FORCE_OVERRIDE_REDIRECT';

const String SDL_HINT_XINPUT_ENABLED = 'SDL_XINPUT_ENABLED';

const String SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING =
    'SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING';

const String SDL_HINT_AUDIO_INCLUDE_MONITORS = 'SDL_AUDIO_INCLUDE_MONITORS';

const int SDL_MAX_LOG_MESSAGE = 4096;

const int SDL_NONSHAPEABLE_WINDOW = -1;

const int SDL_INVALID_SHAPE_ARGUMENT = -2;

const int SDL_WINDOW_LACKS_SHAPE = -3;

const int SDL_MAJOR_VERSION = 2;

const int SDL_MINOR_VERSION = 0;

const int SDL_PATCHLEVEL = 20;

const int SDL_COMPILEDVERSION = 2020;

const int SDL_INIT_TIMER = 1;

const int SDL_INIT_AUDIO = 16;

const int SDL_INIT_VIDEO = 32;

const int SDL_INIT_JOYSTICK = 512;

const int SDL_INIT_HAPTIC = 4096;

const int SDL_INIT_GAMECONTROLLER = 8192;

const int SDL_INIT_EVENTS = 16384;

const int SDL_INIT_SENSOR = 32768;

const int SDL_INIT_NOPARACHUTE = 1048576;

const int SDL_INIT_EVERYTHING = 62001;

const String SDL_REVISION =
    'https://github.com/libsdl-org/SDL.git@b424665e0899769b200231ba943353a5fee1b6b6';

const int SDL_REVISION_NUMBER = 0;

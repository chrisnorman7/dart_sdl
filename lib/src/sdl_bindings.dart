// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for SDL
class DartSdl {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DartSdl(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DartSdl.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// \brief Gets the name of the platform.
  ffi.Pointer<ffi.Int8> SDL_GetPlatform() {
    return _SDL_GetPlatform();
  }

  late final _SDL_GetPlatformPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetPlatform');
  late final _SDL_GetPlatform =
      _SDL_GetPlatformPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(uintptr_t)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(uintptr_t)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<uintptr_t> ___security_cookie =
      _lookup<uintptr_t>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo =
      __invalid_parameter_noinfoPtr.asFunction<void Function()>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr.asFunction<void Function()>();

  void _invoke_watson(
    ffi.Pointer<wchar_t> _Expression,
    ffi.Pointer<wchar_t> _FunctionName,
    ffi.Pointer<wchar_t> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
              ffi.Pointer<wchar_t>, ffi.Uint32, uintptr_t)>>('_invoke_watson');
  late final __invoke_watson = __invoke_watsonPtr.asFunction<
      void Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
          ffi.Pointer<wchar_t>, int, int)>();

  ffi.Pointer<ffi.Int32> _errno() {
    return __errno();
  }

  late final __errnoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int32> Function()>>('_errno');
  late final __errno =
      __errnoPtr.asFunction<ffi.Pointer<ffi.Int32> Function()>();

  int _set_errno(
    int _Value,
  ) {
    return __set_errno(
      _Value,
    );
  }

  late final __set_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Int32)>>('_set_errno');
  late final __set_errno = __set_errnoPtr.asFunction<int Function(int)>();

  int _get_errno(
    ffi.Pointer<ffi.Int32> _Value,
  ) {
    return __get_errno(
      _Value,
    );
  }

  late final __get_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.Int32>)>>(
          '_get_errno');
  late final __get_errno =
      __get_errnoPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  int __threadid() {
    return ___threadid();
  }

  late final ___threadidPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('__threadid');
  late final ___threadid = ___threadidPtr.asFunction<int Function()>();

  int __threadhandle() {
    return ___threadhandle();
  }

  late final ___threadhandlePtr =
      _lookup<ffi.NativeFunction<uintptr_t Function()>>('__threadhandle');
  late final ___threadhandle = ___threadhandlePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Void> SDL_malloc(
    int size,
  ) {
    return _SDL_malloc(
      size,
    );
  }

  late final _SDL_mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(size_t)>>(
          'SDL_malloc');
  late final _SDL_malloc =
      _SDL_mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> SDL_calloc(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc(
      nmemb,
      size,
    );
  }

  late final _SDL_callocPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(size_t, size_t)>>(
      'SDL_calloc');
  late final _SDL_calloc =
      _SDL_callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> SDL_realloc(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc(
      mem,
      size,
    );
  }

  late final _SDL_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, size_t)>>('SDL_realloc');
  late final _SDL_realloc = _SDL_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void SDL_free(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free(
      mem,
    );
  }

  late final _SDL_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_free');
  late final _SDL_free =
      _SDL_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// \brief Get the current set of SDL memory functions
  void SDL_GetMemoryFunctions(
    ffi.Pointer<SDL_malloc_func> malloc_func,
    ffi.Pointer<SDL_calloc_func> calloc_func,
    ffi.Pointer<SDL_realloc_func> realloc_func,
    ffi.Pointer<SDL_free_func> free_func,
  ) {
    return _SDL_GetMemoryFunctions(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_malloc_func>,
              ffi.Pointer<SDL_calloc_func>,
              ffi.Pointer<SDL_realloc_func>,
              ffi.Pointer<SDL_free_func>)>>('SDL_GetMemoryFunctions');
  late final _SDL_GetMemoryFunctions = _SDL_GetMemoryFunctionsPtr.asFunction<
      void Function(ffi.Pointer<SDL_malloc_func>, ffi.Pointer<SDL_calloc_func>,
          ffi.Pointer<SDL_realloc_func>, ffi.Pointer<SDL_free_func>)>();

  /// \brief Replace SDL's memory allocation functions with a custom set
  ///
  /// \note If you are replacing SDL's memory functions, you should call
  /// SDL_GetNumAllocations() and be very careful if it returns non-zero.
  /// That means that your free function will be called with memory
  /// allocated by the previous memory allocation functions.
  int SDL_SetMemoryFunctions(
    SDL_malloc_func malloc_func,
    SDL_calloc_func calloc_func,
    SDL_realloc_func realloc_func,
    SDL_free_func free_func,
  ) {
    return _SDL_SetMemoryFunctions(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SDL_malloc_func, SDL_calloc_func, SDL_realloc_func,
              SDL_free_func)>>('SDL_SetMemoryFunctions');
  late final _SDL_SetMemoryFunctions = _SDL_SetMemoryFunctionsPtr.asFunction<
      int Function(
          SDL_malloc_func, SDL_calloc_func, SDL_realloc_func, SDL_free_func)>();

  /// \brief Get the number of outstanding (unfreed) allocations
  int SDL_GetNumAllocations() {
    return _SDL_GetNumAllocations();
  }

  late final _SDL_GetNumAllocationsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetNumAllocations');
  late final _SDL_GetNumAllocations =
      _SDL_GetNumAllocationsPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Int8> SDL_getenv(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_getenv(
      name,
    );
  }

  late final _SDL_getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>>('SDL_getenv');
  late final _SDL_getenv = _SDL_getenvPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>();

  int SDL_setenv(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
    int overwrite,
  ) {
    return _SDL_setenv(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('SDL_setenv');
  late final _SDL_setenv = _SDL_setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  void SDL_qsort(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int32 Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        compare,
  ) {
    return _SDL_qsort(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              size_t,
              size_t,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_qsort');
  late final _SDL_qsort = _SDL_qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int SDL_abs(
    int x,
  ) {
    return _SDL_abs(
      x,
    );
  }

  late final _SDL_absPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_abs');
  late final _SDL_abs = _SDL_absPtr.asFunction<int Function(int)>();

  int SDL_isdigit(
    int x,
  ) {
    return _SDL_isdigit(
      x,
    );
  }

  late final _SDL_isdigitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_isdigit');
  late final _SDL_isdigit = _SDL_isdigitPtr.asFunction<int Function(int)>();

  int SDL_isspace(
    int x,
  ) {
    return _SDL_isspace(
      x,
    );
  }

  late final _SDL_isspacePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_isspace');
  late final _SDL_isspace = _SDL_isspacePtr.asFunction<int Function(int)>();

  int SDL_isupper(
    int x,
  ) {
    return _SDL_isupper(
      x,
    );
  }

  late final _SDL_isupperPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_isupper');
  late final _SDL_isupper = _SDL_isupperPtr.asFunction<int Function(int)>();

  int SDL_islower(
    int x,
  ) {
    return _SDL_islower(
      x,
    );
  }

  late final _SDL_islowerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_islower');
  late final _SDL_islower = _SDL_islowerPtr.asFunction<int Function(int)>();

  int SDL_toupper(
    int x,
  ) {
    return _SDL_toupper(
      x,
    );
  }

  late final _SDL_toupperPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_toupper');
  late final _SDL_toupper = _SDL_toupperPtr.asFunction<int Function(int)>();

  int SDL_tolower(
    int x,
  ) {
    return _SDL_tolower(
      x,
    );
  }

  late final _SDL_tolowerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_tolower');
  late final _SDL_tolower = _SDL_tolowerPtr.asFunction<int Function(int)>();

  int SDL_crc32(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc32(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc32Ptr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(Uint32, ffi.Pointer<ffi.Void>, size_t)>>('SDL_crc32');
  late final _SDL_crc32 =
      _SDL_crc32Ptr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memset(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32, size_t)>>('SDL_memset');
  late final _SDL_memset = _SDL_memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> SDL_memcpy(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, size_t)>>('SDL_memcpy');
  late final _SDL_memcpy = _SDL_memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> SDL_memmove(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, size_t)>>('SDL_memmove');
  late final _SDL_memmove = _SDL_memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_memcmp(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              size_t)>>('SDL_memcmp');
  late final _SDL_memcmp = _SDL_memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int SDL_wcslen(
    ffi.Pointer<wchar_t> wstr,
  ) {
    return _SDL_wcslen(
      wstr,
    );
  }

  late final _SDL_wcslenPtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<wchar_t>)>>(
          'SDL_wcslen');
  late final _SDL_wcslen =
      _SDL_wcslenPtr.asFunction<int Function(ffi.Pointer<wchar_t>)>();

  int SDL_wcslcpy(
    ffi.Pointer<wchar_t> dst,
    ffi.Pointer<wchar_t> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpyPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
              size_t)>>('SDL_wcslcpy');
  late final _SDL_wcslcpy = _SDL_wcslcpyPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>, int)>();

  int SDL_wcslcat(
    ffi.Pointer<wchar_t> dst,
    ffi.Pointer<wchar_t> src,
    int maxlen,
  ) {
    return _SDL_wcslcat(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcatPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
              size_t)>>('SDL_wcslcat');
  late final _SDL_wcslcat = _SDL_wcslcatPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>, int)>();

  ffi.Pointer<wchar_t> SDL_wcsdup(
    ffi.Pointer<wchar_t> wstr,
  ) {
    return _SDL_wcsdup(
      wstr,
    );
  }

  late final _SDL_wcsdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wchar_t> Function(ffi.Pointer<wchar_t>)>>('SDL_wcsdup');
  late final _SDL_wcsdup = _SDL_wcsdupPtr.asFunction<
      ffi.Pointer<wchar_t> Function(ffi.Pointer<wchar_t>)>();

  ffi.Pointer<wchar_t> SDL_wcsstr(
    ffi.Pointer<wchar_t> haystack,
    ffi.Pointer<wchar_t> needle,
  ) {
    return _SDL_wcsstr(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<wchar_t> Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('SDL_wcsstr');
  late final _SDL_wcsstr = _SDL_wcsstrPtr.asFunction<
      ffi.Pointer<wchar_t> Function(
          ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int SDL_wcscmp(
    ffi.Pointer<wchar_t> str1,
    ffi.Pointer<wchar_t> str2,
  ) {
    return _SDL_wcscmp(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('SDL_wcscmp');
  late final _SDL_wcscmp = _SDL_wcscmpPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int SDL_wcsncmp(
    ffi.Pointer<wchar_t> str1,
    ffi.Pointer<wchar_t> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
              size_t)>>('SDL_wcsncmp');
  late final _SDL_wcsncmp = _SDL_wcsncmpPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>, int)>();

  int SDL_wcscasecmp(
    ffi.Pointer<wchar_t> str1,
    ffi.Pointer<wchar_t> str2,
  ) {
    return _SDL_wcscasecmp(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('SDL_wcscasecmp');
  late final _SDL_wcscasecmp = _SDL_wcscasecmpPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int SDL_wcsncasecmp(
    ffi.Pointer<wchar_t> str1,
    ffi.Pointer<wchar_t> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
              size_t)>>('SDL_wcsncasecmp');
  late final _SDL_wcsncasecmp = _SDL_wcsncasecmpPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>, int)>();

  int SDL_strlen(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strlen(
      str,
    );
  }

  late final _SDL_strlenPtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_strlen');
  late final _SDL_strlen =
      _SDL_strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  int SDL_strlcpy(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int maxlen,
  ) {
    return _SDL_strlcpy(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpyPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              size_t)>>('SDL_strlcpy');
  late final _SDL_strlcpy = _SDL_strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int SDL_utf8strlcpy(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpyPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              size_t)>>('SDL_utf8strlcpy');
  late final _SDL_utf8strlcpy = _SDL_utf8strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int SDL_strlcat(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int maxlen,
  ) {
    return _SDL_strlcat(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcatPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              size_t)>>('SDL_strlcat');
  late final _SDL_strlcat = _SDL_strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_strdup(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strdup(
      str,
    );
  }

  late final _SDL_strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>>('SDL_strdup');
  late final _SDL_strdup = _SDL_strdupPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<ffi.Int8> SDL_strrev(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strrev(
      str,
    );
  }

  late final _SDL_strrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>>('SDL_strrev');
  late final _SDL_strrev = _SDL_strrevPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<ffi.Int8> SDL_strupr(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strupr(
      str,
    );
  }

  late final _SDL_struprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>>('SDL_strupr');
  late final _SDL_strupr = _SDL_struprPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<ffi.Int8> SDL_strlwr(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strlwr(
      str,
    );
  }

  late final _SDL_strlwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>>('SDL_strlwr');
  late final _SDL_strlwr = _SDL_strlwrPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<ffi.Int8> SDL_strchr(
    ffi.Pointer<ffi.Int8> str,
    int c,
  ) {
    return _SDL_strchr(
      str,
      c,
    );
  }

  late final _SDL_strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_strchr');
  late final _SDL_strchr = _SDL_strchrPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_strrchr(
    ffi.Pointer<ffi.Int8> str,
    int c,
  ) {
    return _SDL_strrchr(
      str,
      c,
    );
  }

  late final _SDL_strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_strrchr');
  late final _SDL_strrchr = _SDL_strrchrPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_strstr(
    ffi.Pointer<ffi.Int8> haystack,
    ffi.Pointer<ffi.Int8> needle,
  ) {
    return _SDL_strstr(
      haystack,
      needle,
    );
  }

  late final _SDL_strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_strstr');
  late final _SDL_strstr = _SDL_strstrPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<ffi.Int8> SDL_strtokr(
    ffi.Pointer<ffi.Int8> s1,
    ffi.Pointer<ffi.Int8> s2,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
  ) {
    return _SDL_strtokr(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('SDL_strtokr');
  late final _SDL_strtokr = _SDL_strtokrPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int SDL_utf8strlen(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_utf8strlen(
      str,
    );
  }

  late final _SDL_utf8strlenPtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_utf8strlen');
  late final _SDL_utf8strlen =
      _SDL_utf8strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<ffi.Int8> SDL_itoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_itoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_itoa');
  late final _SDL_itoa = _SDL_itoaPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_uitoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_uitoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Uint32, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_uitoa');
  late final _SDL_uitoa = _SDL_uitoaPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_ltoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_ltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Int64, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_ltoa');
  late final _SDL_ltoa = _SDL_ltoaPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_ultoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_ultoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Uint64, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_ultoa');
  late final _SDL_ultoa = _SDL_ultoaPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_lltoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_lltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              Sint64, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_lltoa');
  late final _SDL_lltoa = _SDL_lltoaPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, ffi.Pointer<ffi.Int8>, int)>();

  ffi.Pointer<ffi.Int8> SDL_ulltoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_ulltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              Uint64, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_ulltoa');
  late final _SDL_ulltoa = _SDL_ulltoaPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, ffi.Pointer<ffi.Int8>, int)>();

  int SDL_atoi(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_atoi(
      str,
    );
  }

  late final _SDL_atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_atoi');
  late final _SDL_atoi =
      _SDL_atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  double SDL_atof(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_atof(
      str,
    );
  }

  late final _SDL_atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_atof');
  late final _SDL_atof =
      _SDL_atofPtr.asFunction<double Function(ffi.Pointer<ffi.Int8>)>();

  int SDL_strtol(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtol(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>, ffi.Int32)>>('SDL_strtol');
  late final _SDL_strtol = _SDL_strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>, int)>();

  int SDL_strtoul(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtoul(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>, ffi.Int32)>>('SDL_strtoul');
  late final _SDL_strtoul = _SDL_strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>, int)>();

  int SDL_strtoll(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtoll(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtollPtr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>, ffi.Int32)>>('SDL_strtoll');
  late final _SDL_strtoll = _SDL_strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>, int)>();

  int SDL_strtoull(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtoull(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoullPtr = _lookup<
      ffi.NativeFunction<
          Uint64 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>, ffi.Int32)>>('SDL_strtoull');
  late final _SDL_strtoull = _SDL_strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>, int)>();

  double SDL_strtod(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  ) {
    return _SDL_strtod(
      str,
      endp,
    );
  }

  late final _SDL_strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('SDL_strtod');
  late final _SDL_strtod = _SDL_strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int SDL_strcmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
  ) {
    return _SDL_strcmp(
      str1,
      str2,
    );
  }

  late final _SDL_strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_strcmp');
  late final _SDL_strcmp = _SDL_strcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int SDL_strncmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
    int maxlen,
  ) {
    return _SDL_strncmp(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              size_t)>>('SDL_strncmp');
  late final _SDL_strncmp = _SDL_strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int SDL_strcasecmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
  ) {
    return _SDL_strcasecmp(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_strcasecmp');
  late final _SDL_strcasecmp = _SDL_strcasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int SDL_strncasecmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
    int len,
  ) {
    return _SDL_strncasecmp(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              size_t)>>('SDL_strncasecmp');
  late final _SDL_strncasecmp = _SDL_strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int SDL_sscanf(
    ffi.Pointer<ffi.Int8> text,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_sscanf(
      text,
      fmt,
    );
  }

  late final _SDL_sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_sscanf');
  late final _SDL_sscanf = _SDL_sscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int SDL_vsscanf(
    ffi.Pointer<ffi.Int8> text,
    ffi.Pointer<ffi.Int8> fmt,
    va_list ap,
  ) {
    return _SDL_vsscanf(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              va_list)>>('SDL_vsscanf');
  late final _SDL_vsscanf = _SDL_vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, va_list)>();

  int SDL_snprintf(
    ffi.Pointer<ffi.Int8> text,
    int maxlen,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_snprintf(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, size_t,
              ffi.Pointer<ffi.Int8>)>>('SDL_snprintf');
  late final _SDL_snprintf = _SDL_snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, int, ffi.Pointer<ffi.Int8>)>();

  int SDL_vsnprintf(
    ffi.Pointer<ffi.Int8> text,
    int maxlen,
    ffi.Pointer<ffi.Int8> fmt,
    va_list ap,
  ) {
    return _SDL_vsnprintf(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, size_t,
              ffi.Pointer<ffi.Int8>, va_list)>>('SDL_vsnprintf');
  late final _SDL_vsnprintf = _SDL_vsnprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, int, ffi.Pointer<ffi.Int8>, va_list)>();

  double SDL_acos(
    double x,
  ) {
    return _SDL_acos(
      x,
    );
  }

  late final _SDL_acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_acos');
  late final _SDL_acos = _SDL_acosPtr.asFunction<double Function(double)>();

  double SDL_acosf(
    double x,
  ) {
    return _SDL_acosf(
      x,
    );
  }

  late final _SDL_acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_acosf');
  late final _SDL_acosf = _SDL_acosfPtr.asFunction<double Function(double)>();

  double SDL_asin(
    double x,
  ) {
    return _SDL_asin(
      x,
    );
  }

  late final _SDL_asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_asin');
  late final _SDL_asin = _SDL_asinPtr.asFunction<double Function(double)>();

  double SDL_asinf(
    double x,
  ) {
    return _SDL_asinf(
      x,
    );
  }

  late final _SDL_asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_asinf');
  late final _SDL_asinf = _SDL_asinfPtr.asFunction<double Function(double)>();

  double SDL_atan(
    double x,
  ) {
    return _SDL_atan(
      x,
    );
  }

  late final _SDL_atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_atan');
  late final _SDL_atan = _SDL_atanPtr.asFunction<double Function(double)>();

  double SDL_atanf(
    double x,
  ) {
    return _SDL_atanf(
      x,
    );
  }

  late final _SDL_atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_atanf');
  late final _SDL_atanf = _SDL_atanfPtr.asFunction<double Function(double)>();

  double SDL_atan2(
    double x,
    double y,
  ) {
    return _SDL_atan2(
      x,
      y,
    );
  }

  late final _SDL_atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_atan2');
  late final _SDL_atan2 =
      _SDL_atan2Ptr.asFunction<double Function(double, double)>();

  double SDL_atan2f(
    double x,
    double y,
  ) {
    return _SDL_atan2f(
      x,
      y,
    );
  }

  late final _SDL_atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_atan2f');
  late final _SDL_atan2f =
      _SDL_atan2fPtr.asFunction<double Function(double, double)>();

  double SDL_ceil(
    double x,
  ) {
    return _SDL_ceil(
      x,
    );
  }

  late final _SDL_ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_ceil');
  late final _SDL_ceil = _SDL_ceilPtr.asFunction<double Function(double)>();

  double SDL_ceilf(
    double x,
  ) {
    return _SDL_ceilf(
      x,
    );
  }

  late final _SDL_ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_ceilf');
  late final _SDL_ceilf = _SDL_ceilfPtr.asFunction<double Function(double)>();

  double SDL_copysign(
    double x,
    double y,
  ) {
    return _SDL_copysign(
      x,
      y,
    );
  }

  late final _SDL_copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_copysign');
  late final _SDL_copysign =
      _SDL_copysignPtr.asFunction<double Function(double, double)>();

  double SDL_copysignf(
    double x,
    double y,
  ) {
    return _SDL_copysignf(
      x,
      y,
    );
  }

  late final _SDL_copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_copysignf');
  late final _SDL_copysignf =
      _SDL_copysignfPtr.asFunction<double Function(double, double)>();

  double SDL_cos(
    double x,
  ) {
    return _SDL_cos(
      x,
    );
  }

  late final _SDL_cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_cos');
  late final _SDL_cos = _SDL_cosPtr.asFunction<double Function(double)>();

  double SDL_cosf(
    double x,
  ) {
    return _SDL_cosf(
      x,
    );
  }

  late final _SDL_cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_cosf');
  late final _SDL_cosf = _SDL_cosfPtr.asFunction<double Function(double)>();

  double SDL_exp(
    double x,
  ) {
    return _SDL_exp(
      x,
    );
  }

  late final _SDL_expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_exp');
  late final _SDL_exp = _SDL_expPtr.asFunction<double Function(double)>();

  double SDL_expf(
    double x,
  ) {
    return _SDL_expf(
      x,
    );
  }

  late final _SDL_expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_expf');
  late final _SDL_expf = _SDL_expfPtr.asFunction<double Function(double)>();

  double SDL_fabs(
    double x,
  ) {
    return _SDL_fabs(
      x,
    );
  }

  late final _SDL_fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_fabs');
  late final _SDL_fabs = _SDL_fabsPtr.asFunction<double Function(double)>();

  double SDL_fabsf(
    double x,
  ) {
    return _SDL_fabsf(
      x,
    );
  }

  late final _SDL_fabsfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_fabsf');
  late final _SDL_fabsf = _SDL_fabsfPtr.asFunction<double Function(double)>();

  double SDL_floor(
    double x,
  ) {
    return _SDL_floor(
      x,
    );
  }

  late final _SDL_floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_floor');
  late final _SDL_floor = _SDL_floorPtr.asFunction<double Function(double)>();

  double SDL_floorf(
    double x,
  ) {
    return _SDL_floorf(
      x,
    );
  }

  late final _SDL_floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_floorf');
  late final _SDL_floorf = _SDL_floorfPtr.asFunction<double Function(double)>();

  double SDL_trunc(
    double x,
  ) {
    return _SDL_trunc(
      x,
    );
  }

  late final _SDL_truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_trunc');
  late final _SDL_trunc = _SDL_truncPtr.asFunction<double Function(double)>();

  double SDL_truncf(
    double x,
  ) {
    return _SDL_truncf(
      x,
    );
  }

  late final _SDL_truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_truncf');
  late final _SDL_truncf = _SDL_truncfPtr.asFunction<double Function(double)>();

  double SDL_fmod(
    double x,
    double y,
  ) {
    return _SDL_fmod(
      x,
      y,
    );
  }

  late final _SDL_fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_fmod');
  late final _SDL_fmod =
      _SDL_fmodPtr.asFunction<double Function(double, double)>();

  double SDL_fmodf(
    double x,
    double y,
  ) {
    return _SDL_fmodf(
      x,
      y,
    );
  }

  late final _SDL_fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_fmodf');
  late final _SDL_fmodf =
      _SDL_fmodfPtr.asFunction<double Function(double, double)>();

  double SDL_log(
    double x,
  ) {
    return _SDL_log(
      x,
    );
  }

  late final _SDL_logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log');
  late final _SDL_log = _SDL_logPtr.asFunction<double Function(double)>();

  double SDL_logf(
    double x,
  ) {
    return _SDL_logf(
      x,
    );
  }

  late final _SDL_logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_logf');
  late final _SDL_logf = _SDL_logfPtr.asFunction<double Function(double)>();

  double SDL_log10(
    double x,
  ) {
    return _SDL_log10(
      x,
    );
  }

  late final _SDL_log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_log10');
  late final _SDL_log10 = _SDL_log10Ptr.asFunction<double Function(double)>();

  double SDL_log10f(
    double x,
  ) {
    return _SDL_log10f(
      x,
    );
  }

  late final _SDL_log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_log10f');
  late final _SDL_log10f = _SDL_log10fPtr.asFunction<double Function(double)>();

  double SDL_pow(
    double x,
    double y,
  ) {
    return _SDL_pow(
      x,
      y,
    );
  }

  late final _SDL_powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'SDL_pow');
  late final _SDL_pow =
      _SDL_powPtr.asFunction<double Function(double, double)>();

  double SDL_powf(
    double x,
    double y,
  ) {
    return _SDL_powf(
      x,
      y,
    );
  }

  late final _SDL_powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'SDL_powf');
  late final _SDL_powf =
      _SDL_powfPtr.asFunction<double Function(double, double)>();

  double SDL_scalbn(
    double x,
    int n,
  ) {
    return _SDL_scalbn(
      x,
      n,
    );
  }

  late final _SDL_scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int32)>>(
          'SDL_scalbn');
  late final _SDL_scalbn =
      _SDL_scalbnPtr.asFunction<double Function(double, int)>();

  double SDL_scalbnf(
    double x,
    int n,
  ) {
    return _SDL_scalbnf(
      x,
      n,
    );
  }

  late final _SDL_scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int32)>>(
          'SDL_scalbnf');
  late final _SDL_scalbnf =
      _SDL_scalbnfPtr.asFunction<double Function(double, int)>();

  double SDL_sin(
    double x,
  ) {
    return _SDL_sin(
      x,
    );
  }

  late final _SDL_sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sin');
  late final _SDL_sin = _SDL_sinPtr.asFunction<double Function(double)>();

  double SDL_sinf(
    double x,
  ) {
    return _SDL_sinf(
      x,
    );
  }

  late final _SDL_sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sinf');
  late final _SDL_sinf = _SDL_sinfPtr.asFunction<double Function(double)>();

  double SDL_sqrt(
    double x,
  ) {
    return _SDL_sqrt(
      x,
    );
  }

  late final _SDL_sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_sqrt');
  late final _SDL_sqrt = _SDL_sqrtPtr.asFunction<double Function(double)>();

  double SDL_sqrtf(
    double x,
  ) {
    return _SDL_sqrtf(
      x,
    );
  }

  late final _SDL_sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_sqrtf');
  late final _SDL_sqrtf = _SDL_sqrtfPtr.asFunction<double Function(double)>();

  double SDL_tan(
    double x,
  ) {
    return _SDL_tan(
      x,
    );
  }

  late final _SDL_tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('SDL_tan');
  late final _SDL_tan = _SDL_tanPtr.asFunction<double Function(double)>();

  double SDL_tanf(
    double x,
  ) {
    return _SDL_tanf(
      x,
    );
  }

  late final _SDL_tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('SDL_tanf');
  late final _SDL_tanf = _SDL_tanfPtr.asFunction<double Function(double)>();

  SDL_iconv_t1 SDL_iconv_open(
    ffi.Pointer<ffi.Int8> tocode,
    ffi.Pointer<ffi.Int8> fromcode,
  ) {
    return _SDL_iconv_open(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_openPtr = _lookup<
      ffi.NativeFunction<
          SDL_iconv_t1 Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_iconv_open');
  late final _SDL_iconv_open = _SDL_iconv_openPtr.asFunction<
      SDL_iconv_t1 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int SDL_iconv_close(
    SDL_iconv_t1 cd,
  ) {
    return _SDL_iconv_close(
      cd,
    );
  }

  late final _SDL_iconv_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_iconv_t1)>>(
          'SDL_iconv_close');
  late final _SDL_iconv_close =
      _SDL_iconv_closePtr.asFunction<int Function(SDL_iconv_t1)>();

  int SDL_iconv(
    SDL_iconv_t1 cd,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> inbuf,
    ffi.Pointer<size_t> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> outbuf,
    ffi.Pointer<size_t> outbytesleft,
  ) {
    return _SDL_iconv(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconvPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(
              SDL_iconv_t1,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<size_t>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<size_t>)>>('SDL_iconv');
  late final _SDL_iconv = _SDL_iconvPtr.asFunction<
      int Function(
          SDL_iconv_t1,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<size_t>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<size_t>)>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ffi.Pointer<ffi.Int8> SDL_iconv_string(
    ffi.Pointer<ffi.Int8> tocode,
    ffi.Pointer<ffi.Int8> fromcode,
    ffi.Pointer<ffi.Int8> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              size_t)>>('SDL_iconv_string');
  late final _SDL_iconv_string = _SDL_iconv_stringPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int SDL_main(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ) {
    return _SDL_main(
      argc,
      argv,
    );
  }

  late final _SDL_mainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('SDL_main');
  late final _SDL_main = _SDL_mainPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// This is called by the real SDL main function to let the rest of the
  /// library know that initialization was done properly.
  ///
  /// Calling this yourself without knowing what you're doing can cause
  /// crashes and hard to diagnose problems with your application.
  void SDL_SetMainReady() {
    return _SDL_SetMainReady();
  }

  late final _SDL_SetMainReadyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_SetMainReady');
  late final _SDL_SetMainReady =
      _SDL_SetMainReadyPtr.asFunction<void Function()>();

  /// This can be called to set the application class at startup
  int SDL_RegisterApp(
    ffi.Pointer<ffi.Int8> name,
    int style,
    ffi.Pointer<ffi.Void> hInst,
  ) {
    return _SDL_RegisterApp(
      name,
      style,
      hInst,
    );
  }

  late final _SDL_RegisterAppPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, Uint32,
              ffi.Pointer<ffi.Void>)>>('SDL_RegisterApp');
  late final _SDL_RegisterApp = _SDL_RegisterAppPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, int, ffi.Pointer<ffi.Void>)>();

  void SDL_UnregisterApp() {
    return _SDL_UnregisterApp();
  }

  late final _SDL_UnregisterAppPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnregisterApp');
  late final _SDL_UnregisterApp =
      _SDL_UnregisterAppPtr.asFunction<void Function()>();

  void __debugbreak() {
    return ___debugbreak();
  }

  late final ___debugbreakPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('__debugbreak');
  late final ___debugbreak = ___debugbreakPtr.asFunction<void Function()>();

  int SDL_ReportAssertion(
    ffi.Pointer<SDL_AssertData> arg0,
    ffi.Pointer<ffi.Int8> arg1,
    ffi.Pointer<ffi.Int8> arg2,
    int arg3,
  ) {
    return _SDL_ReportAssertion(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _SDL_ReportAssertionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_ReportAssertion');
  late final _SDL_ReportAssertion = _SDL_ReportAssertionPtr.asFunction<
      int Function(ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>, int)>();

  /// \brief Set an application-defined assertion handler.
  ///
  /// This allows an app to show its own assertion UI and/or force the
  /// response to an assertion failure. If the app doesn't provide this, SDL
  /// will try to do the right thing, popping up a system-specific GUI dialog,
  /// and probably minimizing any fullscreen windows.
  ///
  /// This callback may fire from any thread, but it runs wrapped in a mutex, so
  /// it will only fire from one thread at a time.
  ///
  /// Setting the callback to NULL restores SDL's original internal handler.
  ///
  /// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
  ///
  /// Return SDL_AssertState value of how to handle the assertion failure.
  ///
  /// \param handler Callback function, called when an assertion fails.
  /// \param userdata A pointer passed to the callback as-is.
  void SDL_SetAssertionHandler(
    SDL_AssertionHandler handler,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetAssertionHandler(
      handler,
      userdata,
    );
  }

  late final _SDL_SetAssertionHandlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_AssertionHandler,
              ffi.Pointer<ffi.Void>)>>('SDL_SetAssertionHandler');
  late final _SDL_SetAssertionHandler = _SDL_SetAssertionHandlerPtr.asFunction<
      void Function(SDL_AssertionHandler, ffi.Pointer<ffi.Void>)>();

  /// \brief Get the default assertion handler.
  ///
  /// This returns the function pointer that is called by default when an
  /// assertion is triggered. This is an internal function provided by SDL,
  /// that is used for assertions when SDL_SetAssertionHandler() hasn't been
  /// used to provide a different function.
  ///
  /// \return The default SDL_AssertionHandler that is called when an assert triggers.
  SDL_AssertionHandler SDL_GetDefaultAssertionHandler() {
    return _SDL_GetDefaultAssertionHandler();
  }

  late final _SDL_GetDefaultAssertionHandlerPtr =
      _lookup<ffi.NativeFunction<SDL_AssertionHandler Function()>>(
          'SDL_GetDefaultAssertionHandler');
  late final _SDL_GetDefaultAssertionHandler =
      _SDL_GetDefaultAssertionHandlerPtr.asFunction<
          SDL_AssertionHandler Function()>();

  /// \brief Get the current assertion handler.
  ///
  /// This returns the function pointer that is called when an assertion is
  /// triggered. This is either the value last passed to
  /// SDL_SetAssertionHandler(), or if no application-specified function is
  /// set, is equivalent to calling SDL_GetDefaultAssertionHandler().
  ///
  /// \param puserdata Pointer to a void*, which will store the "userdata"
  /// pointer that was passed to SDL_SetAssertionHandler().
  /// This value will always be NULL for the default handler.
  /// If you don't care about this data, it is safe to pass
  /// a NULL pointer to this function to ignore it.
  /// \return The SDL_AssertionHandler that is called when an assert triggers.
  SDL_AssertionHandler SDL_GetAssertionHandler(
    ffi.Pointer<ffi.Pointer<ffi.Void>> puserdata,
  ) {
    return _SDL_GetAssertionHandler(
      puserdata,
    );
  }

  late final _SDL_GetAssertionHandlerPtr = _lookup<
      ffi.NativeFunction<
          SDL_AssertionHandler Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetAssertionHandler');
  late final _SDL_GetAssertionHandler = _SDL_GetAssertionHandlerPtr.asFunction<
      SDL_AssertionHandler Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// \brief Get a list of all assertion failures.
  ///
  /// Get all assertions triggered since last call to SDL_ResetAssertionReport(),
  /// or the start of the program.
  ///
  /// The proper way to examine this data looks something like this:
  ///
  /// <code>
  /// const SDL_AssertData *item = SDL_GetAssertionReport();
  /// while (item) {
  /// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
  /// item->condition, item->function, item->filename,
  /// item->linenum, item->trigger_count,
  /// item->always_ignore ? "yes" : "no");
  /// item = item->next;
  /// }
  /// </code>
  ///
  /// \return List of all assertions.
  /// \sa SDL_ResetAssertionReport
  ffi.Pointer<SDL_AssertData> SDL_GetAssertionReport() {
    return _SDL_GetAssertionReport();
  }

  late final _SDL_GetAssertionReportPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_AssertData> Function()>>(
          'SDL_GetAssertionReport');
  late final _SDL_GetAssertionReport = _SDL_GetAssertionReportPtr.asFunction<
      ffi.Pointer<SDL_AssertData> Function()>();

  /// \brief Reset the list of all assertion failures.
  ///
  /// Reset list of all assertions triggered.
  ///
  /// \sa SDL_GetAssertionReport
  void SDL_ResetAssertionReport() {
    return _SDL_ResetAssertionReport();
  }

  late final _SDL_ResetAssertionReportPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_ResetAssertionReport');
  late final _SDL_ResetAssertionReport =
      _SDL_ResetAssertionReportPtr.asFunction<void Function()>();

  /// \brief Try to lock a spin lock by setting it to a non-zero value.
  ///
  /// \param lock Points to the lock.
  ///
  /// \return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held.
  int SDL_AtomicTryLock(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicTryLock(
      lock,
    );
  }

  late final _SDL_AtomicTryLockPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_SpinLock>)>>(
      'SDL_AtomicTryLock');
  late final _SDL_AtomicTryLock = _SDL_AtomicTryLockPtr.asFunction<
      int Function(ffi.Pointer<SDL_SpinLock>)>();

  /// \brief Lock a spin lock by setting it to a non-zero value.
  ///
  /// \param lock Points to the lock.
  void SDL_AtomicLock(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicLock(
      lock,
    );
  }

  late final _SDL_AtomicLockPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicLock');
  late final _SDL_AtomicLock =
      _SDL_AtomicLockPtr.asFunction<void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// \brief Unlock a spin lock by setting it to 0. Always returns immediately
  ///
  /// \param lock Points to the lock.
  void SDL_AtomicUnlock(
    ffi.Pointer<SDL_SpinLock> lock,
  ) {
    return _SDL_AtomicUnlock(
      lock,
    );
  }

  late final _SDL_AtomicUnlockPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_SpinLock>)>>(
          'SDL_AtomicUnlock');
  late final _SDL_AtomicUnlock = _SDL_AtomicUnlockPtr.asFunction<
      void Function(ffi.Pointer<SDL_SpinLock>)>();

  /// Memory barriers are designed to prevent reads and writes from being
  /// reordered by the compiler and being seen out of order on multi-core CPUs.
  ///
  /// A typical pattern would be for thread A to write some data and a flag,
  /// and for thread B to read the flag and get the data. In this case you
  /// would insert a release barrier between writing the data and the flag,
  /// guaranteeing that the data write completes no later than the flag is
  /// written, and you would insert an acquire barrier between reading the
  /// flag and reading the data, to ensure that all the reads associated
  /// with the flag have completed.
  ///
  /// In this pattern you should always see a release barrier paired with
  /// an acquire barrier and you should gate the data reads/writes with a
  /// single flag variable.
  ///
  /// For more information on these semantics, take a look at the blog post:
  /// http://preshing.com/20120913/acquire-and-release-semantics
  void SDL_MemoryBarrierReleaseFunction() {
    return _SDL_MemoryBarrierReleaseFunction();
  }

  late final _SDL_MemoryBarrierReleaseFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierReleaseFunction');
  late final _SDL_MemoryBarrierReleaseFunction =
      _SDL_MemoryBarrierReleaseFunctionPtr.asFunction<void Function()>();

  void SDL_MemoryBarrierAcquireFunction() {
    return _SDL_MemoryBarrierAcquireFunction();
  }

  late final _SDL_MemoryBarrierAcquireFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_MemoryBarrierAcquireFunction');
  late final _SDL_MemoryBarrierAcquireFunction =
      _SDL_MemoryBarrierAcquireFunctionPtr.asFunction<void Function()>();

  /// \brief Set an atomic variable to a new value if it is currently an old value.
  ///
  /// \return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
  ///
  /// \note If you don't know what this function is for, you shouldn't use it!
  int SDL_AtomicCAS(
    ffi.Pointer<SDL_atomic_t> a,
    int oldval,
    int newval,
  ) {
    return _SDL_AtomicCAS(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_atomic_t>, ffi.Int32,
              ffi.Int32)>>('SDL_AtomicCAS');
  late final _SDL_AtomicCAS = _SDL_AtomicCASPtr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int, int)>();

  /// \brief Set an atomic variable to a value.
  ///
  /// \return The previous value of the atomic variable.
  int SDL_AtomicSet(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicSet(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int32)>>('SDL_AtomicSet');
  late final _SDL_AtomicSet = _SDL_AtomicSetPtr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// \brief Get the value of an atomic variable
  int SDL_AtomicGet(
    ffi.Pointer<SDL_atomic_t> a,
  ) {
    return _SDL_AtomicGet(
      a,
    );
  }

  late final _SDL_AtomicGetPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_atomic_t>)>>(
      'SDL_AtomicGet');
  late final _SDL_AtomicGet =
      _SDL_AtomicGetPtr.asFunction<int Function(ffi.Pointer<SDL_atomic_t>)>();

  /// \brief Add to an atomic variable.
  ///
  /// \return The previous value of the atomic variable.
  ///
  /// \note This same style can be used for any number operation
  int SDL_AtomicAdd(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicAdd(
      a,
      v,
    );
  }

  late final _SDL_AtomicAddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_atomic_t>, ffi.Int32)>>('SDL_AtomicAdd');
  late final _SDL_AtomicAdd = _SDL_AtomicAddPtr.asFunction<
      int Function(ffi.Pointer<SDL_atomic_t>, int)>();

  /// \brief Set a pointer to a new value if it is currently an old value.
  ///
  /// \return SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
  ///
  /// \note If you don't know what this function is for, you shouldn't use it!
  int SDL_AtomicCASPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> oldval,
    ffi.Pointer<ffi.Void> newval,
  ) {
    return _SDL_AtomicCASPtr1(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicCASPtr');
  late final _SDL_AtomicCASPtr1 = _SDL_AtomicCASPtrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// \brief Set a pointer to a value atomically.
  ///
  /// \return The previous value of the pointer.
  ffi.Pointer<ffi.Void> SDL_AtomicSetPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> v,
  ) {
    return _SDL_AtomicSetPtr1(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Void>)>>('SDL_AtomicSetPtr');
  late final _SDL_AtomicSetPtr1 = _SDL_AtomicSetPtrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Void>)>();

  /// \brief Get the value of a pointer atomically.
  ffi.Pointer<ffi.Void> SDL_AtomicGetPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ) {
    return _SDL_AtomicGetPtr1(
      a,
    );
  }

  late final _SDL_AtomicGetPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_AtomicGetPtr');
  late final _SDL_AtomicGetPtr1 = _SDL_AtomicGetPtrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// \brief Set the error message for the current thread
  ///
  /// \return -1, there is no error handling for this function
  int SDL_SetError(
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_SetError(
      fmt,
    );
  }

  late final _SDL_SetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_SetError');
  late final _SDL_SetError =
      _SDL_SetErrorPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Get the last error message that was set
  ///
  /// SDL API functions may set error messages and then succeed, so you should
  /// only use the error value if a function fails.
  ///
  /// This returns a pointer to a static buffer for convenience and should not
  /// be called by multiple threads simultaneously.
  ///
  /// \return a pointer to the last error message that was set
  ffi.Pointer<ffi.Int8> SDL_GetError() {
    return _SDL_GetError();
  }

  late final _SDL_GetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetError');
  late final _SDL_GetError =
      _SDL_GetErrorPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// \brief Get the last error message that was set for the current thread
  ///
  /// SDL API functions may set error messages and then succeed, so you should
  /// only use the error value if a function fails.
  ///
  /// \param errstr A buffer to fill with the last error message that was set
  /// for the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  ///
  /// \return errstr
  ffi.Pointer<ffi.Int8> SDL_GetErrorMsg(
    ffi.Pointer<ffi.Int8> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_GetErrorMsg');
  late final _SDL_GetErrorMsg = _SDL_GetErrorMsgPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>, int)>();

  /// \brief Clear the error message for the current thread
  void SDL_ClearError() {
    return _SDL_ClearError();
  }

  late final _SDL_ClearErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearError');
  late final _SDL_ClearError = _SDL_ClearErrorPtr.asFunction<void Function()>();

  int SDL_Error(
    int code,
  ) {
    return _SDL_Error(
      code,
    );
  }

  late final _SDL_ErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('SDL_Error');
  late final _SDL_Error = _SDL_ErrorPtr.asFunction<int Function(int)>();

  /// Create a mutex, initialized unlocked.
  ffi.Pointer<SDL_mutex> SDL_CreateMutex() {
    return _SDL_CreateMutex();
  }

  late final _SDL_CreateMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_mutex> Function()>>(
          'SDL_CreateMutex');
  late final _SDL_CreateMutex =
      _SDL_CreateMutexPtr.asFunction<ffi.Pointer<SDL_mutex> Function()>();

  int SDL_LockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_LockMutex(
      mutex,
    );
  }

  late final _SDL_LockMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_LockMutex');
  late final _SDL_LockMutex =
      _SDL_LockMutexPtr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Try to lock the mutex
  ///
  /// \return 0, SDL_MUTEX_TIMEDOUT, or -1 on error
  int SDL_TryLockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_TryLockMutex(
      mutex,
    );
  }

  late final _SDL_TryLockMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_TryLockMutex');
  late final _SDL_TryLockMutex =
      _SDL_TryLockMutexPtr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  int SDL_UnlockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_UnlockMutex(
      mutex,
    );
  }

  late final _SDL_UnlockMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_UnlockMutex');
  late final _SDL_UnlockMutex =
      _SDL_UnlockMutexPtr.asFunction<int Function(ffi.Pointer<SDL_mutex>)>();

  /// Destroy a mutex.
  void SDL_DestroyMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_DestroyMutex(
      mutex,
    );
  }

  late final _SDL_DestroyMutexPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_mutex>)>>(
          'SDL_DestroyMutex');
  late final _SDL_DestroyMutex =
      _SDL_DestroyMutexPtr.asFunction<void Function(ffi.Pointer<SDL_mutex>)>();

  /// Create a semaphore, initialized with value, returns NULL on failure.
  ffi.Pointer<SDL_sem> SDL_CreateSemaphore(
    int initial_value,
  ) {
    return _SDL_CreateSemaphore(
      initial_value,
    );
  }

  late final _SDL_CreateSemaphorePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_sem> Function(Uint32)>>(
          'SDL_CreateSemaphore');
  late final _SDL_CreateSemaphore =
      _SDL_CreateSemaphorePtr.asFunction<ffi.Pointer<SDL_sem> Function(int)>();

  /// Destroy a semaphore.
  void SDL_DestroySemaphore(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_DestroySemaphore(
      sem,
    );
  }

  late final _SDL_DestroySemaphorePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_DestroySemaphore');
  late final _SDL_DestroySemaphore = _SDL_DestroySemaphorePtr.asFunction<
      void Function(ffi.Pointer<SDL_sem>)>();

  /// This function suspends the calling thread until the semaphore pointed
  /// to by \c sem has a positive count. It then atomically decreases the
  /// semaphore count.
  int SDL_SemWait(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemWait(
      sem,
    );
  }

  late final _SDL_SemWaitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemWait');
  late final _SDL_SemWait =
      _SDL_SemWaitPtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Non-blocking variant of SDL_SemWait().
  ///
  /// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would
  /// block, and -1 on error.
  int SDL_SemTryWait(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemTryWait(
      sem,
    );
  }

  late final _SDL_SemTryWaitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemTryWait');
  late final _SDL_SemTryWait =
      _SDL_SemTryWaitPtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Variant of SDL_SemWait() with a timeout in milliseconds.
  ///
  /// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not
  /// succeed in the allotted time, and -1 on error.
  ///
  /// \warning On some platforms this function is implemented by looping with a
  /// delay of 1 ms, and so should be avoided if possible.
  int SDL_SemWaitTimeout(
    ffi.Pointer<SDL_sem> sem,
    int ms,
  ) {
    return _SDL_SemWaitTimeout(
      sem,
      ms,
    );
  }

  late final _SDL_SemWaitTimeoutPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_sem>, Uint32)>>(
      'SDL_SemWaitTimeout');
  late final _SDL_SemWaitTimeout = _SDL_SemWaitTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_sem>, int)>();

  /// Atomically increases the semaphore's count (not blocking).
  ///
  /// \return 0, or -1 on error.
  int SDL_SemPost(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemPost(
      sem,
    );
  }

  late final _SDL_SemPostPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemPost');
  late final _SDL_SemPost =
      _SDL_SemPostPtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Returns the current count of the semaphore.
  int SDL_SemValue(
    ffi.Pointer<SDL_sem> sem,
  ) {
    return _SDL_SemValue(
      sem,
    );
  }

  late final _SDL_SemValuePtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_sem>)>>(
          'SDL_SemValue');
  late final _SDL_SemValue =
      _SDL_SemValuePtr.asFunction<int Function(ffi.Pointer<SDL_sem>)>();

  /// Create a condition variable.
  ///
  /// Typical use of condition variables:
  ///
  /// Thread A:
  /// SDL_LockMutex(lock);
  /// while ( ! condition ) {
  /// SDL_CondWait(cond, lock);
  /// }
  /// SDL_UnlockMutex(lock);
  ///
  /// Thread B:
  /// SDL_LockMutex(lock);
  /// ...
  /// condition = true;
  /// ...
  /// SDL_CondSignal(cond);
  /// SDL_UnlockMutex(lock);
  ///
  /// There is some discussion whether to signal the condition variable
  /// with the mutex locked or not.  There is some potential performance
  /// benefit to unlocking first on some platforms, but there are some
  /// potential race conditions depending on how your code is structured.
  ///
  /// In general it's safer to signal the condition variable while the
  /// mutex is locked.
  ffi.Pointer<SDL_cond> SDL_CreateCond() {
    return _SDL_CreateCond();
  }

  late final _SDL_CreateCondPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_cond> Function()>>(
          'SDL_CreateCond');
  late final _SDL_CreateCond =
      _SDL_CreateCondPtr.asFunction<ffi.Pointer<SDL_cond> Function()>();

  /// Destroy a condition variable.
  void SDL_DestroyCond(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_DestroyCond(
      cond,
    );
  }

  late final _SDL_DestroyCondPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_DestroyCond');
  late final _SDL_DestroyCond =
      _SDL_DestroyCondPtr.asFunction<void Function(ffi.Pointer<SDL_cond>)>();

  /// Restart one of the threads that are waiting on the condition variable.
  ///
  /// \return 0 or -1 on error.
  int SDL_CondSignal(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondSignal(
      cond,
    );
  }

  late final _SDL_CondSignalPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondSignal');
  late final _SDL_CondSignal =
      _SDL_CondSignalPtr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Restart all threads that are waiting on the condition variable.
  ///
  /// \return 0 or -1 on error.
  int SDL_CondBroadcast(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondBroadcast(
      cond,
    );
  }

  late final _SDL_CondBroadcastPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_cond>)>>(
          'SDL_CondBroadcast');
  late final _SDL_CondBroadcast =
      _SDL_CondBroadcastPtr.asFunction<int Function(ffi.Pointer<SDL_cond>)>();

  /// Wait on the condition variable, unlocking the provided mutex.
  ///
  /// \warning The mutex must be locked before entering this function!
  ///
  /// The mutex is re-locked once the condition variable is signaled.
  ///
  /// \return 0 when it is signaled, or -1 on error.
  int SDL_CondWait(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_CondWait(
      cond,
      mutex,
    );
  }

  late final _SDL_CondWaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>>('SDL_CondWait');
  late final _SDL_CondWait = _SDL_CondWaitPtr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>)>();

  /// Waits for at most \c ms milliseconds, and returns 0 if the condition
  /// variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not
  /// signaled in the allotted time, and -1 on error.
  ///
  /// \warning On some platforms this function is implemented by looping with a
  /// delay of 1 ms, and so should be avoided if possible.
  int SDL_CondWaitTimeout(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
    int ms,
  ) {
    return _SDL_CondWaitTimeout(
      cond,
      mutex,
      ms,
    );
  }

  late final _SDL_CondWaitTimeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>,
              Uint32)>>('SDL_CondWaitTimeout');
  late final _SDL_CondWaitTimeout = _SDL_CondWaitTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_cond>, ffi.Pointer<SDL_mutex>, int)>();

  late final ffi.Pointer<ffi.Double> __HUGE = _lookup<ffi.Double>('_HUGE');

  double get _HUGE => __HUGE.value;

  set _HUGE(double value) => __HUGE.value = value;

  void _fperrraise(
    int _Except,
  ) {
    return __fperrraise(
      _Except,
    );
  }

  late final __fperrraisePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>('_fperrraise');
  late final __fperrraise = __fperrraisePtr.asFunction<void Function(int)>();

  int _dclass(
    double _X,
  ) {
    return __dclass(
      _X,
    );
  }

  late final __dclassPtr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(ffi.Double)>>('_dclass');
  late final __dclass = __dclassPtr.asFunction<int Function(double)>();

  int _fdclass(
    double _X,
  ) {
    return __fdclass(
      _X,
    );
  }

  late final __fdclassPtr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(ffi.Float)>>('_fdclass');
  late final __fdclass = __fdclassPtr.asFunction<int Function(double)>();

  int _dsign(
    double _X,
  ) {
    return __dsign(
      _X,
    );
  }

  late final __dsignPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Double)>>('_dsign');
  late final __dsign = __dsignPtr.asFunction<int Function(double)>();

  int _fdsign(
    double _X,
  ) {
    return __fdsign(
      _X,
    );
  }

  late final __fdsignPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>('_fdsign');
  late final __fdsign = __fdsignPtr.asFunction<int Function(double)>();

  int _dpcomp(
    double _X,
    double _Y,
  ) {
    return __dpcomp(
      _X,
      _Y,
    );
  }

  late final __dpcompPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Double, ffi.Double)>>(
          '_dpcomp');
  late final __dpcomp = __dpcompPtr.asFunction<int Function(double, double)>();

  int _fdpcomp(
    double _X,
    double _Y,
  ) {
    return __fdpcomp(
      _X,
      _Y,
    );
  }

  late final __fdpcompPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float, ffi.Float)>>(
          '_fdpcomp');
  late final __fdpcomp =
      __fdpcompPtr.asFunction<int Function(double, double)>();

  int _dtest(
    ffi.Pointer<ffi.Double> _Px,
  ) {
    return __dtest(
      _Px,
    );
  }

  late final __dtestPtr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(ffi.Pointer<ffi.Double>)>>(
          '_dtest');
  late final __dtest =
      __dtestPtr.asFunction<int Function(ffi.Pointer<ffi.Double>)>();

  int _fdtest(
    ffi.Pointer<ffi.Float> _Px,
  ) {
    return __fdtest(
      _Px,
    );
  }

  late final __fdtestPtr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(ffi.Pointer<ffi.Float>)>>(
          '_fdtest');
  late final __fdtest =
      __fdtestPtr.asFunction<int Function(ffi.Pointer<ffi.Float>)>();

  int _d_int(
    ffi.Pointer<ffi.Double> _Px,
    int _Xexp,
  ) {
    return __d_int(
      _Px,
      _Xexp,
    );
  }

  late final __d_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(ffi.Pointer<ffi.Double>, ffi.Int16)>>('_d_int');
  late final __d_int =
      __d_intPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  int _fd_int(
    ffi.Pointer<ffi.Float> _Px,
    int _Xexp,
  ) {
    return __fd_int(
      _Px,
      _Xexp,
    );
  }

  late final __fd_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(ffi.Pointer<ffi.Float>, ffi.Int16)>>('_fd_int');
  late final __fd_int =
      __fd_intPtr.asFunction<int Function(ffi.Pointer<ffi.Float>, int)>();

  int _dscale(
    ffi.Pointer<ffi.Double> _Px,
    int _Lexp,
  ) {
    return __dscale(
      _Px,
      _Lexp,
    );
  }

  late final __dscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(ffi.Pointer<ffi.Double>, ffi.Int64)>>('_dscale');
  late final __dscale =
      __dscalePtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  int _fdscale(
    ffi.Pointer<ffi.Float> _Px,
    int _Lexp,
  ) {
    return __fdscale(
      _Px,
      _Lexp,
    );
  }

  late final __fdscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(ffi.Pointer<ffi.Float>, ffi.Int64)>>('_fdscale');
  late final __fdscale =
      __fdscalePtr.asFunction<int Function(ffi.Pointer<ffi.Float>, int)>();

  int _dunscale(
    ffi.Pointer<ffi.Int16> _Pex,
    ffi.Pointer<ffi.Double> _Px,
  ) {
    return __dunscale(
      _Pex,
      _Px,
    );
  }

  late final __dunscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(
              ffi.Pointer<ffi.Int16>, ffi.Pointer<ffi.Double>)>>('_dunscale');
  late final __dunscale = __dunscalePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int16>, ffi.Pointer<ffi.Double>)>();

  int _fdunscale(
    ffi.Pointer<ffi.Int16> _Pex,
    ffi.Pointer<ffi.Float> _Px,
  ) {
    return __fdunscale(
      _Pex,
      _Px,
    );
  }

  late final __fdunscalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(
              ffi.Pointer<ffi.Int16>, ffi.Pointer<ffi.Float>)>>('_fdunscale');
  late final __fdunscale = __fdunscalePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int16>, ffi.Pointer<ffi.Float>)>();

  int _dexp(
    ffi.Pointer<ffi.Double> _Px,
    double _Y,
    int _Eoff,
  ) {
    return __dexp(
      _Px,
      _Y,
      _Eoff,
    );
  }

  late final __dexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(
              ffi.Pointer<ffi.Double>, ffi.Double, ffi.Int64)>>('_dexp');
  late final __dexp = __dexpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Double>, double, int)>();

  int _fdexp(
    ffi.Pointer<ffi.Float> _Px,
    double _Y,
    int _Eoff,
  ) {
    return __fdexp(
      _Px,
      _Y,
      _Eoff,
    );
  }

  late final __fdexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(
              ffi.Pointer<ffi.Float>, ffi.Float, ffi.Int64)>>('_fdexp');
  late final __fdexp = __fdexpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Float>, double, int)>();

  int _dnorm(
    ffi.Pointer<ffi.Uint16> _Ps,
  ) {
    return __dnorm(
      _Ps,
    );
  }

  late final __dnormPtr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(ffi.Pointer<ffi.Uint16>)>>(
          '_dnorm');
  late final __dnorm =
      __dnormPtr.asFunction<int Function(ffi.Pointer<ffi.Uint16>)>();

  int _fdnorm(
    ffi.Pointer<ffi.Uint16> _Ps,
  ) {
    return __fdnorm(
      _Ps,
    );
  }

  late final __fdnormPtr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(ffi.Pointer<ffi.Uint16>)>>(
          '_fdnorm');
  late final __fdnorm =
      __fdnormPtr.asFunction<int Function(ffi.Pointer<ffi.Uint16>)>();

  double _dpoly(
    double _X,
    ffi.Pointer<ffi.Double> _Tab,
    int _N,
  ) {
    return __dpoly(
      _X,
      _Tab,
      _N,
    );
  }

  late final __dpolyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Pointer<ffi.Double>, ffi.Int32)>>('_dpoly');
  late final __dpoly = __dpolyPtr
      .asFunction<double Function(double, ffi.Pointer<ffi.Double>, int)>();

  double _fdpoly(
    double _X,
    ffi.Pointer<ffi.Float> _Tab,
    int _N,
  ) {
    return __fdpoly(
      _X,
      _Tab,
      _N,
    );
  }

  late final __fdpolyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Pointer<ffi.Float>, ffi.Int32)>>('_fdpoly');
  late final __fdpoly = __fdpolyPtr
      .asFunction<double Function(double, ffi.Pointer<ffi.Float>, int)>();

  double _dlog(
    double _X,
    int _Baseflag,
  ) {
    return __dlog(
      _X,
      _Baseflag,
    );
  }

  late final __dlogPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int32)>>(
          '_dlog');
  late final __dlog = __dlogPtr.asFunction<double Function(double, int)>();

  double _fdlog(
    double _X,
    int _Baseflag,
  ) {
    return __fdlog(
      _X,
      _Baseflag,
    );
  }

  late final __fdlogPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int32)>>(
          '_fdlog');
  late final __fdlog = __fdlogPtr.asFunction<double Function(double, int)>();

  double _dsin(
    double _X,
    int _Qoff,
  ) {
    return __dsin(
      _X,
      _Qoff,
    );
  }

  late final __dsinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Uint32)>>(
          '_dsin');
  late final __dsin = __dsinPtr.asFunction<double Function(double, int)>();

  double _fdsin(
    double _X,
    int _Qoff,
  ) {
    return __fdsin(
      _X,
      _Qoff,
    );
  }

  late final __fdsinPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Uint32)>>(
          '_fdsin');
  late final __fdsin = __fdsinPtr.asFunction<double Function(double, int)>();

  late final ffi.Pointer<_float_const> __Denorm_C =
      _lookup<_float_const>('_Denorm_C');

  ffi.Pointer<_float_const> get _Denorm_C => __Denorm_C;

  late final ffi.Pointer<_float_const> __Inf_C =
      _lookup<_float_const>('_Inf_C');

  ffi.Pointer<_float_const> get _Inf_C => __Inf_C;

  late final ffi.Pointer<_float_const> __Nan_C =
      _lookup<_float_const>('_Nan_C');

  ffi.Pointer<_float_const> get _Nan_C => __Nan_C;

  late final ffi.Pointer<_float_const> __Snan_C =
      _lookup<_float_const>('_Snan_C');

  ffi.Pointer<_float_const> get _Snan_C => __Snan_C;

  late final ffi.Pointer<_float_const> __Hugeval_C =
      _lookup<_float_const>('_Hugeval_C');

  ffi.Pointer<_float_const> get _Hugeval_C => __Hugeval_C;

  late final ffi.Pointer<_float_const> __FDenorm_C =
      _lookup<_float_const>('_FDenorm_C');

  ffi.Pointer<_float_const> get _FDenorm_C => __FDenorm_C;

  late final ffi.Pointer<_float_const> __FInf_C =
      _lookup<_float_const>('_FInf_C');

  ffi.Pointer<_float_const> get _FInf_C => __FInf_C;

  late final ffi.Pointer<_float_const> __FNan_C =
      _lookup<_float_const>('_FNan_C');

  ffi.Pointer<_float_const> get _FNan_C => __FNan_C;

  late final ffi.Pointer<_float_const> __FSnan_C =
      _lookup<_float_const>('_FSnan_C');

  ffi.Pointer<_float_const> get _FSnan_C => __FSnan_C;

  late final ffi.Pointer<_float_const> __LDenorm_C =
      _lookup<_float_const>('_LDenorm_C');

  ffi.Pointer<_float_const> get _LDenorm_C => __LDenorm_C;

  late final ffi.Pointer<_float_const> __LInf_C =
      _lookup<_float_const>('_LInf_C');

  ffi.Pointer<_float_const> get _LInf_C => __LInf_C;

  late final ffi.Pointer<_float_const> __LNan_C =
      _lookup<_float_const>('_LNan_C');

  ffi.Pointer<_float_const> get _LNan_C => __LNan_C;

  late final ffi.Pointer<_float_const> __LSnan_C =
      _lookup<_float_const>('_LSnan_C');

  ffi.Pointer<_float_const> get _LSnan_C => __LSnan_C;

  late final ffi.Pointer<_float_const> __Eps_C =
      _lookup<_float_const>('_Eps_C');

  ffi.Pointer<_float_const> get _Eps_C => __Eps_C;

  late final ffi.Pointer<_float_const> __Rteps_C =
      _lookup<_float_const>('_Rteps_C');

  ffi.Pointer<_float_const> get _Rteps_C => __Rteps_C;

  late final ffi.Pointer<_float_const> __FEps_C =
      _lookup<_float_const>('_FEps_C');

  ffi.Pointer<_float_const> get _FEps_C => __FEps_C;

  late final ffi.Pointer<_float_const> __FRteps_C =
      _lookup<_float_const>('_FRteps_C');

  ffi.Pointer<_float_const> get _FRteps_C => __FRteps_C;

  late final ffi.Pointer<_float_const> __LEps_C =
      _lookup<_float_const>('_LEps_C');

  ffi.Pointer<_float_const> get _LEps_C => __LEps_C;

  late final ffi.Pointer<_float_const> __LRteps_C =
      _lookup<_float_const>('_LRteps_C');

  ffi.Pointer<_float_const> get _LRteps_C => __LRteps_C;

  late final ffi.Pointer<ffi.Double> __Zero_C = _lookup<ffi.Double>('_Zero_C');

  double get _Zero_C => __Zero_C.value;

  set _Zero_C(double value) => __Zero_C.value = value;

  late final ffi.Pointer<ffi.Double> __Xbig_C = _lookup<ffi.Double>('_Xbig_C');

  double get _Xbig_C => __Xbig_C.value;

  set _Xbig_C(double value) => __Xbig_C.value = value;

  late final ffi.Pointer<ffi.Float> __FZero_C = _lookup<ffi.Float>('_FZero_C');

  double get _FZero_C => __FZero_C.value;

  set _FZero_C(double value) => __FZero_C.value = value;

  late final ffi.Pointer<ffi.Float> __FXbig_C = _lookup<ffi.Float>('_FXbig_C');

  double get _FXbig_C => __FXbig_C.value;

  set _FXbig_C(double value) => __FXbig_C.value = value;

  int abs(
    int _X,
  ) {
    return _abs(
      _X,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int _X,
  ) {
    return _labs(
      _X,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Int64)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int _X,
  ) {
    return _llabs(
      _X,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Int64)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  double acos(
    double _X,
  ) {
    return _acos(
      _X,
    );
  }

  late final _acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acos');
  late final _acos = _acosPtr.asFunction<double Function(double)>();

  double asin(
    double _X,
  ) {
    return _asin(
      _X,
    );
  }

  late final _asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asin');
  late final _asin = _asinPtr.asFunction<double Function(double)>();

  double atan(
    double _X,
  ) {
    return _atan(
      _X,
    );
  }

  late final _atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atan');
  late final _atan = _atanPtr.asFunction<double Function(double)>();

  double atan2(
    double _Y,
    double _X,
  ) {
    return _atan2(
      _Y,
      _X,
    );
  }

  late final _atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'atan2');
  late final _atan2 = _atan2Ptr.asFunction<double Function(double, double)>();

  double cos(
    double _X,
  ) {
    return _cos(
      _X,
    );
  }

  late final _cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cos');
  late final _cos = _cosPtr.asFunction<double Function(double)>();

  double cosh(
    double _X,
  ) {
    return _cosh(
      _X,
    );
  }

  late final _coshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cosh');
  late final _cosh = _coshPtr.asFunction<double Function(double)>();

  double exp(
    double _X,
  ) {
    return _exp(
      _X,
    );
  }

  late final _expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp');
  late final _exp = _expPtr.asFunction<double Function(double)>();

  double fabs(
    double _X,
  ) {
    return _fabs(
      _X,
    );
  }

  late final _fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('fabs');
  late final _fabs = _fabsPtr.asFunction<double Function(double)>();

  double fmod(
    double _X,
    double _Y,
  ) {
    return _fmod(
      _X,
      _Y,
    );
  }

  late final _fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmod');
  late final _fmod = _fmodPtr.asFunction<double Function(double, double)>();

  double log(
    double _X,
  ) {
    return _log(
      _X,
    );
  }

  late final _logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log');
  late final _log = _logPtr.asFunction<double Function(double)>();

  double log10(
    double _X,
  ) {
    return _log10(
      _X,
    );
  }

  late final _log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log10');
  late final _log10 = _log10Ptr.asFunction<double Function(double)>();

  double pow(
    double _X,
    double _Y,
  ) {
    return _pow(
      _X,
      _Y,
    );
  }

  late final _powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'pow');
  late final _pow = _powPtr.asFunction<double Function(double, double)>();

  double sin(
    double _X,
  ) {
    return _sin(
      _X,
    );
  }

  late final _sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sin');
  late final _sin = _sinPtr.asFunction<double Function(double)>();

  double sinh(
    double _X,
  ) {
    return _sinh(
      _X,
    );
  }

  late final _sinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sinh');
  late final _sinh = _sinhPtr.asFunction<double Function(double)>();

  double sqrt(
    double _X,
  ) {
    return _sqrt(
      _X,
    );
  }

  late final _sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sqrt');
  late final _sqrt = _sqrtPtr.asFunction<double Function(double)>();

  double tan(
    double _X,
  ) {
    return _tan(
      _X,
    );
  }

  late final _tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tan');
  late final _tan = _tanPtr.asFunction<double Function(double)>();

  double tanh(
    double _X,
  ) {
    return _tanh(
      _X,
    );
  }

  late final _tanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tanh');
  late final _tanh = _tanhPtr.asFunction<double Function(double)>();

  double acosh(
    double _X,
  ) {
    return _acosh(
      _X,
    );
  }

  late final _acoshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acosh');
  late final _acosh = _acoshPtr.asFunction<double Function(double)>();

  double asinh(
    double _X,
  ) {
    return _asinh(
      _X,
    );
  }

  late final _asinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asinh');
  late final _asinh = _asinhPtr.asFunction<double Function(double)>();

  double atanh(
    double _X,
  ) {
    return _atanh(
      _X,
    );
  }

  late final _atanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atanh');
  late final _atanh = _atanhPtr.asFunction<double Function(double)>();

  double atof(
    ffi.Pointer<ffi.Int8> _String,
  ) {
    return _atof(
      _String,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Int8>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Int8>)>();

  double _atof_l(
    ffi.Pointer<ffi.Int8> _String,
    _locale_t _Locale,
  ) {
    return __atof_l(
      _String,
      _Locale,
    );
  }

  late final __atof_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Int8>, _locale_t)>>('_atof_l');
  late final __atof_l = __atof_lPtr
      .asFunction<double Function(ffi.Pointer<ffi.Int8>, _locale_t)>();

  double _cabs(
    complex _Complex_value,
  ) {
    return __cabs(
      _Complex_value,
    );
  }

  late final __cabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(complex)>>('_cabs');
  late final __cabs = __cabsPtr.asFunction<double Function(complex)>();

  double cbrt(
    double _X,
  ) {
    return _cbrt(
      _X,
    );
  }

  late final _cbrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cbrt');
  late final _cbrt = _cbrtPtr.asFunction<double Function(double)>();

  double ceil(
    double _X,
  ) {
    return _ceil(
      _X,
    );
  }

  late final _ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('ceil');
  late final _ceil = _ceilPtr.asFunction<double Function(double)>();

  double _chgsign(
    double _X,
  ) {
    return __chgsign(
      _X,
    );
  }

  late final __chgsignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_chgsign');
  late final __chgsign = __chgsignPtr.asFunction<double Function(double)>();

  double copysign(
    double _Number,
    double _Sign,
  ) {
    return _copysign1(
      _Number,
      _Sign,
    );
  }

  late final _copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'copysign');
  late final _copysign1 =
      _copysignPtr.asFunction<double Function(double, double)>();

  double _copysign(
    double _Number,
    double _Sign,
  ) {
    return __copysign(
      _Number,
      _Sign,
    );
  }

  late final __copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          '_copysign');
  late final __copysign =
      __copysignPtr.asFunction<double Function(double, double)>();

  double erf(
    double _X,
  ) {
    return _erf(
      _X,
    );
  }

  late final _erfPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erf');
  late final _erf = _erfPtr.asFunction<double Function(double)>();

  double erfc(
    double _X,
  ) {
    return _erfc(
      _X,
    );
  }

  late final _erfcPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erfc');
  late final _erfc = _erfcPtr.asFunction<double Function(double)>();

  double exp2(
    double _X,
  ) {
    return _exp2(
      _X,
    );
  }

  late final _exp2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp2');
  late final _exp2 = _exp2Ptr.asFunction<double Function(double)>();

  double expm1(
    double _X,
  ) {
    return _expm1(
      _X,
    );
  }

  late final _expm1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('expm1');
  late final _expm1 = _expm1Ptr.asFunction<double Function(double)>();

  double fdim(
    double _X,
    double _Y,
  ) {
    return _fdim(
      _X,
      _Y,
    );
  }

  late final _fdimPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fdim');
  late final _fdim = _fdimPtr.asFunction<double Function(double, double)>();

  double floor(
    double _X,
  ) {
    return _floor(
      _X,
    );
  }

  late final _floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('floor');
  late final _floor = _floorPtr.asFunction<double Function(double)>();

  double fma(
    double _X,
    double _Y,
    double _Z,
  ) {
    return _fma(
      _X,
      _Y,
      _Z,
    );
  }

  late final _fmaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Double, ffi.Double)>>('fma');
  late final _fma =
      _fmaPtr.asFunction<double Function(double, double, double)>();

  double fmax(
    double _X,
    double _Y,
  ) {
    return _fmax(
      _X,
      _Y,
    );
  }

  late final _fmaxPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmax');
  late final _fmax = _fmaxPtr.asFunction<double Function(double, double)>();

  double fmin(
    double _X,
    double _Y,
  ) {
    return _fmin(
      _X,
      _Y,
    );
  }

  late final _fminPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmin');
  late final _fmin = _fminPtr.asFunction<double Function(double, double)>();

  double frexp(
    double _X,
    ffi.Pointer<ffi.Int32> _Y,
  ) {
    return _frexp(
      _X,
      _Y,
    );
  }

  late final _frexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Int32>)>>('frexp');
  late final _frexp =
      _frexpPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int32>)>();

  double hypot(
    double _X,
    double _Y,
  ) {
    return _hypot1(
      _X,
      _Y,
    );
  }

  late final _hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'hypot');
  late final _hypot1 = _hypotPtr.asFunction<double Function(double, double)>();

  double _hypot(
    double _X,
    double _Y,
  ) {
    return __hypot(
      _X,
      _Y,
    );
  }

  late final __hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          '_hypot');
  late final __hypot = __hypotPtr.asFunction<double Function(double, double)>();

  int ilogb(
    double _X,
  ) {
    return _ilogb(
      _X,
    );
  }

  late final _ilogbPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Double)>>('ilogb');
  late final _ilogb = _ilogbPtr.asFunction<int Function(double)>();

  double ldexp(
    double _X,
    int _Y,
  ) {
    return _ldexp(
      _X,
      _Y,
    );
  }

  late final _ldexpPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int32)>>(
          'ldexp');
  late final _ldexp = _ldexpPtr.asFunction<double Function(double, int)>();

  double lgamma(
    double _X,
  ) {
    return _lgamma(
      _X,
    );
  }

  late final _lgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('lgamma');
  late final _lgamma = _lgammaPtr.asFunction<double Function(double)>();

  int llrint(
    double _X,
  ) {
    return _llrint(
      _X,
    );
  }

  late final _llrintPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Double)>>('llrint');
  late final _llrint = _llrintPtr.asFunction<int Function(double)>();

  int llround(
    double _X,
  ) {
    return _llround(
      _X,
    );
  }

  late final _llroundPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Double)>>('llround');
  late final _llround = _llroundPtr.asFunction<int Function(double)>();

  double log1p(
    double _X,
  ) {
    return _log1p(
      _X,
    );
  }

  late final _log1pPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log1p');
  late final _log1p = _log1pPtr.asFunction<double Function(double)>();

  double log2(
    double _X,
  ) {
    return _log2(
      _X,
    );
  }

  late final _log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log2');
  late final _log2 = _log2Ptr.asFunction<double Function(double)>();

  double logb(
    double _X,
  ) {
    return _logb(
      _X,
    );
  }

  late final _logbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('logb');
  late final _logb = _logbPtr.asFunction<double Function(double)>();

  int lrint(
    double _X,
  ) {
    return _lrint(
      _X,
    );
  }

  late final _lrintPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Double)>>('lrint');
  late final _lrint = _lrintPtr.asFunction<int Function(double)>();

  int lround(
    double _X,
  ) {
    return _lround(
      _X,
    );
  }

  late final _lroundPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Double)>>('lround');
  late final _lround = _lroundPtr.asFunction<int Function(double)>();

  int _matherr(
    ffi.Pointer<exception> _Except,
  ) {
    return __matherr(
      _Except,
    );
  }

  late final __matherrPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<exception>)>>(
          '_matherr');
  late final __matherr =
      __matherrPtr.asFunction<int Function(ffi.Pointer<exception>)>();

  double modf(
    double _X,
    ffi.Pointer<ffi.Double> _Y,
  ) {
    return _modf(
      _X,
      _Y,
    );
  }

  late final _modfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Double>)>>('modf');
  late final _modf =
      _modfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Double>)>();

  double nan(
    ffi.Pointer<ffi.Int8> _X,
  ) {
    return _nan(
      _X,
    );
  }

  late final _nanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Int8>)>>(
          'nan');
  late final _nan =
      _nanPtr.asFunction<double Function(ffi.Pointer<ffi.Int8>)>();

  double nearbyint(
    double _X,
  ) {
    return _nearbyint(
      _X,
    );
  }

  late final _nearbyintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('nearbyint');
  late final _nearbyint = _nearbyintPtr.asFunction<double Function(double)>();

  double nextafter(
    double _X,
    double _Y,
  ) {
    return _nextafter(
      _X,
      _Y,
    );
  }

  late final _nextafterPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'nextafter');
  late final _nextafter =
      _nextafterPtr.asFunction<double Function(double, double)>();

  double remainder(
    double _X,
    double _Y,
  ) {
    return _remainder(
      _X,
      _Y,
    );
  }

  late final _remainderPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'remainder');
  late final _remainder =
      _remainderPtr.asFunction<double Function(double, double)>();

  double remquo(
    double _X,
    double _Y,
    ffi.Pointer<ffi.Int32> _Z,
  ) {
    return _remquo(
      _X,
      _Y,
      _Z,
    );
  }

  late final _remquoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Double, ffi.Pointer<ffi.Int32>)>>('remquo');
  late final _remquo = _remquoPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int32>)>();

  double rint(
    double _X,
  ) {
    return _rint(
      _X,
    );
  }

  late final _rintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('rint');
  late final _rint = _rintPtr.asFunction<double Function(double)>();

  double round(
    double _X,
  ) {
    return _round(
      _X,
    );
  }

  late final _roundPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('round');
  late final _round = _roundPtr.asFunction<double Function(double)>();

  double scalbln(
    double _X,
    int _Y,
  ) {
    return _scalbln(
      _X,
      _Y,
    );
  }

  late final _scalblnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int64)>>(
          'scalbln');
  late final _scalbln = _scalblnPtr.asFunction<double Function(double, int)>();

  double scalbn(
    double _X,
    int _Y,
  ) {
    return _scalbn(
      _X,
      _Y,
    );
  }

  late final _scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int32)>>(
          'scalbn');
  late final _scalbn = _scalbnPtr.asFunction<double Function(double, int)>();

  double tgamma(
    double _X,
  ) {
    return _tgamma(
      _X,
    );
  }

  late final _tgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tgamma');
  late final _tgamma = _tgammaPtr.asFunction<double Function(double)>();

  double trunc(
    double _X,
  ) {
    return _trunc(
      _X,
    );
  }

  late final _truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('trunc');
  late final _trunc = _truncPtr.asFunction<double Function(double)>();

  double _j0(
    double _X,
  ) {
    return __j0(
      _X,
    );
  }

  late final __j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_j0');
  late final __j0 = __j0Ptr.asFunction<double Function(double)>();

  double _j1(
    double _X,
  ) {
    return __j1(
      _X,
    );
  }

  late final __j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_j1');
  late final __j1 = __j1Ptr.asFunction<double Function(double)>();

  double _jn(
    int _X,
    double _Y,
  ) {
    return __jn(
      _X,
      _Y,
    );
  }

  late final __jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int32, ffi.Double)>>(
          '_jn');
  late final __jn = __jnPtr.asFunction<double Function(int, double)>();

  double _y0(
    double _X,
  ) {
    return __y0(
      _X,
    );
  }

  late final __y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_y0');
  late final __y0 = __y0Ptr.asFunction<double Function(double)>();

  double _y1(
    double _X,
  ) {
    return __y1(
      _X,
    );
  }

  late final __y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('_y1');
  late final __y1 = __y1Ptr.asFunction<double Function(double)>();

  double _yn(
    int _X,
    double _Y,
  ) {
    return __yn(
      _X,
      _Y,
    );
  }

  late final __ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int32, ffi.Double)>>(
          '_yn');
  late final __yn = __ynPtr.asFunction<double Function(int, double)>();

  double acoshf(
    double _X,
  ) {
    return _acoshf(
      _X,
    );
  }

  late final _acoshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acoshf');
  late final _acoshf = _acoshfPtr.asFunction<double Function(double)>();

  double asinhf(
    double _X,
  ) {
    return _asinhf(
      _X,
    );
  }

  late final _asinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinhf');
  late final _asinhf = _asinhfPtr.asFunction<double Function(double)>();

  double atanhf(
    double _X,
  ) {
    return _atanhf(
      _X,
    );
  }

  late final _atanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanhf');
  late final _atanhf = _atanhfPtr.asFunction<double Function(double)>();

  double cbrtf(
    double _X,
  ) {
    return _cbrtf(
      _X,
    );
  }

  late final _cbrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cbrtf');
  late final _cbrtf = _cbrtfPtr.asFunction<double Function(double)>();

  double _chgsignf(
    double _X,
  ) {
    return __chgsignf(
      _X,
    );
  }

  late final __chgsignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('_chgsignf');
  late final __chgsignf = __chgsignfPtr.asFunction<double Function(double)>();

  double copysignf(
    double _Number,
    double _Sign,
  ) {
    return _copysignf1(
      _Number,
      _Sign,
    );
  }

  late final _copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'copysignf');
  late final _copysignf1 =
      _copysignfPtr.asFunction<double Function(double, double)>();

  double _copysignf(
    double _Number,
    double _Sign,
  ) {
    return __copysignf(
      _Number,
      _Sign,
    );
  }

  late final __copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          '_copysignf');
  late final __copysignf =
      __copysignfPtr.asFunction<double Function(double, double)>();

  double erff(
    double _X,
  ) {
    return _erff(
      _X,
    );
  }

  late final _erffPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erff');
  late final _erff = _erffPtr.asFunction<double Function(double)>();

  double erfcf(
    double _X,
  ) {
    return _erfcf(
      _X,
    );
  }

  late final _erfcfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erfcf');
  late final _erfcf = _erfcfPtr.asFunction<double Function(double)>();

  double expm1f(
    double _X,
  ) {
    return _expm1f(
      _X,
    );
  }

  late final _expm1fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expm1f');
  late final _expm1f = _expm1fPtr.asFunction<double Function(double)>();

  double exp2f(
    double _X,
  ) {
    return _exp2f(
      _X,
    );
  }

  late final _exp2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('exp2f');
  late final _exp2f = _exp2fPtr.asFunction<double Function(double)>();

  double fdimf(
    double _X,
    double _Y,
  ) {
    return _fdimf(
      _X,
      _Y,
    );
  }

  late final _fdimfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fdimf');
  late final _fdimf = _fdimfPtr.asFunction<double Function(double, double)>();

  double fmaf(
    double _X,
    double _Y,
    double _Z,
  ) {
    return _fmaf(
      _X,
      _Y,
      _Z,
    );
  }

  late final _fmafPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Float, ffi.Float)>>('fmaf');
  late final _fmaf =
      _fmafPtr.asFunction<double Function(double, double, double)>();

  double fmaxf(
    double _X,
    double _Y,
  ) {
    return _fmaxf(
      _X,
      _Y,
    );
  }

  late final _fmaxfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmaxf');
  late final _fmaxf = _fmaxfPtr.asFunction<double Function(double, double)>();

  double fminf(
    double _X,
    double _Y,
  ) {
    return _fminf(
      _X,
      _Y,
    );
  }

  late final _fminfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fminf');
  late final _fminf = _fminfPtr.asFunction<double Function(double, double)>();

  double _hypotf(
    double _X,
    double _Y,
  ) {
    return __hypotf(
      _X,
      _Y,
    );
  }

  late final __hypotfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          '_hypotf');
  late final __hypotf =
      __hypotfPtr.asFunction<double Function(double, double)>();

  int ilogbf(
    double _X,
  ) {
    return _ilogbf(
      _X,
    );
  }

  late final _ilogbfPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>('ilogbf');
  late final _ilogbf = _ilogbfPtr.asFunction<int Function(double)>();

  double lgammaf(
    double _X,
  ) {
    return _lgammaf(
      _X,
    );
  }

  late final _lgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('lgammaf');
  late final _lgammaf = _lgammafPtr.asFunction<double Function(double)>();

  int llrintf(
    double _X,
  ) {
    return _llrintf(
      _X,
    );
  }

  late final _llrintfPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Float)>>('llrintf');
  late final _llrintf = _llrintfPtr.asFunction<int Function(double)>();

  int llroundf(
    double _X,
  ) {
    return _llroundf(
      _X,
    );
  }

  late final _llroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Float)>>('llroundf');
  late final _llroundf = _llroundfPtr.asFunction<int Function(double)>();

  double log1pf(
    double _X,
  ) {
    return _log1pf(
      _X,
    );
  }

  late final _log1pfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log1pf');
  late final _log1pf = _log1pfPtr.asFunction<double Function(double)>();

  double log2f(
    double _X,
  ) {
    return _log2f(
      _X,
    );
  }

  late final _log2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log2f');
  late final _log2f = _log2fPtr.asFunction<double Function(double)>();

  double logbf(
    double _X,
  ) {
    return _logbf1(
      _X,
    );
  }

  late final _logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logbf');
  late final _logbf1 = _logbfPtr.asFunction<double Function(double)>();

  int lrintf(
    double _X,
  ) {
    return _lrintf(
      _X,
    );
  }

  late final _lrintfPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Float)>>('lrintf');
  late final _lrintf = _lrintfPtr.asFunction<int Function(double)>();

  int lroundf(
    double _X,
  ) {
    return _lroundf(
      _X,
    );
  }

  late final _lroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Float)>>('lroundf');
  late final _lroundf = _lroundfPtr.asFunction<int Function(double)>();

  double nanf(
    ffi.Pointer<ffi.Int8> _X,
  ) {
    return _nanf(
      _X,
    );
  }

  late final _nanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Int8>)>>(
          'nanf');
  late final _nanf =
      _nanfPtr.asFunction<double Function(ffi.Pointer<ffi.Int8>)>();

  double nearbyintf(
    double _X,
  ) {
    return _nearbyintf(
      _X,
    );
  }

  late final _nearbyintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('nearbyintf');
  late final _nearbyintf = _nearbyintfPtr.asFunction<double Function(double)>();

  double nextafterf(
    double _X,
    double _Y,
  ) {
    return _nextafterf1(
      _X,
      _Y,
    );
  }

  late final _nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'nextafterf');
  late final _nextafterf1 =
      _nextafterfPtr.asFunction<double Function(double, double)>();

  double remainderf(
    double _X,
    double _Y,
  ) {
    return _remainderf(
      _X,
      _Y,
    );
  }

  late final _remainderfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'remainderf');
  late final _remainderf =
      _remainderfPtr.asFunction<double Function(double, double)>();

  double remquof(
    double _X,
    double _Y,
    ffi.Pointer<ffi.Int32> _Z,
  ) {
    return _remquof(
      _X,
      _Y,
      _Z,
    );
  }

  late final _remquofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Int32>)>>('remquof');
  late final _remquof = _remquofPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int32>)>();

  double rintf(
    double _X,
  ) {
    return _rintf(
      _X,
    );
  }

  late final _rintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('rintf');
  late final _rintf = _rintfPtr.asFunction<double Function(double)>();

  double roundf(
    double _X,
  ) {
    return _roundf(
      _X,
    );
  }

  late final _roundfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('roundf');
  late final _roundf = _roundfPtr.asFunction<double Function(double)>();

  double scalblnf(
    double _X,
    int _Y,
  ) {
    return _scalblnf(
      _X,
      _Y,
    );
  }

  late final _scalblnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int64)>>(
          'scalblnf');
  late final _scalblnf =
      _scalblnfPtr.asFunction<double Function(double, int)>();

  double scalbnf(
    double _X,
    int _Y,
  ) {
    return _scalbnf(
      _X,
      _Y,
    );
  }

  late final _scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int32)>>(
          'scalbnf');
  late final _scalbnf = _scalbnfPtr.asFunction<double Function(double, int)>();

  double tgammaf(
    double _X,
  ) {
    return _tgammaf(
      _X,
    );
  }

  late final _tgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tgammaf');
  late final _tgammaf = _tgammafPtr.asFunction<double Function(double)>();

  double truncf(
    double _X,
  ) {
    return _truncf(
      _X,
    );
  }

  late final _truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('truncf');
  late final _truncf = _truncfPtr.asFunction<double Function(double)>();

  double _logbf(
    double _X,
  ) {
    return __logbf(
      _X,
    );
  }

  late final __logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('_logbf');
  late final __logbf = __logbfPtr.asFunction<double Function(double)>();

  double _nextafterf(
    double _X,
    double _Y,
  ) {
    return __nextafterf(
      _X,
      _Y,
    );
  }

  late final __nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          '_nextafterf');
  late final __nextafterf =
      __nextafterfPtr.asFunction<double Function(double, double)>();

  int _finitef(
    double _X,
  ) {
    return __finitef(
      _X,
    );
  }

  late final __finitefPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>('_finitef');
  late final __finitef = __finitefPtr.asFunction<int Function(double)>();

  int _isnanf(
    double _X,
  ) {
    return __isnanf(
      _X,
    );
  }

  late final __isnanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>('_isnanf');
  late final __isnanf = __isnanfPtr.asFunction<int Function(double)>();

  int _fpclassf(
    double _X,
  ) {
    return __fpclassf(
      _X,
    );
  }

  late final __fpclassfPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>('_fpclassf');
  late final __fpclassf = __fpclassfPtr.asFunction<int Function(double)>();

  int _set_FMA3_enable(
    int _Flag,
  ) {
    return __set_FMA3_enable(
      _Flag,
    );
  }

  late final __set_FMA3_enablePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          '_set_FMA3_enable');
  late final __set_FMA3_enable =
      __set_FMA3_enablePtr.asFunction<int Function(int)>();

  int _get_FMA3_enable() {
    return __get_FMA3_enable();
  }

  late final __get_FMA3_enablePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('_get_FMA3_enable');
  late final __get_FMA3_enable =
      __get_FMA3_enablePtr.asFunction<int Function()>();

  double acosf(
    double _X,
  ) {
    return _acosf(
      _X,
    );
  }

  late final _acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acosf');
  late final _acosf = _acosfPtr.asFunction<double Function(double)>();

  double asinf(
    double _X,
  ) {
    return _asinf(
      _X,
    );
  }

  late final _asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinf');
  late final _asinf = _asinfPtr.asFunction<double Function(double)>();

  double atan2f(
    double _Y,
    double _X,
  ) {
    return _atan2f(
      _Y,
      _X,
    );
  }

  late final _atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'atan2f');
  late final _atan2f = _atan2fPtr.asFunction<double Function(double, double)>();

  double atanf(
    double _X,
  ) {
    return _atanf(
      _X,
    );
  }

  late final _atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanf');
  late final _atanf = _atanfPtr.asFunction<double Function(double)>();

  double ceilf(
    double _X,
  ) {
    return _ceilf(
      _X,
    );
  }

  late final _ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('ceilf');
  late final _ceilf = _ceilfPtr.asFunction<double Function(double)>();

  double cosf(
    double _X,
  ) {
    return _cosf(
      _X,
    );
  }

  late final _cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cosf');
  late final _cosf = _cosfPtr.asFunction<double Function(double)>();

  double coshf(
    double _X,
  ) {
    return _coshf(
      _X,
    );
  }

  late final _coshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('coshf');
  late final _coshf = _coshfPtr.asFunction<double Function(double)>();

  double expf(
    double _X,
  ) {
    return _expf(
      _X,
    );
  }

  late final _expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expf');
  late final _expf = _expfPtr.asFunction<double Function(double)>();

  double floorf(
    double _X,
  ) {
    return _floorf(
      _X,
    );
  }

  late final _floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('floorf');
  late final _floorf = _floorfPtr.asFunction<double Function(double)>();

  double fmodf(
    double _X,
    double _Y,
  ) {
    return _fmodf(
      _X,
      _Y,
    );
  }

  late final _fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmodf');
  late final _fmodf = _fmodfPtr.asFunction<double Function(double, double)>();

  double log10f(
    double _X,
  ) {
    return _log10f(
      _X,
    );
  }

  late final _log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log10f');
  late final _log10f = _log10fPtr.asFunction<double Function(double)>();

  double logf(
    double _X,
  ) {
    return _logf(
      _X,
    );
  }

  late final _logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logf');
  late final _logf = _logfPtr.asFunction<double Function(double)>();

  double modff(
    double _X,
    ffi.Pointer<ffi.Float> _Y,
  ) {
    return _modff(
      _X,
      _Y,
    );
  }

  late final _modffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Float>)>>('modff');
  late final _modff =
      _modffPtr.asFunction<double Function(double, ffi.Pointer<ffi.Float>)>();

  double powf(
    double _X,
    double _Y,
  ) {
    return _powf(
      _X,
      _Y,
    );
  }

  late final _powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'powf');
  late final _powf = _powfPtr.asFunction<double Function(double, double)>();

  double sinf(
    double _X,
  ) {
    return _sinf(
      _X,
    );
  }

  late final _sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinf');
  late final _sinf = _sinfPtr.asFunction<double Function(double)>();

  double sinhf(
    double _X,
  ) {
    return _sinhf(
      _X,
    );
  }

  late final _sinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinhf');
  late final _sinhf = _sinhfPtr.asFunction<double Function(double)>();

  double sqrtf(
    double _X,
  ) {
    return _sqrtf(
      _X,
    );
  }

  late final _sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sqrtf');
  late final _sqrtf = _sqrtfPtr.asFunction<double Function(double)>();

  double tanf(
    double _X,
  ) {
    return _tanf(
      _X,
    );
  }

  late final _tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanf');
  late final _tanf = _tanfPtr.asFunction<double Function(double)>();

  double tanhf(
    double _X,
  ) {
    return _tanhf(
      _X,
    );
  }

  late final _tanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanhf');
  late final _tanhf = _tanhfPtr.asFunction<double Function(double)>();

  late final ffi.Pointer<ffi.Double> _HUGE1 = _lookup<ffi.Double>('HUGE');

  double get HUGE => _HUGE1.value;

  set HUGE(double value) => _HUGE1.value = value;

  double j0(
    double _X,
  ) {
    return _j01(
      _X,
    );
  }

  late final _j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j0');
  late final _j01 = _j0Ptr.asFunction<double Function(double)>();

  double j1(
    double _X,
  ) {
    return _j11(
      _X,
    );
  }

  late final _j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j1');
  late final _j11 = _j1Ptr.asFunction<double Function(double)>();

  double jn(
    int _X,
    double _Y,
  ) {
    return _jn1(
      _X,
      _Y,
    );
  }

  late final _jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int32, ffi.Double)>>(
          'jn');
  late final _jn1 = _jnPtr.asFunction<double Function(int, double)>();

  double y0(
    double _X,
  ) {
    return _y01(
      _X,
    );
  }

  late final _y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y0');
  late final _y01 = _y0Ptr.asFunction<double Function(double)>();

  double y1(
    double _X,
  ) {
    return _y11(
      _X,
    );
  }

  late final _y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y1');
  late final _y11 = _y1Ptr.asFunction<double Function(double)>();

  double yn(
    int _X,
    double _Y,
  ) {
    return _yn1(
      _X,
      _Y,
    );
  }

  late final _ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int32, ffi.Double)>>(
          'yn');
  late final _yn1 = _ynPtr.asFunction<double Function(int, double)>();

  late final ffi.Pointer<ffi.Int32> ___current_exit_return_mode =
      _lookup<ffi.Int32>('__current_exit_return_mode');

  int get __current_exit_return_mode => ___current_exit_return_mode.value;

  set __current_exit_return_mode(int value) =>
      ___current_exit_return_mode.value = value;

  bool __vcrt_initialize() {
    return ___vcrt_initialize() != 0;
  }

  late final ___vcrt_initializePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>('__vcrt_initialize');
  late final ___vcrt_initialize =
      ___vcrt_initializePtr.asFunction<int Function()>();

  bool __vcrt_uninitialize(
    bool _Terminating,
  ) {
    return ___vcrt_uninitialize(
          _Terminating ? 1 : 0,
        ) !=
        0;
  }

  late final ___vcrt_uninitializePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          '__vcrt_uninitialize');
  late final ___vcrt_uninitialize =
      ___vcrt_uninitializePtr.asFunction<int Function(int)>();

  bool __vcrt_uninitialize_critical() {
    return ___vcrt_uninitialize_critical() != 0;
  }

  late final ___vcrt_uninitialize_criticalPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
          '__vcrt_uninitialize_critical');
  late final ___vcrt_uninitialize_critical =
      ___vcrt_uninitialize_criticalPtr.asFunction<int Function()>();

  bool __vcrt_thread_attach() {
    return ___vcrt_thread_attach() != 0;
  }

  late final ___vcrt_thread_attachPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>('__vcrt_thread_attach');
  late final ___vcrt_thread_attach =
      ___vcrt_thread_attachPtr.asFunction<int Function()>();

  bool __vcrt_thread_detach() {
    return ___vcrt_thread_detach() != 0;
  }

  late final ___vcrt_thread_detachPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>('__vcrt_thread_detach');
  late final ___vcrt_thread_detach =
      ___vcrt_thread_detachPtr.asFunction<int Function()>();

  int __isa_available_init() {
    return ___isa_available_init();
  }

  late final ___isa_available_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('__isa_available_init');
  late final ___isa_available_init =
      ___isa_available_initPtr.asFunction<int Function()>();

  int _get_startup_argv_mode() {
    return __get_startup_argv_mode();
  }

  late final __get_startup_argv_modePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          '_get_startup_argv_mode');
  late final __get_startup_argv_mode =
      __get_startup_argv_modePtr.asFunction<int Function()>();

  int _seh_filter_dll(
    int _ExceptionNum,
    ffi.Pointer<EXCEPTION_POINTERS> _ExceptionPtr,
  ) {
    return __seh_filter_dll(
      _ExceptionNum,
      _ExceptionPtr,
    );
  }

  late final __seh_filter_dllPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint64, ffi.Pointer<EXCEPTION_POINTERS>)>>('_seh_filter_dll');
  late final __seh_filter_dll = __seh_filter_dllPtr
      .asFunction<int Function(int, ffi.Pointer<EXCEPTION_POINTERS>)>();

  int _seh_filter_exe(
    int _ExceptionNum,
    ffi.Pointer<EXCEPTION_POINTERS> _ExceptionPtr,
  ) {
    return __seh_filter_exe(
      _ExceptionNum,
      _ExceptionPtr,
    );
  }

  late final __seh_filter_exePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint64, ffi.Pointer<EXCEPTION_POINTERS>)>>('_seh_filter_exe');
  late final __seh_filter_exe = __seh_filter_exePtr
      .asFunction<int Function(int, ffi.Pointer<EXCEPTION_POINTERS>)>();

  int _query_app_type() {
    return __query_app_type();
  }

  late final __query_app_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('_query_app_type');
  late final __query_app_type =
      __query_app_typePtr.asFunction<int Function()>();

  void _set_app_type(
    int _Type,
  ) {
    return __set_app_type(
      _Type,
    );
  }

  late final __set_app_typePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          '_set_app_type');
  late final __set_app_type =
      __set_app_typePtr.asFunction<void Function(int)>();

  void __setusermatherr(
    _UserMathErrorFunctionPointer _UserMathErrorFunction,
  ) {
    return ___setusermatherr(
      _UserMathErrorFunction,
    );
  }

  late final ___setusermatherrPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(_UserMathErrorFunctionPointer)>>(
      '__setusermatherr');
  late final ___setusermatherr = ___setusermatherrPtr
      .asFunction<void Function(_UserMathErrorFunctionPointer)>();

  int _is_c_termination_complete() {
    return __is_c_termination_complete();
  }

  late final __is_c_termination_completePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          '_is_c_termination_complete');
  late final __is_c_termination_complete =
      __is_c_termination_completePtr.asFunction<int Function()>();

  int _configure_narrow_argv(
    int mode,
  ) {
    return __configure_narrow_argv(
      mode,
    );
  }

  late final __configure_narrow_argvPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Int32)>>(
          '_configure_narrow_argv');
  late final __configure_narrow_argv =
      __configure_narrow_argvPtr.asFunction<int Function(int)>();

  int _configure_wide_argv(
    int mode,
  ) {
    return __configure_wide_argv(
      mode,
    );
  }

  late final __configure_wide_argvPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Int32)>>(
          '_configure_wide_argv');
  late final __configure_wide_argv =
      __configure_wide_argvPtr.asFunction<int Function(int)>();

  int _initialize_narrow_environment() {
    return __initialize_narrow_environment();
  }

  late final __initialize_narrow_environmentPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          '_initialize_narrow_environment');
  late final __initialize_narrow_environment =
      __initialize_narrow_environmentPtr.asFunction<int Function()>();

  int _initialize_wide_environment() {
    return __initialize_wide_environment();
  }

  late final __initialize_wide_environmentPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          '_initialize_wide_environment');
  late final __initialize_wide_environment =
      __initialize_wide_environmentPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Pointer<ffi.Int8>> _get_initial_narrow_environment() {
    return __get_initial_narrow_environment();
  }

  late final __get_initial_narrow_environmentPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Pointer<ffi.Int8>> Function()>>(
      '_get_initial_narrow_environment');
  late final __get_initial_narrow_environment =
      __get_initial_narrow_environmentPtr
          .asFunction<ffi.Pointer<ffi.Pointer<ffi.Int8>> Function()>();

  ffi.Pointer<ffi.Pointer<wchar_t>> _get_initial_wide_environment() {
    return __get_initial_wide_environment();
  }

  late final __get_initial_wide_environmentPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Pointer<wchar_t>> Function()>>(
          '_get_initial_wide_environment');
  late final __get_initial_wide_environment = __get_initial_wide_environmentPtr
      .asFunction<ffi.Pointer<ffi.Pointer<wchar_t>> Function()>();

  ffi.Pointer<ffi.Int8> _get_narrow_winmain_command_line() {
    return __get_narrow_winmain_command_line();
  }

  late final __get_narrow_winmain_command_linePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          '_get_narrow_winmain_command_line');
  late final __get_narrow_winmain_command_line =
      __get_narrow_winmain_command_linePtr
          .asFunction<ffi.Pointer<ffi.Int8> Function()>();

  ffi.Pointer<wchar_t> _get_wide_winmain_command_line() {
    return __get_wide_winmain_command_line();
  }

  late final __get_wide_winmain_command_linePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<wchar_t> Function()>>(
          '_get_wide_winmain_command_line');
  late final __get_wide_winmain_command_line =
      __get_wide_winmain_command_linePtr
          .asFunction<ffi.Pointer<wchar_t> Function()>();

  ffi.Pointer<ffi.Pointer<ffi.Int8>> __p__acmdln() {
    return ___p__acmdln();
  }

  late final ___p__acmdlnPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Pointer<ffi.Int8>> Function()>>(
      '__p__acmdln');
  late final ___p__acmdln = ___p__acmdlnPtr
      .asFunction<ffi.Pointer<ffi.Pointer<ffi.Int8>> Function()>();

  ffi.Pointer<ffi.Pointer<wchar_t>> __p__wcmdln() {
    return ___p__wcmdln();
  }

  late final ___p__wcmdlnPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Pointer<wchar_t>> Function()>>(
          '__p__wcmdln');
  late final ___p__wcmdln = ___p__wcmdlnPtr
      .asFunction<ffi.Pointer<ffi.Pointer<wchar_t>> Function()>();

  void _initterm(
    ffi.Pointer<_PVFV> _First,
    ffi.Pointer<_PVFV> _Last,
  ) {
    return __initterm(
      _First,
      _Last,
    );
  }

  late final __inittermPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_PVFV>, ffi.Pointer<_PVFV>)>>('_initterm');
  late final __initterm = __inittermPtr
      .asFunction<void Function(ffi.Pointer<_PVFV>, ffi.Pointer<_PVFV>)>();

  int _initterm_e(
    ffi.Pointer<_PIFV> _First,
    ffi.Pointer<_PIFV> _Last,
  ) {
    return __initterm_e(
      _First,
      _Last,
    );
  }

  late final __initterm_ePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<_PIFV>, ffi.Pointer<_PIFV>)>>('_initterm_e');
  late final __initterm_e = __initterm_ePtr
      .asFunction<int Function(ffi.Pointer<_PIFV>, ffi.Pointer<_PIFV>)>();

  int _initialize_onexit_table(
    ffi.Pointer<onexit_table_t> _Table,
  ) {
    return __initialize_onexit_table(
      _Table,
    );
  }

  late final __initialize_onexit_tablePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<onexit_table_t>)>>(
      '_initialize_onexit_table');
  late final __initialize_onexit_table = __initialize_onexit_tablePtr
      .asFunction<int Function(ffi.Pointer<onexit_table_t>)>();

  int _register_onexit_function(
    ffi.Pointer<onexit_table_t> _Table,
    _onexit_t _Function,
  ) {
    return __register_onexit_function(
      _Table,
      _Function,
    );
  }

  late final __register_onexit_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<onexit_table_t>,
              _onexit_t)>>('_register_onexit_function');
  late final __register_onexit_function = __register_onexit_functionPtr
      .asFunction<int Function(ffi.Pointer<onexit_table_t>, _onexit_t)>();

  int _execute_onexit_table(
    ffi.Pointer<onexit_table_t> _Table,
  ) {
    return __execute_onexit_table(
      _Table,
    );
  }

  late final __execute_onexit_tablePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<onexit_table_t>)>>(
      '_execute_onexit_table');
  late final __execute_onexit_table = __execute_onexit_tablePtr
      .asFunction<int Function(ffi.Pointer<onexit_table_t>)>();

  int _crt_atexit(
    _PVFV _Function,
  ) {
    return __crt_atexit(
      _Function,
    );
  }

  late final __crt_atexitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(_PVFV)>>('_crt_atexit');
  late final __crt_atexit = __crt_atexitPtr.asFunction<int Function(_PVFV)>();

  int _crt_at_quick_exit(
    _PVFV _Function,
  ) {
    return __crt_at_quick_exit(
      _Function,
    );
  }

  late final __crt_at_quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(_PVFV)>>(
          '_crt_at_quick_exit');
  late final __crt_at_quick_exit =
      __crt_at_quick_exitPtr.asFunction<int Function(_PVFV)>();

  bool __acrt_initialize() {
    return ___acrt_initialize() != 0;
  }

  late final ___acrt_initializePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>('__acrt_initialize');
  late final ___acrt_initialize =
      ___acrt_initializePtr.asFunction<int Function()>();

  bool __acrt_uninitialize(
    bool _Terminating,
  ) {
    return ___acrt_uninitialize(
          _Terminating ? 1 : 0,
        ) !=
        0;
  }

  late final ___acrt_uninitializePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          '__acrt_uninitialize');
  late final ___acrt_uninitialize =
      ___acrt_uninitializePtr.asFunction<int Function(int)>();

  bool __acrt_uninitialize_critical(
    bool _Terminating,
  ) {
    return ___acrt_uninitialize_critical(
          _Terminating ? 1 : 0,
        ) !=
        0;
  }

  late final ___acrt_uninitialize_criticalPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          '__acrt_uninitialize_critical');
  late final ___acrt_uninitialize_critical =
      ___acrt_uninitialize_criticalPtr.asFunction<int Function(int)>();

  bool __acrt_thread_attach() {
    return ___acrt_thread_attach() != 0;
  }

  late final ___acrt_thread_attachPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>('__acrt_thread_attach');
  late final ___acrt_thread_attach =
      ___acrt_thread_attachPtr.asFunction<int Function()>();

  bool __acrt_thread_detach() {
    return ___acrt_thread_detach() != 0;
  }

  late final ___acrt_thread_detachPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function()>>('__acrt_thread_detach');
  late final ___acrt_thread_detach =
      ___acrt_thread_detachPtr.asFunction<int Function()>();

  int _wexecl(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wexecl(
      _FileName,
      _ArgList,
    );
  }

  late final __wexeclPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('_wexecl');
  late final __wexecl = __wexeclPtr
      .asFunction<int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wexecle(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wexecle(
      _FileName,
      _ArgList,
    );
  }

  late final __wexeclePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('_wexecle');
  late final __wexecle = __wexeclePtr
      .asFunction<int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wexeclp(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wexeclp(
      _FileName,
      _ArgList,
    );
  }

  late final __wexeclpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('_wexeclp');
  late final __wexeclp = __wexeclpPtr
      .asFunction<int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wexeclpe(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wexeclpe(
      _FileName,
      _ArgList,
    );
  }

  late final __wexeclpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>>('_wexeclpe');
  late final __wexeclpe = __wexeclpePtr
      .asFunction<int Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wexecv(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
  ) {
    return __wexecv(
      _FileName,
      _ArgList,
    );
  }

  late final __wexecvPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wexecv');
  late final __wexecv = __wexecvPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wexecve(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
    ffi.Pointer<ffi.Pointer<wchar_t>> _Env,
  ) {
    return __wexecve(
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wexecvePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wexecve');
  late final __wexecve = __wexecvePtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>,
          ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wexecvp(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
  ) {
    return __wexecvp(
      _FileName,
      _ArgList,
    );
  }

  late final __wexecvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wexecvp');
  late final __wexecvp = __wexecvpPtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wexecvpe(
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
    ffi.Pointer<ffi.Pointer<wchar_t>> _Env,
  ) {
    return __wexecvpe(
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wexecvpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wexecvpe');
  late final __wexecvpe = __wexecvpePtr.asFunction<
      int Function(ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>,
          ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wspawnl(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wspawnl(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnlPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<wchar_t>,
              ffi.Pointer<wchar_t>)>>('_wspawnl');
  late final __wspawnl = __wspawnlPtr.asFunction<
      int Function(int, ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wspawnle(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wspawnle(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnlePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<wchar_t>,
              ffi.Pointer<wchar_t>)>>('_wspawnle');
  late final __wspawnle = __wspawnlePtr.asFunction<
      int Function(int, ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wspawnlp(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wspawnlp(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<wchar_t>,
              ffi.Pointer<wchar_t>)>>('_wspawnlp');
  late final __wspawnlp = __wspawnlpPtr.asFunction<
      int Function(int, ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wspawnlpe(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<wchar_t> _ArgList,
  ) {
    return __wspawnlpe(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnlpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<wchar_t>,
              ffi.Pointer<wchar_t>)>>('_wspawnlpe');
  late final __wspawnlpe = __wspawnlpePtr.asFunction<
      int Function(int, ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>)>();

  int _wspawnv(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
  ) {
    return __wspawnv(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnvPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wspawnv');
  late final __wspawnv = __wspawnvPtr.asFunction<
      int Function(
          int, ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wspawnve(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
    ffi.Pointer<ffi.Pointer<wchar_t>> _Env,
  ) {
    return __wspawnve(
      _Mode,
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wspawnvePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Int32,
              ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wspawnve');
  late final __wspawnve = __wspawnvePtr.asFunction<
      int Function(int, ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>,
          ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wspawnvp(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
  ) {
    return __wspawnvp(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wspawnvp');
  late final __wspawnvp = __wspawnvpPtr.asFunction<
      int Function(
          int, ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wspawnvpe(
    int _Mode,
    ffi.Pointer<wchar_t> _FileName,
    ffi.Pointer<ffi.Pointer<wchar_t>> _ArgList,
    ffi.Pointer<ffi.Pointer<wchar_t>> _Env,
  ) {
    return __wspawnvpe(
      _Mode,
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wspawnvpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Int32,
              ffi.Pointer<wchar_t>,
              ffi.Pointer<ffi.Pointer<wchar_t>>,
              ffi.Pointer<ffi.Pointer<wchar_t>>)>>('_wspawnvpe');
  late final __wspawnvpe = __wspawnvpePtr.asFunction<
      int Function(int, ffi.Pointer<wchar_t>, ffi.Pointer<ffi.Pointer<wchar_t>>,
          ffi.Pointer<ffi.Pointer<wchar_t>>)>();

  int _wsystem(
    ffi.Pointer<wchar_t> _Command,
  ) {
    return __wsystem(
      _Command,
    );
  }

  late final __wsystemPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<wchar_t>)>>(
          '_wsystem');
  late final __wsystem =
      __wsystemPtr.asFunction<int Function(ffi.Pointer<wchar_t>)>();

  void exit(
    int _Code,
  ) {
    return _exit1(
      _Code,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>('exit');
  late final _exit1 = _exitPtr.asFunction<void Function(int)>();

  void _exit(
    int _Code,
  ) {
    return __exit(
      _Code,
    );
  }

  late final __exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>('_exit');
  late final __exit = __exitPtr.asFunction<void Function(int)>();

  void _Exit(
    int _Code,
  ) {
    return __Exit(
      _Code,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  void quick_exit(
    int _Code,
  ) {
    return _quick_exit(
      _Code,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int system(
    ffi.Pointer<ffi.Int8> _Command,
  ) {
    return _system(
      _Command,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  void _cexit() {
    return __cexit();
  }

  late final __cexitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('_cexit');
  late final __cexit = __cexitPtr.asFunction<void Function()>();

  void _c_exit() {
    return __c_exit();
  }

  late final __c_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('_c_exit');
  late final __c_exit = __c_exitPtr.asFunction<void Function()>();

  void _register_thread_local_exe_atexit_callback(
    _tls_callback_type _Callback,
  ) {
    return __register_thread_local_exe_atexit_callback(
      _Callback,
    );
  }

  late final __register_thread_local_exe_atexit_callbackPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(_tls_callback_type)>>(
          '_register_thread_local_exe_atexit_callback');
  late final __register_thread_local_exe_atexit_callback =
      __register_thread_local_exe_atexit_callbackPtr
          .asFunction<void Function(_tls_callback_type)>();

  int _beginthread(
    _beginthread_proc_type _StartAddress,
    int _StackSize,
    ffi.Pointer<ffi.Void> _ArgList,
  ) {
    return __beginthread(
      _StartAddress,
      _StackSize,
      _ArgList,
    );
  }

  late final __beginthreadPtr = _lookup<
      ffi.NativeFunction<
          uintptr_t Function(_beginthread_proc_type, ffi.Uint32,
              ffi.Pointer<ffi.Void>)>>('_beginthread');
  late final __beginthread = __beginthreadPtr.asFunction<
      int Function(_beginthread_proc_type, int, ffi.Pointer<ffi.Void>)>();

  void _endthread() {
    return __endthread();
  }

  late final __endthreadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('_endthread');
  late final __endthread = __endthreadPtr.asFunction<void Function()>();

  int _beginthreadex(
    ffi.Pointer<ffi.Void> _Security,
    int _StackSize,
    _beginthreadex_proc_type _StartAddress,
    ffi.Pointer<ffi.Void> _ArgList,
    int _InitFlag,
    ffi.Pointer<ffi.Uint32> _ThrdAddr,
  ) {
    return __beginthreadex(
      _Security,
      _StackSize,
      _StartAddress,
      _ArgList,
      _InitFlag,
      _ThrdAddr,
    );
  }

  late final __beginthreadexPtr = _lookup<
      ffi.NativeFunction<
          uintptr_t Function(
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              _beginthreadex_proc_type,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint32>)>>('_beginthreadex');
  late final __beginthreadex = __beginthreadexPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, _beginthreadex_proc_type,
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Uint32>)>();

  void _endthreadex(
    int _ReturnCode,
  ) {
    return __endthreadex(
      _ReturnCode,
    );
  }

  late final __endthreadexPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          '_endthreadex');
  late final __endthreadex = __endthreadexPtr.asFunction<void Function(int)>();

  int _getpid() {
    return __getpid();
  }

  late final __getpidPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('_getpid');
  late final __getpid = __getpidPtr.asFunction<int Function()>();

  int _cwait(
    ffi.Pointer<ffi.Int32> _TermStat,
    int _ProcHandle,
    int _Action,
  ) {
    return __cwait(
      _TermStat,
      _ProcHandle,
      _Action,
    );
  }

  late final __cwaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int32>, ffi.IntPtr, ffi.Int32)>>('_cwait');
  late final __cwait =
      __cwaitPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>, int, int)>();

  int _execl(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execl(
      _FileName,
      _Arguments,
    );
  }

  late final __execlPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('_execl');
  late final __execl = __execlPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _execle(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execle(
      _FileName,
      _Arguments,
    );
  }

  late final __execlePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('_execle');
  late final __execle = __execlePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _execlp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execlp(
      _FileName,
      _Arguments,
    );
  }

  late final __execlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('_execlp');
  late final __execlp = __execlpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _execlpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execlpe(
      _FileName,
      _Arguments,
    );
  }

  late final __execlpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('_execlpe');
  late final __execlpe = __execlpePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _execv(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __execv(
      _FileName,
      _Arguments,
    );
  }

  late final __execvPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_execv');
  late final __execv = __execvPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _execve(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __execve(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __execvePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_execve');
  late final __execve = __execvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _execvp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __execvp(
      _FileName,
      _Arguments,
    );
  }

  late final __execvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_execvp');
  late final __execvp = __execvpPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _execvpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __execvpe(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __execvpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_execvpe');
  late final __execvpe = __execvpePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _spawnl(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnl(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnlPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('_spawnl');
  late final __spawnl = __spawnlPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _spawnle(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnle(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnlePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('_spawnle');
  late final __spawnle = __spawnlePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _spawnlp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnlp(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('_spawnlp');
  late final __spawnlp = __spawnlpPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _spawnlpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnlpe(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnlpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('_spawnlpe');
  late final __spawnlpe = __spawnlpePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int _spawnv(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __spawnv(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnvPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_spawnv');
  late final __spawnv = __spawnvPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _spawnve(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __spawnve(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __spawnvePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_spawnve');
  late final __spawnve = __spawnvePtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _spawnvp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __spawnvp(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_spawnvp');
  late final __spawnvp = __spawnvpPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _spawnvpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __spawnvpe(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __spawnvpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('_spawnvpe');
  late final __spawnvpe = __spawnvpePtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int _loaddll(
    ffi.Pointer<ffi.Int8> _FileName,
  ) {
    return __loaddll(
      _FileName,
    );
  }

  late final __loaddllPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Int8>)>>(
          '_loaddll');
  late final __loaddll =
      __loaddllPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  int _unloaddll(
    int _Handle,
  ) {
    return __unloaddll(
      _Handle,
    );
  }

  late final __unloaddllPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.IntPtr)>>('_unloaddll');
  late final __unloaddll = __unloaddllPtr.asFunction<int Function(int)>();

  _GetDllProcAddrProcType _getdllprocaddr(
    int _Handle,
    ffi.Pointer<ffi.Int8> _ProcedureName,
    int _Ordinal,
  ) {
    return __getdllprocaddr(
      _Handle,
      _ProcedureName,
      _Ordinal,
    );
  }

  late final __getdllprocaddrPtr = _lookup<
      ffi.NativeFunction<
          _GetDllProcAddrProcType Function(ffi.IntPtr, ffi.Pointer<ffi.Int8>,
              ffi.IntPtr)>>('_getdllprocaddr');
  late final __getdllprocaddr = __getdllprocaddrPtr.asFunction<
      _GetDllProcAddrProcType Function(int, ffi.Pointer<ffi.Int8>, int)>();

  int cwait(
    ffi.Pointer<ffi.Int32> _TermStat,
    int _ProcHandle,
    int _Action,
  ) {
    return _cwait1(
      _TermStat,
      _ProcHandle,
      _Action,
    );
  }

  late final _cwaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int32>, ffi.IntPtr, ffi.Int32)>>('cwait');
  late final _cwait1 =
      _cwaitPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>, int, int)>();

  int execl(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execl1(
      _FileName,
      _Arguments,
    );
  }

  late final _execlPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('execl');
  late final _execl1 = _execlPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int execle(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execle1(
      _FileName,
      _Arguments,
    );
  }

  late final _execlePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('execle');
  late final _execle1 = _execlePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int execlp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execlp1(
      _FileName,
      _Arguments,
    );
  }

  late final _execlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('execlp');
  late final _execlp1 = _execlpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int execlpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execlpe1(
      _FileName,
      _Arguments,
    );
  }

  late final _execlpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('execlpe');
  late final _execlpe1 = _execlpePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int execv(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _execv1(
      _FileName,
      _Arguments,
    );
  }

  late final _execvPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('execv');
  late final _execv1 = _execvPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int execve(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _execve1(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _execvePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('execve');
  late final _execve1 = _execvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int execvp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _execvp1(
      _FileName,
      _Arguments,
    );
  }

  late final _execvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('execvp');
  late final _execvp1 = _execvpPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int execvpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _execvpe1(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _execvpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('execvpe');
  late final _execvpe1 = _execvpePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int spawnl(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnl1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnlPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('spawnl');
  late final _spawnl1 = _spawnlPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int spawnle(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnle1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnlePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('spawnle');
  late final _spawnle1 = _spawnlePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int spawnlp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnlp1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('spawnlp');
  late final _spawnlp1 = _spawnlpPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int spawnlpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnlpe1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnlpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('spawnlpe');
  late final _spawnlpe1 = _spawnlpePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int spawnv(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _spawnv1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnvPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('spawnv');
  late final _spawnv1 = _spawnvPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int spawnve(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _spawnve1(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _spawnvePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('spawnve');
  late final _spawnve1 = _spawnvePtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int spawnvp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _spawnvp1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(ffi.Int32, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('spawnvp');
  late final _spawnvp1 = _spawnvpPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int spawnvpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _spawnvpe1(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _spawnvpePtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('spawnvpe');
  late final _spawnvpe1 = _spawnvpePtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>,
          ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int getpid() {
    return _getpid1();
  }

  late final _getpidPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('getpid');
  late final _getpid1 = _getpidPtr.asFunction<int Function()>();

  /// Create a thread.
  ffi.Pointer<SDL_Thread> SDL_CreateThread(
    SDL_ThreadFunction fn,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThread(
      fn,
      name,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              SDL_ThreadFunction,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThread');
  late final _SDL_CreateThread = _SDL_CreateThreadPtr.asFunction<
      ffi.Pointer<SDL_Thread> Function(
          SDL_ThreadFunction,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Void>,
          pfnSDL_CurrentBeginThread,
          pfnSDL_CurrentEndThread)>();

  ffi.Pointer<SDL_Thread> SDL_CreateThreadWithStackSize(
    ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>
        fn,
    ffi.Pointer<ffi.Int8> name,
    int stacksize,
    ffi.Pointer<ffi.Void> data,
    pfnSDL_CurrentBeginThread pfnBeginThread,
    pfnSDL_CurrentEndThread pfnEndThread,
  ) {
    return _SDL_CreateThreadWithStackSize(
      fn,
      name,
      stacksize,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadWithStackSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Int8>,
              size_t,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>>('SDL_CreateThreadWithStackSize');
  late final _SDL_CreateThreadWithStackSize =
      _SDL_CreateThreadWithStackSizePtr.asFunction<
          ffi.Pointer<SDL_Thread> Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Int8>,
              int,
              ffi.Pointer<ffi.Void>,
              pfnSDL_CurrentBeginThread,
              pfnSDL_CurrentEndThread)>();

  /// Get the thread name, as it was specified in SDL_CreateThread().
  /// This function returns a pointer to a UTF-8 string that names the
  /// specified thread, or NULL if it doesn't have a name. This is internal
  /// memory, not to be free()'d by the caller, and remains valid until the
  /// specified thread is cleaned up by SDL_WaitThread().
  ffi.Pointer<ffi.Int8> SDL_GetThreadName(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadName(
      thread,
    );
  }

  late final _SDL_GetThreadNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_Thread>)>>('SDL_GetThreadName');
  late final _SDL_GetThreadName = _SDL_GetThreadNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_Thread>)>();

  /// Get the thread identifier for the current thread.
  int SDL_ThreadID() {
    return _SDL_ThreadID();
  }

  late final _SDL_ThreadIDPtr =
      _lookup<ffi.NativeFunction<SDL_threadID Function()>>('SDL_ThreadID');
  late final _SDL_ThreadID = _SDL_ThreadIDPtr.asFunction<int Function()>();

  /// Get the thread identifier for the specified thread.
  ///
  /// Equivalent to SDL_ThreadID() if the specified thread is NULL.
  int SDL_GetThreadID(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadID(
      thread,
    );
  }

  late final _SDL_GetThreadIDPtr = _lookup<
          ffi.NativeFunction<SDL_threadID Function(ffi.Pointer<SDL_Thread>)>>(
      'SDL_GetThreadID');
  late final _SDL_GetThreadID =
      _SDL_GetThreadIDPtr.asFunction<int Function(ffi.Pointer<SDL_Thread>)>();

  /// Set the priority for the current thread
  int SDL_SetThreadPriority(
    int priority,
  ) {
    return _SDL_SetThreadPriority(
      priority,
    );
  }

  late final _SDL_SetThreadPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_SetThreadPriority');
  late final _SDL_SetThreadPriority =
      _SDL_SetThreadPriorityPtr.asFunction<int Function(int)>();

  /// Wait for a thread to finish. Threads that haven't been detached will
  /// remain (as a "zombie") until this function cleans them up. Not doing so
  /// is a resource leak.
  ///
  /// Once a thread has been cleaned up through this function, the SDL_Thread
  /// that references it becomes invalid and should not be referenced again.
  /// As such, only one thread may call SDL_WaitThread() on another.
  ///
  /// The return code for the thread function is placed in the area
  /// pointed to by \c status, if \c status is not NULL.
  ///
  /// You may not wait on a thread that has been used in a call to
  /// SDL_DetachThread(). Use either that function or this one, but not
  /// both, or behavior is undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  void SDL_WaitThread(
    ffi.Pointer<SDL_Thread> thread,
    ffi.Pointer<ffi.Int32> status,
  ) {
    return _SDL_WaitThread(
      thread,
      status,
    );
  }

  late final _SDL_WaitThreadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Thread>,
              ffi.Pointer<ffi.Int32>)>>('SDL_WaitThread');
  late final _SDL_WaitThread = _SDL_WaitThreadPtr.asFunction<
      void Function(ffi.Pointer<SDL_Thread>, ffi.Pointer<ffi.Int32>)>();

  /// A thread may be "detached" to signify that it should not remain until
  /// another thread has called SDL_WaitThread() on it. Detaching a thread
  /// is useful for long-running threads that nothing needs to synchronize
  /// with or further manage. When a detached thread is done, it simply
  /// goes away.
  ///
  /// There is no way to recover the return code of a detached thread. If you
  /// need this, don't detach the thread and instead use SDL_WaitThread().
  ///
  /// Once a thread is detached, you should usually assume the SDL_Thread isn't
  /// safe to reference again, as it will become invalid immediately upon
  /// the detached thread's exit, instead of remaining until someone has called
  /// SDL_WaitThread() to finally clean it up. As such, don't detach the same
  /// thread more than once.
  ///
  /// If a thread has already exited when passed to SDL_DetachThread(), it will
  /// stop waiting for a call to SDL_WaitThread() and clean up immediately.
  /// It is not safe to detach a thread that might be used with SDL_WaitThread().
  ///
  /// You may not call SDL_WaitThread() on a thread that has been detached.
  /// Use either that function or this one, but not both, or behavior is
  /// undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  void SDL_DetachThread(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_DetachThread(
      thread,
    );
  }

  late final _SDL_DetachThreadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Thread>)>>(
          'SDL_DetachThread');
  late final _SDL_DetachThread =
      _SDL_DetachThreadPtr.asFunction<void Function(ffi.Pointer<SDL_Thread>)>();

  /// \brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific.
  ///
  /// \return The newly created thread local storage identifier, or 0 on error
  ///
  /// \code
  /// static SDL_SpinLock tls_lock;
  /// static SDL_TLSID thread_local_storage;
  ///
  /// void SetMyThreadData(void *value)
  /// {
  /// if (!thread_local_storage) {
  /// SDL_AtomicLock(&tls_lock);
  /// if (!thread_local_storage) {
  /// thread_local_storage = SDL_TLSCreate();
  /// }
  /// SDL_AtomicUnlock(&tls_lock);
  /// }
  /// SDL_TLSSet(thread_local_storage, value, 0);
  /// }
  ///
  /// void *GetMyThreadData(void)
  /// {
  /// return SDL_TLSGet(thread_local_storage);
  /// }
  /// \endcode
  ///
  /// \sa SDL_TLSGet()
  /// \sa SDL_TLSSet()
  int SDL_TLSCreate() {
    return _SDL_TLSCreate();
  }

  late final _SDL_TLSCreatePtr =
      _lookup<ffi.NativeFunction<SDL_TLSID Function()>>('SDL_TLSCreate');
  late final _SDL_TLSCreate = _SDL_TLSCreatePtr.asFunction<int Function()>();

  /// \brief Get the value associated with a thread local storage ID for the current thread.
  ///
  /// \param id The thread local storage ID
  ///
  /// \return The value associated with the ID for the current thread, or NULL if no value has been set.
  ///
  /// \sa SDL_TLSCreate()
  /// \sa SDL_TLSSet()
  ffi.Pointer<ffi.Void> SDL_TLSGet(
    int id,
  ) {
    return _SDL_TLSGet(
      id,
    );
  }

  late final _SDL_TLSGetPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(SDL_TLSID)>>(
          'SDL_TLSGet');
  late final _SDL_TLSGet =
      _SDL_TLSGetPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// \brief Set the value associated with a thread local storage ID for the current thread.
  ///
  /// \param id The thread local storage ID
  /// \param value The value to associate with the ID for the current thread
  /// \param destructor A function called when the thread exits, to free the value.
  ///
  /// \return 0 on success, -1 on error
  ///
  /// \sa SDL_TLSCreate()
  /// \sa SDL_TLSGet()
  int SDL_TLSSet(
    int id,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        destructor,
  ) {
    return _SDL_TLSSet(
      id,
      value,
      destructor,
    );
  }

  late final _SDL_TLSSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SDL_TLSID,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>)>>)>>('SDL_TLSSet');
  late final _SDL_TLSSet = _SDL_TLSSetPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  ffi.Pointer<SDL_RWops> SDL_RWFromFile(
    ffi.Pointer<ffi.Int8> file,
    ffi.Pointer<ffi.Int8> mode,
  ) {
    return _SDL_RWFromFile(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_RWFromFile');
  late final _SDL_RWFromFile = _SDL_RWFromFilePtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  ffi.Pointer<SDL_RWops> SDL_RWFromFP(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFPPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromFP');
  late final _SDL_RWFromFP = _SDL_RWFromFPPtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<SDL_RWops> SDL_RWFromMem(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromMem');
  late final _SDL_RWFromMem = _SDL_RWFromMemPtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_RWops> Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_RWFromConstMem');
  late final _SDL_RWFromConstMem = _SDL_RWFromConstMemPtr.asFunction<
      ffi.Pointer<SDL_RWops> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<SDL_RWops> SDL_AllocRW() {
    return _SDL_AllocRW();
  }

  late final _SDL_AllocRWPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_RWops> Function()>>(
          'SDL_AllocRW');
  late final _SDL_AllocRW =
      _SDL_AllocRWPtr.asFunction<ffi.Pointer<SDL_RWops> Function()>();

  void SDL_FreeRW(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW(
      area,
    );
  }

  late final _SDL_FreeRWPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_FreeRW');
  late final _SDL_FreeRW =
      _SDL_FreeRWPtr.asFunction<void Function(ffi.Pointer<SDL_RWops>)>();

  /// Return the size of the file in this rwops, or -1 if unknown
  int SDL_RWsize(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize(
      context,
    );
  }

  late final _SDL_RWsizePtr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWsize');
  late final _SDL_RWsize =
      _SDL_RWsizePtr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Seek to \c offset relative to \c whence, one of stdio's whence values:
  /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
  ///
  /// \return the final offset in the data stream, or -1 on error.
  int SDL_RWseek(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseekPtr = _lookup<
      ffi.NativeFunction<
          Sint64 Function(
              ffi.Pointer<SDL_RWops>, Sint64, ffi.Int32)>>('SDL_RWseek');
  late final _SDL_RWseek = _SDL_RWseekPtr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, int, int)>();

  /// Return the current offset in the data stream, or -1 on error.
  int SDL_RWtell(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell(
      context,
    );
  }

  late final _SDL_RWtellPtr =
      _lookup<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWtell');
  late final _SDL_RWtell =
      _SDL_RWtellPtr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Read up to \c maxnum objects each of size \c size from the data
  /// stream to the area pointed at by \c ptr.
  ///
  /// \return the number of objects read, or 0 at error or end of file.
  int SDL_RWread(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWreadPtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, size_t,
              size_t)>>('SDL_RWread');
  late final _SDL_RWread = _SDL_RWreadPtr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write exactly \c num objects each of size \c size from the area
  /// pointed at by \c ptr to data stream.
  ///
  /// \return the number of objects written, or 0 at error or end of file.
  int SDL_RWwrite(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwritePtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, size_t,
              size_t)>>('SDL_RWwrite');
  late final _SDL_RWwrite = _SDL_RWwritePtr.asFunction<
      int Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// \return 0 if successful or -1 on write error when flushing data.
  int SDL_RWclose(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose(
      context,
    );
  }

  late final _SDL_RWclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_RWclose');
  late final _SDL_RWclose =
      _SDL_RWclosePtr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated)
  ///
  /// If \c datasize is not NULL, it is filled with the size of the data read.
  ///
  /// If \c freesrc is non-zero, the stream will be closed after being read.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \return the data, or NULL if there was an error.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<size_t> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_RWops>,
              ffi.Pointer<size_t>, ffi.Int32)>>('SDL_LoadFile_RW');
  late final _SDL_LoadFile_RW = _SDL_LoadFile_RWPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_RWops>, ffi.Pointer<size_t>, int)>();

  /// Load an entire file.
  ///
  /// The data is allocated with a zero byte at the end (null terminated)
  ///
  /// If \c datasize is not NULL, it is filled with the size of the data read.
  ///
  /// If \c freesrc is non-zero, the stream will be closed after being read.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \return the data, or NULL if there was an error.
  ffi.Pointer<ffi.Void> SDL_LoadFile(
    ffi.Pointer<ffi.Int8> file,
    ffi.Pointer<size_t> datasize,
  ) {
    return _SDL_LoadFile(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<size_t>)>>('SDL_LoadFile');
  late final _SDL_LoadFile = _SDL_LoadFilePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<size_t>)>();

  int SDL_ReadU8(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU8(
      src,
    );
  }

  late final _SDL_ReadU8Ptr =
      _lookup<ffi.NativeFunction<Uint8 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadU8');
  late final _SDL_ReadU8 =
      _SDL_ReadU8Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_ReadLE16(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE16(
      src,
    );
  }

  late final _SDL_ReadLE16Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE16');
  late final _SDL_ReadLE16 =
      _SDL_ReadLE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_ReadBE16(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE16(
      src,
    );
  }

  late final _SDL_ReadBE16Ptr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE16');
  late final _SDL_ReadBE16 =
      _SDL_ReadBE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_ReadLE32(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE32(
      src,
    );
  }

  late final _SDL_ReadLE32Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE32');
  late final _SDL_ReadLE32 =
      _SDL_ReadLE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_ReadBE32(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE32(
      src,
    );
  }

  late final _SDL_ReadBE32Ptr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE32');
  late final _SDL_ReadBE32 =
      _SDL_ReadBE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_ReadLE64(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE64(
      src,
    );
  }

  late final _SDL_ReadLE64Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadLE64');
  late final _SDL_ReadLE64 =
      _SDL_ReadLE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_ReadBE64(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE64(
      src,
    );
  }

  late final _SDL_ReadBE64Ptr =
      _lookup<ffi.NativeFunction<Uint64 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_ReadBE64');
  late final _SDL_ReadBE64 =
      _SDL_ReadBE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  int SDL_WriteU8(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU8(
      dst,
      value,
    );
  }

  late final _SDL_WriteU8Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint8)>>(
      'SDL_WriteU8');
  late final _SDL_WriteU8 =
      _SDL_WriteU8Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_WriteLE16(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE16(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE16Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint16)>>(
      'SDL_WriteLE16');
  late final _SDL_WriteLE16 =
      _SDL_WriteLE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_WriteBE16(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE16(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE16Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint16)>>(
      'SDL_WriteBE16');
  late final _SDL_WriteBE16 =
      _SDL_WriteBE16Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_WriteLE32(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE32(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE32Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint32)>>(
      'SDL_WriteLE32');
  late final _SDL_WriteLE32 =
      _SDL_WriteLE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_WriteBE32(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE32(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE32Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint32)>>(
      'SDL_WriteBE32');
  late final _SDL_WriteBE32 =
      _SDL_WriteBE32Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_WriteLE64(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE64(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE64Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint64)>>(
      'SDL_WriteLE64');
  late final _SDL_WriteLE64 =
      _SDL_WriteLE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_WriteBE64(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE64(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE64Ptr = _lookup<
          ffi.NativeFunction<size_t Function(ffi.Pointer<SDL_RWops>, Uint64)>>(
      'SDL_WriteBE64');
  late final _SDL_WriteBE64 =
      _SDL_WriteBE64Ptr.asFunction<int Function(ffi.Pointer<SDL_RWops>, int)>();

  int SDL_GetNumAudioDrivers() {
    return _SDL_GetNumAudioDrivers();
  }

  late final _SDL_GetNumAudioDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetNumAudioDrivers');
  late final _SDL_GetNumAudioDrivers =
      _SDL_GetNumAudioDriversPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Int8> SDL_GetAudioDriver(
    int index,
  ) {
    return _SDL_GetAudioDriver(
      index,
    );
  }

  late final _SDL_GetAudioDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GetAudioDriver');
  late final _SDL_GetAudioDriver =
      _SDL_GetAudioDriverPtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  int SDL_AudioInit(
    ffi.Pointer<ffi.Int8> driver_name,
  ) {
    return _SDL_AudioInit(
      driver_name,
    );
  }

  late final _SDL_AudioInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_AudioInit');
  late final _SDL_AudioInit =
      _SDL_AudioInitPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  void SDL_AudioQuit() {
    return _SDL_AudioQuit();
  }

  late final _SDL_AudioQuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_AudioQuit');
  late final _SDL_AudioQuit = _SDL_AudioQuitPtr.asFunction<void Function()>();

  /// This function returns the name of the current audio driver, or NULL
  /// if no driver has been initialized.
  ffi.Pointer<ffi.Int8> SDL_GetCurrentAudioDriver() {
    return _SDL_GetCurrentAudioDriver();
  }

  late final _SDL_GetCurrentAudioDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetCurrentAudioDriver');
  late final _SDL_GetCurrentAudioDriver = _SDL_GetCurrentAudioDriverPtr
      .asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// This function opens the audio device with the desired parameters, and
  /// returns 0 if successful, placing the actual hardware parameters in the
  /// structure pointed to by \c obtained.  If \c obtained is NULL, the audio
  /// data passed to the callback function will be guaranteed to be in the
  /// requested format, and will be automatically converted to the hardware
  /// audio format if necessary.  This function returns -1 if it failed
  /// to open the audio device, or couldn't set up the audio thread.
  ///
  /// When filling in the desired audio spec structure,
  /// - \c desired->freq should be the desired audio frequency in samples-per-
  /// second.
  /// - \c desired->format should be the desired audio format.
  /// - \c desired->samples is the desired size of the audio buffer, in
  /// samples.  This number should be a power of two, and may be adjusted by
  /// the audio driver to a value more suitable for the hardware.  Good values
  /// seem to range between 512 and 8096 inclusive, depending on the
  /// application and CPU speed.  Smaller values yield faster response time,
  /// but can lead to underflow if the application is doing heavy processing
  /// and cannot fill the audio buffer in time.  A stereo sample consists of
  /// both right and left channels in LR ordering.
  /// Note that the number of samples is directly related to time by the
  /// following formula:  \code ms = (samples*1000)/freq \endcode
  /// - \c desired->size is the size in bytes of the audio buffer, and is
  /// calculated by SDL_OpenAudio().
  /// - \c desired->silence is the value used to set the buffer to silence,
  /// and is calculated by SDL_OpenAudio().
  /// - \c desired->callback should be set to a function that will be called
  /// when the audio device is ready for more data.  It is passed a pointer
  /// to the audio buffer, and the length in bytes of the audio buffer.
  /// This function usually runs in a separate thread, and so you should
  /// protect data structures that it accesses by calling SDL_LockAudio()
  /// and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL
  /// pointer here, and call SDL_QueueAudio() with some frequency, to queue
  /// more audio samples to be played (or for capture devices, call
  /// SDL_DequeueAudio() with some frequency, to obtain audio samples).
  /// - \c desired->userdata is passed as the first parameter to your callback
  /// function. If you passed a NULL callback, this value is ignored.
  ///
  /// The audio device starts out playing silence when it's opened, and should
  /// be enabled for playing by calling \c SDL_PauseAudio(0) when you are ready
  /// for your audio callback function to be called.  Since the audio driver
  /// may modify the requested size of the audio buffer, you should allocate
  /// any local mixing buffers after you open the audio device.
  int SDL_OpenAudio(
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
  ) {
    return _SDL_OpenAudio(
      desired,
      obtained,
    );
  }

  late final _SDL_OpenAudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<SDL_AudioSpec>)>>('SDL_OpenAudio');
  late final _SDL_OpenAudio = _SDL_OpenAudioPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioSpec>, ffi.Pointer<SDL_AudioSpec>)>();

  /// Get the number of available devices exposed by the current driver.
  /// Only valid after a successfully initializing the audio subsystem.
  /// Returns -1 if an explicit list of devices can't be determined; this is
  /// not an error. For example, if SDL is set up to talk to a remote audio
  /// server, it can't list every one available on the Internet, but it will
  /// still allow a specific host to be specified to SDL_OpenAudioDevice().
  ///
  /// In many common cases, when this function returns a value <= 0, it can still
  /// successfully open the default device (NULL for first argument of
  /// SDL_OpenAudioDevice()).
  int SDL_GetNumAudioDevices(
    int iscapture,
  ) {
    return _SDL_GetNumAudioDevices(
      iscapture,
    );
  }

  late final _SDL_GetNumAudioDevicesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_GetNumAudioDevices');
  late final _SDL_GetNumAudioDevices =
      _SDL_GetNumAudioDevicesPtr.asFunction<int Function(int)>();

  /// Get the human-readable name of a specific audio device.
  /// Must be a value between 0 and (number of audio devices-1).
  /// Only valid after a successfully initializing the audio subsystem.
  /// The values returned by this function reflect the latest call to
  /// SDL_GetNumAudioDevices(); recall that function to redetect available
  /// hardware.
  ///
  /// The string returned by this function is UTF-8 encoded, read-only, and
  /// managed internally. You are not to free it. If you need to keep the
  /// string for any length of time, you should make your own copy of it, as it
  /// will be invalid next time any of several other SDL functions is called.
  ffi.Pointer<ffi.Int8> SDL_GetAudioDeviceName(
    int index,
    int iscapture,
  ) {
    return _SDL_GetAudioDeviceName(
      index,
      iscapture,
    );
  }

  late final _SDL_GetAudioDeviceNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Int32, ffi.Int32)>>('SDL_GetAudioDeviceName');
  late final _SDL_GetAudioDeviceName = _SDL_GetAudioDeviceNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int, int)>();

  /// Open a specific audio device. Passing in a device name of NULL requests
  /// the most reasonable default (and is equivalent to calling SDL_OpenAudio()).
  ///
  /// The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
  /// some drivers allow arbitrary and driver-specific strings, such as a
  /// hostname/IP address for a remote audio server, or a filename in the
  /// diskaudio driver.
  ///
  /// \return 0 on error, a valid device ID that is >= 2 on success.
  ///
  /// SDL_OpenAudio(), unlike this function, always acts on device ID 1.
  int SDL_OpenAudioDevice(
    ffi.Pointer<ffi.Int8> device,
    int iscapture,
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
    int allowed_changes,
  ) {
    return _SDL_OpenAudioDevice(
      device,
      iscapture,
      desired,
      obtained,
      allowed_changes,
    );
  }

  late final _SDL_OpenAudioDevicePtr = _lookup<
      ffi.NativeFunction<
          SDL_AudioDeviceID Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Int32)>>('SDL_OpenAudioDevice');
  late final _SDL_OpenAudioDevice = _SDL_OpenAudioDevicePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, int, ffi.Pointer<SDL_AudioSpec>,
          ffi.Pointer<SDL_AudioSpec>, int)>();

  int SDL_GetAudioStatus() {
    return _SDL_GetAudioStatus();
  }

  late final _SDL_GetAudioStatusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetAudioStatus');
  late final _SDL_GetAudioStatus =
      _SDL_GetAudioStatusPtr.asFunction<int Function()>();

  int SDL_GetAudioDeviceStatus(
    int dev,
  ) {
    return _SDL_GetAudioDeviceStatus(
      dev,
    );
  }

  late final _SDL_GetAudioDeviceStatusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_AudioDeviceID)>>(
          'SDL_GetAudioDeviceStatus');
  late final _SDL_GetAudioDeviceStatus =
      _SDL_GetAudioDeviceStatusPtr.asFunction<int Function(int)>();

  void SDL_PauseAudio(
    int pause_on,
  ) {
    return _SDL_PauseAudio(
      pause_on,
    );
  }

  late final _SDL_PauseAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_PauseAudio');
  late final _SDL_PauseAudio =
      _SDL_PauseAudioPtr.asFunction<void Function(int)>();

  void SDL_PauseAudioDevice(
    int dev,
    int pause_on,
  ) {
    return _SDL_PauseAudioDevice(
      dev,
      pause_on,
    );
  }

  late final _SDL_PauseAudioDevicePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID, ffi.Int32)>>(
      'SDL_PauseAudioDevice');
  late final _SDL_PauseAudioDevice =
      _SDL_PauseAudioDevicePtr.asFunction<void Function(int, int)>();

  /// \brief Load the audio data of a WAVE file into memory
  ///
  /// Loading a WAVE file requires \c src, \c spec, \c audio_buf and \c audio_len
  /// to be valid pointers. The entire data portion of the file is then loaded
  /// into memory and decoded if necessary.
  ///
  /// If \c freesrc is non-zero, the data source gets automatically closed and
  /// freed before the function returns.
  ///
  /// Supported are RIFF WAVE files with the formats PCM (8, 16, 24, and 32 bits),
  /// IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and A-law and
  /// µ-law (8 bits). Other formats are currently unsupported and cause an error.
  ///
  /// If this function succeeds, the pointer returned by it is equal to \c spec
  /// and the pointer to the audio data allocated by the function is written to
  /// \c audio_buf and its length in bytes to \c audio_len. The \ref SDL_AudioSpec
  /// members \c freq, \c channels, and \c format are set to the values of the
  /// audio data in the buffer. The \c samples member is set to a sane default and
  /// all others are set to zero.
  ///
  /// It's necessary to use SDL_FreeWAV() to free the audio data returned in
  /// \c audio_buf when it is no longer used.
  ///
  /// Because of the underspecification of the Waveform format, there are many
  /// problematic files in the wild that cause issues with strict decoders. To
  /// provide compatibility with these files, this decoder is lenient in regards
  /// to the truncation of the file, the fact chunk, and the size of the RIFF
  /// chunk. The hints SDL_HINT_WAVE_RIFF_CHUNK_SIZE, SDL_HINT_WAVE_TRUNCATION,
  /// and SDL_HINT_WAVE_FACT_CHUNK can be used to tune the behavior of the
  /// loading process.
  ///
  /// Any file that is invalid (due to truncation, corruption, or wrong values in
  /// the headers), too big, or unsupported causes an error. Additionally, any
  /// critical I/O error from the data source will terminate the loading process
  /// with an error. The function returns NULL on error and in all cases (with the
  /// exception of \c src being NULL), an appropriate error message will be set.
  ///
  /// It is required that the data source supports seeking.
  ///
  /// Example:
  /// \code
  /// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
  /// \endcode
  ///
  /// \param src The data source with the WAVE data
  /// \param freesrc A integer value that makes the function close the data source if non-zero
  /// \param spec A pointer filled with the audio format of the audio data
  /// \param audio_buf A pointer filled with the audio data allocated by the function
  /// \param audio_len A pointer filled with the length of the audio data buffer in bytes
  /// \return NULL on error, or non-NULL on success.
  ffi.Pointer<SDL_AudioSpec> SDL_LoadWAV_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
    ffi.Pointer<SDL_AudioSpec> spec,
    ffi.Pointer<ffi.Pointer<Uint8>> audio_buf,
    ffi.Pointer<Uint32> audio_len,
  ) {
    return _SDL_LoadWAV_RW(
      src,
      freesrc,
      spec,
      audio_buf,
      audio_len,
    );
  }

  late final _SDL_LoadWAV_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_AudioSpec> Function(
              ffi.Pointer<SDL_RWops>,
              ffi.Int32,
              ffi.Pointer<SDL_AudioSpec>,
              ffi.Pointer<ffi.Pointer<Uint8>>,
              ffi.Pointer<Uint32>)>>('SDL_LoadWAV_RW');
  late final _SDL_LoadWAV_RW = _SDL_LoadWAV_RWPtr.asFunction<
      ffi.Pointer<SDL_AudioSpec> Function(
          ffi.Pointer<SDL_RWops>,
          int,
          ffi.Pointer<SDL_AudioSpec>,
          ffi.Pointer<ffi.Pointer<Uint8>>,
          ffi.Pointer<Uint32>)>();

  /// This function frees data previously allocated with SDL_LoadWAV_RW()
  void SDL_FreeWAV(
    ffi.Pointer<Uint8> audio_buf,
  ) {
    return _SDL_FreeWAV(
      audio_buf,
    );
  }

  late final _SDL_FreeWAVPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Uint8>)>>(
          'SDL_FreeWAV');
  late final _SDL_FreeWAV =
      _SDL_FreeWAVPtr.asFunction<void Function(ffi.Pointer<Uint8>)>();

  /// This function takes a source format and rate and a destination format
  /// and rate, and initializes the \c cvt structure with information needed
  /// by SDL_ConvertAudio() to convert a buffer of audio data from one format
  /// to the other. An unsupported format causes an error and -1 will be returned.
  ///
  /// \return 0 if no conversion is needed, 1 if the audio filter is set up,
  /// or -1 on error.
  int SDL_BuildAudioCVT(
    ffi.Pointer<SDL_AudioCVT> cvt,
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_BuildAudioCVT(
      cvt,
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_BuildAudioCVTPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_AudioCVT>,
              SDL_AudioFormat,
              Uint8,
              ffi.Int32,
              SDL_AudioFormat,
              Uint8,
              ffi.Int32)>>('SDL_BuildAudioCVT');
  late final _SDL_BuildAudioCVT = _SDL_BuildAudioCVTPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioCVT>, int, int, int, int, int, int)>();

  /// Once you have initialized the \c cvt structure using SDL_BuildAudioCVT(),
  /// created an audio buffer \c cvt->buf, and filled it with \c cvt->len bytes of
  /// audio data in the source format, this function will convert it in-place
  /// to the desired format.
  ///
  /// The data conversion may expand the size of the audio data, so the buffer
  /// \c cvt->buf should be allocated after the \c cvt structure is initialized by
  /// SDL_BuildAudioCVT(), and should be \c cvt->len*cvt->len_mult bytes long.
  ///
  /// \return 0 on success or -1 if \c cvt->buf is NULL.
  int SDL_ConvertAudio(
    ffi.Pointer<SDL_AudioCVT> cvt,
  ) {
    return _SDL_ConvertAudio(
      cvt,
    );
  }

  late final _SDL_ConvertAudioPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_AudioCVT>)>>(
      'SDL_ConvertAudio');
  late final _SDL_ConvertAudio = _SDL_ConvertAudioPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioCVT>)>();

  /// Create a new audio stream
  ///
  /// \param src_format The format of the source audio
  /// \param src_channels The number of channels of the source audio
  /// \param src_rate The sampling rate of the source audio
  /// \param dst_format The format of the desired audio output
  /// \param dst_channels The number of channels of the desired audio output
  /// \param dst_rate The sampling rate of the desired audio output
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  ffi.Pointer<SDL_AudioStream1> SDL_NewAudioStream(
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_NewAudioStream(
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_NewAudioStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_AudioStream1> Function(
              SDL_AudioFormat,
              Uint8,
              ffi.Int32,
              SDL_AudioFormat,
              Uint8,
              ffi.Int32)>>('SDL_NewAudioStream');
  late final _SDL_NewAudioStream = _SDL_NewAudioStreamPtr.asFunction<
      ffi.Pointer<SDL_AudioStream1> Function(int, int, int, int, int, int)>();

  /// Add data to be converted/resampled to the stream
  ///
  /// \param stream The stream the audio data is being added to
  /// \param buf A pointer to the audio data to add
  /// \param len The number of bytes to write to the stream
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamPut(
    ffi.Pointer<SDL_AudioStream1> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamPut(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamPutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_AudioStream1>,
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_AudioStreamPut');
  late final _SDL_AudioStreamPut = _SDL_AudioStreamPutPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_AudioStream1>, ffi.Pointer<ffi.Void>, int)>();

  /// Get converted/resampled data from the stream
  ///
  /// \param stream The stream the audio is being requested from
  /// \param buf A buffer to fill with audio data
  /// \param len The maximum number of bytes to fill
  /// \return The number of bytes read from the stream, or -1 on error
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamGet(
    ffi.Pointer<SDL_AudioStream1> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamGet(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_AudioStream1>,
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_AudioStreamGet');
  late final _SDL_AudioStreamGet = _SDL_AudioStreamGetPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_AudioStream1>, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of converted/resampled bytes available. The stream may be
  /// buffering data behind the scenes until it has enough to resample
  /// correctly, so this number might be lower than what you expect, or even
  /// be zero. Add more data or flush the stream if you need the data now.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamAvailable(
    ffi.Pointer<SDL_AudioStream1> stream,
  ) {
    return _SDL_AudioStreamAvailable(
      stream,
    );
  }

  late final _SDL_AudioStreamAvailablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_AudioStream1>)>>('SDL_AudioStreamAvailable');
  late final _SDL_AudioStreamAvailable = _SDL_AudioStreamAvailablePtr
      .asFunction<int Function(ffi.Pointer<SDL_AudioStream1>)>();

  /// Tell the stream that you're done sending data, and anything being buffered
  /// should be converted/resampled and made available immediately.
  ///
  /// It is legal to add more data to a stream after flushing, but there will
  /// be audio gaps in the output. Generally this is intended to signal the
  /// end of input, so the complete output becomes available.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamFlush(
    ffi.Pointer<SDL_AudioStream1> stream,
  ) {
    return _SDL_AudioStreamFlush(
      stream,
    );
  }

  late final _SDL_AudioStreamFlushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_AudioStream1>)>>('SDL_AudioStreamFlush');
  late final _SDL_AudioStreamFlush = _SDL_AudioStreamFlushPtr.asFunction<
      int Function(ffi.Pointer<SDL_AudioStream1>)>();

  /// Clear any pending data in the stream without converting it
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_FreeAudioStream
  void SDL_AudioStreamClear(
    ffi.Pointer<SDL_AudioStream1> stream,
  ) {
    return _SDL_AudioStreamClear(
      stream,
    );
  }

  late final _SDL_AudioStreamClearPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_AudioStream1>)>>(
      'SDL_AudioStreamClear');
  late final _SDL_AudioStreamClear = _SDL_AudioStreamClearPtr.asFunction<
      void Function(ffi.Pointer<SDL_AudioStream1>)>();

  /// Free an audio stream
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  void SDL_FreeAudioStream(
    ffi.Pointer<SDL_AudioStream1> stream,
  ) {
    return _SDL_FreeAudioStream(
      stream,
    );
  }

  late final _SDL_FreeAudioStreamPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_AudioStream1>)>>(
      'SDL_FreeAudioStream');
  late final _SDL_FreeAudioStream = _SDL_FreeAudioStreamPtr.asFunction<
      void Function(ffi.Pointer<SDL_AudioStream1>)>();

  /// This takes two audio buffers of the playing audio format and mixes
  /// them, performing addition, volume adjustment, and overflow clipping.
  /// The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME
  /// for full audio volume.  Note this does not change hardware volume.
  /// This is provided for convenience -- you can mix your own audio data.
  void SDL_MixAudio(
    ffi.Pointer<Uint8> dst,
    ffi.Pointer<Uint8> src,
    int len,
    int volume,
  ) {
    return _SDL_MixAudio(
      dst,
      src,
      len,
      volume,
    );
  }

  late final _SDL_MixAudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, Uint32,
              ffi.Int32)>>('SDL_MixAudio');
  late final _SDL_MixAudio = _SDL_MixAudioPtr.asFunction<
      void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int)>();

  /// This works like SDL_MixAudio(), but you specify the audio format instead of
  /// using the format of audio device 1. Thus it can be used when no audio
  /// device is open at all.
  void SDL_MixAudioFormat(
    ffi.Pointer<Uint8> dst,
    ffi.Pointer<Uint8> src,
    int format,
    int len,
    int volume,
  ) {
    return _SDL_MixAudioFormat(
      dst,
      src,
      format,
      len,
      volume,
    );
  }

  late final _SDL_MixAudioFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>,
              SDL_AudioFormat, Uint32, ffi.Int32)>>('SDL_MixAudioFormat');
  late final _SDL_MixAudioFormat = _SDL_MixAudioFormatPtr.asFunction<
      void Function(ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int)>();

  /// Queue more audio on non-callback devices.
  ///
  /// (If you are looking to retrieve queued audio from a non-callback capture
  /// device, you want SDL_DequeueAudio() instead. This will return -1 to
  /// signify an error if you use it with capture devices.)
  ///
  /// SDL offers two ways to feed audio to the device: you can either supply a
  /// callback that SDL triggers with some frequency to obtain more audio
  /// (pull method), or you can supply no callback, and then SDL will expect
  /// you to supply data at regular intervals (push method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Queued data will drain to the device as
  /// necessary without further intervention from you. If the device needs
  /// audio but there is not enough queued, it will play silence to make up
  /// the difference. This means you will have skips in your audio playback
  /// if you aren't routinely queueing sufficient data.
  ///
  /// This function copies the supplied data, so you are safe to free it when
  /// the function returns. This function is thread-safe, but queueing to the
  /// same device from two threads at once does not promise which buffer will
  /// be queued first.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; doing so returns an error. You have to use the audio callback
  /// or queue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before queueing; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev The device ID to which we will queue audio.
  /// \param data The data to queue to the device for later playback.
  /// \param len The number of bytes (not samples!) to which (data) points.
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_GetQueuedAudioSize
  /// \sa SDL_ClearQueuedAudio
  int SDL_QueueAudio(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_QueueAudio(
      dev,
      data,
      len,
    );
  }

  late final _SDL_QueueAudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SDL_AudioDeviceID, ffi.Pointer<ffi.Void>,
              Uint32)>>('SDL_QueueAudio');
  late final _SDL_QueueAudio = _SDL_QueueAudioPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Dequeue more audio on non-callback devices.
  ///
  /// (If you are looking to queue audio for output on a non-callback playback
  /// device, you want SDL_QueueAudio() instead. This will always return 0
  /// if you use it with playback devices.)
  ///
  /// SDL offers two ways to retrieve audio from a capture device: you can
  /// either supply a callback that SDL triggers with some frequency as the
  /// device records more audio data, (push method), or you can supply no
  /// callback, and then SDL will expect you to retrieve data at regular
  /// intervals (pull method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Data from the device will keep queuing as
  /// necessary without further intervention from you. This means you will
  /// eventually run out of memory if you aren't routinely dequeueing data.
  ///
  /// Capture devices will not queue data when paused; if you are expecting
  /// to not need captured audio for some length of time, use
  /// SDL_PauseAudioDevice() to stop the capture device from queueing more
  /// data. This can be useful during, say, level loading times. When
  /// unpaused, capture devices will start queueing data from that point,
  /// having flushed any capturable data available while paused.
  ///
  /// This function is thread-safe, but dequeueing from the same device from
  /// two threads at once does not promise which thread will dequeued data
  /// first.
  ///
  /// You may not dequeue audio from a device that is using an
  /// application-supplied callback; doing so returns an error. You have to use
  /// the audio callback, or dequeue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before queueing; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev The device ID from which we will dequeue audio.
  /// \param data A pointer into where audio data should be copied.
  /// \param len The number of bytes (not samples!) to which (data) points.
  /// \return number of bytes dequeued, which could be less than requested.
  ///
  /// \sa SDL_GetQueuedAudioSize
  /// \sa SDL_ClearQueuedAudio
  int SDL_DequeueAudio(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_DequeueAudio(
      dev,
      data,
      len,
    );
  }

  late final _SDL_DequeueAudioPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(SDL_AudioDeviceID, ffi.Pointer<ffi.Void>,
              Uint32)>>('SDL_DequeueAudio');
  late final _SDL_DequeueAudio = _SDL_DequeueAudioPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of bytes of still-queued audio.
  ///
  /// For playback device:
  ///
  /// This is the number of bytes that have been queued for playback with
  /// SDL_QueueAudio(), but have not yet been sent to the hardware. This
  /// number may shrink at any time, so this only informs of pending data.
  ///
  /// Once we've sent it to the hardware, this function can not decide the
  /// exact byte boundary of what has been played. It's possible that we just
  /// gave the hardware several kilobytes right before you called this
  /// function, but it hasn't played any of it yet, or maybe half of it, etc.
  ///
  /// For capture devices:
  ///
  /// This is the number of bytes that have been captured by the device and
  /// are waiting for you to dequeue. This number may grow at any time, so
  /// this only informs of the lower-bound of available data.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; calling this function on such a device always returns 0.
  /// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
  /// the audio callback, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before querying; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev The device ID of which we will query queued audio size.
  /// \return Number of bytes (not samples!) of queued audio.
  ///
  /// \sa SDL_QueueAudio
  /// \sa SDL_ClearQueuedAudio
  int SDL_GetQueuedAudioSize(
    int dev,
  ) {
    return _SDL_GetQueuedAudioSize(
      dev,
    );
  }

  late final _SDL_GetQueuedAudioSizePtr =
      _lookup<ffi.NativeFunction<Uint32 Function(SDL_AudioDeviceID)>>(
          'SDL_GetQueuedAudioSize');
  late final _SDL_GetQueuedAudioSize =
      _SDL_GetQueuedAudioSizePtr.asFunction<int Function(int)>();

  /// Drop any queued audio data. For playback devices, this is any queued data
  /// still waiting to be submitted to the hardware. For capture devices, this
  /// is any data that was queued by the device that hasn't yet been dequeued by
  /// the application.
  ///
  /// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
  /// playback devices, the hardware will start playing silence if more audio
  /// isn't queued. Unpaused capture devices will start filling the queue again
  /// as soon as they have more data available (which, depending on the state
  /// of the hardware and the thread, could be before this function call
  /// returns!).
  ///
  /// This will not prevent playback of queued audio that's already been sent
  /// to the hardware, as we can not undo that, so expect there to be some
  /// fraction of a second of audio that might still be heard. This can be
  /// useful if you want to, say, drop any pending music during a level change
  /// in your game.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; calling this function on such a device is always a no-op.
  /// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
  /// the audio callback, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before clearing the
  /// queue; SDL handles locking internally for this function.
  ///
  /// This function always succeeds and thus returns void.
  ///
  /// \param dev The device ID of which to clear the audio queue.
  ///
  /// \sa SDL_QueueAudio
  /// \sa SDL_GetQueuedAudioSize
  void SDL_ClearQueuedAudio(
    int dev,
  ) {
    return _SDL_ClearQueuedAudio(
      dev,
    );
  }

  late final _SDL_ClearQueuedAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_ClearQueuedAudio');
  late final _SDL_ClearQueuedAudio =
      _SDL_ClearQueuedAudioPtr.asFunction<void Function(int)>();

  void SDL_LockAudio() {
    return _SDL_LockAudio();
  }

  late final _SDL_LockAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockAudio');
  late final _SDL_LockAudio = _SDL_LockAudioPtr.asFunction<void Function()>();

  void SDL_LockAudioDevice(
    int dev,
  ) {
    return _SDL_LockAudioDevice(
      dev,
    );
  }

  late final _SDL_LockAudioDevicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_LockAudioDevice');
  late final _SDL_LockAudioDevice =
      _SDL_LockAudioDevicePtr.asFunction<void Function(int)>();

  void SDL_UnlockAudio() {
    return _SDL_UnlockAudio();
  }

  late final _SDL_UnlockAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockAudio');
  late final _SDL_UnlockAudio =
      _SDL_UnlockAudioPtr.asFunction<void Function()>();

  void SDL_UnlockAudioDevice(
    int dev,
  ) {
    return _SDL_UnlockAudioDevice(
      dev,
    );
  }

  late final _SDL_UnlockAudioDevicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_UnlockAudioDevice');
  late final _SDL_UnlockAudioDevice =
      _SDL_UnlockAudioDevicePtr.asFunction<void Function(int)>();

  /// This function shuts down audio processing and closes the audio device.
  void SDL_CloseAudio() {
    return _SDL_CloseAudio();
  }

  late final _SDL_CloseAudioPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_CloseAudio');
  late final _SDL_CloseAudio = _SDL_CloseAudioPtr.asFunction<void Function()>();

  void SDL_CloseAudioDevice(
    int dev,
  ) {
    return _SDL_CloseAudioDevice(
      dev,
    );
  }

  late final _SDL_CloseAudioDevicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_AudioDeviceID)>>(
          'SDL_CloseAudioDevice');
  late final _SDL_CloseAudioDevice =
      _SDL_CloseAudioDevicePtr.asFunction<void Function(int)>();

  /// \brief Put UTF-8 text into the clipboard
  ///
  /// \sa SDL_GetClipboardText()
  int SDL_SetClipboardText(
    ffi.Pointer<ffi.Int8> text,
  ) {
    return _SDL_SetClipboardText(
      text,
    );
  }

  late final _SDL_SetClipboardTextPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_SetClipboardText');
  late final _SDL_SetClipboardText = _SDL_SetClipboardTextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()
  ///
  /// \sa SDL_SetClipboardText()
  ffi.Pointer<ffi.Int8> SDL_GetClipboardText() {
    return _SDL_GetClipboardText();
  }

  late final _SDL_GetClipboardTextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetClipboardText');
  late final _SDL_GetClipboardText =
      _SDL_GetClipboardTextPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// \brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty
  ///
  /// \sa SDL_GetClipboardText()
  int SDL_HasClipboardText() {
    return _SDL_HasClipboardText();
  }

  late final _SDL_HasClipboardTextPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasClipboardText');
  late final _SDL_HasClipboardText =
      _SDL_HasClipboardTextPtr.asFunction<int Function()>();

  /// This function returns the number of CPU cores available.
  int SDL_GetCPUCount() {
    return _SDL_GetCPUCount();
  }

  late final _SDL_GetCPUCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetCPUCount');
  late final _SDL_GetCPUCount =
      _SDL_GetCPUCountPtr.asFunction<int Function()>();

  /// This function returns the L1 cache line size of the CPU
  ///
  /// This is useful for determining multi-threaded structure padding
  /// or SIMD prefetch sizes.
  int SDL_GetCPUCacheLineSize() {
    return _SDL_GetCPUCacheLineSize();
  }

  late final _SDL_GetCPUCacheLineSizePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetCPUCacheLineSize');
  late final _SDL_GetCPUCacheLineSize =
      _SDL_GetCPUCacheLineSizePtr.asFunction<int Function()>();

  /// This function returns true if the CPU has the RDTSC instruction.
  int SDL_HasRDTSC() {
    return _SDL_HasRDTSC();
  }

  late final _SDL_HasRDTSCPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasRDTSC');
  late final _SDL_HasRDTSC = _SDL_HasRDTSCPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has AltiVec features.
  int SDL_HasAltiVec() {
    return _SDL_HasAltiVec();
  }

  late final _SDL_HasAltiVecPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAltiVec');
  late final _SDL_HasAltiVec = _SDL_HasAltiVecPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has MMX features.
  int SDL_HasMMX() {
    return _SDL_HasMMX();
  }

  late final _SDL_HasMMXPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasMMX');
  late final _SDL_HasMMX = _SDL_HasMMXPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has 3DNow! features.
  int SDL_Has3DNow() {
    return _SDL_Has3DNow();
  }

  late final _SDL_Has3DNowPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_Has3DNow');
  late final _SDL_Has3DNow = _SDL_Has3DNowPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has SSE features.
  int SDL_HasSSE() {
    return _SDL_HasSSE();
  }

  late final _SDL_HasSSEPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE');
  late final _SDL_HasSSE = _SDL_HasSSEPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has SSE2 features.
  int SDL_HasSSE2() {
    return _SDL_HasSSE2();
  }

  late final _SDL_HasSSE2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE2');
  late final _SDL_HasSSE2 = _SDL_HasSSE2Ptr.asFunction<int Function()>();

  /// This function returns true if the CPU has SSE3 features.
  int SDL_HasSSE3() {
    return _SDL_HasSSE3();
  }

  late final _SDL_HasSSE3Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE3');
  late final _SDL_HasSSE3 = _SDL_HasSSE3Ptr.asFunction<int Function()>();

  /// This function returns true if the CPU has SSE4.1 features.
  int SDL_HasSSE41() {
    return _SDL_HasSSE41();
  }

  late final _SDL_HasSSE41Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE41');
  late final _SDL_HasSSE41 = _SDL_HasSSE41Ptr.asFunction<int Function()>();

  /// This function returns true if the CPU has SSE4.2 features.
  int SDL_HasSSE42() {
    return _SDL_HasSSE42();
  }

  late final _SDL_HasSSE42Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasSSE42');
  late final _SDL_HasSSE42 = _SDL_HasSSE42Ptr.asFunction<int Function()>();

  /// This function returns true if the CPU has AVX features.
  int SDL_HasAVX() {
    return _SDL_HasAVX();
  }

  late final _SDL_HasAVXPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX');
  late final _SDL_HasAVX = _SDL_HasAVXPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has AVX2 features.
  int SDL_HasAVX2() {
    return _SDL_HasAVX2();
  }

  late final _SDL_HasAVX2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX2');
  late final _SDL_HasAVX2 = _SDL_HasAVX2Ptr.asFunction<int Function()>();

  /// This function returns true if the CPU has AVX-512F (foundation) features.
  int SDL_HasAVX512F() {
    return _SDL_HasAVX512F();
  }

  late final _SDL_HasAVX512FPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasAVX512F');
  late final _SDL_HasAVX512F = _SDL_HasAVX512FPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has ARM SIMD (ARMv6) features.
  int SDL_HasARMSIMD() {
    return _SDL_HasARMSIMD();
  }

  late final _SDL_HasARMSIMDPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasARMSIMD');
  late final _SDL_HasARMSIMD = _SDL_HasARMSIMDPtr.asFunction<int Function()>();

  /// This function returns true if the CPU has NEON (ARM SIMD) features.
  int SDL_HasNEON() {
    return _SDL_HasNEON();
  }

  late final _SDL_HasNEONPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_HasNEON');
  late final _SDL_HasNEON = _SDL_HasNEONPtr.asFunction<int Function()>();

  /// This function returns the amount of RAM configured in the system, in MB.
  int SDL_GetSystemRAM() {
    return _SDL_GetSystemRAM();
  }

  late final _SDL_GetSystemRAMPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetSystemRAM');
  late final _SDL_GetSystemRAM =
      _SDL_GetSystemRAMPtr.asFunction<int Function()>();

  /// \brief Report the alignment this system needs for SIMD allocations.
  ///
  /// This will return the minimum number of bytes to which a pointer must be
  /// aligned to be compatible with SIMD instructions on the current machine.
  /// For example, if the machine supports SSE only, it will return 16, but if
  /// it supports AVX-512F, it'll return 64 (etc). This only reports values for
  /// instruction sets SDL knows about, so if your SDL build doesn't have
  /// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
  /// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
  /// Plan accordingly.
  int SDL_SIMDGetAlignment() {
    return _SDL_SIMDGetAlignment();
  }

  late final _SDL_SIMDGetAlignmentPtr =
      _lookup<ffi.NativeFunction<size_t Function()>>('SDL_SIMDGetAlignment');
  late final _SDL_SIMDGetAlignment =
      _SDL_SIMDGetAlignmentPtr.asFunction<int Function()>();

  /// \brief Allocate memory in a SIMD-friendly way.
  ///
  /// This will allocate a block of memory that is suitable for use with SIMD
  /// instructions. Specifically, it will be properly aligned and padded for
  /// the system's supported vector instructions.
  ///
  /// The memory returned will be padded such that it is safe to read or write
  /// an incomplete vector at the end of the memory block. This can be useful
  /// so you don't have to drop back to a scalar fallback at the end of your
  /// SIMD processing loop to deal with the final elements without overflowing
  /// the allocated buffer.
  ///
  /// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free()
  /// or delete[], etc.
  ///
  /// Note that SDL will only deal with SIMD instruction sets it is aware of;
  /// for example, SDL 2.0.8 knows that SSE wants 16-byte vectors
  /// (SDL_HasSSE()), and AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't
  /// know that AVX-512 wants 64. To be clear: if you can't decide to use an
  /// instruction set with an SDL_Has*() function, don't use that instruction
  /// set with memory allocated through here.
  ///
  /// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't
  /// out of memory.
  ///
  /// \param len The length, in bytes, of the block to allocated. The actual
  /// allocated block might be larger due to padding, etc.
  /// \return Pointer to newly-allocated block, NULL if out of memory.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDRealloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDAlloc(
    int len,
  ) {
    return _SDL_SIMDAlloc(
      len,
    );
  }

  late final _SDL_SIMDAllocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(size_t)>>(
          'SDL_SIMDAlloc');
  late final _SDL_SIMDAlloc =
      _SDL_SIMDAllocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// \brief Reallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
  /// SDL_malloc, memalign, new[], etc.
  ///
  /// \param mem The pointer obtained from SDL_SIMDAlloc. This function also
  /// accepts NULL, at which point this function is the same as
  /// calling SDL_realloc with a NULL pointer.
  /// \param len The length, in bytes, of the block to allocated. The actual
  /// allocated block might be larger due to padding, etc. Passing 0
  /// will return a non-NULL pointer, assuming the system isn't out of
  /// memory.
  /// \return Pointer to newly-reallocated block, NULL if out of memory.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDRealloc(
    ffi.Pointer<ffi.Void> mem,
    int len,
  ) {
    return _SDL_SIMDRealloc(
      mem,
      len,
    );
  }

  late final _SDL_SIMDReallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, size_t)>>('SDL_SIMDRealloc');
  late final _SDL_SIMDRealloc = _SDL_SIMDReallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// \brief Deallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
  /// SDL_malloc, memalign, new[], etc.
  ///
  /// However, SDL_SIMDFree(NULL) is a legal no-op.
  ///
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDRealloc
  void SDL_SIMDFree(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _SDL_SIMDFree(
      ptr,
    );
  }

  late final _SDL_SIMDFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_SIMDFree');
  late final _SDL_SIMDFree =
      _SDL_SIMDFreePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// \brief Get the human readable name of a pixel format
  ffi.Pointer<ffi.Int8> SDL_GetPixelFormatName(
    int format,
  ) {
    return _SDL_GetPixelFormatName(
      format,
    );
  }

  late final _SDL_GetPixelFormatNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(Uint32)>>(
          'SDL_GetPixelFormatName');
  late final _SDL_GetPixelFormatName = _SDL_GetPixelFormatNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Convert one of the enumerated pixel formats to a bpp and RGBA masks.
  ///
  /// \return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.
  ///
  /// \sa SDL_MasksToPixelFormatEnum()
  int SDL_PixelFormatEnumToMasks(
    int format,
    ffi.Pointer<ffi.Int32> bpp,
    ffi.Pointer<Uint32> Rmask,
    ffi.Pointer<Uint32> Gmask,
    ffi.Pointer<Uint32> Bmask,
    ffi.Pointer<Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>)>>('SDL_PixelFormatEnumToMasks');
  late final _SDL_PixelFormatEnumToMasks =
      _SDL_PixelFormatEnumToMasksPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int32>, ffi.Pointer<Uint32>,
              ffi.Pointer<Uint32>, ffi.Pointer<Uint32>, ffi.Pointer<Uint32>)>();

  /// \brief Convert a bpp and RGBA masks to an enumerated pixel format.
  ///
  /// \return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion
  /// wasn't possible.
  ///
  /// \sa SDL_PixelFormatEnumToMasks()
  int SDL_MasksToPixelFormatEnum(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnumPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Int32, Uint32, Uint32, Uint32,
              Uint32)>>('SDL_MasksToPixelFormatEnum');
  late final _SDL_MasksToPixelFormatEnum = _SDL_MasksToPixelFormatEnumPtr
      .asFunction<int Function(int, int, int, int, int)>();

  /// \brief Create an SDL_PixelFormat structure from a pixel format enum.
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat(
    int pixel_format,
  ) {
    return _SDL_AllocFormat(
      pixel_format,
    );
  }

  late final _SDL_AllocFormatPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_PixelFormat> Function(Uint32)>>(
      'SDL_AllocFormat');
  late final _SDL_AllocFormat = _SDL_AllocFormatPtr.asFunction<
      ffi.Pointer<SDL_PixelFormat> Function(int)>();

  /// \brief Free an SDL_PixelFormat structure.
  void SDL_FreeFormat(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat(
      format,
    );
  }

  late final _SDL_FreeFormatPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_PixelFormat>)>>(
      'SDL_FreeFormat');
  late final _SDL_FreeFormat = _SDL_FreeFormatPtr.asFunction<
      void Function(ffi.Pointer<SDL_PixelFormat>)>();

  /// \brief Create a palette structure with the specified number of color
  /// entries.
  ///
  /// \return A new palette, or NULL if there wasn't enough memory.
  ///
  /// \note The palette entries are initialized to white.
  ///
  /// \sa SDL_FreePalette()
  ffi.Pointer<SDL_Palette> SDL_AllocPalette(
    int ncolors,
  ) {
    return _SDL_AllocPalette(
      ncolors,
    );
  }

  late final _SDL_AllocPalettePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Palette> Function(ffi.Int32)>>(
          'SDL_AllocPalette');
  late final _SDL_AllocPalette =
      _SDL_AllocPalettePtr.asFunction<ffi.Pointer<SDL_Palette> Function(int)>();

  /// \brief Set the palette for a pixel format structure.
  int SDL_SetPixelFormatPalette(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalettePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetPixelFormatPalette');
  late final _SDL_SetPixelFormatPalette =
      _SDL_SetPixelFormatPalettePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<SDL_Palette>)>();

  /// \brief Set a range of colors in a palette.
  ///
  /// \param palette    The palette to modify.
  /// \param colors     An array of colors to copy into the palette.
  /// \param firstcolor The index of the first palette entry to modify.
  /// \param ncolors    The number of entries to modify.
  ///
  /// \return 0 on success, or -1 if not all of the colors could be set.
  int SDL_SetPaletteColors(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>,
              ffi.Int32, ffi.Int32)>>('SDL_SetPaletteColors');
  late final _SDL_SetPaletteColors = _SDL_SetPaletteColorsPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Palette>, ffi.Pointer<SDL_Color>, int, int)>();

  /// \brief Free a palette created with SDL_AllocPalette().
  ///
  /// \sa SDL_AllocPalette()
  void SDL_FreePalette(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette(
      palette,
    );
  }

  late final _SDL_FreePalettePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Palette>)>>(
          'SDL_FreePalette');
  late final _SDL_FreePalette =
      _SDL_FreePalettePtr.asFunction<void Function(ffi.Pointer<SDL_Palette>)>();

  /// \brief Maps an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// \sa SDL_MapRGBA
  int SDL_MapRGB(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGBPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8,
              Uint8)>>('SDL_MapRGB');
  late final _SDL_MapRGB = _SDL_MapRGBPtr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int)>();

  /// \brief Maps an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// \sa SDL_MapRGB
  int SDL_MapRGBA(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBAPtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<SDL_PixelFormat>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_MapRGBA');
  late final _SDL_MapRGBA = _SDL_MapRGBAPtr.asFunction<
      int Function(ffi.Pointer<SDL_PixelFormat>, int, int, int, int)>();

  /// \brief Get the RGB components from a pixel of the specified format.
  ///
  /// \sa SDL_GetRGBA
  void SDL_GetRGB(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetRGB(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGB');
  late final _SDL_GetRGB = _SDL_GetRGBPtr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// \brief Get the RGBA components from a pixel of the specified format.
  ///
  /// \sa SDL_GetRGB
  void SDL_GetRGBA(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRGBA(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Uint32,
              ffi.Pointer<SDL_PixelFormat>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRGBA');
  late final _SDL_GetRGBA = _SDL_GetRGBAPtr.asFunction<
      void Function(int, ffi.Pointer<SDL_PixelFormat>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// \brief Calculate a 256 entry gamma ramp for a gamma value.
  void SDL_CalculateGammaRamp(
    double gamma,
    ffi.Pointer<Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Float, ffi.Pointer<Uint16>)>>('SDL_CalculateGammaRamp');
  late final _SDL_CalculateGammaRamp = _SDL_CalculateGammaRampPtr.asFunction<
      void Function(double, ffi.Pointer<Uint16>)>();

  /// \brief Determine whether two rectangles intersect.
  ///
  /// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  int SDL_HasIntersection(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection(
      A,
      B,
    );
  }

  late final _SDL_HasIntersectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_HasIntersection');
  late final _SDL_HasIntersection = _SDL_HasIntersectionPtr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Calculate the intersection of two rectangles.
  ///
  /// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  int SDL_IntersectRect(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_IntersectRect');
  late final _SDL_IntersectRect = _SDL_IntersectRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// \brief Calculate the union of two rectangles.
  void SDL_UnionRect(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UnionRect');
  late final _SDL_UnionRect = _SDL_UnionRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// \brief Calculate a minimal rectangle enclosing a set of points
  ///
  /// \return SDL_TRUE if any points were within the clipping rect
  int SDL_EnclosePoints(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Point>,
              ffi.Int32,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_EnclosePoints');
  late final _SDL_EnclosePoints = _SDL_EnclosePointsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Point>, int, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>)>();

  /// \brief Calculate the intersection of a rectangle and line segment.
  ///
  /// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  int SDL_IntersectRectAndLine(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int32> X1,
    ffi.Pointer<ffi.Int32> Y1,
    ffi.Pointer<ffi.Int32> X2,
    ffi.Pointer<ffi.Int32> Y2,
  ) {
    return _SDL_IntersectRectAndLine(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_IntersectRectAndLine');
  late final _SDL_IntersectRectAndLine =
      _SDL_IntersectRectAndLinePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Create a custom blend mode, which may or may not be supported by a given renderer
  ///
  /// \param srcColorFactor source color factor
  /// \param dstColorFactor destination color factor
  /// \param colorOperation color operation
  /// \param srcAlphaFactor source alpha factor
  /// \param dstAlphaFactor destination alpha factor
  /// \param alphaOperation alpha operation
  ///
  /// The result of the blend mode operation will be:
  /// dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor
  /// and
  /// dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor
  int SDL_ComposeCustomBlendMode(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_ComposeCustomBlendMode');
  late final _SDL_ComposeCustomBlendMode = _SDL_ComposeCustomBlendModePtr
      .asFunction<int Function(int, int, int, int, int, int)>();

  /// Allocate and free an RGB surface.
  ///
  /// If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If the depth is greater than 8 bits, the pixel format is set using the
  /// flags '[RGB]mask'.
  ///
  /// If the function runs out of memory, it will return NULL.
  ///
  /// \param flags The \c flags are obsolete and should be set to 0.
  /// \param width The width in pixels of the surface to create.
  /// \param height The height in pixels of the surface to create.
  /// \param depth The depth in bits of the surface to create.
  /// \param Rmask The red mask of the surface to create.
  /// \param Gmask The green mask of the surface to create.
  /// \param Bmask The blue mask of the surface to create.
  /// \param Amask The alpha mask of the surface to create.
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              Uint32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurface');
  late final _SDL_CreateRGBSurface = _SDL_CreateRGBSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          int, int, int, int, int, int, int, int)>();

  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(Uint32, ffi.Int32, ffi.Int32,
              ffi.Int32, Uint32)>>('SDL_CreateRGBSurfaceWithFormat');
  late final _SDL_CreateRGBSurfaceWithFormat =
      _SDL_CreateRGBSurfaceWithFormatPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(int, int, int, int, int)>();

  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              Uint32,
              Uint32,
              Uint32,
              Uint32)>>('SDL_CreateRGBSurfaceFrom');
  late final _SDL_CreateRGBSurfaceFrom =
      _SDL_CreateRGBSurfaceFromPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              Uint32)>>('SDL_CreateRGBSurfaceWithFormatFrom');
  late final _SDL_CreateRGBSurfaceWithFormatFrom =
      _SDL_CreateRGBSurfaceWithFormatFromPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  void SDL_FreeSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface(
      surface,
    );
  }

  late final _SDL_FreeSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_FreeSurface');
  late final _SDL_FreeSurface =
      _SDL_FreeSurfacePtr.asFunction<void Function(ffi.Pointer<SDL_Surface>)>();

  /// \brief Set the palette used by a surface.
  ///
  /// \return 0, or -1 if the surface format doesn't use a palette.
  ///
  /// \note A single palette can be shared with many surfaces.
  int SDL_SetSurfacePalette(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalettePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Palette>)>>('SDL_SetSurfacePalette');
  late final _SDL_SetSurfacePalette = _SDL_SetSurfacePalettePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Palette>)>();

  /// \brief Sets up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write
  /// to and read from \c surface->pixels, using the pixel format stored in
  /// \c surface->format.  Once you are done accessing the surface, you should
  /// use SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates
  /// to 0, then you can read and write to the surface at any time, and the
  /// pixel format of the surface will not change.
  ///
  /// No operating system or library calls should be made between lock/unlock
  /// pairs, as critical system locks may be held during this time.
  ///
  /// SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.
  ///
  /// \sa SDL_UnlockSurface()
  int SDL_LockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface(
      surface,
    );
  }

  late final _SDL_LockSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_LockSurface');
  late final _SDL_LockSurface =
      _SDL_LockSurfacePtr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// \sa SDL_LockSurface()
  void SDL_UnlockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface(
      surface,
    );
  }

  late final _SDL_UnlockSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_UnlockSurface');
  late final _SDL_UnlockSurface = _SDL_UnlockSurfacePtr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>)>();

  /// Load a surface from a seekable SDL data stream (memory or file).
  ///
  /// If \c freesrc is non-zero, the stream will be closed after being read.
  ///
  /// The new surface should be freed with SDL_FreeSurface().
  ///
  /// \return the new surface, or NULL if there was an error.
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_RWops>, ffi.Int32)>>('SDL_LoadBMP_RW');
  late final _SDL_LoadBMP_RW = _SDL_LoadBMP_RWPtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Save a surface to a seekable SDL data stream (memory or file).
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// If \c freedst is non-zero, the stream will be closed after being written.
  ///
  /// \return 0 if successful or -1 if there was an error.
  int SDL_SaveBMP_RW(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>,
              ffi.Int32)>>('SDL_SaveBMP_RW');
  late final _SDL_SaveBMP_RW = _SDL_SaveBMP_RWPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_RWops>, int)>();

  /// \brief Sets the RLE acceleration hint for a surface.
  ///
  /// \return 0 on success, or -1 if the surface is not valid
  ///
  /// \note If RLE is enabled, colorkey and alpha blending blits are much faster,
  /// but the surface must be locked before directly accessing the pixels.
  int SDL_SetSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLEPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceRLE');
  late final _SDL_SetSurfaceRLE = _SDL_SetSurfaceRLEPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// \brief Returns whether the surface is RLE enabled
  ///
  /// \return SDL_TRUE if the surface is RLE enabled, or SDL_FALSE if the surface is NULL or not RLE enabled
  int SDL_HasSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLEPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasSurfaceRLE');
  late final _SDL_HasSurfaceRLE = _SDL_HasSurfaceRLEPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>)>();

  /// \brief Sets the color key (transparent pixel) in a blittable surface.
  ///
  /// \param surface The surface to update
  /// \param flag Non-zero to enable colorkey and 0 to disable colorkey
  /// \param key The transparent pixel in the native surface format
  ///
  /// \return 0 on success, or -1 if the surface is not valid
  ///
  /// You can pass SDL_RLEACCEL to enable RLE accelerated blits.
  int SDL_SetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32, Uint32)>>('SDL_SetColorKey');
  late final _SDL_SetColorKey = _SDL_SetColorKeyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// \brief Returns whether the surface has a color key
  ///
  /// \return SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key
  int SDL_HasColorKey(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey(
      surface,
    );
  }

  late final _SDL_HasColorKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Surface>)>>(
          'SDL_HasColorKey');
  late final _SDL_HasColorKey =
      _SDL_HasColorKeyPtr.asFunction<int Function(ffi.Pointer<SDL_Surface>)>();

  /// \brief Gets the color key (transparent pixel) in a blittable surface.
  ///
  /// \param surface The surface to update
  /// \param key A pointer filled in with the transparent pixel in the native
  /// surface format
  ///
  /// \return 0 on success, or -1 if the surface is not valid or colorkey is not
  /// enabled.
  int SDL_GetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint32> key,
  ) {
    return _SDL_GetColorKey(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint32>)>>('SDL_GetColorKey');
  late final _SDL_GetColorKey = _SDL_GetColorKeyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint32>)>();

  /// \brief Set an additional color value used in blit operations.
  ///
  /// \param surface The surface to update.
  /// \param r The red color value multiplied into blit operations.
  /// \param g The green color value multiplied into blit operations.
  /// \param b The blue color value multiplied into blit operations.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_GetSurfaceColorMod()
  int SDL_SetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>, Uint8, Uint8,
              Uint8)>>('SDL_SetSurfaceColorMod');
  late final _SDL_SetSurfaceColorMod = _SDL_SetSurfaceColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int, int, int)>();

  /// \brief Get the additional color value used in blit operations.
  ///
  /// \param surface The surface to query.
  /// \param r A pointer filled in with the current red color value.
  /// \param g A pointer filled in with the current green color value.
  /// \param b A pointer filled in with the current blue color value.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_SetSurfaceColorMod()
  int SDL_GetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceColorMod');
  late final _SDL_GetSurfaceColorMod = _SDL_GetSurfaceColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// \brief Set an additional alpha value used in blit operations.
  ///
  /// \param surface The surface to update.
  /// \param alpha The alpha value multiplied into blit operations.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_GetSurfaceAlphaMod()
  int SDL_SetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>, Uint8)>>('SDL_SetSurfaceAlphaMod');
  late final _SDL_SetSurfaceAlphaMod = _SDL_SetSurfaceAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// \brief Get the additional alpha value used in blit operations.
  ///
  /// \param surface The surface to query.
  /// \param alpha A pointer filled in with the current alpha value.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_SetSurfaceAlphaMod()
  int SDL_GetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<Uint8>)>>('SDL_GetSurfaceAlphaMod');
  late final _SDL_GetSurfaceAlphaMod = _SDL_GetSurfaceAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<Uint8>)>();

  /// \brief Set the blend mode used for blit operations.
  ///
  /// \param surface The surface to update.
  /// \param blendMode ::SDL_BlendMode to use for blit blending.
  ///
  /// \return 0 on success, or -1 if the parameters are not valid.
  ///
  /// \sa SDL_GetSurfaceBlendMode()
  int SDL_SetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>, ffi.Int32)>>('SDL_SetSurfaceBlendMode');
  late final _SDL_SetSurfaceBlendMode = _SDL_SetSurfaceBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, int)>();

  /// \brief Get the blend mode used for blit operations.
  ///
  /// \param surface   The surface to query.
  /// \param blendMode A pointer filled in with the current blend mode.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_SetSurfaceBlendMode()
  int SDL_GetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetSurfaceBlendMode');
  late final _SDL_GetSurfaceBlendMode = _SDL_GetSurfaceBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<ffi.Int32>)>();

  /// Sets the clipping rectangle for the destination surface in a blit.
  ///
  /// If the clip rectangle is NULL, clipping will be disabled.
  ///
  /// If the clip rectangle doesn't intersect the surface, the function will
  /// return SDL_FALSE and blits will be completely clipped.  Otherwise the
  /// function returns SDL_TRUE and blits to the surface will be clipped to
  /// the intersection of the surface area and the clipping rectangle.
  ///
  /// Note that blits are automatically clipped to the edges of the source
  /// and destination surfaces.
  int SDL_SetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SetClipRect');
  late final _SDL_SetClipRect = _SDL_SetClipRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// Gets the clipping rectangle for the destination surface in a blit.
  ///
  /// \c rect must be a pointer to a valid rectangle which will be filled
  /// with the correct values.
  void SDL_GetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_GetClipRect');
  late final _SDL_GetClipRect = _SDL_GetClipRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface(
      surface,
    );
  }

  late final _SDL_DuplicateSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_DuplicateSurface');
  late final _SDL_DuplicateSurface = _SDL_DuplicateSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>)>();

  /// Creates a new surface of the specified format, and then copies and maps
  /// the given surface to it so the blit of the converted surface will be as
  /// fast as possible.  If this function fails, it returns NULL.
  ///
  /// The \c flags parameter is passed to SDL_CreateRGBSurface() and has those
  /// semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and
  /// SDL will try to RLE accelerate colorkey and alpha blits in the resulting
  /// surface.
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_PixelFormat>, Uint32)>>('SDL_ConvertSurface');
  late final _SDL_ConvertSurface = _SDL_ConvertSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_PixelFormat>, int)>();

  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Surface>, Uint32,
              Uint32)>>('SDL_ConvertSurfaceFormat');
  late final _SDL_ConvertSurfaceFormat =
      _SDL_ConvertSurfaceFormatPtr.asFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Surface>, int, int)>();

  /// \brief Copy a block of pixels of one format to another format
  ///
  /// \return 0 on success, or -1 if there was an error
  int SDL_ConvertPixels(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int32)>>('SDL_ConvertPixels');
  late final _SDL_ConvertPixels = _SDL_ConvertPixelsPtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// Performs a fast fill of the given rectangle with \c color.
  ///
  /// If \c rect is NULL, the whole surface will be filled with \c color.
  ///
  /// The color should be a pixel of the format used by the surface, and
  /// can be generated by the SDL_MapRGB() function.
  ///
  /// \return 0 on success, or -1 on error.
  int SDL_FillRect(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              Uint32)>>('SDL_FillRect');
  late final _SDL_FillRect = _SDL_FillRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int)>();

  int SDL_FillRects(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
              ffi.Int32, Uint32)>>('SDL_FillRects');
  late final _SDL_FillRects = _SDL_FillRectsPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>, int, int)>();

  /// This is the public blit function, SDL_BlitSurface(), and it performs
  /// rectangle validation and clipping before passing it to SDL_LowerBlit()
  int SDL_UpperBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlit');
  late final _SDL_UpperBlit = _SDL_UpperBlitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// This is a semi-private blit function and it performs low-level surface
  /// blitting only.
  int SDL_LowerBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlit');
  late final _SDL_LowerBlit = _SDL_LowerBlitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Perform a fast, low quality, stretch blit between two surfaces of the
  /// same pixel format.
  ///
  /// \note This function uses a static buffer, and is not thread-safe.
  int SDL_SoftStretch(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_SoftStretch');
  late final _SDL_SoftStretch = _SDL_SoftStretchPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// This is the public scaled blit function, SDL_BlitScaled(), and it performs
  /// rectangle validation and clipping before passing it to SDL_LowerBlitScaled()
  int SDL_UpperBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_UpperBlitScaled');
  late final _SDL_UpperBlitScaled = _SDL_UpperBlitScaledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// This is a semi-private blit function and it performs low-level surface
  /// scaled blitting only.
  int SDL_LowerBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_Rect>)>>('SDL_LowerBlitScaled');
  late final _SDL_LowerBlitScaled = _SDL_LowerBlitScaledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Surface>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Set the YUV conversion mode
  void SDL_SetYUVConversionMode(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode(
      mode,
    );
  }

  late final _SDL_SetYUVConversionModePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetYUVConversionMode');
  late final _SDL_SetYUVConversionMode =
      _SDL_SetYUVConversionModePtr.asFunction<void Function(int)>();

  /// \brief Get the YUV conversion mode
  int SDL_GetYUVConversionMode() {
    return _SDL_GetYUVConversionMode();
  }

  late final _SDL_GetYUVConversionModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetYUVConversionMode');
  late final _SDL_GetYUVConversionMode =
      _SDL_GetYUVConversionModePtr.asFunction<int Function()>();

  /// \brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  int SDL_GetYUVConversionModeForResolution(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolutionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _SDL_GetYUVConversionModeForResolution =
      _SDL_GetYUVConversionModeForResolutionPtr.asFunction<
          int Function(int, int)>();

  /// \brief Get the number of video drivers compiled into SDL
  ///
  /// \sa SDL_GetVideoDriver()
  int SDL_GetNumVideoDrivers() {
    return _SDL_GetNumVideoDrivers();
  }

  late final _SDL_GetNumVideoDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetNumVideoDrivers');
  late final _SDL_GetNumVideoDrivers =
      _SDL_GetNumVideoDriversPtr.asFunction<int Function()>();

  /// \brief Get the name of a built in video driver.
  ///
  /// \note The video drivers are presented in the order in which they are
  /// normally checked during initialization.
  ///
  /// \sa SDL_GetNumVideoDrivers()
  ffi.Pointer<ffi.Int8> SDL_GetVideoDriver(
    int index,
  ) {
    return _SDL_GetVideoDriver(
      index,
    );
  }

  late final _SDL_GetVideoDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GetVideoDriver');
  late final _SDL_GetVideoDriver =
      _SDL_GetVideoDriverPtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// \param driver_name Initialize a specific driver by name, or NULL for the
  /// default video driver.
  ///
  /// \return 0 on success, -1 on error
  ///
  /// This function initializes the video subsystem; setting up a connection
  /// to the window manager, etc, and determines the available display modes
  /// and pixel formats, but does not initialize a window or graphics mode.
  ///
  /// \sa SDL_VideoQuit()
  int SDL_VideoInit(
    ffi.Pointer<ffi.Int8> driver_name,
  ) {
    return _SDL_VideoInit(
      driver_name,
    );
  }

  late final _SDL_VideoInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_VideoInit');
  late final _SDL_VideoInit =
      _SDL_VideoInitPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Shuts down the video subsystem.
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \sa SDL_VideoInit()
  void SDL_VideoQuit() {
    return _SDL_VideoQuit();
  }

  late final _SDL_VideoQuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_VideoQuit');
  late final _SDL_VideoQuit = _SDL_VideoQuitPtr.asFunction<void Function()>();

  /// \brief Returns the name of the currently initialized video driver.
  ///
  /// \return The name of the current video driver or NULL if no driver
  /// has been initialized
  ///
  /// \sa SDL_GetNumVideoDrivers()
  /// \sa SDL_GetVideoDriver()
  ffi.Pointer<ffi.Int8> SDL_GetCurrentVideoDriver() {
    return _SDL_GetCurrentVideoDriver();
  }

  late final _SDL_GetCurrentVideoDriverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetCurrentVideoDriver');
  late final _SDL_GetCurrentVideoDriver = _SDL_GetCurrentVideoDriverPtr
      .asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// \brief Returns the number of available video displays.
  ///
  /// \sa SDL_GetDisplayBounds()
  int SDL_GetNumVideoDisplays() {
    return _SDL_GetNumVideoDisplays();
  }

  late final _SDL_GetNumVideoDisplaysPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetNumVideoDisplays');
  late final _SDL_GetNumVideoDisplays =
      _SDL_GetNumVideoDisplaysPtr.asFunction<int Function()>();

  /// \brief Get the name of a display in UTF-8 encoding
  ///
  /// \return The name of a display, or NULL for an invalid display index.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  ffi.Pointer<ffi.Int8> SDL_GetDisplayName(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GetDisplayName');
  late final _SDL_GetDisplayName =
      _SDL_GetDisplayNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Get the desktop area represented by a display, with the primary
  /// display located at 0,0
  ///
  /// \return 0 on success, or -1 if the index is out of range.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBoundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<SDL_Rect>)>>('SDL_GetDisplayBounds');
  late final _SDL_GetDisplayBounds = _SDL_GetDisplayBoundsPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// \brief Get the usable desktop area represented by a display, with the
  /// primary display located at 0,0
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Mac OS X, this subtracts
  /// the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// \return 0 on success, or -1 if the index is out of range.
  ///
  /// \sa SDL_GetDisplayBounds()
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayUsableBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBoundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<SDL_Rect>)>>('SDL_GetDisplayUsableBounds');
  late final _SDL_GetDisplayUsableBounds = _SDL_GetDisplayUsableBoundsPtr
      .asFunction<int Function(int, ffi.Pointer<SDL_Rect>)>();

  /// \brief Get the dots/pixels-per-inch for a display
  ///
  /// \note Diagonal, horizontal and vertical DPI can all be optionally
  /// returned if the parameter is non-NULL.
  ///
  /// \return 0 on success, or -1 if no DPI information is available or the index is out of range.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayDPI(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPIPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetDisplayDPI');
  late final _SDL_GetDisplayDPI = _SDL_GetDisplayDPIPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// \brief Get the orientation of a display
  ///
  /// \return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayOrientation(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientationPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_GetDisplayOrientation');
  late final _SDL_GetDisplayOrientation =
      _SDL_GetDisplayOrientationPtr.asFunction<int Function(int)>();

  /// \brief Returns the number of available display modes.
  ///
  /// \sa SDL_GetDisplayMode()
  int SDL_GetNumDisplayModes(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_GetNumDisplayModes');
  late final _SDL_GetNumDisplayModes =
      _SDL_GetNumDisplayModesPtr.asFunction<int Function(int)>();

  /// \brief Fill in information about a specific display mode.
  ///
  /// \note The display modes are sorted in this priority:
  /// \li bits per pixel -> more colors to fewer colors
  /// \li width -> largest to smallest
  /// \li height -> largest to smallest
  /// \li refresh rate -> highest to lowest
  ///
  /// \sa SDL_GetNumDisplayModes()
  int SDL_GetDisplayMode(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDisplayMode');
  late final _SDL_GetDisplayMode = _SDL_GetDisplayModePtr.asFunction<
      int Function(int, int, ffi.Pointer<SDL_DisplayMode>)>();

  /// \brief Fill in information about the desktop display mode.
  int SDL_GetDesktopDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetDesktopDisplayMode');
  late final _SDL_GetDesktopDisplayMode = _SDL_GetDesktopDisplayModePtr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// \brief Fill in information about the current display mode.
  int SDL_GetCurrentDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetCurrentDisplayMode');
  late final _SDL_GetCurrentDisplayMode = _SDL_GetCurrentDisplayModePtr
      .asFunction<int Function(int, ffi.Pointer<SDL_DisplayMode>)>();

  /// \brief Get the closest match to the requested display mode.
  ///
  /// \param displayIndex The index of display from which mode should be queried.
  /// \param mode The desired display mode
  /// \param closest A pointer to a display mode to be filled in with the closest
  /// match of the available display modes.
  ///
  /// \return The passed in value \c closest, or NULL if no matching video mode
  /// was available.
  ///
  /// The available display modes are scanned, and \c closest is filled in with the
  /// closest mode matching the requested mode and returned.  The mode format and
  /// refresh_rate default to the desktop mode if they are 0.  The modes are
  /// scanned with size being first priority, format being second priority, and
  /// finally checking the refresh_rate.  If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \sa SDL_GetNumDisplayModes()
  /// \sa SDL_GetDisplayMode()
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_DisplayMode> Function(
              ffi.Int32,
              ffi.Pointer<SDL_DisplayMode>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetClosestDisplayMode');
  late final _SDL_GetClosestDisplayMode =
      _SDL_GetClosestDisplayModePtr.asFunction<
          ffi.Pointer<SDL_DisplayMode> Function(int,
              ffi.Pointer<SDL_DisplayMode>, ffi.Pointer<SDL_DisplayMode>)>();

  /// \brief Get the display index associated with a window.
  ///
  /// \return the display index of the display containing the center of the
  /// window, or -1 on error.
  int SDL_GetWindowDisplayIndex(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowDisplayIndex');
  late final _SDL_GetWindowDisplayIndex = _SDL_GetWindowDisplayIndexPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set the display mode used when a fullscreen window is visible.
  ///
  /// By default the window's dimensions and the desktop format and refresh rate
  /// are used.
  ///
  /// \param window The window for which the display mode should be set.
  /// \param mode The mode to use, or NULL for the default mode.
  ///
  /// \return 0 on success, or -1 if setting the display mode failed.
  ///
  /// \sa SDL_GetWindowDisplayMode()
  /// \sa SDL_SetWindowFullscreen()
  int SDL_SetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_SetWindowDisplayMode');
  late final _SDL_SetWindowDisplayMode =
      _SDL_SetWindowDisplayModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// \brief Fill in information about the display mode used when a fullscreen
  /// window is visible.
  ///
  /// \sa SDL_SetWindowDisplayMode()
  /// \sa SDL_SetWindowFullscreen()
  int SDL_GetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_DisplayMode>)>>('SDL_GetWindowDisplayMode');
  late final _SDL_GetWindowDisplayMode =
      _SDL_GetWindowDisplayModePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_DisplayMode>)>();

  /// \brief Get the pixel format associated with the window.
  int SDL_GetWindowPixelFormat(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormatPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowPixelFormat');
  late final _SDL_GetWindowPixelFormat = _SDL_GetWindowPixelFormatPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Create a window with the specified position, dimensions, and flags.
  ///
  /// \param title The title of the window, in UTF-8 encoding.
  /// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param w     The width of the window, in screen coordinates.
  /// \param h     The height of the window, in screen coordinates.
  /// \param flags The flags for the window, a mask of any of the following:
  /// ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,
  /// ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,
  /// ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,
  /// ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,
  /// ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN
  /// ::SDL_WINDOW_METAL.
  ///
  /// \return The created window, or NULL if window creation failed.
  ///
  /// If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query
  /// the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the
  /// drawable size in pixels.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// \note On non-Apple devices, SDL requires you to either not link to the
  /// Vulkan loader or link to a dynamic library version. This limitation
  /// may be removed in a future version of SDL.
  ///
  /// \sa SDL_DestroyWindow()
  /// \sa SDL_GL_LoadLibrary()
  /// \sa SDL_Vulkan_LoadLibrary()
  ffi.Pointer<SDL_Window> SDL_CreateWindow(
    ffi.Pointer<ffi.Int8> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Int8>, ffi.Int32,
              ffi.Int32, ffi.Int32, ffi.Int32, Uint32)>>('SDL_CreateWindow');
  late final _SDL_CreateWindow = _SDL_CreateWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Int8>, int, int, int, int, int)>();

  /// \brief Create an SDL window from an existing native window.
  ///
  /// \param data A pointer to driver-dependent window creation data
  ///
  /// \return The created window, or NULL if window creation failed.
  ///
  /// \sa SDL_DestroyWindow()
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom(
      data,
    );
  }

  late final _SDL_CreateWindowFromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Void>)>>('SDL_CreateWindowFrom');
  late final _SDL_CreateWindowFrom = _SDL_CreateWindowFromPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(ffi.Pointer<ffi.Void>)>();

  /// \brief Get the numeric ID of a window, for logging purposes.
  int SDL_GetWindowID(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID(
      window,
    );
  }

  late final _SDL_GetWindowIDPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowID');
  late final _SDL_GetWindowID =
      _SDL_GetWindowIDPtr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Get a window from a stored ID, or NULL if it doesn't exist.
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID(
    int id,
  ) {
    return _SDL_GetWindowFromID(
      id,
    );
  }

  late final _SDL_GetWindowFromIDPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function(Uint32)>>(
          'SDL_GetWindowFromID');
  late final _SDL_GetWindowFromID = _SDL_GetWindowFromIDPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(int)>();

  /// \brief Get the window flags.
  int SDL_GetWindowFlags(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags(
      window,
    );
  }

  late final _SDL_GetWindowFlagsPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowFlags');
  late final _SDL_GetWindowFlags = _SDL_GetWindowFlagsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set the title of a window, in UTF-8 format.
  ///
  /// \sa SDL_GetWindowTitle()
  void SDL_SetWindowTitle(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int8> title,
  ) {
    return _SDL_SetWindowTitle(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int8>)>>('SDL_SetWindowTitle');
  late final _SDL_SetWindowTitle = _SDL_SetWindowTitlePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int8>)>();

  /// \brief Get the title of a window, in UTF-8 format.
  ///
  /// \sa SDL_SetWindowTitle()
  ffi.Pointer<ffi.Int8> SDL_GetWindowTitle(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle(
      window,
    );
  }

  late final _SDL_GetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowTitle');
  late final _SDL_GetWindowTitle = _SDL_GetWindowTitlePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set the icon for a window.
  ///
  /// \param window The window for which the icon should be set.
  /// \param icon The icon for the window.
  void SDL_SetWindowIcon(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Surface>)>>('SDL_SetWindowIcon');
  late final _SDL_SetWindowIcon = _SDL_SetWindowIconPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>)>();

  /// \brief Associate an arbitrary named pointer with a window.
  ///
  /// \param window   The window to associate with the pointer.
  /// \param name     The name of the pointer.
  /// \param userdata The associated pointer.
  ///
  /// \return The previous value associated with 'name'
  ///
  /// \note The name is case-sensitive.
  ///
  /// \sa SDL_GetWindowData()
  ffi.Pointer<ffi.Void> SDL_SetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowData');
  late final _SDL_SetWindowData = _SDL_SetWindowDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Void>)>();

  /// \brief Retrieve the data pointer associated with a window.
  ///
  /// \param window   The window to query.
  /// \param name     The name of the pointer.
  ///
  /// \return The value associated with 'name'
  ///
  /// \sa SDL_SetWindowData()
  ffi.Pointer<ffi.Void> SDL_GetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetWindowData(
      window,
      name,
    );
  }

  late final _SDL_GetWindowDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int8>)>>('SDL_GetWindowData');
  late final _SDL_GetWindowData = _SDL_GetWindowDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int8>)>();

  /// \brief Set the position of a window.
  ///
  /// \param window   The window to reposition.
  /// \param x        The x coordinate of the window in screen coordinates, or
  /// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y        The y coordinate of the window in screen coordinates, or
  /// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
  ///
  /// \note The window coordinate origin is the upper left of the display.
  ///
  /// \sa SDL_GetWindowPosition()
  void SDL_SetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int32,
              ffi.Int32)>>('SDL_SetWindowPosition');
  late final _SDL_SetWindowPosition = _SDL_SetWindowPositionPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// \brief Get the position of a window.
  ///
  /// \param window   The window to query.
  /// \param x        Pointer to variable for storing the x position, in screen
  /// coordinates. May be NULL.
  /// \param y        Pointer to variable for storing the y position, in screen
  /// coordinates. May be NULL.
  ///
  /// \sa SDL_SetWindowPosition()
  void SDL_GetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetWindowPosition');
  late final _SDL_GetWindowPosition = _SDL_GetWindowPositionPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// \brief Set the size of a window's client area.
  ///
  /// \param window   The window to resize.
  /// \param w        The width of the window, in screen coordinates. Must be >0.
  /// \param h        The height of the window, in screen coordinates. Must be >0.
  ///
  /// \note Fullscreen windows automatically match the size of the display mode,
  /// and you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// The window size in screen coordinates may differ from the size in pixels, if
  /// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
  /// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// \sa SDL_GetWindowSize()
  /// \sa SDL_SetWindowDisplayMode()
  void SDL_SetWindowSize(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int32,
              ffi.Int32)>>('SDL_SetWindowSize');
  late final _SDL_SetWindowSize = _SDL_SetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// \brief Get the size of a window's client area.
  ///
  /// \param window   The window to query.
  /// \param w        Pointer to variable for storing the width, in screen
  /// coordinates. May be NULL.
  /// \param h        Pointer to variable for storing the height, in screen
  /// coordinates. May be NULL.
  ///
  /// The window size in screen coordinates may differ from the size in pixels, if
  /// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
  /// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// \sa SDL_SetWindowSize()
  void SDL_GetWindowSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetWindowSize');
  late final _SDL_GetWindowSize = _SDL_GetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// \brief Get the size of a window's borders (decorations) around the client area.
  ///
  /// \param window The window to query.
  /// \param top Pointer to variable for storing the size of the top border. NULL is permitted.
  /// \param left Pointer to variable for storing the size of the left border. NULL is permitted.
  /// \param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted.
  /// \param right Pointer to variable for storing the size of the right border. NULL is permitted.
  ///
  /// \return 0 on success, or -1 if getting this information is not supported.
  ///
  /// \note if this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as
  /// if the window in question was borderless.
  int SDL_GetWindowBordersSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> top,
    ffi.Pointer<ffi.Int32> left,
    ffi.Pointer<ffi.Int32> bottom,
    ffi.Pointer<ffi.Int32> right,
  ) {
    return _SDL_GetWindowBordersSize(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetWindowBordersSize');
  late final _SDL_GetWindowBordersSize =
      _SDL_GetWindowBordersSizePtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Set the minimum size of a window's client area.
  ///
  /// \param window    The window to set a new minimum size.
  /// \param min_w     The minimum width of the window, must be >0
  /// \param min_h     The minimum height of the window, must be >0
  ///
  /// \note You can't change the minimum size of a fullscreen window, it
  /// automatically matches the size of the display mode.
  ///
  /// \sa SDL_GetWindowMinimumSize()
  /// \sa SDL_SetWindowMaximumSize()
  void SDL_SetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int32,
              ffi.Int32)>>('SDL_SetWindowMinimumSize');
  late final _SDL_SetWindowMinimumSize = _SDL_SetWindowMinimumSizePtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// \brief Get the minimum size of a window's client area.
  ///
  /// \param window   The window to query.
  /// \param w        Pointer to variable for storing the minimum width, may be NULL
  /// \param h        Pointer to variable for storing the minimum height, may be NULL
  ///
  /// \sa SDL_GetWindowMaximumSize()
  /// \sa SDL_SetWindowMinimumSize()
  void SDL_GetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetWindowMinimumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetWindowMinimumSize');
  late final _SDL_GetWindowMinimumSize =
      _SDL_GetWindowMinimumSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Set the maximum size of a window's client area.
  ///
  /// \param window    The window to set a new maximum size.
  /// \param max_w     The maximum width of the window, must be >0
  /// \param max_h     The maximum height of the window, must be >0
  ///
  /// \note You can't change the maximum size of a fullscreen window, it
  /// automatically matches the size of the display mode.
  ///
  /// \sa SDL_GetWindowMaximumSize()
  /// \sa SDL_SetWindowMinimumSize()
  void SDL_SetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int32,
              ffi.Int32)>>('SDL_SetWindowMaximumSize');
  late final _SDL_SetWindowMaximumSize = _SDL_SetWindowMaximumSizePtr
      .asFunction<void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// \brief Get the maximum size of a window's client area.
  ///
  /// \param window   The window to query.
  /// \param w        Pointer to variable for storing the maximum width, may be NULL
  /// \param h        Pointer to variable for storing the maximum height, may be NULL
  ///
  /// \sa SDL_GetWindowMinimumSize()
  /// \sa SDL_SetWindowMaximumSize()
  void SDL_GetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetWindowMaximumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetWindowMaximumSize');
  late final _SDL_GetWindowMaximumSize =
      _SDL_GetWindowMaximumSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Set the border state of a window.
  ///
  /// This will add or remove the window's SDL_WINDOW_BORDERLESS flag and
  /// add or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// \param window The window of which to change the border state.
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border.
  ///
  /// \note You can't change the border state of a fullscreen window.
  ///
  /// \sa SDL_GetWindowFlags()
  void SDL_SetWindowBordered(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBorderedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowBordered');
  late final _SDL_SetWindowBordered = _SDL_SetWindowBorderedPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// \brief Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's SDL_WINDOW_RESIZABLE flag and
  /// allow/disallow user resizing of the window. This is a no-op if the
  /// window's resizable state already matches the requested state.
  ///
  /// \param window The window of which to change the resizable state.
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow.
  ///
  /// \note You can't change the resizable state of a fullscreen window.
  ///
  /// \sa SDL_GetWindowFlags()
  void SDL_SetWindowResizable(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowResizable');
  late final _SDL_SetWindowResizable = _SDL_SetWindowResizablePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// \brief Show a window.
  ///
  /// \sa SDL_HideWindow()
  void SDL_ShowWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow(
      window,
    );
  }

  late final _SDL_ShowWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_ShowWindow');
  late final _SDL_ShowWindow =
      _SDL_ShowWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Hide a window.
  ///
  /// \sa SDL_ShowWindow()
  void SDL_HideWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow(
      window,
    );
  }

  late final _SDL_HideWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_HideWindow');
  late final _SDL_HideWindow =
      _SDL_HideWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Raise a window above other windows and set the input focus.
  void SDL_RaiseWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow(
      window,
    );
  }

  late final _SDL_RaiseWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RaiseWindow');
  late final _SDL_RaiseWindow =
      _SDL_RaiseWindowPtr.asFunction<void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Make a window as large as possible.
  ///
  /// \sa SDL_RestoreWindow()
  void SDL_MaximizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow(
      window,
    );
  }

  late final _SDL_MaximizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MaximizeWindow');
  late final _SDL_MaximizeWindow = _SDL_MaximizeWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Minimize a window to an iconic representation.
  ///
  /// \sa SDL_RestoreWindow()
  void SDL_MinimizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow(
      window,
    );
  }

  late final _SDL_MinimizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_MinimizeWindow');
  late final _SDL_MinimizeWindow = _SDL_MinimizeWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Restore the size and position of a minimized or maximized window.
  ///
  /// \sa SDL_MaximizeWindow()
  /// \sa SDL_MinimizeWindow()
  void SDL_RestoreWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow(
      window,
    );
  }

  late final _SDL_RestoreWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_RestoreWindow');
  late final _SDL_RestoreWindow = _SDL_RestoreWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set a window's fullscreen state.
  ///
  /// \return 0 on success, or -1 if setting the display mode failed.
  ///
  /// \sa SDL_SetWindowDisplayMode()
  /// \sa SDL_GetWindowDisplayMode()
  int SDL_SetWindowFullscreen(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>, Uint32)>>('SDL_SetWindowFullscreen');
  late final _SDL_SetWindowFullscreen = _SDL_SetWindowFullscreenPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, int)>();

  /// \brief Get the SDL surface associated with the window.
  ///
  /// \return The window's framebuffer surface, or NULL on error.
  ///
  /// A new surface will be created with the optimal format for the window,
  /// if necessary. This surface will be freed when the window is destroyed.
  ///
  /// \note You may not combine this with 3D or the rendering API on this window.
  ///
  /// \sa SDL_UpdateWindowSurface()
  /// \sa SDL_UpdateWindowSurfaceRects()
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface(
      window,
    );
  }

  late final _SDL_GetWindowSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Surface> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetWindowSurface');
  late final _SDL_GetWindowSurface = _SDL_GetWindowSurfacePtr.asFunction<
      ffi.Pointer<SDL_Surface> Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Copy the window surface to the screen.
  ///
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_GetWindowSurface()
  /// \sa SDL_UpdateWindowSurfaceRects()
  int SDL_UpdateWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface(
      window,
    );
  }

  late final _SDL_UpdateWindowSurfacePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_UpdateWindowSurface');
  late final _SDL_UpdateWindowSurface = _SDL_UpdateWindowSurfacePtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Copy a number of rectangles on the window surface to the screen.
  ///
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_GetWindowSurface()
  /// \sa SDL_UpdateWindowSurface()
  int SDL_UpdateWindowSurfaceRects(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>,
              ffi.Int32)>>('SDL_UpdateWindowSurfaceRects');
  late final _SDL_UpdateWindowSurfaceRects =
      _SDL_UpdateWindowSurfaceRectsPtr.asFunction<
          int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Rect>, int)>();

  /// \brief Set a window's input grab mode.
  ///
  /// \param window The window for which the input grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.
  ///
  /// If the caller enables a grab while another window is currently grabbed,
  /// the other window loses its grab in favor of the caller's window.
  ///
  /// \sa SDL_GetWindowGrab()
  void SDL_SetWindowGrab(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Window>, ffi.Int32)>>('SDL_SetWindowGrab');
  late final _SDL_SetWindowGrab = _SDL_SetWindowGrabPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int)>();

  /// \brief Get a window's input grab mode.
  ///
  /// \return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.
  ///
  /// \sa SDL_SetWindowGrab()
  int SDL_GetWindowGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab(
      window,
    );
  }

  late final _SDL_GetWindowGrabPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowGrab');
  late final _SDL_GetWindowGrab =
      _SDL_GetWindowGrabPtr.asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Get the window that currently has an input grab enabled.
  ///
  /// \return This returns the window if input is grabbed, and NULL otherwise.
  ///
  /// \sa SDL_SetWindowGrab()
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow() {
    return _SDL_GetGrabbedWindow();
  }

  late final _SDL_GetGrabbedWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetGrabbedWindow');
  late final _SDL_GetGrabbedWindow =
      _SDL_GetGrabbedWindowPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// \brief Set the brightness (gamma correction) for a window.
  ///
  /// \return 0 on success, or -1 if setting the brightness isn't supported.
  ///
  /// \sa SDL_GetWindowBrightness()
  /// \sa SDL_SetWindowGammaRamp()
  int SDL_SetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightnessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowBrightness');
  late final _SDL_SetWindowBrightness = _SDL_SetWindowBrightnessPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// \brief Get the brightness (gamma correction) for a window.
  ///
  /// \return The last brightness value passed to SDL_SetWindowBrightness()
  ///
  /// \sa SDL_SetWindowBrightness()
  double SDL_GetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness(
      window,
    );
  }

  late final _SDL_GetWindowBrightnessPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GetWindowBrightness');
  late final _SDL_GetWindowBrightness = _SDL_GetWindowBrightnessPtr.asFunction<
      double Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set the opacity for a window
  ///
  /// \param window The window which will be made transparent or opaque
  /// \param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be
  /// clamped internally between 0.0f and 1.0f.
  ///
  /// \return 0 on success, or -1 if setting the opacity isn't supported.
  ///
  /// \sa SDL_GetWindowOpacity()
  int SDL_SetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>, ffi.Float)>>('SDL_SetWindowOpacity');
  late final _SDL_SetWindowOpacity = _SDL_SetWindowOpacityPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, double)>();

  /// \brief Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// \param window The window in question.
  /// \param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)
  ///
  /// \return 0 on success, or -1 on error (invalid window, etc).
  ///
  /// \sa SDL_SetWindowOpacity()
  int SDL_GetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<ffi.Float>)>>('SDL_GetWindowOpacity');
  late final _SDL_GetWindowOpacity = _SDL_GetWindowOpacityPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Float>)>();

  /// \brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)
  ///
  /// \param modal_window The window that should be modal
  /// \param parent_window The parent window
  ///
  /// \return 0 on success, or -1 otherwise.
  int SDL_SetWindowModalFor(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalForPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_Window>)>>('SDL_SetWindowModalFor');
  late final _SDL_SetWindowModalFor = _SDL_SetWindowModalForPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Window>)>();

  /// \brief Explicitly sets input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that's completely
  /// obscured by other windows.
  ///
  /// \param window The window that should get the input focus
  ///
  /// \return 0 on success, or -1 otherwise.
  /// \sa SDL_RaiseWindow()
  int SDL_SetWindowInputFocus(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus(
      window,
    );
  }

  late final _SDL_SetWindowInputFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_SetWindowInputFocus');
  late final _SDL_SetWindowInputFocus = _SDL_SetWindowInputFocusPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set the gamma ramp for a window.
  ///
  /// \param window The window for which the gamma ramp should be set.
  /// \param red The translation table for the red channel, or NULL.
  /// \param green The translation table for the green channel, or NULL.
  /// \param blue The translation table for the blue channel, or NULL.
  ///
  /// \return 0 on success, or -1 if gamma ramps are unsupported.
  ///
  /// Set the gamma translation table for the red, green, and blue channels
  /// of the video hardware.  Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel.
  /// The input is the index into the array, and the output is the 16-bit
  /// gamma value at that index, scaled to the output color precision.
  ///
  /// \sa SDL_GetWindowGammaRamp()
  int SDL_SetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_SetWindowGammaRamp');
  late final _SDL_SetWindowGammaRamp = _SDL_SetWindowGammaRampPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// \brief Get the gamma ramp for a window.
  ///
  /// \param window The window from which the gamma ramp should be queried.
  /// \param red   A pointer to a 256 element array of 16-bit quantities to hold
  /// the translation table for the red channel, or NULL.
  /// \param green A pointer to a 256 element array of 16-bit quantities to hold
  /// the translation table for the green channel, or NULL.
  /// \param blue  A pointer to a 256 element array of 16-bit quantities to hold
  /// the translation table for the blue channel, or NULL.
  ///
  /// \return 0 on success, or -1 if gamma ramps are unsupported.
  ///
  /// \sa SDL_SetWindowGammaRamp()
  int SDL_GetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<Uint16> red,
    ffi.Pointer<Uint16> green,
    ffi.Pointer<Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>,
              ffi.Pointer<Uint16>)>>('SDL_GetWindowGammaRamp');
  late final _SDL_GetWindowGammaRamp = _SDL_GetWindowGammaRampPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<Uint16>,
          ffi.Pointer<Uint16>, ffi.Pointer<Uint16>)>();

  /// \brief Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable
  /// from any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of
  /// a given window as special. This callback is run during event processing
  /// if we need to tell the OS to treat a region of the window specially; the
  /// use of this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within
  /// a special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire
  /// when the OS is deciding whether to drag your window, but it fires for lots
  /// of other reasons, too, some unrelated to anything you probably care about
  /// _and when the mouse isn't actually at the location it is testing_).
  /// Since this can fire at any time, you should try to keep your callback
  /// efficient, devoid of allocations, etc.
  ///
  /// \param window The window to set hit-testing on.
  /// \param callback The callback to call when doing a hit-test.
  /// \param callback_data An app-defined void pointer passed to the callback.
  /// \return 0 on success, -1 on error (including unsupported).
  int SDL_SetWindowHitTest(
    ffi.Pointer<SDL_Window> window,
    SDL_HitTest callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>, SDL_HitTest,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowHitTest');
  late final _SDL_SetWindowHitTest = _SDL_SetWindowHitTestPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, SDL_HitTest, ffi.Pointer<ffi.Void>)>();

  /// \brief Destroy a window.
  void SDL_DestroyWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow(
      window,
    );
  }

  late final _SDL_DestroyWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_DestroyWindow');
  late final _SDL_DestroyWindow = _SDL_DestroyWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Returns whether the screensaver is currently enabled (default off).
  ///
  /// \sa SDL_EnableScreenSaver()
  /// \sa SDL_DisableScreenSaver()
  int SDL_IsScreenSaverEnabled() {
    return _SDL_IsScreenSaverEnabled();
  }

  late final _SDL_IsScreenSaverEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsScreenSaverEnabled');
  late final _SDL_IsScreenSaverEnabled =
      _SDL_IsScreenSaverEnabledPtr.asFunction<int Function()>();

  /// \brief Allow the screen to be blanked by a screensaver
  ///
  /// \sa SDL_IsScreenSaverEnabled()
  /// \sa SDL_DisableScreenSaver()
  void SDL_EnableScreenSaver() {
    return _SDL_EnableScreenSaver();
  }

  late final _SDL_EnableScreenSaverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_EnableScreenSaver');
  late final _SDL_EnableScreenSaver =
      _SDL_EnableScreenSaverPtr.asFunction<void Function()>();

  /// \brief Prevent the screen from being blanked by a screensaver
  ///
  /// \sa SDL_IsScreenSaverEnabled()
  /// \sa SDL_EnableScreenSaver()
  void SDL_DisableScreenSaver() {
    return _SDL_DisableScreenSaver();
  }

  late final _SDL_DisableScreenSaverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_DisableScreenSaver');
  late final _SDL_DisableScreenSaver =
      _SDL_DisableScreenSaverPtr.asFunction<void Function()>();

  /// \brief Dynamically load an OpenGL library.
  ///
  /// \param path The platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library.
  ///
  /// \return 0 on success, or -1 if the library couldn't be loaded.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows.  If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// \note If you do this, you need to retrieve all of the GL functions used in
  /// your program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \sa SDL_GL_GetProcAddress()
  /// \sa SDL_GL_UnloadLibrary()
  int SDL_GL_LoadLibrary(
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _SDL_GL_LoadLibrary(
      path,
    );
  }

  late final _SDL_GL_LoadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GL_LoadLibrary');
  late final _SDL_GL_LoadLibrary =
      _SDL_GL_LoadLibraryPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Get the address of an OpenGL function.
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress(
    ffi.Pointer<ffi.Int8> proc,
  ) {
    return _SDL_GL_GetProcAddress(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Int8>)>>('SDL_GL_GetProcAddress');
  late final _SDL_GL_GetProcAddress = _SDL_GL_GetProcAddressPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \sa SDL_GL_LoadLibrary()
  void SDL_GL_UnloadLibrary() {
    return _SDL_GL_UnloadLibrary();
  }

  late final _SDL_GL_UnloadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_GL_UnloadLibrary');
  late final _SDL_GL_UnloadLibrary =
      _SDL_GL_UnloadLibraryPtr.asFunction<void Function()>();

  /// \brief Return true if an OpenGL extension is supported for the current
  /// context.
  int SDL_GL_ExtensionSupported(
    ffi.Pointer<ffi.Int8> extension1,
  ) {
    return _SDL_GL_ExtensionSupported(
      extension1,
    );
  }

  late final _SDL_GL_ExtensionSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GL_ExtensionSupported');
  late final _SDL_GL_ExtensionSupported = _SDL_GL_ExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Reset all previously set OpenGL context attributes to their default values
  void SDL_GL_ResetAttributes() {
    return _SDL_GL_ResetAttributes();
  }

  late final _SDL_GL_ResetAttributesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GL_ResetAttributes');
  late final _SDL_GL_ResetAttributes =
      _SDL_GL_ResetAttributesPtr.asFunction<void Function()>();

  /// \brief Set an OpenGL window attribute before window creation.
  ///
  /// \return 0 on success, or -1 if the attribute could not be set.
  int SDL_GL_SetAttribute(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttributePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
          'SDL_GL_SetAttribute');
  late final _SDL_GL_SetAttribute =
      _SDL_GL_SetAttributePtr.asFunction<int Function(int, int)>();

  /// \brief Get the actual value for an attribute from the current context.
  ///
  /// \return 0 on success, or -1 if the attribute could not be retrieved.
  /// The integer at \c value will be modified in either case.
  int SDL_GL_GetAttribute(
    int attr,
    ffi.Pointer<ffi.Int32> value,
  ) {
    return _SDL_GL_GetAttribute(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttributePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Int32>)>>('SDL_GL_GetAttribute');
  late final _SDL_GL_GetAttribute = _SDL_GL_GetAttributePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int32>)>();

  /// \brief Create an OpenGL context for use with an OpenGL window, and make it
  /// current.
  ///
  /// \sa SDL_GL_DeleteContext()
  SDL_GLContext SDL_GL_CreateContext(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext(
      window,
    );
  }

  late final _SDL_GL_CreateContextPtr = _lookup<
          ffi.NativeFunction<SDL_GLContext Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_GL_CreateContext');
  late final _SDL_GL_CreateContext = _SDL_GL_CreateContextPtr.asFunction<
      SDL_GLContext Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// \note The context must have been created with a compatible window.
  int SDL_GL_MakeCurrent(
    ffi.Pointer<SDL_Window> window,
    SDL_GLContext context,
  ) {
    return _SDL_GL_MakeCurrent(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Window>, SDL_GLContext)>>('SDL_GL_MakeCurrent');
  late final _SDL_GL_MakeCurrent = _SDL_GL_MakeCurrentPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, SDL_GLContext)>();

  /// \brief Get the currently active OpenGL window.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow() {
    return _SDL_GL_GetCurrentWindow();
  }

  late final _SDL_GL_GetCurrentWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GL_GetCurrentWindow');
  late final _SDL_GL_GetCurrentWindow = _SDL_GL_GetCurrentWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function()>();

  /// \brief Get the currently active OpenGL context.
  SDL_GLContext SDL_GL_GetCurrentContext() {
    return _SDL_GL_GetCurrentContext();
  }

  late final _SDL_GL_GetCurrentContextPtr =
      _lookup<ffi.NativeFunction<SDL_GLContext Function()>>(
          'SDL_GL_GetCurrentContext');
  late final _SDL_GL_GetCurrentContext =
      _SDL_GL_GetCurrentContextPtr.asFunction<SDL_GLContext Function()>();

  /// \brief Get the size of a window's underlying drawable in pixels (for use
  /// with glViewport).
  ///
  /// \param window   Window from which the drawable size should be queried
  /// \param w        Pointer to variable for storing the width in pixels, may be NULL
  /// \param h        Pointer to variable for storing the height in pixels, may be NULL
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not disabled
  /// by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
  ///
  /// \sa SDL_GetWindowSize()
  /// \sa SDL_CreateWindow()
  void SDL_GL_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GL_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GL_GetDrawableSize');
  late final _SDL_GL_GetDrawableSize = _SDL_GL_GetDrawableSizePtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// \brief Set the swap interval for the current OpenGL context.
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with the
  /// vertical retrace. If the system supports it, you may
  /// specify -1 to allow late swaps to happen immediately
  /// instead of waiting for the next retrace.
  ///
  /// \return 0 on success, or -1 if setting the swap interval is not supported.
  ///
  /// \sa SDL_GL_GetSwapInterval()
  int SDL_GL_SetSwapInterval(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval(
      interval,
    );
  }

  late final _SDL_GL_SetSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_GL_SetSwapInterval');
  late final _SDL_GL_SetSwapInterval =
      _SDL_GL_SetSwapIntervalPtr.asFunction<int Function(int)>();

  /// \brief Get the swap interval for the current OpenGL context.
  ///
  /// \return 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace.
  /// If the system can't determine the swap interval, or there isn't a
  /// valid current context, this will return 0 as a safe default.
  ///
  /// \sa SDL_GL_SetSwapInterval()
  int SDL_GL_GetSwapInterval() {
    return _SDL_GL_GetSwapInterval();
  }

  late final _SDL_GL_GetSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GL_GetSwapInterval');
  late final _SDL_GL_GetSwapInterval =
      _SDL_GL_GetSwapIntervalPtr.asFunction<int Function()>();

  /// \brief Swap the OpenGL buffers for a window, if double-buffering is
  /// supported.
  void SDL_GL_SwapWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow(
      window,
    );
  }

  late final _SDL_GL_SwapWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_GL_SwapWindow');
  late final _SDL_GL_SwapWindow = _SDL_GL_SwapWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Delete an OpenGL context.
  ///
  /// \sa SDL_GL_CreateContext()
  void SDL_GL_DeleteContext(
    SDL_GLContext context,
  ) {
    return _SDL_GL_DeleteContext(
      context,
    );
  }

  late final _SDL_GL_DeleteContextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_GLContext)>>(
          'SDL_GL_DeleteContext');
  late final _SDL_GL_DeleteContext =
      _SDL_GL_DeleteContextPtr.asFunction<void Function(SDL_GLContext)>();

  /// \brief Get the window which currently has keyboard focus.
  ffi.Pointer<SDL_Window> SDL_GetKeyboardFocus() {
    return _SDL_GetKeyboardFocus();
  }

  late final _SDL_GetKeyboardFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetKeyboardFocus');
  late final _SDL_GetKeyboardFocus =
      _SDL_GetKeyboardFocusPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// \brief Get a snapshot of the current state of the keyboard.
  ///
  /// \param numkeys if non-NULL, receives the length of the returned array.
  ///
  /// \return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.
  ///
  /// \b Example:
  /// \code
  /// const Uint8 *state = SDL_GetKeyboardState(NULL);
  /// if ( state[SDL_SCANCODE_RETURN] )   {
  /// printf("<RETURN> is pressed.\n");
  /// }
  /// \endcode
  ffi.Pointer<Uint8> SDL_GetKeyboardState(
    ffi.Pointer<ffi.Int32> numkeys,
  ) {
    return _SDL_GetKeyboardState(
      numkeys,
    );
  }

  late final _SDL_GetKeyboardStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Uint8> Function(
              ffi.Pointer<ffi.Int32>)>>('SDL_GetKeyboardState');
  late final _SDL_GetKeyboardState = _SDL_GetKeyboardStatePtr.asFunction<
      ffi.Pointer<Uint8> Function(ffi.Pointer<ffi.Int32>)>();

  /// \brief Get the current key modifier state for the keyboard.
  int SDL_GetModState() {
    return _SDL_GetModState();
  }

  late final _SDL_GetModStatePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_GetModState');
  late final _SDL_GetModState =
      _SDL_GetModStatePtr.asFunction<int Function()>();

  /// \brief Set the current key modifier state for the keyboard.
  ///
  /// \note This does not change the keyboard state, only the key modifier flags.
  void SDL_SetModState(
    int modstate,
  ) {
    return _SDL_SetModState(
      modstate,
    );
  }

  late final _SDL_SetModStatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_SetModState');
  late final _SDL_SetModState =
      _SDL_SetModStatePtr.asFunction<void Function(int)>();

  /// \brief Get the key code corresponding to the given scancode according
  /// to the current keyboard layout.
  ///
  /// See ::SDL_Keycode for details.
  ///
  /// \sa SDL_GetKeyName()
  int SDL_GetKeyFromScancode(
    int scancode,
  ) {
    return _SDL_GetKeyFromScancode(
      scancode,
    );
  }

  late final _SDL_GetKeyFromScancodePtr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Int32)>>(
          'SDL_GetKeyFromScancode');
  late final _SDL_GetKeyFromScancode =
      _SDL_GetKeyFromScancodePtr.asFunction<int Function(int)>();

  /// \brief Get the scancode corresponding to the given key code according to the
  /// current keyboard layout.
  ///
  /// See ::SDL_Scancode for details.
  ///
  /// \sa SDL_GetScancodeName()
  int SDL_GetScancodeFromKey(
    int key,
  ) {
    return _SDL_GetScancodeFromKey(
      key,
    );
  }

  late final _SDL_GetScancodeFromKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_Keycode)>>(
          'SDL_GetScancodeFromKey');
  late final _SDL_GetScancodeFromKey =
      _SDL_GetScancodeFromKeyPtr.asFunction<int Function(int)>();

  /// \brief Get a human-readable name for a scancode.
  ///
  /// \return A pointer to the name for the scancode.
  /// If the scancode doesn't have a name, this function returns
  /// an empty string ("").
  ///
  /// \sa SDL_Scancode
  ffi.Pointer<ffi.Int8> SDL_GetScancodeName(
    int scancode,
  ) {
    return _SDL_GetScancodeName(
      scancode,
    );
  }

  late final _SDL_GetScancodeNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GetScancodeName');
  late final _SDL_GetScancodeName =
      _SDL_GetScancodeNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Get a scancode from a human-readable name
  ///
  /// \return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized
  ///
  /// \sa SDL_Scancode
  int SDL_GetScancodeFromName(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetScancodeFromName(
      name,
    );
  }

  late final _SDL_GetScancodeFromNamePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GetScancodeFromName');
  late final _SDL_GetScancodeFromName = _SDL_GetScancodeFromNamePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Get a human-readable name for a key.
  ///
  /// \return A pointer to a UTF-8 string that stays valid at least until the next
  /// call to this function. If you need it around any longer, you must
  /// copy it.  If the key doesn't have a name, this function returns an
  /// empty string ("").
  ///
  /// \sa SDL_Keycode
  ffi.Pointer<ffi.Int8> SDL_GetKeyName(
    int key,
  ) {
    return _SDL_GetKeyName(
      key,
    );
  }

  late final _SDL_GetKeyNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(SDL_Keycode)>>(
          'SDL_GetKeyName');
  late final _SDL_GetKeyName =
      _SDL_GetKeyNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Get a key code from a human-readable name
  ///
  /// \return key code, or SDLK_UNKNOWN if the name wasn't recognized
  ///
  /// \sa SDL_Keycode
  int SDL_GetKeyFromName(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetKeyFromName(
      name,
    );
  }

  late final _SDL_GetKeyFromNamePtr =
      _lookup<ffi.NativeFunction<SDL_Keycode Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GetKeyFromName');
  late final _SDL_GetKeyFromName =
      _SDL_GetKeyFromNamePtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Start accepting Unicode text input events.
  /// This function will show the on-screen keyboard if supported.
  ///
  /// \sa SDL_StopTextInput()
  /// \sa SDL_SetTextInputRect()
  /// \sa SDL_HasScreenKeyboardSupport()
  void SDL_StartTextInput() {
    return _SDL_StartTextInput();
  }

  late final _SDL_StartTextInputPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StartTextInput');
  late final _SDL_StartTextInput =
      _SDL_StartTextInputPtr.asFunction<void Function()>();

  /// \brief Return whether or not Unicode text input events are enabled.
  ///
  /// \sa SDL_StartTextInput()
  /// \sa SDL_StopTextInput()
  int SDL_IsTextInputActive() {
    return _SDL_IsTextInputActive();
  }

  late final _SDL_IsTextInputActivePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_IsTextInputActive');
  late final _SDL_IsTextInputActive =
      _SDL_IsTextInputActivePtr.asFunction<int Function()>();

  /// \brief Stop receiving any text input events.
  /// This function will hide the on-screen keyboard if supported.
  ///
  /// \sa SDL_StartTextInput()
  /// \sa SDL_HasScreenKeyboardSupport()
  void SDL_StopTextInput() {
    return _SDL_StopTextInput();
  }

  late final _SDL_StopTextInputPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_StopTextInput');
  late final _SDL_StopTextInput =
      _SDL_StopTextInputPtr.asFunction<void Function()>();

  /// \brief Set the rectangle used to type Unicode text inputs.
  /// This is used as a hint for IME and on-screen keyboard placement.
  ///
  /// \sa SDL_StartTextInput()
  void SDL_SetTextInputRect(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetTextInputRect(
      rect,
    );
  }

  late final _SDL_SetTextInputRectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Rect>)>>(
          'SDL_SetTextInputRect');
  late final _SDL_SetTextInputRect = _SDL_SetTextInputRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Rect>)>();

  /// \brief Returns whether the platform has some screen keyboard support.
  ///
  /// \return SDL_TRUE if some keyboard support is available else SDL_FALSE.
  ///
  /// \note Not all screen keyboard functions are supported on all platforms.
  ///
  /// \sa SDL_IsScreenKeyboardShown()
  int SDL_HasScreenKeyboardSupport() {
    return _SDL_HasScreenKeyboardSupport();
  }

  late final _SDL_HasScreenKeyboardSupportPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_HasScreenKeyboardSupport');
  late final _SDL_HasScreenKeyboardSupport =
      _SDL_HasScreenKeyboardSupportPtr.asFunction<int Function()>();

  /// \brief Returns whether the screen keyboard is shown for given window.
  ///
  /// \param window The window for which screen keyboard should be queried.
  ///
  /// \return SDL_TRUE if screen keyboard is shown else SDL_FALSE.
  ///
  /// \sa SDL_HasScreenKeyboardSupport()
  int SDL_IsScreenKeyboardShown(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsScreenKeyboardShown(
      window,
    );
  }

  late final _SDL_IsScreenKeyboardShownPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsScreenKeyboardShown');
  late final _SDL_IsScreenKeyboardShown = _SDL_IsScreenKeyboardShownPtr
      .asFunction<int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Get the window which currently has mouse focus.
  ffi.Pointer<SDL_Window> SDL_GetMouseFocus() {
    return _SDL_GetMouseFocus();
  }

  late final _SDL_GetMouseFocusPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Window> Function()>>(
          'SDL_GetMouseFocus');
  late final _SDL_GetMouseFocus =
      _SDL_GetMouseFocusPtr.asFunction<ffi.Pointer<SDL_Window> Function()>();

  /// \brief Retrieve the current state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can
  /// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  /// mouse cursor position relative to the focus window for the currently
  /// selected mouse.  You can pass NULL for either x or y.
  int SDL_GetMouseState(
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetMouseState');
  late final _SDL_GetMouseState = _SDL_GetMouseStatePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Get the current state of the mouse, in relation to the desktop
  ///
  /// This works just like SDL_GetMouseState(), but the coordinates will be
  /// reported relative to the top-left of the desktop. This can be useful if
  /// you need to track the mouse outside of a specific window and
  /// SDL_CaptureMouse() doesn't fit your needs. For example, it could be
  /// useful if you need to track the mouse while dragging a window, where
  /// coordinates relative to a window might not be in sync at all times.
  ///
  /// \note SDL_GetMouseState() returns the mouse position as SDL understands
  /// it from the last pump of the event queue. This function, however,
  /// queries the OS for the current mouse position, and as such, might
  /// be a slightly less efficient function. Unless you know what you're
  /// doing and have a good reason to use this function, you probably want
  /// SDL_GetMouseState() instead.
  ///
  /// \param x Returns the current X coord, relative to the desktop. Can be NULL.
  /// \param y Returns the current Y coord, relative to the desktop. Can be NULL.
  /// \return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros.
  ///
  /// \sa SDL_GetMouseState
  int SDL_GetGlobalMouseState(
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetGlobalMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetGlobalMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetGlobalMouseState');
  late final _SDL_GetGlobalMouseState = _SDL_GetGlobalMouseStatePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Retrieve the relative state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can
  /// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  /// mouse deltas since the last call to SDL_GetRelativeMouseState().
  int SDL_GetRelativeMouseState(
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetRelativeMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetRelativeMouseStatePtr = _lookup<
      ffi.NativeFunction<
          Uint32 Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetRelativeMouseState');
  late final _SDL_GetRelativeMouseState =
      _SDL_GetRelativeMouseStatePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Moves the mouse to the given position within the window.
  ///
  /// \param window The window to move the mouse into, or NULL for the current mouse focus
  /// \param x The x coordinate within the window
  /// \param y The y coordinate within the window
  ///
  /// \note This function generates a mouse motion event
  void SDL_WarpMouseInWindow(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_WarpMouseInWindow(
      window,
      x,
      y,
    );
  }

  late final _SDL_WarpMouseInWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Int32,
              ffi.Int32)>>('SDL_WarpMouseInWindow');
  late final _SDL_WarpMouseInWindow = _SDL_WarpMouseInWindowPtr.asFunction<
      void Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// \brief Moves the mouse to the given position in global screen space.
  ///
  /// \param x The x coordinate
  /// \param y The y coordinate
  /// \return 0 on success, -1 on error (usually: unsupported by a platform).
  ///
  /// \note This function generates a mouse motion event
  int SDL_WarpMouseGlobal(
    int x,
    int y,
  ) {
    return _SDL_WarpMouseGlobal(
      x,
      y,
    );
  }

  late final _SDL_WarpMouseGlobalPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
          'SDL_WarpMouseGlobal');
  late final _SDL_WarpMouseGlobal =
      _SDL_WarpMouseGlobalPtr.asFunction<int Function(int, int)>();

  /// \brief Set relative mouse mode.
  ///
  /// \param enabled Whether or not to enable relative mode
  ///
  /// \return 0 on success, or -1 if relative mode is not supported.
  ///
  /// While the mouse is in relative mode, the cursor is hidden, and the
  /// driver will try to report continuous motion in the current window.
  /// Only relative motion events will be delivered, the mouse position
  /// will not change.
  ///
  /// \note This function will flush any pending mouse motion.
  ///
  /// \sa SDL_GetRelativeMouseMode()
  int SDL_SetRelativeMouseMode(
    int enabled,
  ) {
    return _SDL_SetRelativeMouseMode(
      enabled,
    );
  }

  late final _SDL_SetRelativeMouseModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_SetRelativeMouseMode');
  late final _SDL_SetRelativeMouseMode =
      _SDL_SetRelativeMouseModePtr.asFunction<int Function(int)>();

  /// \brief Capture the mouse, to track input outside an SDL window.
  ///
  /// \param enabled Whether or not to enable capturing
  ///
  /// Capturing enables your app to obtain mouse events globally, instead of
  /// just within your window. Not all video targets support this function.
  /// When capturing is enabled, the current window will get all mouse events,
  /// but unlike relative mode, no change is made to the cursor and it is
  /// not restrained to your window.
  ///
  /// This function may also deny mouse input to other windows--both those in
  /// your application and others on the system--so you should use this
  /// function sparingly, and in small bursts. For example, you might want to
  /// track the mouse while the user is dragging something, until the user
  /// releases a mouse button. It is not recommended that you capture the mouse
  /// for long periods of time, such as the entire time your app is running.
  ///
  /// While captured, mouse events still report coordinates relative to the
  /// current (foreground) window, but those coordinates may be outside the
  /// bounds of the window (including negative values). Capturing is only
  /// allowed for the foreground window. If the window loses focus while
  /// capturing, the capture will be disabled automatically.
  ///
  /// While capturing is enabled, the current window will have the
  /// SDL_WINDOW_MOUSE_CAPTURE flag set.
  ///
  /// \return 0 on success, or -1 if not supported.
  int SDL_CaptureMouse(
    int enabled,
  ) {
    return _SDL_CaptureMouse(
      enabled,
    );
  }

  late final _SDL_CaptureMousePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_CaptureMouse');
  late final _SDL_CaptureMouse =
      _SDL_CaptureMousePtr.asFunction<int Function(int)>();

  /// \brief Query whether relative mouse mode is enabled.
  ///
  /// \sa SDL_SetRelativeMouseMode()
  int SDL_GetRelativeMouseMode() {
    return _SDL_GetRelativeMouseMode();
  }

  late final _SDL_GetRelativeMouseModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetRelativeMouseMode');
  late final _SDL_GetRelativeMouseMode =
      _SDL_GetRelativeMouseModePtr.asFunction<int Function()>();

  /// \brief Create a cursor, using the specified bitmap data and
  /// mask (in MSB format).
  ///
  /// The cursor width must be a multiple of 8 bits.
  ///
  /// The cursor is created in black and white according to the following:
  /// <table>
  /// <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>
  /// <tr><td>  0   </td><td>  1   </td><td> White </td></tr>
  /// <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>
  /// <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>
  /// <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black
  /// if not. </td></tr>
  /// </table>
  ///
  /// \sa SDL_FreeCursor()
  ffi.Pointer<SDL_Cursor> SDL_CreateCursor(
    ffi.Pointer<Uint8> data,
    ffi.Pointer<Uint8> mask,
    int w,
    int h,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateCursor(
      data,
      mask,
      w,
      h,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('SDL_CreateCursor');
  late final _SDL_CreateCursor = _SDL_CreateCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, int, int, int, int)>();

  /// \brief Create a color cursor.
  ///
  /// \sa SDL_FreeCursor()
  ffi.Pointer<SDL_Cursor> SDL_CreateColorCursor(
    ffi.Pointer<SDL_Surface> surface,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateColorCursor(
      surface,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateColorCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, ffi.Int32,
              ffi.Int32)>>('SDL_CreateColorCursor');
  late final _SDL_CreateColorCursor = _SDL_CreateColorCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(ffi.Pointer<SDL_Surface>, int, int)>();

  /// \brief Create a system cursor.
  ///
  /// \sa SDL_FreeCursor()
  ffi.Pointer<SDL_Cursor> SDL_CreateSystemCursor(
    int id,
  ) {
    return _SDL_CreateSystemCursor(
      id,
    );
  }

  late final _SDL_CreateSystemCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function(ffi.Int32)>>(
          'SDL_CreateSystemCursor');
  late final _SDL_CreateSystemCursor = _SDL_CreateSystemCursorPtr.asFunction<
      ffi.Pointer<SDL_Cursor> Function(int)>();

  /// \brief Set the active cursor.
  void SDL_SetCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_SetCursor(
      cursor,
    );
  }

  late final _SDL_SetCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_SetCursor');
  late final _SDL_SetCursor =
      _SDL_SetCursorPtr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// \brief Return the active cursor.
  ffi.Pointer<SDL_Cursor> SDL_GetCursor() {
    return _SDL_GetCursor();
  }

  late final _SDL_GetCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetCursor');
  late final _SDL_GetCursor =
      _SDL_GetCursorPtr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// \brief Return the default cursor.
  ffi.Pointer<SDL_Cursor> SDL_GetDefaultCursor() {
    return _SDL_GetDefaultCursor();
  }

  late final _SDL_GetDefaultCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Cursor> Function()>>(
          'SDL_GetDefaultCursor');
  late final _SDL_GetDefaultCursor =
      _SDL_GetDefaultCursorPtr.asFunction<ffi.Pointer<SDL_Cursor> Function()>();

  /// \brief Frees a cursor created with SDL_CreateCursor() or similar functions.
  ///
  /// \sa SDL_CreateCursor()
  /// \sa SDL_CreateColorCursor()
  /// \sa SDL_CreateSystemCursor()
  void SDL_FreeCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_FreeCursor(
      cursor,
    );
  }

  late final _SDL_FreeCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Cursor>)>>(
          'SDL_FreeCursor');
  late final _SDL_FreeCursor =
      _SDL_FreeCursorPtr.asFunction<void Function(ffi.Pointer<SDL_Cursor>)>();

  /// \brief Toggle whether or not the cursor is shown.
  ///
  /// \param toggle 1 to show the cursor, 0 to hide it, -1 to query the current
  /// state.
  ///
  /// \return 1 if the cursor is shown, or 0 if the cursor is hidden.
  int SDL_ShowCursor(
    int toggle,
  ) {
    return _SDL_ShowCursor(
      toggle,
    );
  }

  late final _SDL_ShowCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_ShowCursor');
  late final _SDL_ShowCursor =
      _SDL_ShowCursorPtr.asFunction<int Function(int)>();

  /// Locking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  void SDL_LockJoysticks() {
    return _SDL_LockJoysticks();
  }

  late final _SDL_LockJoysticksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockJoysticks');
  late final _SDL_LockJoysticks =
      _SDL_LockJoysticksPtr.asFunction<void Function()>();

  void SDL_UnlockJoysticks() {
    return _SDL_UnlockJoysticks();
  }

  late final _SDL_UnlockJoysticksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockJoysticks');
  late final _SDL_UnlockJoysticks =
      _SDL_UnlockJoysticksPtr.asFunction<void Function()>();

  /// Count the number of joysticks attached to the system right now
  int SDL_NumJoysticks() {
    return _SDL_NumJoysticks();
  }

  late final _SDL_NumJoysticksPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_NumJoysticks');
  late final _SDL_NumJoysticks =
      _SDL_NumJoysticksPtr.asFunction<int Function()>();

  /// Get the implementation dependent name of a joystick.
  /// This can be called before any joysticks are opened.
  /// If no name can be found, this function returns NULL.
  ffi.Pointer<ffi.Int8> SDL_JoystickNameForIndex(
    int device_index,
  ) {
    return _SDL_JoystickNameForIndex(
      device_index,
    );
  }

  late final _SDL_JoystickNameForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_JoystickNameForIndex');
  late final _SDL_JoystickNameForIndex = _SDL_JoystickNameForIndexPtr
      .asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// Get the player index of a joystick, or -1 if it's not available
  /// This can be called before any joysticks are opened.
  int SDL_JoystickGetDevicePlayerIndex(
    int device_index,
  ) {
    return _SDL_JoystickGetDevicePlayerIndex(
      device_index,
    );
  }

  late final _SDL_JoystickGetDevicePlayerIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_JoystickGetDevicePlayerIndex');
  late final _SDL_JoystickGetDevicePlayerIndex =
      _SDL_JoystickGetDevicePlayerIndexPtr.asFunction<int Function(int)>();

  /// Return the GUID for the joystick at this index
  /// This can be called before any joysticks are opened.
  SDL_JoystickGUID SDL_JoystickGetDeviceGUID(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceGUID(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceGUIDPtr =
      _lookup<ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Int32)>>(
          'SDL_JoystickGetDeviceGUID');
  late final _SDL_JoystickGetDeviceGUID = _SDL_JoystickGetDeviceGUIDPtr
      .asFunction<SDL_JoystickGUID Function(int)>();

  /// Get the USB vendor ID of a joystick, if available.
  /// This can be called before any joysticks are opened.
  /// If the vendor ID isn't available this function returns 0.
  int SDL_JoystickGetDeviceVendor(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceVendor(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceVendorPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int32)>>(
          'SDL_JoystickGetDeviceVendor');
  late final _SDL_JoystickGetDeviceVendor =
      _SDL_JoystickGetDeviceVendorPtr.asFunction<int Function(int)>();

  /// Get the USB product ID of a joystick, if available.
  /// This can be called before any joysticks are opened.
  /// If the product ID isn't available this function returns 0.
  int SDL_JoystickGetDeviceProduct(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProduct(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int32)>>(
          'SDL_JoystickGetDeviceProduct');
  late final _SDL_JoystickGetDeviceProduct =
      _SDL_JoystickGetDeviceProductPtr.asFunction<int Function(int)>();

  /// Get the product version of a joystick, if available.
  /// This can be called before any joysticks are opened.
  /// If the product version isn't available this function returns 0.
  int SDL_JoystickGetDeviceProductVersion(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProductVersion(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductVersionPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Int32)>>(
          'SDL_JoystickGetDeviceProductVersion');
  late final _SDL_JoystickGetDeviceProductVersion =
      _SDL_JoystickGetDeviceProductVersionPtr.asFunction<int Function(int)>();

  /// Get the type of a joystick, if available.
  /// This can be called before any joysticks are opened.
  int SDL_JoystickGetDeviceType(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceType(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_JoystickGetDeviceType');
  late final _SDL_JoystickGetDeviceType =
      _SDL_JoystickGetDeviceTypePtr.asFunction<int Function(int)>();

  /// Get the instance ID of a joystick.
  /// This can be called before any joysticks are opened.
  /// If the index is out of range, this function will return -1.
  int SDL_JoystickGetDeviceInstanceID(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceInstanceID(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceInstanceIDPtr =
      _lookup<ffi.NativeFunction<SDL_JoystickID Function(ffi.Int32)>>(
          'SDL_JoystickGetDeviceInstanceID');
  late final _SDL_JoystickGetDeviceInstanceID =
      _SDL_JoystickGetDeviceInstanceIDPtr.asFunction<int Function(int)>();

  /// Open a joystick for use.
  /// The index passed as an argument refers to the N'th joystick on the system.
  /// This index is not the value which will identify this joystick in future
  /// joystick events.  The joystick's instance id (::SDL_JoystickID) will be used
  /// there instead.
  ///
  /// \return A joystick identifier, or NULL if an error occurred.
  ffi.Pointer<SDL_Joystick1> SDL_JoystickOpen(
    int device_index,
  ) {
    return _SDL_JoystickOpen(
      device_index,
    );
  }

  late final _SDL_JoystickOpenPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_Joystick1> Function(ffi.Int32)>>(
      'SDL_JoystickOpen');
  late final _SDL_JoystickOpen = _SDL_JoystickOpenPtr.asFunction<
      ffi.Pointer<SDL_Joystick1> Function(int)>();

  /// Return the SDL_Joystick associated with an instance id.
  ffi.Pointer<SDL_Joystick1> SDL_JoystickFromInstanceID(
    int instance_id,
  ) {
    return _SDL_JoystickFromInstanceID(
      instance_id,
    );
  }

  late final _SDL_JoystickFromInstanceIDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Joystick1> Function(
              SDL_JoystickID)>>('SDL_JoystickFromInstanceID');
  late final _SDL_JoystickFromInstanceID = _SDL_JoystickFromInstanceIDPtr
      .asFunction<ffi.Pointer<SDL_Joystick1> Function(int)>();

  /// Return the SDL_Joystick associated with a player index.
  ffi.Pointer<SDL_Joystick1> SDL_JoystickFromPlayerIndex(
    int player_index,
  ) {
    return _SDL_JoystickFromPlayerIndex(
      player_index,
    );
  }

  late final _SDL_JoystickFromPlayerIndexPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_Joystick1> Function(ffi.Int32)>>(
      'SDL_JoystickFromPlayerIndex');
  late final _SDL_JoystickFromPlayerIndex = _SDL_JoystickFromPlayerIndexPtr
      .asFunction<ffi.Pointer<SDL_Joystick1> Function(int)>();

  /// Attaches a new virtual joystick.
  /// Returns the joystick's device index, or -1 if an error occurred.
  int SDL_JoystickAttachVirtual(
    int type,
    int naxes,
    int nbuttons,
    int nhats,
  ) {
    return _SDL_JoystickAttachVirtual(
      type,
      naxes,
      nbuttons,
      nhats,
    );
  }

  late final _SDL_JoystickAttachVirtualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32)>>('SDL_JoystickAttachVirtual');
  late final _SDL_JoystickAttachVirtual = _SDL_JoystickAttachVirtualPtr
      .asFunction<int Function(int, int, int, int)>();

  /// Detaches a virtual joystick
  /// Returns 0 on success, or -1 if an error occurred.
  int SDL_JoystickDetachVirtual(
    int device_index,
  ) {
    return _SDL_JoystickDetachVirtual(
      device_index,
    );
  }

  late final _SDL_JoystickDetachVirtualPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_JoystickDetachVirtual');
  late final _SDL_JoystickDetachVirtual =
      _SDL_JoystickDetachVirtualPtr.asFunction<int Function(int)>();

  /// Indicates whether or not a virtual-joystick is at a given device index.
  int SDL_JoystickIsVirtual(
    int device_index,
  ) {
    return _SDL_JoystickIsVirtual(
      device_index,
    );
  }

  late final _SDL_JoystickIsVirtualPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_JoystickIsVirtual');
  late final _SDL_JoystickIsVirtual =
      _SDL_JoystickIsVirtualPtr.asFunction<int Function(int)>();

  /// Set values on an opened, virtual-joystick's controls.
  /// Please note that values set here will not be applied until the next
  /// call to SDL_JoystickUpdate, which can either be called directly,
  /// or can be called indirectly through various other SDL APIS,
  /// including, but not limited to the following: SDL_PollEvent,
  /// SDL_PumpEvents, SDL_WaitEventTimeout, SDL_WaitEvent.
  ///
  /// Returns 0 on success, -1 on error.
  int SDL_JoystickSetVirtualAxis(
    ffi.Pointer<SDL_Joystick1> joystick,
    int axis,
    int value,
  ) {
    return _SDL_JoystickSetVirtualAxis(
      joystick,
      axis,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, ffi.Int32,
              Sint16)>>('SDL_JoystickSetVirtualAxis');
  late final _SDL_JoystickSetVirtualAxis = _SDL_JoystickSetVirtualAxisPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>, int, int)>();

  int SDL_JoystickSetVirtualButton(
    ffi.Pointer<SDL_Joystick1> joystick,
    int button,
    int value,
  ) {
    return _SDL_JoystickSetVirtualButton(
      joystick,
      button,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualButtonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, ffi.Int32,
              Uint8)>>('SDL_JoystickSetVirtualButton');
  late final _SDL_JoystickSetVirtualButton = _SDL_JoystickSetVirtualButtonPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>, int, int)>();

  int SDL_JoystickSetVirtualHat(
    ffi.Pointer<SDL_Joystick1> joystick,
    int hat,
    int value,
  ) {
    return _SDL_JoystickSetVirtualHat(
      joystick,
      hat,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualHatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, ffi.Int32,
              Uint8)>>('SDL_JoystickSetVirtualHat');
  late final _SDL_JoystickSetVirtualHat = _SDL_JoystickSetVirtualHatPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>, int, int)>();

  /// Return the name for this currently opened joystick.
  /// If no name can be found, this function returns NULL.
  ffi.Pointer<ffi.Int8> SDL_JoystickName(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickName(
      joystick,
    );
  }

  late final _SDL_JoystickNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_Joystick1>)>>('SDL_JoystickName');
  late final _SDL_JoystickName = _SDL_JoystickNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the player index of an opened joystick, or -1 if it's not available
  ///
  /// For XInput controllers this returns the XInput user index.
  int SDL_JoystickGetPlayerIndex(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetPlayerIndex(
      joystick,
    );
  }

  late final _SDL_JoystickGetPlayerIndexPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickGetPlayerIndex');
  late final _SDL_JoystickGetPlayerIndex = _SDL_JoystickGetPlayerIndexPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Set the player index of an opened joystick
  void SDL_JoystickSetPlayerIndex(
    ffi.Pointer<SDL_Joystick1> joystick,
    int player_index,
  ) {
    return _SDL_JoystickSetPlayerIndex(
      joystick,
      player_index,
    );
  }

  late final _SDL_JoystickSetPlayerIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Joystick1>,
              ffi.Int32)>>('SDL_JoystickSetPlayerIndex');
  late final _SDL_JoystickSetPlayerIndex = _SDL_JoystickSetPlayerIndexPtr
      .asFunction<void Function(ffi.Pointer<SDL_Joystick1>, int)>();

  /// Return the GUID for this opened joystick
  SDL_JoystickGUID SDL_JoystickGetGUID(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetGUID(
      joystick,
    );
  }

  late final _SDL_JoystickGetGUIDPtr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickGUID Function(
              ffi.Pointer<SDL_Joystick1>)>>('SDL_JoystickGetGUID');
  late final _SDL_JoystickGetGUID = _SDL_JoystickGetGUIDPtr.asFunction<
      SDL_JoystickGUID Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the USB vendor ID of an opened joystick, if available.
  /// If the vendor ID isn't available this function returns 0.
  int SDL_JoystickGetVendor(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetVendor(
      joystick,
    );
  }

  late final _SDL_JoystickGetVendorPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick1>)>>(
          'SDL_JoystickGetVendor');
  late final _SDL_JoystickGetVendor = _SDL_JoystickGetVendorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the USB product ID of an opened joystick, if available.
  /// If the product ID isn't available this function returns 0.
  int SDL_JoystickGetProduct(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetProduct(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick1>)>>(
          'SDL_JoystickGetProduct');
  late final _SDL_JoystickGetProduct = _SDL_JoystickGetProductPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the product version of an opened joystick, if available.
  /// If the product version isn't available this function returns 0.
  int SDL_JoystickGetProductVersion(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetProductVersion(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductVersionPtr =
      _lookup<ffi.NativeFunction<Uint16 Function(ffi.Pointer<SDL_Joystick1>)>>(
          'SDL_JoystickGetProductVersion');
  late final _SDL_JoystickGetProductVersion = _SDL_JoystickGetProductVersionPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the serial number of an opened joystick, if available.
  ///
  /// Returns the serial number of the joystick, or NULL if it is not available.
  ffi.Pointer<ffi.Int8> SDL_JoystickGetSerial(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetSerial(
      joystick,
    );
  }

  late final _SDL_JoystickGetSerialPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_Joystick1>)>>('SDL_JoystickGetSerial');
  late final _SDL_JoystickGetSerial = _SDL_JoystickGetSerialPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the type of an opened joystick.
  int SDL_JoystickGetType(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetType(
      joystick,
    );
  }

  late final _SDL_JoystickGetTypePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickGetType');
  late final _SDL_JoystickGetType = _SDL_JoystickGetTypePtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Return a string representation for this guid. pszGUID must point to at least 33 bytes
  /// (32 for the string plus a NULL terminator).
  void SDL_JoystickGetGUIDString(
    SDL_JoystickGUID guid,
    ffi.Pointer<ffi.Int8> pszGUID,
    int cbGUID,
  ) {
    return _SDL_JoystickGetGUIDString(
      guid,
      pszGUID,
      cbGUID,
    );
  }

  late final _SDL_JoystickGetGUIDStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('SDL_JoystickGetGUIDString');
  late final _SDL_JoystickGetGUIDString =
      _SDL_JoystickGetGUIDStringPtr.asFunction<
          void Function(SDL_JoystickGUID, ffi.Pointer<ffi.Int8>, int)>();

  /// Convert a string into a joystick guid
  SDL_JoystickGUID SDL_JoystickGetGUIDFromString(
    ffi.Pointer<ffi.Int8> pchGUID,
  ) {
    return _SDL_JoystickGetGUIDFromString(
      pchGUID,
    );
  }

  late final _SDL_JoystickGetGUIDFromStringPtr = _lookup<
          ffi.NativeFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Int8>)>>(
      'SDL_JoystickGetGUIDFromString');
  late final _SDL_JoystickGetGUIDFromString = _SDL_JoystickGetGUIDFromStringPtr
      .asFunction<SDL_JoystickGUID Function(ffi.Pointer<ffi.Int8>)>();

  /// Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not.
  int SDL_JoystickGetAttached(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickGetAttached(
      joystick,
    );
  }

  late final _SDL_JoystickGetAttachedPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickGetAttached');
  late final _SDL_JoystickGetAttached = _SDL_JoystickGetAttachedPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the instance ID of an opened joystick or -1 if the joystick is invalid.
  int SDL_JoystickInstanceID(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickInstanceID(
      joystick,
    );
  }

  late final _SDL_JoystickInstanceIDPtr = _lookup<
      ffi.NativeFunction<
          SDL_JoystickID Function(
              ffi.Pointer<SDL_Joystick1>)>>('SDL_JoystickInstanceID');
  late final _SDL_JoystickInstanceID = _SDL_JoystickInstanceIDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the number of general axis controls on a joystick.
  int SDL_JoystickNumAxes(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickNumAxes(
      joystick,
    );
  }

  late final _SDL_JoystickNumAxesPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickNumAxes');
  late final _SDL_JoystickNumAxes = _SDL_JoystickNumAxesPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the number of trackballs on a joystick.
  ///
  /// Joystick trackballs have only relative motion events associated
  /// with them and their state cannot be polled.
  int SDL_JoystickNumBalls(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickNumBalls(
      joystick,
    );
  }

  late final _SDL_JoystickNumBallsPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickNumBalls');
  late final _SDL_JoystickNumBalls = _SDL_JoystickNumBallsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the number of POV hats on a joystick.
  int SDL_JoystickNumHats(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickNumHats(
      joystick,
    );
  }

  late final _SDL_JoystickNumHatsPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickNumHats');
  late final _SDL_JoystickNumHats = _SDL_JoystickNumHatsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Get the number of buttons on a joystick.
  int SDL_JoystickNumButtons(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickNumButtons(
      joystick,
    );
  }

  late final _SDL_JoystickNumButtonsPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickNumButtons');
  late final _SDL_JoystickNumButtons = _SDL_JoystickNumButtonsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Update the current state of the open joysticks.
  ///
  /// This is called automatically by the event loop if any joystick
  /// events are enabled.
  void SDL_JoystickUpdate() {
    return _SDL_JoystickUpdate();
  }

  late final _SDL_JoystickUpdatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_JoystickUpdate');
  late final _SDL_JoystickUpdate =
      _SDL_JoystickUpdatePtr.asFunction<void Function()>();

  /// Enable/disable joystick event polling.
  ///
  /// If joystick events are disabled, you must call SDL_JoystickUpdate()
  /// yourself and check the state of the joystick when you want joystick
  /// information.
  ///
  /// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
  int SDL_JoystickEventState(
    int state,
  ) {
    return _SDL_JoystickEventState(
      state,
    );
  }

  late final _SDL_JoystickEventStatePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_JoystickEventState');
  late final _SDL_JoystickEventState =
      _SDL_JoystickEventStatePtr.asFunction<int Function(int)>();

  /// Get the current state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  int SDL_JoystickGetAxis(
    ffi.Pointer<SDL_Joystick1> joystick,
    int axis,
  ) {
    return _SDL_JoystickGetAxis(
      joystick,
      axis,
    );
  }

  late final _SDL_JoystickGetAxisPtr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(
              ffi.Pointer<SDL_Joystick1>, ffi.Int32)>>('SDL_JoystickGetAxis');
  late final _SDL_JoystickGetAxis = _SDL_JoystickGetAxisPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>, int)>();

  /// Get the initial state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  ///
  /// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
  int SDL_JoystickGetAxisInitialState(
    ffi.Pointer<SDL_Joystick1> joystick,
    int axis,
    ffi.Pointer<Sint16> state,
  ) {
    return _SDL_JoystickGetAxisInitialState(
      joystick,
      axis,
      state,
    );
  }

  late final _SDL_JoystickGetAxisInitialStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, ffi.Int32,
              ffi.Pointer<Sint16>)>>('SDL_JoystickGetAxisInitialState');
  late final _SDL_JoystickGetAxisInitialState =
      _SDL_JoystickGetAxisInitialStatePtr.asFunction<
          int Function(ffi.Pointer<SDL_Joystick1>, int, ffi.Pointer<Sint16>)>();

  /// Get the current state of a POV hat on a joystick.
  ///
  /// The hat indices start at index 0.
  ///
  /// \return The return value is one of the following positions:
  /// - ::SDL_HAT_CENTERED
  /// - ::SDL_HAT_UP
  /// - ::SDL_HAT_RIGHT
  /// - ::SDL_HAT_DOWN
  /// - ::SDL_HAT_LEFT
  /// - ::SDL_HAT_RIGHTUP
  /// - ::SDL_HAT_RIGHTDOWN
  /// - ::SDL_HAT_LEFTUP
  /// - ::SDL_HAT_LEFTDOWN
  int SDL_JoystickGetHat(
    ffi.Pointer<SDL_Joystick1> joystick,
    int hat,
  ) {
    return _SDL_JoystickGetHat(
      joystick,
      hat,
    );
  }

  late final _SDL_JoystickGetHatPtr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick1>, ffi.Int32)>>('SDL_JoystickGetHat');
  late final _SDL_JoystickGetHat = _SDL_JoystickGetHatPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>, int)>();

  /// Get the ball axis change since the last poll.
  ///
  /// \return 0, or -1 if you passed it invalid parameters.
  ///
  /// The ball indices start at index 0.
  int SDL_JoystickGetBall(
    ffi.Pointer<SDL_Joystick1> joystick,
    int ball,
    ffi.Pointer<ffi.Int32> dx,
    ffi.Pointer<ffi.Int32> dy,
  ) {
    return _SDL_JoystickGetBall(
      joystick,
      ball,
      dx,
      dy,
    );
  }

  late final _SDL_JoystickGetBallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Joystick1>,
              ffi.Int32,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_JoystickGetBall');
  late final _SDL_JoystickGetBall = _SDL_JoystickGetBallPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>, int, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// Get the current state of a button on a joystick.
  ///
  /// The button indices start at index 0.
  int SDL_JoystickGetButton(
    ffi.Pointer<SDL_Joystick1> joystick,
    int button,
  ) {
    return _SDL_JoystickGetButton(
      joystick,
      button,
    );
  }

  late final _SDL_JoystickGetButtonPtr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(
              ffi.Pointer<SDL_Joystick1>, ffi.Int32)>>('SDL_JoystickGetButton');
  late final _SDL_JoystickGetButton = _SDL_JoystickGetButtonPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>, int)>();

  /// Start a rumble effect
  /// Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if rumble isn't supported on this joystick
  int SDL_JoystickRumble(
    ffi.Pointer<SDL_Joystick1> joystick,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumble(
      joystick,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumble');
  late final _SDL_JoystickRumble = _SDL_JoystickRumblePtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>, int, int, int)>();

  /// Start a rumble effect in the joystick's triggers
  /// Each call to this function cancels any previous trigger rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0 to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if trigger rumble isn't supported on this joystick
  int SDL_JoystickRumbleTriggers(
    ffi.Pointer<SDL_Joystick1> joystick,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumbleTriggers(
      joystick,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumbleTriggersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, Uint16, Uint16,
              Uint32)>>('SDL_JoystickRumbleTriggers');
  late final _SDL_JoystickRumbleTriggers = _SDL_JoystickRumbleTriggersPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>, int, int, int)>();

  /// Return whether a joystick has an LED
  ///
  /// \param joystick The joystick to query
  ///
  /// \return SDL_TRUE, or SDL_FALSE if this joystick does not have a modifiable LED
  int SDL_JoystickHasLED(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickHasLED(
      joystick,
    );
  }

  late final _SDL_JoystickHasLEDPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickHasLED');
  late final _SDL_JoystickHasLED = _SDL_JoystickHasLEDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Update a joystick's LED color.
  ///
  /// \param joystick The joystick to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  ///
  /// \return 0, or -1 if this joystick does not have a modifiable LED
  int SDL_JoystickSetLED(
    ffi.Pointer<SDL_Joystick1> joystick,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_JoystickSetLED(
      joystick,
      red,
      green,
      blue,
    );
  }

  late final _SDL_JoystickSetLEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>, Uint8, Uint8,
              Uint8)>>('SDL_JoystickSetLED');
  late final _SDL_JoystickSetLED = _SDL_JoystickSetLEDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>, int, int, int)>();

  /// Close a joystick previously opened with SDL_JoystickOpen().
  void SDL_JoystickClose(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickClose(
      joystick,
    );
  }

  late final _SDL_JoystickClosePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickClose');
  late final _SDL_JoystickClose = _SDL_JoystickClosePtr.asFunction<
      void Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Return the battery level of this joystick
  int SDL_JoystickCurrentPowerLevel(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickCurrentPowerLevel(
      joystick,
    );
  }

  late final _SDL_JoystickCurrentPowerLevelPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickCurrentPowerLevel');
  late final _SDL_JoystickCurrentPowerLevel = _SDL_JoystickCurrentPowerLevelPtr
      .asFunction<int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// Locking for multi-threaded access to the sensor API
  ///
  /// If you are using the sensor API or handling events from multiple threads
  /// you should use these locking functions to protect access to the sensors.
  ///
  /// In particular, you are guaranteed that the sensor list won't change, so
  /// the API functions that take a sensor index will be valid, and sensor
  /// events will not be delivered.
  void SDL_LockSensors() {
    return _SDL_LockSensors();
  }

  late final _SDL_LockSensorsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_LockSensors');
  late final _SDL_LockSensors =
      _SDL_LockSensorsPtr.asFunction<void Function()>();

  void SDL_UnlockSensors() {
    return _SDL_UnlockSensors();
  }

  late final _SDL_UnlockSensorsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_UnlockSensors');
  late final _SDL_UnlockSensors =
      _SDL_UnlockSensorsPtr.asFunction<void Function()>();

  /// \brief Count the number of sensors attached to the system right now
  int SDL_NumSensors() {
    return _SDL_NumSensors();
  }

  late final _SDL_NumSensorsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_NumSensors');
  late final _SDL_NumSensors = _SDL_NumSensorsPtr.asFunction<int Function()>();

  /// \brief Get the implementation dependent name of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor name, or NULL if device_index is out of range.
  ffi.Pointer<ffi.Int8> SDL_SensorGetDeviceName(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceName(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_SensorGetDeviceName');
  late final _SDL_SensorGetDeviceName = _SDL_SensorGetDeviceNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Get the type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor type, or SDL_SENSOR_INVALID if device_index is out of range.
  int SDL_SensorGetDeviceType(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceType(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_SensorGetDeviceType');
  late final _SDL_SensorGetDeviceType =
      _SDL_SensorGetDeviceTypePtr.asFunction<int Function(int)>();

  /// \brief Get the platform dependent type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor platform dependent type, or -1 if device_index is out of range.
  int SDL_SensorGetDeviceNonPortableType(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceNonPortableType(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNonPortableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_SensorGetDeviceNonPortableType');
  late final _SDL_SensorGetDeviceNonPortableType =
      _SDL_SensorGetDeviceNonPortableTypePtr.asFunction<int Function(int)>();

  /// \brief Get the instance ID of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor instance ID, or -1 if device_index is out of range.
  int SDL_SensorGetDeviceInstanceID(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceInstanceID(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceInstanceIDPtr =
      _lookup<ffi.NativeFunction<SDL_SensorID Function(ffi.Int32)>>(
          'SDL_SensorGetDeviceInstanceID');
  late final _SDL_SensorGetDeviceInstanceID =
      _SDL_SensorGetDeviceInstanceIDPtr.asFunction<int Function(int)>();

  /// \brief Open a sensor for use.
  ///
  /// The index passed as an argument refers to the N'th sensor on the system.
  ///
  /// \return A sensor identifier, or NULL if an error occurred.
  ffi.Pointer<SDL_Sensor1> SDL_SensorOpen(
    int device_index,
  ) {
    return _SDL_SensorOpen(
      device_index,
    );
  }

  late final _SDL_SensorOpenPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Sensor1> Function(ffi.Int32)>>(
          'SDL_SensorOpen');
  late final _SDL_SensorOpen =
      _SDL_SensorOpenPtr.asFunction<ffi.Pointer<SDL_Sensor1> Function(int)>();

  /// Return the SDL_Sensor associated with an instance id.
  ffi.Pointer<SDL_Sensor1> SDL_SensorFromInstanceID(
    int instance_id,
  ) {
    return _SDL_SensorFromInstanceID(
      instance_id,
    );
  }

  late final _SDL_SensorFromInstanceIDPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<SDL_Sensor1> Function(SDL_SensorID)>>(
      'SDL_SensorFromInstanceID');
  late final _SDL_SensorFromInstanceID = _SDL_SensorFromInstanceIDPtr
      .asFunction<ffi.Pointer<SDL_Sensor1> Function(int)>();

  /// \brief Get the implementation dependent name of a sensor.
  ///
  /// \return The sensor name, or NULL if the sensor is NULL.
  ffi.Pointer<ffi.Int8> SDL_SensorGetName(
    ffi.Pointer<SDL_Sensor1> sensor,
  ) {
    return _SDL_SensorGetName(
      sensor,
    );
  }

  late final _SDL_SensorGetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_Sensor1>)>>('SDL_SensorGetName');
  late final _SDL_SensorGetName = _SDL_SensorGetNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_Sensor1>)>();

  /// \brief Get the type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL.
  int SDL_SensorGetType(
    ffi.Pointer<SDL_Sensor1> sensor,
  ) {
    return _SDL_SensorGetType(
      sensor,
    );
  }

  late final _SDL_SensorGetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Sensor1>)>>(
          'SDL_SensorGetType');
  late final _SDL_SensorGetType = _SDL_SensorGetTypePtr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor1>)>();

  /// \brief Get the platform dependent type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor platform dependent type, or -1 if the sensor is NULL.
  int SDL_SensorGetNonPortableType(
    ffi.Pointer<SDL_Sensor1> sensor,
  ) {
    return _SDL_SensorGetNonPortableType(
      sensor,
    );
  }

  late final _SDL_SensorGetNonPortableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Sensor1>)>>(
          'SDL_SensorGetNonPortableType');
  late final _SDL_SensorGetNonPortableType = _SDL_SensorGetNonPortableTypePtr
      .asFunction<int Function(ffi.Pointer<SDL_Sensor1>)>();

  /// \brief Get the instance ID of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor instance ID, or -1 if the sensor is NULL.
  int SDL_SensorGetInstanceID(
    ffi.Pointer<SDL_Sensor1> sensor,
  ) {
    return _SDL_SensorGetInstanceID(
      sensor,
    );
  }

  late final _SDL_SensorGetInstanceIDPtr = _lookup<
          ffi.NativeFunction<SDL_SensorID Function(ffi.Pointer<SDL_Sensor1>)>>(
      'SDL_SensorGetInstanceID');
  late final _SDL_SensorGetInstanceID = _SDL_SensorGetInstanceIDPtr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor1>)>();

  /// Get the current state of an opened sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  ///
  /// \param sensor The sensor to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  ///
  /// \return 0 or -1 if an error occurred.
  int SDL_SensorGetData(
    ffi.Pointer<SDL_Sensor1> sensor,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_SensorGetData(
      sensor,
      data,
      num_values,
    );
  }

  late final _SDL_SensorGetDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Sensor1>, ffi.Pointer<ffi.Float>,
              ffi.Int32)>>('SDL_SensorGetData');
  late final _SDL_SensorGetData = _SDL_SensorGetDataPtr.asFunction<
      int Function(ffi.Pointer<SDL_Sensor1>, ffi.Pointer<ffi.Float>, int)>();

  /// Close a sensor previously opened with SDL_SensorOpen()
  void SDL_SensorClose(
    ffi.Pointer<SDL_Sensor1> sensor,
  ) {
    return _SDL_SensorClose(
      sensor,
    );
  }

  late final _SDL_SensorClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Sensor1>)>>(
          'SDL_SensorClose');
  late final _SDL_SensorClose =
      _SDL_SensorClosePtr.asFunction<void Function(ffi.Pointer<SDL_Sensor1>)>();

  /// Update the current state of the open sensors.
  ///
  /// This is called automatically by the event loop if sensor events are enabled.
  ///
  /// This needs to be called from the thread that initialized the sensor subsystem.
  void SDL_SensorUpdate() {
    return _SDL_SensorUpdate();
  }

  late final _SDL_SensorUpdatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_SensorUpdate');
  late final _SDL_SensorUpdate =
      _SDL_SensorUpdatePtr.asFunction<void Function()>();

  /// Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()
  /// A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt
  ///
  /// If \c freerw is non-zero, the stream will be closed after being read.
  ///
  /// \return number of mappings added, -1 on error
  int SDL_GameControllerAddMappingsFromRW(
    ffi.Pointer<SDL_RWops> rw,
    int freerw,
  ) {
    return _SDL_GameControllerAddMappingsFromRW(
      rw,
      freerw,
    );
  }

  late final _SDL_GameControllerAddMappingsFromRWPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_RWops>,
              ffi.Int32)>>('SDL_GameControllerAddMappingsFromRW');
  late final _SDL_GameControllerAddMappingsFromRW =
      _SDL_GameControllerAddMappingsFromRWPtr.asFunction<
          int Function(ffi.Pointer<SDL_RWops>, int)>();

  /// Add or update an existing mapping configuration
  ///
  /// \return 1 if mapping is added, 0 if updated, -1 on error
  int SDL_GameControllerAddMapping(
    ffi.Pointer<ffi.Int8> mappingString,
  ) {
    return _SDL_GameControllerAddMapping(
      mappingString,
    );
  }

  late final _SDL_GameControllerAddMappingPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GameControllerAddMapping');
  late final _SDL_GameControllerAddMapping = _SDL_GameControllerAddMappingPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// Get the number of mappings installed
  ///
  /// \return the number of mappings
  int SDL_GameControllerNumMappings() {
    return _SDL_GameControllerNumMappings();
  }

  late final _SDL_GameControllerNumMappingsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GameControllerNumMappings');
  late final _SDL_GameControllerNumMappings =
      _SDL_GameControllerNumMappingsPtr.asFunction<int Function()>();

  /// Get the mapping at a particular index.
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range.
  ffi.Pointer<ffi.Int8> SDL_GameControllerMappingForIndex(
    int mapping_index,
  ) {
    return _SDL_GameControllerMappingForIndex(
      mapping_index,
    );
  }

  late final _SDL_GameControllerMappingForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GameControllerMappingForIndex');
  late final _SDL_GameControllerMappingForIndex =
      _SDL_GameControllerMappingForIndexPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(int)>();

  /// Get a mapping string for a GUID
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
  ffi.Pointer<ffi.Int8> SDL_GameControllerMappingForGUID(
    SDL_JoystickGUID guid,
  ) {
    return _SDL_GameControllerMappingForGUID(
      guid,
    );
  }

  late final _SDL_GameControllerMappingForGUIDPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(SDL_JoystickGUID)>>(
      'SDL_GameControllerMappingForGUID');
  late final _SDL_GameControllerMappingForGUID =
      _SDL_GameControllerMappingForGUIDPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(SDL_JoystickGUID)>();

  /// Get a mapping string for an open GameController
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
  ffi.Pointer<ffi.Int8> SDL_GameControllerMapping(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerMapping(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerMappingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_GameController1>)>>('SDL_GameControllerMapping');
  late final _SDL_GameControllerMapping =
      _SDL_GameControllerMappingPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_GameController1>)>();

  /// Is the joystick on this index supported by the game controller interface?
  int SDL_IsGameController(
    int joystick_index,
  ) {
    return _SDL_IsGameController(
      joystick_index,
    );
  }

  late final _SDL_IsGameControllerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_IsGameController');
  late final _SDL_IsGameController =
      _SDL_IsGameControllerPtr.asFunction<int Function(int)>();

  /// Get the implementation dependent name of a game controller.
  /// This can be called before any controllers are opened.
  /// If no name can be found, this function returns NULL.
  ffi.Pointer<ffi.Int8> SDL_GameControllerNameForIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerNameForIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerNameForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GameControllerNameForIndex');
  late final _SDL_GameControllerNameForIndex =
      _SDL_GameControllerNameForIndexPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(int)>();

  /// Get the type of a game controller.
  /// This can be called before any controllers are opened.
  int SDL_GameControllerTypeForIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerTypeForIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerTypeForIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_GameControllerTypeForIndex');
  late final _SDL_GameControllerTypeForIndex =
      _SDL_GameControllerTypeForIndexPtr.asFunction<int Function(int)>();

  /// Get the mapping of a game controller.
  /// This can be called before any controllers are opened.
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
  ffi.Pointer<ffi.Int8> SDL_GameControllerMappingForDeviceIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerMappingForDeviceIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerMappingForDeviceIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GameControllerMappingForDeviceIndex');
  late final _SDL_GameControllerMappingForDeviceIndex =
      _SDL_GameControllerMappingForDeviceIndexPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(int)>();

  /// Open a game controller for use.
  /// The index passed as an argument refers to the N'th game controller on the system.
  /// This index is not the value which will identify this controller in future
  /// controller events.  The joystick's instance id (::SDL_JoystickID) will be
  /// used there instead.
  ///
  /// \return A controller identifier, or NULL if an error occurred.
  ffi.Pointer<SDL_GameController1> SDL_GameControllerOpen(
    int joystick_index,
  ) {
    return _SDL_GameControllerOpen(
      joystick_index,
    );
  }

  late final _SDL_GameControllerOpenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController1> Function(
              ffi.Int32)>>('SDL_GameControllerOpen');
  late final _SDL_GameControllerOpen = _SDL_GameControllerOpenPtr.asFunction<
      ffi.Pointer<SDL_GameController1> Function(int)>();

  /// Return the SDL_GameController associated with an instance id.
  ffi.Pointer<SDL_GameController1> SDL_GameControllerFromInstanceID(
    int joyid,
  ) {
    return _SDL_GameControllerFromInstanceID(
      joyid,
    );
  }

  late final _SDL_GameControllerFromInstanceIDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController1> Function(
              SDL_JoystickID)>>('SDL_GameControllerFromInstanceID');
  late final _SDL_GameControllerFromInstanceID =
      _SDL_GameControllerFromInstanceIDPtr.asFunction<
          ffi.Pointer<SDL_GameController1> Function(int)>();

  /// Return the SDL_GameController associated with a player index.
  ffi.Pointer<SDL_GameController1> SDL_GameControllerFromPlayerIndex(
    int player_index,
  ) {
    return _SDL_GameControllerFromPlayerIndex(
      player_index,
    );
  }

  late final _SDL_GameControllerFromPlayerIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_GameController1> Function(
              ffi.Int32)>>('SDL_GameControllerFromPlayerIndex');
  late final _SDL_GameControllerFromPlayerIndex =
      _SDL_GameControllerFromPlayerIndexPtr.asFunction<
          ffi.Pointer<SDL_GameController1> Function(int)>();

  /// Return the name for this currently opened controller
  ffi.Pointer<ffi.Int8> SDL_GameControllerName(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerName(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<SDL_GameController1>)>>('SDL_GameControllerName');
  late final _SDL_GameControllerName = _SDL_GameControllerNamePtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_GameController1>)>();

  /// Return the type of this currently opened controller
  int SDL_GameControllerGetType(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetType(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController1>)>>('SDL_GameControllerGetType');
  late final _SDL_GameControllerGetType = _SDL_GameControllerGetTypePtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Get the player index of an opened game controller, or -1 if it's not available
  ///
  /// For XInput controllers this returns the XInput user index.
  int SDL_GameControllerGetPlayerIndex(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetPlayerIndex(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetPlayerIndexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetPlayerIndex');
  late final _SDL_GameControllerGetPlayerIndex =
      _SDL_GameControllerGetPlayerIndexPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Set the player index of an opened game controller
  void SDL_GameControllerSetPlayerIndex(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int player_index,
  ) {
    return _SDL_GameControllerSetPlayerIndex(
      gamecontroller,
      player_index,
    );
  }

  late final _SDL_GameControllerSetPlayerIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerSetPlayerIndex');
  late final _SDL_GameControllerSetPlayerIndex =
      _SDL_GameControllerSetPlayerIndexPtr.asFunction<
          void Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Get the USB vendor ID of an opened controller, if available.
  /// If the vendor ID isn't available this function returns 0.
  int SDL_GameControllerGetVendor(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetVendor(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetVendorPtr = _lookup<
          ffi.NativeFunction<
              Uint16 Function(ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetVendor');
  late final _SDL_GameControllerGetVendor = _SDL_GameControllerGetVendorPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Get the USB product ID of an opened controller, if available.
  /// If the product ID isn't available this function returns 0.
  int SDL_GameControllerGetProduct(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetProduct(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProductPtr = _lookup<
          ffi.NativeFunction<
              Uint16 Function(ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetProduct');
  late final _SDL_GameControllerGetProduct = _SDL_GameControllerGetProductPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Get the product version of an opened controller, if available.
  /// If the product version isn't available this function returns 0.
  int SDL_GameControllerGetProductVersion(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetProductVersion(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProductVersionPtr = _lookup<
          ffi.NativeFunction<
              Uint16 Function(ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetProductVersion');
  late final _SDL_GameControllerGetProductVersion =
      _SDL_GameControllerGetProductVersionPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Get the serial number of an opened controller, if available.
  ///
  /// Returns the serial number of the controller, or NULL if it is not available.
  ffi.Pointer<ffi.Int8> SDL_GameControllerGetSerial(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetSerial(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetSerialPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int8> Function(
                  ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetSerial');
  late final _SDL_GameControllerGetSerial =
      _SDL_GameControllerGetSerialPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<SDL_GameController1>)>();

  /// Returns SDL_TRUE if the controller has been opened and currently connected,
  /// or SDL_FALSE if it has not.
  int SDL_GameControllerGetAttached(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetAttached(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetAttachedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetAttached');
  late final _SDL_GameControllerGetAttached = _SDL_GameControllerGetAttachedPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Get the underlying joystick object used by a controller
  ffi.Pointer<SDL_Joystick1> SDL_GameControllerGetJoystick(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetJoystick(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetJoystickPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SDL_Joystick1> Function(
                  ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetJoystick');
  late final _SDL_GameControllerGetJoystick =
      _SDL_GameControllerGetJoystickPtr.asFunction<
          ffi.Pointer<SDL_Joystick1> Function(
              ffi.Pointer<SDL_GameController1>)>();

  /// Enable/disable controller event polling.
  ///
  /// If controller events are disabled, you must call SDL_GameControllerUpdate()
  /// yourself and check the state of the controller when you want controller
  /// information.
  ///
  /// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
  int SDL_GameControllerEventState(
    int state,
  ) {
    return _SDL_GameControllerEventState(
      state,
    );
  }

  late final _SDL_GameControllerEventStatePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_GameControllerEventState');
  late final _SDL_GameControllerEventState =
      _SDL_GameControllerEventStatePtr.asFunction<int Function(int)>();

  /// Update the current state of the open game controllers.
  ///
  /// This is called automatically by the event loop if any game controller
  /// events are enabled.
  void SDL_GameControllerUpdate() {
    return _SDL_GameControllerUpdate();
  }

  late final _SDL_GameControllerUpdatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_GameControllerUpdate');
  late final _SDL_GameControllerUpdate =
      _SDL_GameControllerUpdatePtr.asFunction<void Function()>();

  /// turn this string into a axis mapping
  int SDL_GameControllerGetAxisFromString(
    ffi.Pointer<ffi.Int8> pchString,
  ) {
    return _SDL_GameControllerGetAxisFromString(
      pchString,
    );
  }

  late final _SDL_GameControllerGetAxisFromStringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GameControllerGetAxisFromString');
  late final _SDL_GameControllerGetAxisFromString =
      _SDL_GameControllerGetAxisFromStringPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int8>)>();

  /// turn this axis enum into a string mapping
  ffi.Pointer<ffi.Int8> SDL_GameControllerGetStringForAxis(
    int axis,
  ) {
    return _SDL_GameControllerGetStringForAxis(
      axis,
    );
  }

  late final _SDL_GameControllerGetStringForAxisPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GameControllerGetStringForAxis');
  late final _SDL_GameControllerGetStringForAxis =
      _SDL_GameControllerGetStringForAxisPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(int)>();

  /// Get the SDL joystick layer binding for this controller button mapping
  SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetBindForAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetBindForAxisPtr = _lookup<
      ffi.NativeFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerGetBindForAxis');
  late final _SDL_GameControllerGetBindForAxis =
      _SDL_GameControllerGetBindForAxisPtr.asFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController1>, int)>();

  /// Return whether a game controller has a given axis
  int SDL_GameControllerHasAxis(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerHasAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerHasAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerHasAxis');
  late final _SDL_GameControllerHasAxis = _SDL_GameControllerHasAxisPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Get the current state of an axis control on a game controller.
  ///
  /// The state is a value ranging from -32768 to 32767 (except for the triggers,
  /// which range from 0 to 32767).
  ///
  /// The axis indices start at index 0.
  int SDL_GameControllerGetAxis(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetAxisPtr = _lookup<
      ffi.NativeFunction<
          Sint16 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerGetAxis');
  late final _SDL_GameControllerGetAxis = _SDL_GameControllerGetAxisPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// turn this string into a button mapping
  int SDL_GameControllerGetButtonFromString(
    ffi.Pointer<ffi.Int8> pchString,
  ) {
    return _SDL_GameControllerGetButtonFromString(
      pchString,
    );
  }

  late final _SDL_GameControllerGetButtonFromStringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_GameControllerGetButtonFromString');
  late final _SDL_GameControllerGetButtonFromString =
      _SDL_GameControllerGetButtonFromStringPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int8>)>();

  /// turn this button enum into a string mapping
  ffi.Pointer<ffi.Int8> SDL_GameControllerGetStringForButton(
    int button,
  ) {
    return _SDL_GameControllerGetStringForButton(
      button,
    );
  }

  late final _SDL_GameControllerGetStringForButtonPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_GameControllerGetStringForButton');
  late final _SDL_GameControllerGetStringForButton =
      _SDL_GameControllerGetStringForButtonPtr.asFunction<
          ffi.Pointer<ffi.Int8> Function(int)>();

  /// Get the SDL joystick layer binding for this controller button mapping
  SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetBindForButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetBindForButtonPtr = _lookup<
      ffi.NativeFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerGetBindForButton');
  late final _SDL_GameControllerGetBindForButton =
      _SDL_GameControllerGetBindForButtonPtr.asFunction<
          SDL_GameControllerButtonBind Function(
              ffi.Pointer<SDL_GameController1>, int)>();

  /// Return whether a game controller has a given button
  int SDL_GameControllerHasButton(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerHasButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerHasButtonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerHasButton');
  late final _SDL_GameControllerHasButton = _SDL_GameControllerHasButtonPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Get the current state of a button on a game controller.
  ///
  /// The button indices start at index 0.
  int SDL_GameControllerGetButton(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetButtonPtr = _lookup<
      ffi.NativeFunction<
          Uint8 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerGetButton');
  late final _SDL_GameControllerGetButton = _SDL_GameControllerGetButtonPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Get the number of touchpads on a game controller.
  int SDL_GameControllerGetNumTouchpads(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerGetNumTouchpads(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetNumTouchpadsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SDL_GameController1>)>>(
      'SDL_GameControllerGetNumTouchpads');
  late final _SDL_GameControllerGetNumTouchpads =
      _SDL_GameControllerGetNumTouchpadsPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Get the number of supported simultaneous fingers on a touchpad on a game controller.
  int SDL_GameControllerGetNumTouchpadFingers(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int touchpad,
  ) {
    return _SDL_GameControllerGetNumTouchpadFingers(
      gamecontroller,
      touchpad,
    );
  }

  late final _SDL_GameControllerGetNumTouchpadFingersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerGetNumTouchpadFingers');
  late final _SDL_GameControllerGetNumTouchpadFingers =
      _SDL_GameControllerGetNumTouchpadFingersPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Get the current state of a finger on a touchpad on a game controller.
  int SDL_GameControllerGetTouchpadFinger(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int touchpad,
    int finger,
    ffi.Pointer<Uint8> state,
    ffi.Pointer<ffi.Float> x,
    ffi.Pointer<ffi.Float> y,
    ffi.Pointer<ffi.Float> pressure,
  ) {
    return _SDL_GameControllerGetTouchpadFinger(
      gamecontroller,
      touchpad,
      finger,
      state,
      x,
      y,
      pressure,
    );
  }

  late final _SDL_GameControllerGetTouchpadFingerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController1>,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<Uint8>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GameControllerGetTouchpadFinger');
  late final _SDL_GameControllerGetTouchpadFinger =
      _SDL_GameControllerGetTouchpadFingerPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_GameController1>,
              int,
              int,
              ffi.Pointer<Uint8>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>();

  /// Return whether a game controller has a particular sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  ///
  /// \return SDL_TRUE if the sensor exists, SDL_FALSE otherwise.
  int SDL_GameControllerHasSensor(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerHasSensor(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerHasSensorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerHasSensor');
  late final _SDL_GameControllerHasSensor = _SDL_GameControllerHasSensorPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Set whether data reporting for a game controller sensor is enabled
  ///
  /// \param gamecontroller The controller to update
  /// \param type The type of sensor to enable/disable
  /// \param enabled Whether data reporting should be enabled
  ///
  /// \return 0 or -1 if an error occurred.
  int SDL_GameControllerSetSensorEnabled(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int type,
    int enabled,
  ) {
    return _SDL_GameControllerSetSensorEnabled(
      gamecontroller,
      type,
      enabled,
    );
  }

  late final _SDL_GameControllerSetSensorEnabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>, ffi.Int32,
              ffi.Int32)>>('SDL_GameControllerSetSensorEnabled');
  late final _SDL_GameControllerSetSensorEnabled =
      _SDL_GameControllerSetSensorEnabledPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int, int)>();

  /// Query whether sensor data reporting is enabled for a game controller
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  ///
  /// \return SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.
  int SDL_GameControllerIsSensorEnabled(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerIsSensorEnabled(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerIsSensorEnabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>,
              ffi.Int32)>>('SDL_GameControllerIsSensorEnabled');
  late final _SDL_GameControllerIsSensorEnabled =
      _SDL_GameControllerIsSensorEnabledPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int)>();

  /// Get the current state of a game controller sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  /// See SDL_sensor.h for the details for each type of sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  ///
  /// \return 0 or -1 if an error occurred.
  int SDL_GameControllerGetSensorData(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int type,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_GameControllerGetSensorData(
      gamecontroller,
      type,
      data,
      num_values,
    );
  }

  late final _SDL_GameControllerGetSensorDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController1>,
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Int32)>>('SDL_GameControllerGetSensorData');
  late final _SDL_GameControllerGetSensorData =
      _SDL_GameControllerGetSensorDataPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int,
              ffi.Pointer<ffi.Float>, int)>();

  /// Start a rumble effect
  /// Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if rumble isn't supported on this controller
  int SDL_GameControllerRumble(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumble(
      gamecontroller,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>, Uint16, Uint16,
              Uint32)>>('SDL_GameControllerRumble');
  late final _SDL_GameControllerRumble =
      _SDL_GameControllerRumblePtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int, int, int)>();

  /// Start a rumble effect in the game controller's triggers
  /// Each call to this function cancels any previous trigger rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0 to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if rumble isn't supported on this controller
  int SDL_GameControllerRumbleTriggers(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumbleTriggers(
      gamecontroller,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumbleTriggersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>, Uint16, Uint16,
              Uint32)>>('SDL_GameControllerRumbleTriggers');
  late final _SDL_GameControllerRumbleTriggers =
      _SDL_GameControllerRumbleTriggersPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int, int, int)>();

  /// Return whether a controller has an LED
  ///
  /// \param gamecontroller The controller to query
  ///
  /// \return SDL_TRUE, or SDL_FALSE if this controller does not have a modifiable LED
  int SDL_GameControllerHasLED(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerHasLED(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasLEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_GameController1>)>>('SDL_GameControllerHasLED');
  late final _SDL_GameControllerHasLED = _SDL_GameControllerHasLEDPtr
      .asFunction<int Function(ffi.Pointer<SDL_GameController1>)>();

  /// Update a controller's LED color.
  ///
  /// \param gamecontroller The controller to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  ///
  /// \return 0, or -1 if this controller does not have a modifiable LED
  int SDL_GameControllerSetLED(
    ffi.Pointer<SDL_GameController1> gamecontroller,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_GameControllerSetLED(
      gamecontroller,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GameControllerSetLEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_GameController1>, Uint8, Uint8,
              Uint8)>>('SDL_GameControllerSetLED');
  late final _SDL_GameControllerSetLED =
      _SDL_GameControllerSetLEDPtr.asFunction<
          int Function(ffi.Pointer<SDL_GameController1>, int, int, int)>();

  /// Close a controller previously opened with SDL_GameControllerOpen().
  void SDL_GameControllerClose(
    ffi.Pointer<SDL_GameController1> gamecontroller,
  ) {
    return _SDL_GameControllerClose(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerClosePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_GameController1>)>>('SDL_GameControllerClose');
  late final _SDL_GameControllerClose = _SDL_GameControllerClosePtr.asFunction<
      void Function(ffi.Pointer<SDL_GameController1>)>();

  /// \brief Get the number of registered touch devices.
  int SDL_GetNumTouchDevices() {
    return _SDL_GetNumTouchDevices();
  }

  late final _SDL_GetNumTouchDevicesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetNumTouchDevices');
  late final _SDL_GetNumTouchDevices =
      _SDL_GetNumTouchDevicesPtr.asFunction<int Function()>();

  /// \brief Get the touch ID with the given index, or 0 if the index is invalid.
  int SDL_GetTouchDevice(
    int index,
  ) {
    return _SDL_GetTouchDevice(
      index,
    );
  }

  late final _SDL_GetTouchDevicePtr =
      _lookup<ffi.NativeFunction<SDL_TouchID Function(ffi.Int32)>>(
          'SDL_GetTouchDevice');
  late final _SDL_GetTouchDevice =
      _SDL_GetTouchDevicePtr.asFunction<int Function(int)>();

  /// \brief Get the type of the given touch device.
  int SDL_GetTouchDeviceType(
    int touchID,
  ) {
    return _SDL_GetTouchDeviceType(
      touchID,
    );
  }

  late final _SDL_GetTouchDeviceTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TouchID)>>(
          'SDL_GetTouchDeviceType');
  late final _SDL_GetTouchDeviceType =
      _SDL_GetTouchDeviceTypePtr.asFunction<int Function(int)>();

  /// \brief Get the number of active fingers for a given touch device.
  int SDL_GetNumTouchFingers(
    int touchID,
  ) {
    return _SDL_GetNumTouchFingers(
      touchID,
    );
  }

  late final _SDL_GetNumTouchFingersPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TouchID)>>(
          'SDL_GetNumTouchFingers');
  late final _SDL_GetNumTouchFingers =
      _SDL_GetNumTouchFingersPtr.asFunction<int Function(int)>();

  /// \brief Get the finger object of the given touch, with the given index.
  ffi.Pointer<SDL_Finger> SDL_GetTouchFinger(
    int touchID,
    int index,
  ) {
    return _SDL_GetTouchFinger(
      touchID,
      index,
    );
  }

  late final _SDL_GetTouchFingerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Finger> Function(
              SDL_TouchID, ffi.Int32)>>('SDL_GetTouchFinger');
  late final _SDL_GetTouchFinger = _SDL_GetTouchFingerPtr.asFunction<
      ffi.Pointer<SDL_Finger> Function(int, int)>();

  /// \brief Begin Recording a gesture on the specified touch, or all touches (-1)
  int SDL_RecordGesture(
    int touchId,
  ) {
    return _SDL_RecordGesture(
      touchId,
    );
  }

  late final _SDL_RecordGesturePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TouchID)>>(
          'SDL_RecordGesture');
  late final _SDL_RecordGesture =
      _SDL_RecordGesturePtr.asFunction<int Function(int)>();

  /// \brief Save all currently loaded Dollar Gesture templates
  int SDL_SaveAllDollarTemplates(
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveAllDollarTemplates(
      dst,
    );
  }

  late final _SDL_SaveAllDollarTemplatesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_RWops>)>>(
          'SDL_SaveAllDollarTemplates');
  late final _SDL_SaveAllDollarTemplates = _SDL_SaveAllDollarTemplatesPtr
      .asFunction<int Function(ffi.Pointer<SDL_RWops>)>();

  /// \brief Save a currently loaded Dollar Gesture template
  int SDL_SaveDollarTemplate(
    int gestureId,
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveDollarTemplate(
      gestureId,
      dst,
    );
  }

  late final _SDL_SaveDollarTemplatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SDL_GestureID,
              ffi.Pointer<SDL_RWops>)>>('SDL_SaveDollarTemplate');
  late final _SDL_SaveDollarTemplate = _SDL_SaveDollarTemplatePtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RWops>)>();

  /// \brief Load Dollar Gesture templates from a file
  int SDL_LoadDollarTemplates(
    int touchId,
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_LoadDollarTemplates(
      touchId,
      src,
    );
  }

  late final _SDL_LoadDollarTemplatesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SDL_TouchID, ffi.Pointer<SDL_RWops>)>>('SDL_LoadDollarTemplates');
  late final _SDL_LoadDollarTemplates = _SDL_LoadDollarTemplatesPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RWops>)>();

  /// Pumps the event loop, gathering events from the input devices.
  ///
  /// This function updates the event queue and internal input device state.
  ///
  /// This should only be run in the thread that sets the video mode.
  void SDL_PumpEvents() {
    return _SDL_PumpEvents();
  }

  late final _SDL_PumpEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_PumpEvents');
  late final _SDL_PumpEvents = _SDL_PumpEventsPtr.asFunction<void Function()>();

  /// Checks the event queue for messages and optionally returns them.
  ///
  /// If \c action is ::SDL_ADDEVENT, up to \c numevents events will be added to
  /// the back of the event queue.
  ///
  /// If \c action is ::SDL_PEEKEVENT, up to \c numevents events at the front
  /// of the event queue, within the specified minimum and maximum type,
  /// will be returned and will not be removed from the queue.
  ///
  /// If \c action is ::SDL_GETEVENT, up to \c numevents events at the front
  /// of the event queue, within the specified minimum and maximum type,
  /// will be returned and will be removed from the queue.
  ///
  /// \return The number of events actually stored, or -1 if there was an error.
  ///
  /// This function is thread-safe.
  int SDL_PeepEvents(
    ffi.Pointer<SDL_Event> events,
    int numevents,
    int action,
    int minType,
    int maxType,
  ) {
    return _SDL_PeepEvents(
      events,
      numevents,
      action,
      minType,
      maxType,
    );
  }

  late final _SDL_PeepEventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Event>, ffi.Int32, ffi.Int32,
              Uint32, Uint32)>>('SDL_PeepEvents');
  late final _SDL_PeepEvents = _SDL_PeepEventsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int, int, int, int)>();

  /// Checks to see if certain event types are in the event queue.
  int SDL_HasEvent(
    int type,
  ) {
    return _SDL_HasEvent(
      type,
    );
  }

  late final _SDL_HasEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32)>>('SDL_HasEvent');
  late final _SDL_HasEvent = _SDL_HasEventPtr.asFunction<int Function(int)>();

  int SDL_HasEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_HasEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_HasEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32, Uint32)>>(
          'SDL_HasEvents');
  late final _SDL_HasEvents =
      _SDL_HasEventsPtr.asFunction<int Function(int, int)>();

  /// This function clears events from the event queue
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  void SDL_FlushEvent(
    int type,
  ) {
    return _SDL_FlushEvent(
      type,
    );
  }

  late final _SDL_FlushEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_FlushEvent');
  late final _SDL_FlushEvent =
      _SDL_FlushEventPtr.asFunction<void Function(int)>();

  void SDL_FlushEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_FlushEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_FlushEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32, Uint32)>>(
          'SDL_FlushEvents');
  late final _SDL_FlushEvents =
      _SDL_FlushEventsPtr.asFunction<void Function(int, int)>();

  /// \brief Polls for currently pending events.
  ///
  /// \return 1 if there are any pending events, or 0 if there are none available.
  ///
  /// \param event If not NULL, the next event is removed from the queue and
  /// stored in that area.
  int SDL_PollEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PollEvent(
      event,
    );
  }

  late final _SDL_PollEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PollEvent');
  late final _SDL_PollEvent =
      _SDL_PollEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// \brief Waits indefinitely for the next available event.
  ///
  /// \return 1, or 0 if there was an error while waiting for events.
  ///
  /// \param event If not NULL, the next event is removed from the queue and
  /// stored in that area.
  int SDL_WaitEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_WaitEvent(
      event,
    );
  }

  late final _SDL_WaitEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_WaitEvent');
  late final _SDL_WaitEvent =
      _SDL_WaitEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// \brief Waits until the specified timeout (in milliseconds) for the next
  /// available event.
  ///
  /// \return 1, or 0 if there was an error while waiting for events.
  ///
  /// \param event If not NULL, the next event is removed from the queue and
  /// stored in that area.
  /// \param timeout The timeout (in milliseconds) to wait for next event.
  int SDL_WaitEventTimeout(
    ffi.Pointer<SDL_Event> event,
    int timeout,
  ) {
    return _SDL_WaitEventTimeout(
      event,
      timeout,
    );
  }

  late final _SDL_WaitEventTimeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Event>, ffi.Int32)>>('SDL_WaitEventTimeout');
  late final _SDL_WaitEventTimeout = _SDL_WaitEventTimeoutPtr.asFunction<
      int Function(ffi.Pointer<SDL_Event>, int)>();

  /// \brief Add an event to the event queue.
  ///
  /// \return 1 on success, 0 if the event was filtered, or -1 if the event queue
  /// was full or there was some other error.
  int SDL_PushEvent(
    ffi.Pointer<SDL_Event> event,
  ) {
    return _SDL_PushEvent(
      event,
    );
  }

  late final _SDL_PushEventPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Event>)>>(
          'SDL_PushEvent');
  late final _SDL_PushEvent =
      _SDL_PushEventPtr.asFunction<int Function(ffi.Pointer<SDL_Event>)>();

  /// Sets up a filter to process all events before they change internal state and
  /// are posted to the internal event queue.
  ///
  /// The filter is prototyped as:
  /// \code
  /// int SDL_EventFilter(void *userdata, SDL_Event * event);
  /// \endcode
  ///
  /// If the filter returns 1, then the event will be added to the internal queue.
  /// If it returns 0, then the event will be dropped from the queue, but the
  /// internal state will still be updated.  This allows selective filtering of
  /// dynamically arriving events.
  ///
  /// \warning  Be very careful of what you do in the event filter function, as
  /// it may run in a different thread!
  ///
  /// There is one caveat when dealing with the ::SDL_QuitEvent event type.  The
  /// event filter is only called when the window manager desires to close the
  /// application window.  If the event filter returns 1, then the window will
  /// be closed, otherwise the window will remain open if possible.
  ///
  /// If the quit event is generated by an interrupt signal, it will bypass the
  /// internal queue and be delivered to the application at the next event poll.
  void SDL_SetEventFilter(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetEventFilter(
      filter,
      userdata,
    );
  }

  late final _SDL_SetEventFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_SetEventFilter');
  late final _SDL_SetEventFilter = _SDL_SetEventFilterPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Return the current event filter - can be used to "chain" filters.
  /// If there is no event filter set, this function returns SDL_FALSE.
  int SDL_GetEventFilter(
    ffi.Pointer<SDL_EventFilter> filter,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_GetEventFilter(
      filter,
      userdata,
    );
  }

  late final _SDL_GetEventFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_EventFilter>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_GetEventFilter');
  late final _SDL_GetEventFilter = _SDL_GetEventFilterPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_EventFilter>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Add a function which is called when an event is added to the queue.
  void SDL_AddEventWatch(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddEventWatch(
      filter,
      userdata,
    );
  }

  late final _SDL_AddEventWatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_AddEventWatch');
  late final _SDL_AddEventWatch = _SDL_AddEventWatchPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Remove an event watch function added with SDL_AddEventWatch()
  void SDL_DelEventWatch(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelEventWatch(
      filter,
      userdata,
    );
  }

  late final _SDL_DelEventWatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_DelEventWatch');
  late final _SDL_DelEventWatch = _SDL_DelEventWatchPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// Run the filter function on the current event queue, removing any
  /// events for which the filter returns 0.
  void SDL_FilterEvents(
    SDL_EventFilter filter,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_FilterEvents(
      filter,
      userdata,
    );
  }

  late final _SDL_FilterEventsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SDL_EventFilter, ffi.Pointer<ffi.Void>)>>('SDL_FilterEvents');
  late final _SDL_FilterEvents = _SDL_FilterEventsPtr.asFunction<
      void Function(SDL_EventFilter, ffi.Pointer<ffi.Void>)>();

  /// This function allows you to set the state of processing certain events.
  /// - If \c state is set to ::SDL_IGNORE, that event will be automatically
  /// dropped from the event queue and will not be filtered.
  /// - If \c state is set to ::SDL_ENABLE, that event will be processed
  /// normally.
  /// - If \c state is set to ::SDL_QUERY, SDL_EventState() will return the
  /// current processing state of the specified event.
  int SDL_EventState(
    int type,
    int state,
  ) {
    return _SDL_EventState(
      type,
      state,
    );
  }

  late final _SDL_EventStatePtr =
      _lookup<ffi.NativeFunction<Uint8 Function(Uint32, ffi.Int32)>>(
          'SDL_EventState');
  late final _SDL_EventState =
      _SDL_EventStatePtr.asFunction<int Function(int, int)>();

  /// This function allocates a set of user-defined events, and returns
  /// the beginning event number for that set of events.
  ///
  /// If there aren't enough user-defined events left, this function
  /// returns (Uint32)-1
  int SDL_RegisterEvents(
    int numevents,
  ) {
    return _SDL_RegisterEvents(
      numevents,
    );
  }

  late final _SDL_RegisterEventsPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(ffi.Int32)>>(
          'SDL_RegisterEvents');
  late final _SDL_RegisterEvents =
      _SDL_RegisterEventsPtr.asFunction<int Function(int)>();

  /// \brief Get the path where the application resides.
  ///
  /// Get the "base path". This is the directory where the application was run
  /// from, which is probably the installation directory, and may or may not
  /// be the process's current working directory.
  ///
  /// This returns an absolute path in UTF-8 encoding, and is guaranteed to
  /// end with a path separator ('\\' on Windows, '/' most other places).
  ///
  /// The pointer returned by this function is owned by you. Please call
  /// SDL_free() on the pointer when you are done with it, or it will be a
  /// memory leak. This is not necessarily a fast call, though, so you should
  /// call this once near startup and save the string if you need it.
  ///
  /// Some platforms can't determine the application's path, and on other
  /// platforms, this might be meaningless. In such cases, this function will
  /// return NULL.
  ///
  /// \return String of base dir in UTF-8 encoding, or NULL on error.
  ///
  /// \sa SDL_GetPrefPath
  ffi.Pointer<ffi.Int8> SDL_GetBasePath() {
    return _SDL_GetBasePath();
  }

  late final _SDL_GetBasePathPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetBasePath');
  late final _SDL_GetBasePath =
      _SDL_GetBasePathPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// \brief Get the user-and-app-specific path where files can be written.
  ///
  /// Get the "pref dir". This is meant to be where users can write personal
  /// files (preferences and save games, etc) that are specific to your
  /// application. This directory is unique per user, per application.
  ///
  /// This function will decide the appropriate location in the native filesystem,
  /// create the directory if necessary, and return a string of the absolute
  /// path to the directory in UTF-8 encoding.
  ///
  /// On Windows, the string might look like:
  /// "C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\"
  ///
  /// On Linux, the string might look like:
  /// "/home/bob/.local/share/My Program Name/"
  ///
  /// On Mac OS X, the string might look like:
  /// "/Users/bob/Library/Application Support/My Program Name/"
  ///
  /// (etc.)
  ///
  /// You specify the name of your organization (if it's not a real organization,
  /// your name or an Internet domain you own might do) and the name of your
  /// application. These should be untranslated proper names.
  ///
  /// Both the org and app strings may become part of a directory name, so
  /// please follow these rules:
  ///
  /// - Try to use the same org string (including case-sensitivity) for
  /// all your applications that use this function.
  /// - Always use a unique app string for each one, and make sure it never
  /// changes for an app once you've decided on it.
  /// - Unicode characters are legal, as long as it's UTF-8 encoded, but...
  /// - ...only use letters, numbers, and spaces. Avoid punctuation like
  /// "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
  ///
  /// This returns an absolute path in UTF-8 encoding, and is guaranteed to
  /// end with a path separator ('\\' on Windows, '/' most other places).
  ///
  /// The pointer returned by this function is owned by you. Please call
  /// SDL_free() on the pointer when you are done with it, or it will be a
  /// memory leak. This is not necessarily a fast call, though, so you should
  /// call this once near startup and save the string if you need it.
  ///
  /// You should assume the path returned by this function is the only safe
  /// place to write files (and that SDL_GetBasePath(), while it might be
  /// writable, or even the parent of the returned path, aren't where you
  /// should be writing things).
  ///
  /// Some platforms can't determine the pref path, and on other
  /// platforms, this might be meaningless. In such cases, this function will
  /// return NULL.
  ///
  /// \param org The name of your organization.
  /// \param app The name of your application.
  /// \return UTF-8 string of user dir in platform-dependent notation. NULL
  /// if there's a problem (creating directory failed, etc).
  ///
  /// \sa SDL_GetBasePath
  ffi.Pointer<ffi.Int8> SDL_GetPrefPath(
    ffi.Pointer<ffi.Int8> org,
    ffi.Pointer<ffi.Int8> app,
  ) {
    return _SDL_GetPrefPath(
      org,
      app,
    );
  }

  late final _SDL_GetPrefPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('SDL_GetPrefPath');
  late final _SDL_GetPrefPath = _SDL_GetPrefPathPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  /// \brief Count the number of haptic devices attached to the system.
  ///
  /// \return Number of haptic devices detected on the system.
  int SDL_NumHaptics() {
    return _SDL_NumHaptics();
  }

  late final _SDL_NumHapticsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_NumHaptics');
  late final _SDL_NumHaptics = _SDL_NumHapticsPtr.asFunction<int Function()>();

  /// \brief Get the implementation dependent name of a haptic device.
  ///
  /// This can be called before any joysticks are opened.
  /// If no name can be found, this function returns NULL.
  ///
  /// \param device_index Index of the device to get its name.
  /// \return Name of the device or NULL on error.
  ///
  /// \sa SDL_NumHaptics
  ffi.Pointer<ffi.Int8> SDL_HapticName(
    int device_index,
  ) {
    return _SDL_HapticName(
      device_index,
    );
  }

  late final _SDL_HapticNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'SDL_HapticName');
  late final _SDL_HapticName =
      _SDL_HapticNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// \brief Opens a haptic device for use.
  ///
  /// The index passed as an argument refers to the N'th haptic device on this
  /// system.
  ///
  /// When opening a haptic device, its gain will be set to maximum and
  /// autocenter will be disabled.  To modify these values use
  /// SDL_HapticSetGain() and SDL_HapticSetAutocenter().
  ///
  /// \param device_index Index of the device to open.
  /// \return Device identifier or NULL on error.
  ///
  /// \sa SDL_HapticIndex
  /// \sa SDL_HapticOpenFromMouse
  /// \sa SDL_HapticOpenFromJoystick
  /// \sa SDL_HapticClose
  /// \sa SDL_HapticSetGain
  /// \sa SDL_HapticSetAutocenter
  /// \sa SDL_HapticPause
  /// \sa SDL_HapticStopAll
  ffi.Pointer<SDL_Haptic1> SDL_HapticOpen(
    int device_index,
  ) {
    return _SDL_HapticOpen(
      device_index,
    );
  }

  late final _SDL_HapticOpenPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Haptic1> Function(ffi.Int32)>>(
          'SDL_HapticOpen');
  late final _SDL_HapticOpen =
      _SDL_HapticOpenPtr.asFunction<ffi.Pointer<SDL_Haptic1> Function(int)>();

  /// \brief Checks if the haptic device at index has been opened.
  ///
  /// \param device_index Index to check to see if it has been opened.
  /// \return 1 if it has been opened or 0 if it hasn't.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticIndex
  int SDL_HapticOpened(
    int device_index,
  ) {
    return _SDL_HapticOpened(
      device_index,
    );
  }

  late final _SDL_HapticOpenedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_HapticOpened');
  late final _SDL_HapticOpened =
      _SDL_HapticOpenedPtr.asFunction<int Function(int)>();

  /// \brief Gets the index of a haptic device.
  ///
  /// \param haptic Haptic device to get the index of.
  /// \return The index of the haptic device or -1 on error.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticOpened
  int SDL_HapticIndex(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticIndex(
      haptic,
    );
  }

  late final _SDL_HapticIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticIndex');
  late final _SDL_HapticIndex =
      _SDL_HapticIndexPtr.asFunction<int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Gets whether or not the current mouse has haptic capabilities.
  ///
  /// \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
  ///
  /// \sa SDL_HapticOpenFromMouse
  int SDL_MouseIsHaptic() {
    return _SDL_MouseIsHaptic();
  }

  late final _SDL_MouseIsHapticPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_MouseIsHaptic');
  late final _SDL_MouseIsHaptic =
      _SDL_MouseIsHapticPtr.asFunction<int Function()>();

  /// \brief Tries to open a haptic device from the current mouse.
  ///
  /// \return The haptic device identifier or NULL on error.
  ///
  /// \sa SDL_MouseIsHaptic
  /// \sa SDL_HapticOpen
  ffi.Pointer<SDL_Haptic1> SDL_HapticOpenFromMouse() {
    return _SDL_HapticOpenFromMouse();
  }

  late final _SDL_HapticOpenFromMousePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Haptic1> Function()>>(
          'SDL_HapticOpenFromMouse');
  late final _SDL_HapticOpenFromMouse = _SDL_HapticOpenFromMousePtr.asFunction<
      ffi.Pointer<SDL_Haptic1> Function()>();

  /// \brief Checks to see if a joystick has haptic features.
  ///
  /// \param joystick Joystick to test for haptic capabilities.
  /// \return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't
  /// or -1 if an error occurred.
  ///
  /// \sa SDL_HapticOpenFromJoystick
  int SDL_JoystickIsHaptic(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_JoystickIsHaptic(
      joystick,
    );
  }

  late final _SDL_JoystickIsHapticPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Joystick1>)>>(
      'SDL_JoystickIsHaptic');
  late final _SDL_JoystickIsHaptic = _SDL_JoystickIsHapticPtr.asFunction<
      int Function(ffi.Pointer<SDL_Joystick1>)>();

  /// \brief Opens a haptic device for use from a joystick device.
  ///
  /// You must still close the haptic device separately.  It will not be closed
  /// with the joystick.
  ///
  /// When opening from a joystick you should first close the haptic device before
  /// closing the joystick device.  If not, on some implementations the haptic
  /// device will also get unallocated and you'll be unable to use force feedback
  /// on that device.
  ///
  /// \param joystick Joystick to create a haptic device from.
  /// \return A valid haptic device identifier on success or NULL on error.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticClose
  ffi.Pointer<SDL_Haptic1> SDL_HapticOpenFromJoystick(
    ffi.Pointer<SDL_Joystick1> joystick,
  ) {
    return _SDL_HapticOpenFromJoystick(
      joystick,
    );
  }

  late final _SDL_HapticOpenFromJoystickPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Haptic1> Function(
              ffi.Pointer<SDL_Joystick1>)>>('SDL_HapticOpenFromJoystick');
  late final _SDL_HapticOpenFromJoystick =
      _SDL_HapticOpenFromJoystickPtr.asFunction<
          ffi.Pointer<SDL_Haptic1> Function(ffi.Pointer<SDL_Joystick1>)>();

  /// \brief Closes a haptic device previously opened with SDL_HapticOpen().
  ///
  /// \param haptic Haptic device to close.
  void SDL_HapticClose(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticClose(
      haptic,
    );
  }

  late final _SDL_HapticClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticClose');
  late final _SDL_HapticClose =
      _SDL_HapticClosePtr.asFunction<void Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Returns the number of effects a haptic device can store.
  ///
  /// On some platforms this isn't fully supported, and therefore is an
  /// approximation.  Always check to see if your created effect was actually
  /// created and do not rely solely on SDL_HapticNumEffects().
  ///
  /// \param haptic The haptic device to query effect max.
  /// \return The number of effects the haptic device can store or
  /// -1 on error.
  ///
  /// \sa SDL_HapticNumEffectsPlaying
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffects(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticNumEffects(
      haptic,
    );
  }

  late final _SDL_HapticNumEffectsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticNumEffects');
  late final _SDL_HapticNumEffects = _SDL_HapticNumEffectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Returns the number of effects a haptic device can play at the same
  /// time.
  ///
  /// This is not supported on all platforms, but will always return a value.
  /// Added here for the sake of completeness.
  ///
  /// \param haptic The haptic device to query maximum playing effects.
  /// \return The number of effects the haptic device can play at the same time
  /// or -1 on error.
  ///
  /// \sa SDL_HapticNumEffects
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffectsPlaying(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticNumEffectsPlaying(
      haptic,
    );
  }

  late final _SDL_HapticNumEffectsPlayingPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticNumEffectsPlaying');
  late final _SDL_HapticNumEffectsPlaying = _SDL_HapticNumEffectsPlayingPtr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Gets the haptic device's supported features in bitwise manner.
  ///
  /// Example:
  /// \code
  /// if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {
  /// printf("We have constant haptic effect!\n");
  /// }
  /// \endcode
  ///
  /// \param haptic The haptic device to query.
  /// \return Haptic features in bitwise manner (OR'd).
  ///
  /// \sa SDL_HapticNumEffects
  /// \sa SDL_HapticEffectSupported
  int SDL_HapticQuery(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticQuery(
      haptic,
    );
  }

  late final _SDL_HapticQueryPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<SDL_Haptic1>)>>(
      'SDL_HapticQuery');
  late final _SDL_HapticQuery =
      _SDL_HapticQueryPtr.asFunction<int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Gets the number of haptic axes the device has.
  ///
  /// \sa SDL_HapticDirection
  int SDL_HapticNumAxes(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticNumAxes(
      haptic,
    );
  }

  late final _SDL_HapticNumAxesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticNumAxes');
  late final _SDL_HapticNumAxes = _SDL_HapticNumAxesPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Checks to see if effect is supported by haptic.
  ///
  /// \param haptic Haptic device to check on.
  /// \param effect Effect to check to see if it is supported.
  /// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
  ///
  /// \sa SDL_HapticQuery
  /// \sa SDL_HapticNewEffect
  int SDL_HapticEffectSupported(
    ffi.Pointer<SDL_Haptic1> haptic,
    ffi.Pointer<SDL_HapticEffect> effect,
  ) {
    return _SDL_HapticEffectSupported(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticEffectSupportedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticEffectSupported');
  late final _SDL_HapticEffectSupported =
      _SDL_HapticEffectSupportedPtr.asFunction<
          int Function(
              ffi.Pointer<SDL_Haptic1>, ffi.Pointer<SDL_HapticEffect>)>();

  /// \brief Creates a new haptic effect on the device.
  ///
  /// \param haptic Haptic device to create the effect on.
  /// \param effect Properties of the effect to create.
  /// \return The identifier of the effect on success or -1 on error.
  ///
  /// \sa SDL_HapticUpdateEffect
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticDestroyEffect
  int SDL_HapticNewEffect(
    ffi.Pointer<SDL_Haptic1> haptic,
    ffi.Pointer<SDL_HapticEffect> effect,
  ) {
    return _SDL_HapticNewEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticNewEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticNewEffect');
  late final _SDL_HapticNewEffect = _SDL_HapticNewEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>, ffi.Pointer<SDL_HapticEffect>)>();

  /// \brief Updates the properties of an effect.
  ///
  /// Can be used dynamically, although behavior when dynamically changing
  /// direction may be strange.  Specifically the effect may reupload itself
  /// and start playing from the start.  You cannot change the type either when
  /// running SDL_HapticUpdateEffect().
  ///
  /// \param haptic Haptic device that has the effect.
  /// \param effect Identifier of the effect to update.
  /// \param data New effect properties to use.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticNewEffect
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticDestroyEffect
  int SDL_HapticUpdateEffect(
    ffi.Pointer<SDL_Haptic1> haptic,
    int effect,
    ffi.Pointer<SDL_HapticEffect> data,
  ) {
    return _SDL_HapticUpdateEffect(
      haptic,
      effect,
      data,
    );
  }

  late final _SDL_HapticUpdateEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>, ffi.Int32,
              ffi.Pointer<SDL_HapticEffect>)>>('SDL_HapticUpdateEffect');
  late final _SDL_HapticUpdateEffect = _SDL_HapticUpdateEffectPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Haptic1>, int, ffi.Pointer<SDL_HapticEffect>)>();

  /// \brief Runs the haptic effect on its associated haptic device.
  ///
  /// If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over
  /// repeating the envelope (attack and fade) every time.  If you only want the
  /// effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length
  /// parameter.
  ///
  /// \param haptic Haptic device to run the effect on.
  /// \param effect Identifier of the haptic effect to run.
  /// \param iterations Number of iterations to run the effect. Use
  /// ::SDL_HAPTIC_INFINITY for infinity.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticStopEffect
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticGetEffectStatus
  int SDL_HapticRunEffect(
    ffi.Pointer<SDL_Haptic1> haptic,
    int effect,
    int iterations,
  ) {
    return _SDL_HapticRunEffect(
      haptic,
      effect,
      iterations,
    );
  }

  late final _SDL_HapticRunEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>, ffi.Int32,
              Uint32)>>('SDL_HapticRunEffect');
  late final _SDL_HapticRunEffect = _SDL_HapticRunEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>, int, int)>();

  /// \brief Stops the haptic effect on its associated haptic device.
  ///
  /// \param haptic Haptic device to stop the effect on.
  /// \param effect Identifier of the effect to stop.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticDestroyEffect
  int SDL_HapticStopEffect(
    ffi.Pointer<SDL_Haptic1> haptic,
    int effect,
  ) {
    return _SDL_HapticStopEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticStopEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Haptic1>, ffi.Int32)>>('SDL_HapticStopEffect');
  late final _SDL_HapticStopEffect = _SDL_HapticStopEffectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>, int)>();

  /// \brief Destroys a haptic effect on the device.
  ///
  /// This will stop the effect if it's running.  Effects are automatically
  /// destroyed when the device is closed.
  ///
  /// \param haptic Device to destroy the effect on.
  /// \param effect Identifier of the effect to destroy.
  ///
  /// \sa SDL_HapticNewEffect
  void SDL_HapticDestroyEffect(
    ffi.Pointer<SDL_Haptic1> haptic,
    int effect,
  ) {
    return _SDL_HapticDestroyEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticDestroyEffectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SDL_Haptic1>, ffi.Int32)>>('SDL_HapticDestroyEffect');
  late final _SDL_HapticDestroyEffect = _SDL_HapticDestroyEffectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Haptic1>, int)>();

  /// \brief Gets the status of the current effect on the haptic device.
  ///
  /// Device must support the ::SDL_HAPTIC_STATUS feature.
  ///
  /// \param haptic Haptic device to query the effect status on.
  /// \param effect Identifier of the effect to query its status.
  /// \return 0 if it isn't playing, 1 if it is playing or -1 on error.
  ///
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticStopEffect
  int SDL_HapticGetEffectStatus(
    ffi.Pointer<SDL_Haptic1> haptic,
    int effect,
  ) {
    return _SDL_HapticGetEffectStatus(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticGetEffectStatusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>,
              ffi.Int32)>>('SDL_HapticGetEffectStatus');
  late final _SDL_HapticGetEffectStatus = _SDL_HapticGetEffectStatusPtr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic1>, int)>();

  /// \brief Sets the global gain of the device.
  ///
  /// Device must support the ::SDL_HAPTIC_GAIN feature.
  ///
  /// The user may specify the maximum gain by setting the environment variable
  /// SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
  /// SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the
  /// maximum.
  ///
  /// \param haptic Haptic device to set the gain on.
  /// \param gain Value to set the gain to, should be between 0 and 100.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetGain(
    ffi.Pointer<SDL_Haptic1> haptic,
    int gain,
  ) {
    return _SDL_HapticSetGain(
      haptic,
      gain,
    );
  }

  late final _SDL_HapticSetGainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Haptic1>, ffi.Int32)>>('SDL_HapticSetGain');
  late final _SDL_HapticSetGain = _SDL_HapticSetGainPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>, int)>();

  /// \brief Sets the global autocenter of the device.
  ///
  /// Autocenter should be between 0 and 100.  Setting it to 0 will disable
  /// autocentering.
  ///
  /// Device must support the ::SDL_HAPTIC_AUTOCENTER feature.
  ///
  /// \param haptic Haptic device to set autocentering on.
  /// \param autocenter Value to set autocenter to, 0 disables autocentering.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetAutocenter(
    ffi.Pointer<SDL_Haptic1> haptic,
    int autocenter,
  ) {
    return _SDL_HapticSetAutocenter(
      haptic,
      autocenter,
    );
  }

  late final _SDL_HapticSetAutocenterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Haptic1>, ffi.Int32)>>('SDL_HapticSetAutocenter');
  late final _SDL_HapticSetAutocenter = _SDL_HapticSetAutocenterPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>, int)>();

  /// \brief Pauses a haptic device.
  ///
  /// Device must support the ::SDL_HAPTIC_PAUSE feature.  Call
  /// SDL_HapticUnpause() to resume playback.
  ///
  /// Do not modify the effects nor add new ones while the device is paused.
  /// That can cause all sorts of weird errors.
  ///
  /// \param haptic Haptic device to pause.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticUnpause
  int SDL_HapticPause(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticPause(
      haptic,
    );
  }

  late final _SDL_HapticPausePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticPause');
  late final _SDL_HapticPause =
      _SDL_HapticPausePtr.asFunction<int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Unpauses a haptic device.
  ///
  /// Call to unpause after SDL_HapticPause().
  ///
  /// \param haptic Haptic device to unpause.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticPause
  int SDL_HapticUnpause(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticUnpause(
      haptic,
    );
  }

  late final _SDL_HapticUnpausePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticUnpause');
  late final _SDL_HapticUnpause = _SDL_HapticUnpausePtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Stops all the currently playing effects on a haptic device.
  ///
  /// \param haptic Haptic device to stop.
  /// \return 0 on success or -1 on error.
  int SDL_HapticStopAll(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticStopAll(
      haptic,
    );
  }

  late final _SDL_HapticStopAllPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticStopAll');
  late final _SDL_HapticStopAll = _SDL_HapticStopAllPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Checks to see if rumble is supported on a haptic device.
  ///
  /// \param haptic Haptic device to check to see if it supports rumble.
  /// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumbleSupported(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticRumbleSupported(
      haptic,
    );
  }

  late final _SDL_HapticRumbleSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticRumbleSupported');
  late final _SDL_HapticRumbleSupported = _SDL_HapticRumbleSupportedPtr
      .asFunction<int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Initializes the haptic device for simple rumble playback.
  ///
  /// \param haptic Haptic device to initialize for simple rumble playback.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticRumbleSupported
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumbleInit(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticRumbleInit(
      haptic,
    );
  }

  late final _SDL_HapticRumbleInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticRumbleInit');
  late final _SDL_HapticRumbleInit = _SDL_HapticRumbleInitPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Runs simple rumble on a haptic device
  ///
  /// \param haptic Haptic device to play rumble effect on.
  /// \param strength Strength of the rumble to play as a 0-1 float value.
  /// \param length Length of the rumble to play in milliseconds.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticRumbleSupported
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumblePlay(
    ffi.Pointer<SDL_Haptic1> haptic,
    double strength,
    int length,
  ) {
    return _SDL_HapticRumblePlay(
      haptic,
      strength,
      length,
    );
  }

  late final _SDL_HapticRumblePlayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>, ffi.Float,
              Uint32)>>('SDL_HapticRumblePlay');
  late final _SDL_HapticRumblePlay = _SDL_HapticRumblePlayPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>, double, int)>();

  /// \brief Stops the simple rumble on a haptic device.
  ///
  /// \param haptic Haptic to stop the rumble on.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticRumbleSupported
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  int SDL_HapticRumbleStop(
    ffi.Pointer<SDL_Haptic1> haptic,
  ) {
    return _SDL_HapticRumbleStop(
      haptic,
    );
  }

  late final _SDL_HapticRumbleStopPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Haptic1>)>>(
          'SDL_HapticRumbleStop');
  late final _SDL_HapticRumbleStop = _SDL_HapticRumbleStopPtr.asFunction<
      int Function(ffi.Pointer<SDL_Haptic1>)>();

  /// \brief Set a hint with a specific priority
  ///
  /// The priority controls the behavior when setting a hint that already
  /// has a value.  Hints will replace existing hints of their priority and
  /// lower.  Environment variables are considered to have override priority.
  ///
  /// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
  int SDL_SetHintWithPriority(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
    int priority,
  ) {
    return _SDL_SetHintWithPriority(
      name,
      value,
      priority,
    );
  }

  late final _SDL_SetHintWithPriorityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('SDL_SetHintWithPriority');
  late final _SDL_SetHintWithPriority = _SDL_SetHintWithPriorityPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  /// \brief Set a hint with normal priority
  ///
  /// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
  int SDL_SetHint(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _SDL_SetHint(
      name,
      value,
    );
  }

  late final _SDL_SetHintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>('SDL_SetHint');
  late final _SDL_SetHint = _SDL_SetHintPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  /// \brief Get a hint
  ///
  /// \return The string value of a hint variable.
  ffi.Pointer<ffi.Int8> SDL_GetHint(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetHint(
      name,
    );
  }

  late final _SDL_GetHintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<ffi.Int8>)>>('SDL_GetHint');
  late final _SDL_GetHint = _SDL_GetHintPtr.asFunction<
      ffi.Pointer<ffi.Int8> Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Get a hint
  ///
  /// \return The boolean value of a hint variable.
  int SDL_GetHintBoolean(
    ffi.Pointer<ffi.Int8> name,
    int default_value,
  ) {
    return _SDL_GetHintBoolean(
      name,
      default_value,
    );
  }

  late final _SDL_GetHintBooleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>, ffi.Int32)>>('SDL_GetHintBoolean');
  late final _SDL_GetHintBoolean = _SDL_GetHintBooleanPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, int)>();

  /// \brief Add a function to watch a particular hint
  ///
  /// \param name The hint to watch
  /// \param callback The function to call when the hint value changes
  /// \param userdata A pointer to pass to the callback function
  void SDL_AddHintCallback(
    ffi.Pointer<ffi.Int8> name,
    SDL_HintCallback callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddHintCallback(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_AddHintCallbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int8>, SDL_HintCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddHintCallback');
  late final _SDL_AddHintCallback = _SDL_AddHintCallbackPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Int8>, SDL_HintCallback, ffi.Pointer<ffi.Void>)>();

  /// \brief Remove a function watching a particular hint
  ///
  /// \param name The hint being watched
  /// \param callback The function being called when the hint value changes
  /// \param userdata A pointer being passed to the callback function
  void SDL_DelHintCallback(
    ffi.Pointer<ffi.Int8> name,
    SDL_HintCallback callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelHintCallback(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_DelHintCallbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int8>, SDL_HintCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_DelHintCallback');
  late final _SDL_DelHintCallback = _SDL_DelHintCallbackPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Int8>, SDL_HintCallback, ffi.Pointer<ffi.Void>)>();

  /// \brief  Clear all hints
  ///
  /// This function is called during SDL_Quit() to free stored hints.
  void SDL_ClearHints() {
    return _SDL_ClearHints();
  }

  late final _SDL_ClearHintsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_ClearHints');
  late final _SDL_ClearHints = _SDL_ClearHintsPtr.asFunction<void Function()>();

  /// This function dynamically loads a shared object and returns a pointer
  /// to the object handle (or NULL if there was an error).
  /// The 'sofile' parameter is a system dependent name of the object file.
  ffi.Pointer<ffi.Void> SDL_LoadObject(
    ffi.Pointer<ffi.Int8> sofile,
  ) {
    return _SDL_LoadObject(
      sofile,
    );
  }

  late final _SDL_LoadObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Int8>)>>('SDL_LoadObject');
  late final _SDL_LoadObject = _SDL_LoadObjectPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Int8>)>();

  /// Given an object handle, this function looks up the address of the
  /// named function in the shared object and returns it.  This address
  /// is no longer valid after calling SDL_UnloadObject().
  ffi.Pointer<ffi.Void> SDL_LoadFunction(
    ffi.Pointer<ffi.Void> handle,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_LoadFunction(
      handle,
      name,
    );
  }

  late final _SDL_LoadFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int8>)>>('SDL_LoadFunction');
  late final _SDL_LoadFunction = _SDL_LoadFunctionPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int8>)>();

  /// Unload a shared object from memory.
  void SDL_UnloadObject(
    ffi.Pointer<ffi.Void> handle,
  ) {
    return _SDL_UnloadObject(
      handle,
    );
  }

  late final _SDL_UnloadObjectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'SDL_UnloadObject');
  late final _SDL_UnloadObject =
      _SDL_UnloadObjectPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// \brief Set the priority of all log categories
  void SDL_LogSetAllPriority(
    int priority,
  ) {
    return _SDL_LogSetAllPriority(
      priority,
    );
  }

  late final _SDL_LogSetAllPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'SDL_LogSetAllPriority');
  late final _SDL_LogSetAllPriority =
      _SDL_LogSetAllPriorityPtr.asFunction<void Function(int)>();

  /// \brief Set the priority of a particular log category
  void SDL_LogSetPriority(
    int category,
    int priority,
  ) {
    return _SDL_LogSetPriority(
      category,
      priority,
    );
  }

  late final _SDL_LogSetPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
          'SDL_LogSetPriority');
  late final _SDL_LogSetPriority =
      _SDL_LogSetPriorityPtr.asFunction<void Function(int, int)>();

  /// \brief Get the priority of a particular log category
  int SDL_LogGetPriority(
    int category,
  ) {
    return _SDL_LogGetPriority(
      category,
    );
  }

  late final _SDL_LogGetPriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_LogGetPriority');
  late final _SDL_LogGetPriority =
      _SDL_LogGetPriorityPtr.asFunction<int Function(int)>();

  /// \brief Reset all priorities to default.
  ///
  /// \note This is called in SDL_Quit().
  void SDL_LogResetPriorities() {
    return _SDL_LogResetPriorities();
  }

  late final _SDL_LogResetPrioritiesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_LogResetPriorities');
  late final _SDL_LogResetPriorities =
      _SDL_LogResetPrioritiesPtr.asFunction<void Function()>();

  /// \brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO
  void SDL_Log(
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_Log(
      fmt,
    );
  }

  late final _SDL_LogPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_Log');
  late final _SDL_Log =
      _SDL_LogPtr.asFunction<void Function(ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with SDL_LOG_PRIORITY_VERBOSE
  void SDL_LogVerbose(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogVerbose(
      category,
      fmt,
    );
  }

  late final _SDL_LogVerbosePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogVerbose');
  late final _SDL_LogVerbose = _SDL_LogVerbosePtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with SDL_LOG_PRIORITY_DEBUG
  void SDL_LogDebug(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogDebug(
      category,
      fmt,
    );
  }

  late final _SDL_LogDebugPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogDebug');
  late final _SDL_LogDebug =
      _SDL_LogDebugPtr.asFunction<void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with SDL_LOG_PRIORITY_INFO
  void SDL_LogInfo(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogInfo(
      category,
      fmt,
    );
  }

  late final _SDL_LogInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogInfo');
  late final _SDL_LogInfo =
      _SDL_LogInfoPtr.asFunction<void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with SDL_LOG_PRIORITY_WARN
  void SDL_LogWarn(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogWarn(
      category,
      fmt,
    );
  }

  late final _SDL_LogWarnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogWarn');
  late final _SDL_LogWarn =
      _SDL_LogWarnPtr.asFunction<void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with SDL_LOG_PRIORITY_ERROR
  void SDL_LogError(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogError(
      category,
      fmt,
    );
  }

  late final _SDL_LogErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogError');
  late final _SDL_LogError =
      _SDL_LogErrorPtr.asFunction<void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with SDL_LOG_PRIORITY_CRITICAL
  void SDL_LogCritical(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogCritical(
      category,
      fmt,
    );
  }

  late final _SDL_LogCriticalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogCritical');
  late final _SDL_LogCritical = _SDL_LogCriticalPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with the specified category and priority.
  void SDL_LogMessage(
    int category,
    int priority,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogMessage(
      category,
      priority,
      fmt,
    );
  }

  late final _SDL_LogMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Int8>)>>('SDL_LogMessage');
  late final _SDL_LogMessage = _SDL_LogMessagePtr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Int8>)>();

  /// \brief Log a message with the specified category and priority.
  void SDL_LogMessageV(
    int category,
    int priority,
    ffi.Pointer<ffi.Int8> fmt,
    va_list ap,
  ) {
    return _SDL_LogMessageV(
      category,
      priority,
      fmt,
      ap,
    );
  }

  late final _SDL_LogMessageVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Int8>,
              va_list)>>('SDL_LogMessageV');
  late final _SDL_LogMessageV = _SDL_LogMessageVPtr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Int8>, va_list)>();

  /// \brief Get the current log output function.
  void SDL_LogGetOutputFunction(
    ffi.Pointer<SDL_LogOutputFunction> callback,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_LogGetOutputFunction(
      callback,
      userdata,
    );
  }

  late final _SDL_LogGetOutputFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_LogOutputFunction>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('SDL_LogGetOutputFunction');
  late final _SDL_LogGetOutputFunction =
      _SDL_LogGetOutputFunctionPtr.asFunction<
          void Function(ffi.Pointer<SDL_LogOutputFunction>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// \brief This function allows you to replace the default log output
  /// function with one of your own.
  void SDL_LogSetOutputFunction(
    SDL_LogOutputFunction callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_LogSetOutputFunction(
      callback,
      userdata,
    );
  }

  late final _SDL_LogSetOutputFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_LogOutputFunction,
              ffi.Pointer<ffi.Void>)>>('SDL_LogSetOutputFunction');
  late final _SDL_LogSetOutputFunction =
      _SDL_LogSetOutputFunctionPtr.asFunction<
          void Function(SDL_LogOutputFunction, ffi.Pointer<ffi.Void>)>();

  /// \brief Create a modal message box.
  ///
  /// \param messageboxdata The SDL_MessageBoxData structure with title, text, etc.
  /// \param buttonid The pointer to which user id of hit button should be copied.
  ///
  /// \return -1 on error, otherwise 0 and buttonid contains user id of button
  /// hit or -1 if dialog was closed.
  ///
  /// \note This function should be called on the thread that created the parent
  /// window, or on the main thread if the messagebox has no parent.  It will
  /// block execution of that thread until the user clicks a button or
  /// closes the messagebox.
  int SDL_ShowMessageBox(
    ffi.Pointer<SDL_MessageBoxData> messageboxdata,
    ffi.Pointer<ffi.Int32> buttonid,
  ) {
    return _SDL_ShowMessageBox(
      messageboxdata,
      buttonid,
    );
  }

  late final _SDL_ShowMessageBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_MessageBoxData>,
              ffi.Pointer<ffi.Int32>)>>('SDL_ShowMessageBox');
  late final _SDL_ShowMessageBox = _SDL_ShowMessageBoxPtr.asFunction<
      int Function(ffi.Pointer<SDL_MessageBoxData>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Create a simple modal message box
  ///
  /// \param flags    ::SDL_MessageBoxFlags
  /// \param title    UTF-8 title text
  /// \param message  UTF-8 message text
  /// \param window   The parent window, or NULL for no parent
  ///
  /// \return 0 on success, -1 on error
  ///
  /// \sa SDL_ShowMessageBox
  int SDL_ShowSimpleMessageBox(
    int flags,
    ffi.Pointer<ffi.Int8> title,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowSimpleMessageBox(
      flags,
      title,
      message,
      window,
    );
  }

  late final _SDL_ShowSimpleMessageBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Uint32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<SDL_Window>)>>('SDL_ShowSimpleMessageBox');
  late final _SDL_ShowSimpleMessageBox =
      _SDL_ShowSimpleMessageBoxPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<SDL_Window>)>();

  /// \brief Create a CAMetalLayer-backed NSView/UIView and attach it to the
  /// specified window.
  ///
  /// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on its
  /// own. It is up to user code to do that.
  ///
  /// The returned handle can be casted directly to a NSView or UIView.
  /// To access the backing CAMetalLayer, call SDL_Metal_GetLayer().
  ///
  /// \note \a window must be created with the SDL_WINDOW_METAL flag.
  ///
  /// \sa SDL_Metal_DestroyView
  /// \sa SDL_Metal_GetLayer
  SDL_MetalView SDL_Metal_CreateView(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_Metal_CreateView(
      window,
    );
  }

  late final _SDL_Metal_CreateViewPtr = _lookup<
          ffi.NativeFunction<SDL_MetalView Function(ffi.Pointer<SDL_Window>)>>(
      'SDL_Metal_CreateView');
  late final _SDL_Metal_CreateView = _SDL_Metal_CreateViewPtr.asFunction<
      SDL_MetalView Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Destroy an existing SDL_MetalView object.
  ///
  /// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was
  /// called after SDL_CreateWindow.
  ///
  /// \sa SDL_Metal_CreateView
  void SDL_Metal_DestroyView(
    SDL_MetalView view,
  ) {
    return _SDL_Metal_DestroyView(
      view,
    );
  }

  late final _SDL_Metal_DestroyViewPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SDL_MetalView)>>(
          'SDL_Metal_DestroyView');
  late final _SDL_Metal_DestroyView =
      _SDL_Metal_DestroyViewPtr.asFunction<void Function(SDL_MetalView)>();

  /// \brief Get a pointer to the backing CAMetalLayer for the given view.
  ///
  /// \sa SDL_MetalCreateView
  ffi.Pointer<ffi.Void> SDL_Metal_GetLayer(
    SDL_MetalView view,
  ) {
    return _SDL_Metal_GetLayer(
      view,
    );
  }

  late final _SDL_Metal_GetLayerPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(SDL_MetalView)>>(
      'SDL_Metal_GetLayer');
  late final _SDL_Metal_GetLayer = _SDL_Metal_GetLayerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(SDL_MetalView)>();

  /// \brief Get the size of a window's underlying drawable in pixels (for use
  /// with setting viewport, scissor & etc).
  ///
  /// \param window   SDL_Window from which the drawable size should be queried
  /// \param w        Pointer to variable for storing the width in pixels,
  /// may be NULL
  /// \param h        Pointer to variable for storing the height in pixels,
  /// may be NULL
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not disabled
  /// by the \c SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
  ///
  /// \note On macOS high-DPI support must be enabled for an application by
  /// setting NSHighResolutionCapable to true in its Info.plist.
  ///
  /// \sa SDL_GetWindowSize()
  /// \sa SDL_CreateWindow()
  void SDL_Metal_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_Metal_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_Metal_GetDrawableSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_Metal_GetDrawableSize');
  late final _SDL_Metal_GetDrawableSize =
      _SDL_Metal_GetDrawableSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Window>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Get the current power supply details.
  ///
  /// \param secs Seconds of battery life left. You can pass a NULL here if
  /// you don't care. Will return -1 if we can't determine a
  /// value, or we're not running on a battery.
  ///
  /// \param pct Percentage of battery life left, between 0 and 100. You can
  /// pass a NULL here if you don't care. Will return -1 if we
  /// can't determine a value, or we're not running on a battery.
  ///
  /// \return The state of the battery (if any).
  int SDL_GetPowerInfo(
    ffi.Pointer<ffi.Int32> secs,
    ffi.Pointer<ffi.Int32> pct,
  ) {
    return _SDL_GetPowerInfo(
      secs,
      pct,
    );
  }

  late final _SDL_GetPowerInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetPowerInfo');
  late final _SDL_GetPowerInfo = _SDL_GetPowerInfoPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Get the number of 2D rendering drivers available for the current
  /// display.
  ///
  /// A render driver is a set of code that handles rendering and texture
  /// management on a particular display.  Normally there is only one, but
  /// some drivers may have several available with different capabilities.
  ///
  /// \sa SDL_GetRenderDriverInfo()
  /// \sa SDL_CreateRenderer()
  int SDL_GetNumRenderDrivers() {
    return _SDL_GetNumRenderDrivers();
  }

  late final _SDL_GetNumRenderDriversPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetNumRenderDrivers');
  late final _SDL_GetNumRenderDrivers =
      _SDL_GetNumRenderDriversPtr.asFunction<int Function()>();

  /// \brief Get information about a specific 2D rendering driver for the current
  /// display.
  ///
  /// \param index The index of the driver to query information about.
  /// \param info  A pointer to an SDL_RendererInfo struct to be filled with
  /// information on the rendering driver.
  ///
  /// \return 0 on success, -1 if the index was out of range.
  ///
  /// \sa SDL_CreateRenderer()
  int SDL_GetRenderDriverInfo(
    int index,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRenderDriverInfo(
      index,
      info,
    );
  }

  late final _SDL_GetRenderDriverInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRenderDriverInfo');
  late final _SDL_GetRenderDriverInfo = _SDL_GetRenderDriverInfoPtr.asFunction<
      int Function(int, ffi.Pointer<SDL_RendererInfo>)>();

  /// \brief Create a window and default renderer
  ///
  /// \param width    The width of the window
  /// \param height   The height of the window
  /// \param window_flags The flags used to create the window
  /// \param window   A pointer filled with the window, or NULL on error
  /// \param renderer A pointer filled with the renderer, or NULL on error
  ///
  /// \return 0 on success, or -1 on error
  int SDL_CreateWindowAndRenderer(
    int width,
    int height,
    int window_flags,
    ffi.Pointer<ffi.Pointer<SDL_Window>> window,
    ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
  ) {
    return _SDL_CreateWindowAndRenderer(
      width,
      height,
      window_flags,
      window,
      renderer,
    );
  }

  late final _SDL_CreateWindowAndRendererPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Int32,
                  ffi.Int32,
                  Uint32,
                  ffi.Pointer<ffi.Pointer<SDL_Window>>,
                  ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>>(
      'SDL_CreateWindowAndRenderer');
  late final _SDL_CreateWindowAndRenderer =
      _SDL_CreateWindowAndRendererPtr.asFunction<
          int Function(int, int, int, ffi.Pointer<ffi.Pointer<SDL_Window>>,
              ffi.Pointer<ffi.Pointer<SDL_Renderer>>)>();

  /// \brief Create a 2D rendering context for a window.
  ///
  /// \param window The window where rendering is displayed.
  /// \param index    The index of the rendering driver to initialize, or -1 to
  /// initialize the first one supporting the requested flags.
  /// \param flags    ::SDL_RendererFlags.
  ///
  /// \return A valid rendering context or NULL if there was an error.
  ///
  /// \sa SDL_CreateSoftwareRenderer()
  /// \sa SDL_GetRendererInfo()
  /// \sa SDL_DestroyRenderer()
  ffi.Pointer<SDL_Renderer> SDL_CreateRenderer(
    ffi.Pointer<SDL_Window> window,
    int index,
    int flags,
  ) {
    return _SDL_CreateRenderer(
      window,
      index,
      flags,
    );
  }

  late final _SDL_CreateRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>, ffi.Int32,
              Uint32)>>('SDL_CreateRenderer');
  late final _SDL_CreateRenderer = _SDL_CreateRendererPtr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>, int, int)>();

  /// \brief Create a 2D software rendering context for a surface.
  ///
  /// \param surface The surface where rendering is done.
  ///
  /// \return A valid rendering context or NULL if there was an error.
  ///
  /// \sa SDL_CreateRenderer()
  /// \sa SDL_DestroyRenderer()
  ffi.Pointer<SDL_Renderer> SDL_CreateSoftwareRenderer(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateSoftwareRenderer(
      surface,
    );
  }

  late final _SDL_CreateSoftwareRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateSoftwareRenderer');
  late final _SDL_CreateSoftwareRenderer =
      _SDL_CreateSoftwareRendererPtr.asFunction<
          ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Surface>)>();

  /// \brief Get the renderer associated with a window.
  ffi.Pointer<SDL_Renderer> SDL_GetRenderer(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetRenderer(
      window,
    );
  }

  late final _SDL_GetRendererPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Renderer> Function(
              ffi.Pointer<SDL_Window>)>>('SDL_GetRenderer');
  late final _SDL_GetRenderer = _SDL_GetRendererPtr.asFunction<
      ffi.Pointer<SDL_Renderer> Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Get information about a rendering context.
  int SDL_GetRendererInfo(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRendererInfo(
      renderer,
      info,
    );
  }

  late final _SDL_GetRendererInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_RendererInfo>)>>('SDL_GetRendererInfo');
  late final _SDL_GetRendererInfo = _SDL_GetRendererInfoPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_RendererInfo>)>();

  /// \brief Get the output size in pixels of a rendering context.
  int SDL_GetRendererOutputSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetRendererOutputSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_GetRendererOutputSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetRendererOutputSize');
  late final _SDL_GetRendererOutputSize =
      _SDL_GetRendererOutputSizePtr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Create a texture for a rendering context.
  ///
  /// \param renderer The renderer.
  /// \param format The format of the texture.
  /// \param access One of the enumerated values in ::SDL_TextureAccess.
  /// \param w      The width of the texture in pixels.
  /// \param h      The height of the texture in pixels.
  ///
  /// \return The created texture is returned, or NULL if no rendering context was
  /// active,  the format was unsupported, or the width or height were out
  /// of range.
  ///
  /// \note The contents of the texture are not defined at creation.
  ///
  /// \sa SDL_QueryTexture()
  /// \sa SDL_UpdateTexture()
  /// \sa SDL_DestroyTexture()
  ffi.Pointer<SDL_Texture> SDL_CreateTexture(
    ffi.Pointer<SDL_Renderer> renderer,
    int format,
    int access,
    int w,
    int h,
  ) {
    return _SDL_CreateTexture(
      renderer,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_CreateTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>, Uint32,
              ffi.Int32, ffi.Int32, ffi.Int32)>>('SDL_CreateTexture');
  late final _SDL_CreateTexture = _SDL_CreateTexturePtr.asFunction<
      ffi.Pointer<SDL_Texture> Function(
          ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// \brief Create a texture from an existing surface.
  ///
  /// \param renderer The renderer.
  /// \param surface The surface containing pixel data used to fill the texture.
  ///
  /// \return The created texture is returned, or NULL on error.
  ///
  /// \note The surface is not modified or freed by this function.
  ///
  /// \sa SDL_QueryTexture()
  /// \sa SDL_DestroyTexture()
  ffi.Pointer<SDL_Texture> SDL_CreateTextureFromSurface(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateTextureFromSurface(
      renderer,
      surface,
    );
  }

  late final _SDL_CreateTextureFromSurfacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Surface>)>>('SDL_CreateTextureFromSurface');
  late final _SDL_CreateTextureFromSurface =
      _SDL_CreateTextureFromSurfacePtr.asFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Surface>)>();

  /// \brief Query the attributes of a texture
  ///
  /// \param texture A texture to be queried.
  /// \param format  A pointer filled in with the raw format of the texture.  The
  /// actual format may differ, but pixel transfers will use this
  /// format.
  /// \param access  A pointer filled in with the actual access to the texture.
  /// \param w       A pointer filled in with the width of the texture in pixels.
  /// \param h       A pointer filled in with the height of the texture in pixels.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  int SDL_QueryTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint32> format,
    ffi.Pointer<ffi.Int32> access,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_QueryTexture(
      texture,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_QueryTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_QueryTexture');
  late final _SDL_QueryTexture = _SDL_QueryTexturePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<Uint32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// \brief Set an additional color value used in render copy operations.
  ///
  /// \param texture The texture to update.
  /// \param r       The red color value multiplied into copy operations.
  /// \param g       The green color value multiplied into copy operations.
  /// \param b       The blue color value multiplied into copy operations.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or color modulation
  /// is not supported.
  ///
  /// \sa SDL_GetTextureColorMod()
  int SDL_SetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetTextureColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Texture>, Uint8, Uint8,
              Uint8)>>('SDL_SetTextureColorMod');
  late final _SDL_SetTextureColorMod = _SDL_SetTextureColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int, int, int)>();

  /// \brief Get the additional color value used in render copy operations.
  ///
  /// \param texture The texture to query.
  /// \param r         A pointer filled in with the current red color value.
  /// \param g         A pointer filled in with the current green color value.
  /// \param b         A pointer filled in with the current blue color value.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureColorMod()
  int SDL_GetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
  ) {
    return _SDL_GetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetTextureColorModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureColorMod');
  late final _SDL_GetTextureColorMod = _SDL_GetTextureColorModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// \brief Set an additional alpha value used in render copy operations.
  ///
  /// \param texture The texture to update.
  /// \param alpha     The alpha value multiplied into copy operations.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or alpha modulation
  /// is not supported.
  ///
  /// \sa SDL_GetTextureAlphaMod()
  int SDL_SetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    int alpha,
  ) {
    return _SDL_SetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_SetTextureAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>, Uint8)>>('SDL_SetTextureAlphaMod');
  late final _SDL_SetTextureAlphaMod = _SDL_SetTextureAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// \brief Get the additional alpha value used in render copy operations.
  ///
  /// \param texture The texture to query.
  /// \param alpha     A pointer filled in with the current alpha value.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureAlphaMod()
  int SDL_GetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<Uint8> alpha,
  ) {
    return _SDL_GetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_GetTextureAlphaModPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<Uint8>)>>('SDL_GetTextureAlphaMod');
  late final _SDL_GetTextureAlphaMod = _SDL_GetTextureAlphaModPtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<Uint8>)>();

  /// \brief Set the blend mode used for texture copy operations.
  ///
  /// \param texture The texture to update.
  /// \param blendMode ::SDL_BlendMode to use for texture blending.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or the blend mode is
  /// not supported.
  ///
  /// \note If the blend mode is not supported, the closest supported mode is
  /// chosen.
  ///
  /// \sa SDL_GetTextureBlendMode()
  int SDL_SetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    int blendMode,
  ) {
    return _SDL_SetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_SetTextureBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>, ffi.Int32)>>('SDL_SetTextureBlendMode');
  late final _SDL_SetTextureBlendMode = _SDL_SetTextureBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// \brief Get the blend mode used for texture copy operations.
  ///
  /// \param texture   The texture to query.
  /// \param blendMode A pointer filled in with the current blend mode.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureBlendMode()
  int SDL_GetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_GetTextureBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetTextureBlendMode');
  late final _SDL_GetTextureBlendMode = _SDL_GetTextureBlendModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Set the scale mode used for texture scale operations.
  ///
  /// \param texture The texture to update.
  /// \param scaleMode ::SDL_ScaleMode to use for texture scaling.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \note If the scale mode is not supported, the closest supported mode is
  /// chosen.
  ///
  /// \sa SDL_GetTextureScaleMode()
  int SDL_SetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    int scaleMode,
  ) {
    return _SDL_SetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_SetTextureScaleModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>, ffi.Int32)>>('SDL_SetTextureScaleMode');
  late final _SDL_SetTextureScaleMode = _SDL_SetTextureScaleModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, int)>();

  /// \brief Get the scale mode used for texture scale operations.
  ///
  /// \param texture   The texture to query.
  /// \param scaleMode A pointer filled in with the current scale mode.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureScaleMode()
  int SDL_GetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> scaleMode,
  ) {
    return _SDL_GetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_GetTextureScaleModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Texture>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetTextureScaleMode');
  late final _SDL_GetTextureScaleMode = _SDL_GetTextureScaleModePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Update the given texture rectangle with new pixel data.
  ///
  /// \param texture   The texture to update
  /// \param rect      A pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param pixels    The raw pixel data in the format of the texture.
  /// \param pitch     The number of bytes in a row of pixel data, including padding between lines.
  ///
  /// The pixel data must be in the format of the texture. The pixel format can be
  /// queried with SDL_QueryTexture.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \note This is a fairly slow function.
  int SDL_UpdateTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_UpdateTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_UpdateTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Void>, ffi.Int32)>>('SDL_UpdateTexture');
  late final _SDL_UpdateTexture = _SDL_UpdateTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Void>, int)>();

  /// \brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data.
  ///
  /// \param texture   The texture to update
  /// \param rect      A pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param Yplane    The raw pixel data for the Y plane.
  /// \param Ypitch    The number of bytes between rows of pixel data for the Y plane.
  /// \param Uplane    The raw pixel data for the U plane.
  /// \param Upitch    The number of bytes between rows of pixel data for the U plane.
  /// \param Vplane    The raw pixel data for the V plane.
  /// \param Vpitch    The number of bytes between rows of pixel data for the V plane.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \note You can use SDL_UpdateTexture() as long as your pixel data is
  /// a contiguous block of Y and U/V planes in the proper order, but
  /// this function is available if your pixel data is not contiguous.
  int SDL_UpdateYUVTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<Uint8> Uplane,
    int Upitch,
    ffi.Pointer<Uint8> Vplane,
    int Vpitch,
  ) {
    return _SDL_UpdateYUVTexture(
      texture,
      rect,
      Yplane,
      Ypitch,
      Uplane,
      Upitch,
      Vplane,
      Vpitch,
    );
  }

  late final _SDL_UpdateYUVTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<Uint8>,
              ffi.Int32,
              ffi.Pointer<Uint8>,
              ffi.Int32,
              ffi.Pointer<Uint8>,
              ffi.Int32)>>('SDL_UpdateYUVTexture');
  late final _SDL_UpdateYUVTexture = _SDL_UpdateYUVTexturePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int,
          ffi.Pointer<Uint8>,
          int)>();

  /// \brief Lock a portion of the texture for write-only pixel access.
  ///
  /// \param texture   The texture to lock for access, which was created with
  /// ::SDL_TEXTUREACCESS_STREAMING.
  /// \param rect      A pointer to the rectangle to lock for access. If the rect
  /// is NULL, the entire texture will be locked.
  /// \param pixels    This is filled in with a pointer to the locked pixels,
  /// appropriately offset by the locked area.
  /// \param pitch     This is filled in with the pitch of the locked pixels.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
  ///
  /// \sa SDL_UnlockTexture()
  int SDL_LockTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
    ffi.Pointer<ffi.Int32> pitch,
  ) {
    return _SDL_LockTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_LockTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Int32>)>>('SDL_LockTexture');
  late final _SDL_LockTexture = _SDL_LockTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Lock a portion of the texture for write-only pixel access.
  /// Expose it as a SDL surface.
  ///
  /// \param texture   The texture to lock for access, which was created with
  /// ::SDL_TEXTUREACCESS_STREAMING.
  /// \param rect      A pointer to the rectangle to lock for access. If the rect
  /// is NULL, the entire texture will be locked.
  /// \param surface   This is filled in with a SDL surface representing the locked area
  /// Surface is freed internally after calling SDL_UnlockTexture or SDL_DestroyTexture.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
  ///
  /// \sa SDL_UnlockTexture()
  int SDL_LockTextureToSurface(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
  ) {
    return _SDL_LockTextureToSurface(
      texture,
      rect,
      surface,
    );
  }

  late final _SDL_LockTextureToSurfacePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<SDL_Texture>,
                  ffi.Pointer<SDL_Rect>,
                  ffi.Pointer<ffi.Pointer<SDL_Surface>>)>>(
      'SDL_LockTextureToSurface');
  late final _SDL_LockTextureToSurface =
      _SDL_LockTextureToSurfacePtr.asFunction<
          int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<SDL_Rect>,
              ffi.Pointer<ffi.Pointer<SDL_Surface>>)>();

  /// \brief Unlock a texture, uploading the changes to video memory, if needed.
  /// If SDL_LockTextureToSurface() was called for locking, the SDL surface is freed.
  ///
  /// \sa SDL_LockTexture()
  /// \sa SDL_LockTextureToSurface()
  void SDL_UnlockTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_UnlockTexture(
      texture,
    );
  }

  late final _SDL_UnlockTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_UnlockTexture');
  late final _SDL_UnlockTexture = _SDL_UnlockTexturePtr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// \brief Determines whether a window supports the use of render targets
  ///
  /// \param renderer The renderer that will be checked
  ///
  /// \return SDL_TRUE if supported, SDL_FALSE if not.
  int SDL_RenderTargetSupported(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderTargetSupported(
      renderer,
    );
  }

  late final _SDL_RenderTargetSupportedPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderTargetSupported');
  late final _SDL_RenderTargetSupported = _SDL_RenderTargetSupportedPtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Set a texture as the current rendering target.
  ///
  /// \param renderer The renderer.
  /// \param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \sa SDL_GetRenderTarget()
  int SDL_SetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_SetRenderTarget(
      renderer,
      texture,
    );
  }

  late final _SDL_SetRenderTargetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>)>>('SDL_SetRenderTarget');
  late final _SDL_SetRenderTarget = _SDL_SetRenderTargetPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>)>();

  /// \brief Get the current render target or NULL for the default render target.
  ///
  /// \return The current render target
  ///
  /// \sa SDL_SetRenderTarget()
  ffi.Pointer<SDL_Texture> SDL_GetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_GetRenderTarget(
      renderer,
    );
  }

  late final _SDL_GetRenderTargetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Texture> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_GetRenderTarget');
  late final _SDL_GetRenderTarget = _SDL_GetRenderTargetPtr.asFunction<
      ffi.Pointer<SDL_Texture> Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Set device independent resolution for rendering
  ///
  /// \param renderer The renderer for which resolution should be set.
  /// \param w      The width of the logical resolution
  /// \param h      The height of the logical resolution
  ///
  /// This function uses the viewport and scaling functionality to allow a fixed logical
  /// resolution for rendering, regardless of the actual output resolution.  If the actual
  /// output resolution doesn't have the same aspect ratio the output rendering will be
  /// centered within the output display.
  ///
  /// If the output display is a window, mouse events in the window will be filtered
  /// and scaled so they seem to arrive within the logical resolution.
  ///
  /// \note If this function results in scaling or subpixel drawing by the
  /// rendering backend, it will be handled using the appropriate
  /// quality hints.
  ///
  /// \sa SDL_RenderGetLogicalSize()
  /// \sa SDL_RenderSetScale()
  /// \sa SDL_RenderSetViewport()
  int SDL_RenderSetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    int w,
    int h,
  ) {
    return _SDL_RenderSetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderSetLogicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Int32,
              ffi.Int32)>>('SDL_RenderSetLogicalSize');
  late final _SDL_RenderSetLogicalSize = _SDL_RenderSetLogicalSizePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// \brief Get device independent resolution for rendering
  ///
  /// \param renderer The renderer from which resolution should be queried.
  /// \param w      A pointer filled with the width of the logical resolution
  /// \param h      A pointer filled with the height of the logical resolution
  ///
  /// \sa SDL_RenderSetLogicalSize()
  void SDL_RenderGetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_RenderGetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderGetLogicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_RenderGetLogicalSize');
  late final _SDL_RenderGetLogicalSize =
      _SDL_RenderGetLogicalSizePtr.asFunction<
          void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// \brief Set whether to force integer scales for resolution-independent rendering
  ///
  /// \param renderer The renderer for which integer scaling should be set.
  /// \param enable   Enable or disable integer scaling
  ///
  /// This function restricts the logical viewport to integer values - that is, when
  /// a resolution is between two multiples of a logical size, the viewport size is
  /// rounded down to the lower multiple.
  ///
  /// \sa SDL_RenderSetLogicalSize()
  int SDL_RenderSetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
    int enable,
  ) {
    return _SDL_RenderSetIntegerScale(
      renderer,
      enable,
    );
  }

  late final _SDL_RenderSetIntegerScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Int32)>>('SDL_RenderSetIntegerScale');
  late final _SDL_RenderSetIntegerScale = _SDL_RenderSetIntegerScalePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// \brief Get whether integer scales are forced for resolution-independent rendering
  ///
  /// \param renderer The renderer from which integer scaling should be queried.
  ///
  /// \sa SDL_RenderSetIntegerScale()
  int SDL_RenderGetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetIntegerScale(
      renderer,
    );
  }

  late final _SDL_RenderGetIntegerScalePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderGetIntegerScale');
  late final _SDL_RenderGetIntegerScale = _SDL_RenderGetIntegerScalePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Set the drawing area for rendering on the current target.
  ///
  /// \param renderer The renderer for which the drawing area should be set.
  /// \param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target.
  ///
  /// The x,y of the viewport rect represents the origin for rendering.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \note If the window associated with the renderer is resized, the viewport is automatically reset.
  ///
  /// \sa SDL_RenderGetViewport()
  /// \sa SDL_RenderSetLogicalSize()
  int SDL_RenderSetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetViewport');
  late final _SDL_RenderSetViewport = _SDL_RenderSetViewportPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Get the drawing area for the current target.
  ///
  /// \sa SDL_RenderSetViewport()
  void SDL_RenderGetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetViewport');
  late final _SDL_RenderGetViewport = _SDL_RenderGetViewportPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Set the clip rectangle for the current target.
  ///
  /// \param renderer The renderer for which clip rectangle should be set.
  /// \param rect   A pointer to the rectangle to set as the clip rectangle,
  /// relative to the viewport, or NULL to disable clipping.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \sa SDL_RenderGetClipRect()
  int SDL_RenderSetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderSetClipRect');
  late final _SDL_RenderSetClipRect = _SDL_RenderSetClipRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Get the clip rectangle for the current target.
  ///
  /// \param renderer The renderer from which clip rectangle should be queried.
  /// \param rect   A pointer filled in with the current clip rectangle, or
  /// an empty rectangle if clipping is disabled.
  ///
  /// \sa SDL_RenderSetClipRect()
  void SDL_RenderGetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetClipRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderGetClipRect');
  late final _SDL_RenderGetClipRect = _SDL_RenderGetClipRectPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Get whether clipping is enabled on the given renderer.
  ///
  /// \param renderer The renderer from which clip state should be queried.
  ///
  /// \sa SDL_RenderGetClipRect()
  int SDL_RenderIsClipEnabled(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderIsClipEnabled(
      renderer,
    );
  }

  late final _SDL_RenderIsClipEnabledPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderIsClipEnabled');
  late final _SDL_RenderIsClipEnabled = _SDL_RenderIsClipEnabledPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Set the drawing scale for rendering on the current target.
  ///
  /// \param renderer The renderer for which the drawing scale should be set.
  /// \param scaleX The horizontal scaling factor
  /// \param scaleY The vertical scaling factor
  ///
  /// The drawing coordinates are scaled by the x/y scaling factors
  /// before they are used by the renderer.  This allows resolution
  /// independent drawing with a single coordinate system.
  ///
  /// \note If this results in scaling or subpixel drawing by the
  /// rendering backend, it will be handled using the appropriate
  /// quality hints.  For best results use integer scaling factors.
  ///
  /// \sa SDL_RenderGetScale()
  /// \sa SDL_RenderSetLogicalSize()
  int SDL_RenderSetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    double scaleX,
    double scaleY,
  ) {
    return _SDL_RenderSetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderSetScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderSetScale');
  late final _SDL_RenderSetScale = _SDL_RenderSetScalePtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// \brief Get the drawing scale for the current target.
  ///
  /// \param renderer The renderer from which drawing scale should be queried.
  /// \param scaleX A pointer filled in with the horizontal scaling factor
  /// \param scaleY A pointer filled in with the vertical scaling factor
  ///
  /// \sa SDL_RenderSetScale()
  void SDL_RenderGetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Float> scaleX,
    ffi.Pointer<ffi.Float> scaleY,
  ) {
    return _SDL_RenderGetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderGetScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_RenderGetScale');
  late final _SDL_RenderGetScale = _SDL_RenderGetScalePtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// \brief Set the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer The renderer for which drawing color should be set.
  /// \param r The red value used to draw on the rendering target.
  /// \param g The green value used to draw on the rendering target.
  /// \param b The blue value used to draw on the rendering target.
  /// \param a The alpha value used to draw on the rendering target, usually
  /// ::SDL_ALPHA_OPAQUE (255).
  ///
  /// \return 0 on success, or -1 on error
  int SDL_SetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_SetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_SetRenderDrawColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, Uint8, Uint8, Uint8,
              Uint8)>>('SDL_SetRenderDrawColor');
  late final _SDL_SetRenderDrawColor = _SDL_SetRenderDrawColorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// \brief Get the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer The renderer from which drawing color should be queried.
  /// \param r A pointer to the red value used to draw on the rendering target.
  /// \param g A pointer to the green value used to draw on the rendering target.
  /// \param b A pointer to the blue value used to draw on the rendering target.
  /// \param a A pointer to the alpha value used to draw on the rendering target,
  /// usually ::SDL_ALPHA_OPAQUE (255).
  ///
  /// \return 0 on success, or -1 on error
  int SDL_GetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<Uint8> r,
    ffi.Pointer<Uint8> g,
    ffi.Pointer<Uint8> b,
    ffi.Pointer<Uint8> a,
  ) {
    return _SDL_GetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRenderDrawColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>,
              ffi.Pointer<Uint8>)>>('SDL_GetRenderDrawColor');
  late final _SDL_GetRenderDrawColor = _SDL_GetRenderDrawColorPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<Uint8>,
          ffi.Pointer<Uint8>, ffi.Pointer<Uint8>, ffi.Pointer<Uint8>)>();

  /// \brief Set the blend mode used for drawing operations (Fill and Line).
  ///
  /// \param renderer The renderer for which blend mode should be set.
  /// \param blendMode ::SDL_BlendMode to use for blending.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \note If the blend mode is not supported, the closest supported mode is
  /// chosen.
  ///
  /// \sa SDL_GetRenderDrawBlendMode()
  int SDL_SetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    int blendMode,
  ) {
    return _SDL_SetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_SetRenderDrawBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Int32)>>('SDL_SetRenderDrawBlendMode');
  late final _SDL_SetRenderDrawBlendMode = _SDL_SetRenderDrawBlendModePtr
      .asFunction<int Function(ffi.Pointer<SDL_Renderer>, int)>();

  /// \brief Get the blend mode used for drawing operations.
  ///
  /// \param renderer The renderer from which blend mode should be queried.
  /// \param blendMode A pointer filled in with the current blend mode.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \sa SDL_SetRenderDrawBlendMode()
  int SDL_GetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_GetRenderDrawBlendModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<ffi.Int32>)>>('SDL_GetRenderDrawBlendMode');
  late final _SDL_GetRenderDrawBlendMode =
      _SDL_GetRenderDrawBlendModePtr.asFunction<
          int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Clear the current rendering target with the drawing color
  ///
  /// This function clears the entire rendering target, ignoring the viewport and
  /// the clip rectangle.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderClear(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderClear(
      renderer,
    );
  }

  late final _SDL_RenderClearPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderClear');
  late final _SDL_RenderClear =
      _SDL_RenderClearPtr.asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Draw a point on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPoint(
    ffi.Pointer<SDL_Renderer> renderer,
    int x,
    int y,
  ) {
    return _SDL_RenderDrawPoint(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Int32,
              ffi.Int32)>>('SDL_RenderDrawPoint');
  late final _SDL_RenderDrawPoint = _SDL_RenderDrawPointPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int)>();

  /// \brief Draw multiple points on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPoints(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawPoints(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int32)>>('SDL_RenderDrawPoints');
  late final _SDL_RenderDrawPoints = _SDL_RenderDrawPointsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// \brief Draw a line on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLine(
    ffi.Pointer<SDL_Renderer> renderer,
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _SDL_RenderDrawLine(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('SDL_RenderDrawLine');
  late final _SDL_RenderDrawLine = _SDL_RenderDrawLinePtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, int, int, int, int)>();

  /// \brief Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLines(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawLines(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>,
              ffi.Int32)>>('SDL_RenderDrawLines');
  late final _SDL_RenderDrawLines = _SDL_RenderDrawLinesPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Point>, int)>();

  /// \brief Draw a rectangle on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderDrawRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderDrawRect');
  late final _SDL_RenderDrawRect = _SDL_RenderDrawRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int32)>>('SDL_RenderDrawRects');
  late final _SDL_RenderDrawRects = _SDL_RenderDrawRectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// \brief Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderFillRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderFillRect');
  late final _SDL_RenderFillRect = _SDL_RenderFillRectPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Fill some number of rectangles on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderFillRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>,
              ffi.Int32)>>('SDL_RenderFillRects');
  late final _SDL_RenderFillRects = _SDL_RenderFillRectsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int)>();

  /// \brief Copy a portion of the texture to the current rendering target.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopy(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_RenderCopy(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>)>>('SDL_RenderCopy');
  late final _SDL_RenderCopy = _SDL_RenderCopyPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_Rect>)>();

  /// \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction
  /// \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).
  /// \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopyEx(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
    double angle,
    ffi.Pointer<SDL_Point> center,
    int flip,
  ) {
    return _SDL_RenderCopyEx(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_Rect>,
              ffi.Double,
              ffi.Pointer<SDL_Point>,
              ffi.Int32)>>('SDL_RenderCopyEx');
  late final _SDL_RenderCopyEx = _SDL_RenderCopyExPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_Rect>,
          double,
          ffi.Pointer<SDL_Point>,
          int)>();

  /// \brief Draw a point on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPointF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x,
    double y,
  ) {
    return _SDL_RenderDrawPointF(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Float,
              ffi.Float)>>('SDL_RenderDrawPointF');
  late final _SDL_RenderDrawPointF = _SDL_RenderDrawPointFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, double, double)>();

  /// \brief Draw multiple points on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPointsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawPointsF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int32)>>('SDL_RenderDrawPointsF');
  late final _SDL_RenderDrawPointsF = _SDL_RenderDrawPointsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// \brief Draw a line on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLineF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _SDL_RenderDrawLineF(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLineFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float)>>('SDL_RenderDrawLineF');
  late final _SDL_RenderDrawLineF = _SDL_RenderDrawLineFPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>, double, double, double, double)>();

  /// \brief Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLinesF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawLinesF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>,
              ffi.Int32)>>('SDL_RenderDrawLinesF');
  late final _SDL_RenderDrawLinesF = _SDL_RenderDrawLinesFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FPoint>, int)>();

  /// \brief Draw a rectangle on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderDrawRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderDrawRectF');
  late final _SDL_RenderDrawRectF = _SDL_RenderDrawRectFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// \brief Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int32)>>('SDL_RenderDrawRectsF');
  late final _SDL_RenderDrawRectsF = _SDL_RenderDrawRectsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// \brief Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderFillRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderFillRectF');
  late final _SDL_RenderFillRectF = _SDL_RenderFillRectFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>)>();

  /// \brief Fill some number of rectangles on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderFillRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>,
              ffi.Int32)>>('SDL_RenderFillRectsF');
  late final _SDL_RenderFillRectsF = _SDL_RenderFillRectsFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_FRect>, int)>();

  /// \brief Copy a portion of the texture to the current rendering target.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopyF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
  ) {
    return _SDL_RenderCopyF(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>)>>('SDL_RenderCopyF');
  late final _SDL_RenderCopyF = _SDL_RenderCopyFPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>, ffi.Pointer<SDL_FRect>)>();

  /// \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction
  /// \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).
  /// \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopyExF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
    double angle,
    ffi.Pointer<SDL_FPoint> center,
    int flip,
  ) {
    return _SDL_RenderCopyExF(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyExFPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Texture>,
              ffi.Pointer<SDL_Rect>,
              ffi.Pointer<SDL_FRect>,
              ffi.Double,
              ffi.Pointer<SDL_FPoint>,
              ffi.Int32)>>('SDL_RenderCopyExF');
  late final _SDL_RenderCopyExF = _SDL_RenderCopyExFPtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Renderer>,
          ffi.Pointer<SDL_Texture>,
          ffi.Pointer<SDL_Rect>,
          ffi.Pointer<SDL_FRect>,
          double,
          ffi.Pointer<SDL_FPoint>,
          int)>();

  /// \brief Read pixels from the current rendering target.
  ///
  /// \param renderer The renderer from which pixels should be read.
  /// \param rect   A pointer to the rectangle to read, or NULL for the entire
  /// render target.
  /// \param format The desired format of the pixel data, or 0 to use the format
  /// of the rendering target
  /// \param pixels A pointer to be filled in with the pixel data
  /// \param pitch  The pitch of the pixels parameter.
  ///
  /// \return 0 on success, or -1 if pixel reading is not supported.
  ///
  /// \warning This is a very slow operation, and should not be used frequently.
  int SDL_RenderReadPixels(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
    int format,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_RenderReadPixels(
      renderer,
      rect,
      format,
      pixels,
      pitch,
    );
  }

  late final _SDL_RenderReadPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<SDL_Renderer>,
              ffi.Pointer<SDL_Rect>,
              Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Int32)>>('SDL_RenderReadPixels');
  late final _SDL_RenderReadPixels = _SDL_RenderReadPixelsPtr.asFunction<
      int Function(ffi.Pointer<SDL_Renderer>, ffi.Pointer<SDL_Rect>, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// \brief Update the screen with rendering performed.
  void SDL_RenderPresent(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderPresent(
      renderer,
    );
  }

  late final _SDL_RenderPresentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_RenderPresent');
  late final _SDL_RenderPresent = _SDL_RenderPresentPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Destroy the specified texture.
  ///
  /// \sa SDL_CreateTexture()
  /// \sa SDL_CreateTextureFromSurface()
  void SDL_DestroyTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_DestroyTexture(
      texture,
    );
  }

  late final _SDL_DestroyTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_DestroyTexture');
  late final _SDL_DestroyTexture = _SDL_DestroyTexturePtr.asFunction<
      void Function(ffi.Pointer<SDL_Texture>)>();

  /// \brief Destroy the rendering context for a window and free associated
  /// textures.
  ///
  /// \sa SDL_CreateRenderer()
  void SDL_DestroyRenderer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_DestroyRenderer(
      renderer,
    );
  }

  late final _SDL_DestroyRendererPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_Renderer>)>>(
          'SDL_DestroyRenderer');
  late final _SDL_DestroyRenderer = _SDL_DestroyRendererPtr.asFunction<
      void Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Force the rendering context to flush any pending commands to the
  /// underlying rendering API.
  ///
  /// You do not need to (and in fact, shouldn't) call this function unless
  /// you are planning to call into OpenGL/Direct3D/Metal/whatever directly
  /// in addition to using an SDL_Renderer.
  ///
  /// This is for a very-specific case: if you are using SDL's render API,
  /// you asked for a specific renderer backend (OpenGL, Direct3D, etc),
  /// you set SDL_HINT_RENDER_BATCHING to "1", and you plan to make
  /// OpenGL/D3D/whatever calls in addition to SDL render API calls. If all of
  /// this applies, you should call SDL_RenderFlush() between calls to SDL's
  /// render API and the low-level API you're using in cooperation.
  ///
  /// In all other cases, you can ignore this function. This is only here to
  /// get maximum performance out of a specific situation. In all other cases,
  /// SDL will do the right thing, perhaps at a performance loss.
  ///
  /// This function is first available in SDL 2.0.10, and is not needed in
  /// 2.0.9 and earlier, as earlier versions did not queue rendering commands
  /// at all, instead flushing them to the OS immediately.
  int SDL_RenderFlush(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderFlush(
      renderer,
    );
  }

  late final _SDL_RenderFlushPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Renderer>)>>(
      'SDL_RenderFlush');
  late final _SDL_RenderFlush =
      _SDL_RenderFlushPtr.asFunction<int Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Bind the texture to the current OpenGL/ES/ES2 context for use with
  /// OpenGL instructions.
  ///
  /// \param texture  The SDL texture to bind
  /// \param texw     A pointer to a float that will be filled with the texture width
  /// \param texh     A pointer to a float that will be filled with the texture height
  ///
  /// \return 0 on success, or -1 if the operation is not supported
  int SDL_GL_BindTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> texw,
    ffi.Pointer<ffi.Float> texh,
  ) {
    return _SDL_GL_BindTexture(
      texture,
      texw,
      texh,
    );
  }

  late final _SDL_GL_BindTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('SDL_GL_BindTexture');
  late final _SDL_GL_BindTexture = _SDL_GL_BindTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// \brief Unbind a texture from the current OpenGL/ES/ES2 context.
  ///
  /// \param texture  The SDL texture to unbind
  ///
  /// \return 0 on success, or -1 if the operation is not supported
  int SDL_GL_UnbindTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GL_UnbindTexture(
      texture,
    );
  }

  late final _SDL_GL_UnbindTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Texture>)>>(
          'SDL_GL_UnbindTexture');
  late final _SDL_GL_UnbindTexture = _SDL_GL_UnbindTexturePtr.asFunction<
      int Function(ffi.Pointer<SDL_Texture>)>();

  /// \brief Get the CAMetalLayer associated with the given Metal renderer
  ///
  /// \param renderer The renderer to query
  ///
  /// \return CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer
  ///
  /// \sa SDL_RenderGetMetalCommandEncoder()
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalLayer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalLayer(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalLayerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalLayer');
  late final _SDL_RenderGetMetalLayer = _SDL_RenderGetMetalLayerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Get the Metal command encoder for the current frame
  ///
  /// \param renderer The renderer to query
  ///
  /// \return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer
  ///
  /// \sa SDL_RenderGetMetalLayer()
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalCommandEncoder(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalCommandEncoder(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalCommandEncoderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetMetalCommandEncoder');
  late final _SDL_RenderGetMetalCommandEncoder =
      _SDL_RenderGetMetalCommandEncoderPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Create a window that can be shaped with the specified position, dimensions, and flags.
  ///
  /// \param title The title of the window, in UTF-8 encoding.
  /// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param w     The width of the window.
  /// \param h     The height of the window.
  /// \param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:
  /// ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,
  /// ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,
  /// ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,
  /// ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset.
  ///
  /// \return The window created, or NULL if window creation failed.
  ///
  /// \sa SDL_DestroyWindow()
  ffi.Pointer<SDL_Window> SDL_CreateShapedWindow(
    ffi.Pointer<ffi.Int8> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateShapedWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateShapedWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SDL_Window> Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              Uint32)>>('SDL_CreateShapedWindow');
  late final _SDL_CreateShapedWindow = _SDL_CreateShapedWindowPtr.asFunction<
      ffi.Pointer<SDL_Window> Function(
          ffi.Pointer<ffi.Int8>, int, int, int, int, int)>();

  /// \brief Return whether the given window is a shaped window.
  ///
  /// \param window The window to query for being shaped.
  ///
  /// \return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL.
  ///
  /// \sa SDL_CreateShapedWindow
  int SDL_IsShapedWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsShapedWindow(
      window,
    );
  }

  late final _SDL_IsShapedWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_Window>)>>(
          'SDL_IsShapedWindow');
  late final _SDL_IsShapedWindow = _SDL_IsShapedWindowPtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>)>();

  /// \brief Set the shape and parameters of a shaped window.
  ///
  /// \param window The shaped window whose parameters should be set.
  /// \param shape A surface encoding the desired shape for the window.
  /// \param shape_mode The parameters to set for the shaped window.
  ///
  /// \return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW
  /// if the SDL_Window given does not reference a valid shaped window.
  ///
  /// \sa SDL_WindowShapeMode
  /// \sa SDL_GetShapedWindowMode.
  int SDL_SetWindowShape(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> shape,
    ffi.Pointer<SDL_WindowShapeMode> shape_mode,
  ) {
    return _SDL_SetWindowShape(
      window,
      shape,
      shape_mode,
    );
  }

  late final _SDL_SetWindowShapePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>,
              ffi.Pointer<SDL_WindowShapeMode>)>>('SDL_SetWindowShape');
  late final _SDL_SetWindowShape = _SDL_SetWindowShapePtr.asFunction<
      int Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Surface>,
          ffi.Pointer<SDL_WindowShapeMode>)>();

  /// \brief Get the shape parameters of a shaped window.
  ///
  /// \param window The shaped window whose parameters should be retrieved.
  /// \param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape.
  ///
  /// \return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode
  /// data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if
  /// the SDL_Window given is a shapeable window currently lacking a shape.
  ///
  /// \sa SDL_WindowShapeMode
  /// \sa SDL_SetWindowShape
  int SDL_GetShapedWindowMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_WindowShapeMode> shape_mode,
  ) {
    return _SDL_GetShapedWindowMode(
      window,
      shape_mode,
    );
  }

  late final _SDL_GetShapedWindowModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SDL_Window>,
              ffi.Pointer<SDL_WindowShapeMode>)>>('SDL_GetShapedWindowMode');
  late final _SDL_GetShapedWindowMode = _SDL_GetShapedWindowModePtr.asFunction<
      int Function(
          ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_WindowShapeMode>)>();

  void SDL_SetWindowsMessageHook(
    SDL_WindowsMessageHook callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowsMessageHook(
      callback,
      userdata,
    );
  }

  late final _SDL_SetWindowsMessageHookPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SDL_WindowsMessageHook,
              ffi.Pointer<ffi.Void>)>>('SDL_SetWindowsMessageHook');
  late final _SDL_SetWindowsMessageHook =
      _SDL_SetWindowsMessageHookPtr.asFunction<
          void Function(SDL_WindowsMessageHook, ffi.Pointer<ffi.Void>)>();

  /// \brief Returns the D3D9 adapter index that matches the specified display index.
  ///
  /// This adapter index can be passed to IDirect3D9::CreateDevice and controls
  /// on which monitor a full screen application will appear.
  int SDL_Direct3D9GetAdapterIndex(
    int displayIndex,
  ) {
    return _SDL_Direct3D9GetAdapterIndex(
      displayIndex,
    );
  }

  late final _SDL_Direct3D9GetAdapterIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'SDL_Direct3D9GetAdapterIndex');
  late final _SDL_Direct3D9GetAdapterIndex =
      _SDL_Direct3D9GetAdapterIndexPtr.asFunction<int Function(int)>();

  /// \brief Returns the D3D device associated with a renderer, or NULL if it's not a D3D renderer.
  ///
  /// Once you are done using the device, you should release it to avoid a resource leak.
  ffi.Pointer<IDirect3DDevice9> SDL_RenderGetD3D9Device(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetD3D9Device(
      renderer,
    );
  }

  late final _SDL_RenderGetD3D9DevicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<IDirect3DDevice9> Function(
              ffi.Pointer<SDL_Renderer>)>>('SDL_RenderGetD3D9Device');
  late final _SDL_RenderGetD3D9Device = _SDL_RenderGetD3D9DevicePtr.asFunction<
      ffi.Pointer<IDirect3DDevice9> Function(ffi.Pointer<SDL_Renderer>)>();

  /// \brief Returns the DXGI Adapter and Output indices for the specified display index.
  ///
  /// These can be passed to EnumAdapters and EnumOutputs respectively to get the objects
  /// required to create a DX10 or DX11 device and swap chain.
  int SDL_DXGIGetOutputInfo(
    int displayIndex,
    ffi.Pointer<ffi.Int32> adapterIndex,
    ffi.Pointer<ffi.Int32> outputIndex,
  ) {
    return _SDL_DXGIGetOutputInfo(
      displayIndex,
      adapterIndex,
      outputIndex,
    );
  }

  late final _SDL_DXGIGetOutputInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SDL_DXGIGetOutputInfo');
  late final _SDL_DXGIGetOutputInfo = _SDL_DXGIGetOutputInfoPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// \brief Return true if the current device is a tablet.
  int SDL_IsTablet() {
    return _SDL_IsTablet();
  }

  late final _SDL_IsTabletPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SDL_IsTablet');
  late final _SDL_IsTablet = _SDL_IsTabletPtr.asFunction<int Function()>();

  void SDL_OnApplicationWillTerminate() {
    return _SDL_OnApplicationWillTerminate();
  }

  late final _SDL_OnApplicationWillTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillTerminate');
  late final _SDL_OnApplicationWillTerminate =
      _SDL_OnApplicationWillTerminatePtr.asFunction<void Function()>();

  void SDL_OnApplicationDidReceiveMemoryWarning() {
    return _SDL_OnApplicationDidReceiveMemoryWarning();
  }

  late final _SDL_OnApplicationDidReceiveMemoryWarningPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidReceiveMemoryWarning');
  late final _SDL_OnApplicationDidReceiveMemoryWarning =
      _SDL_OnApplicationDidReceiveMemoryWarningPtr.asFunction<
          void Function()>();

  void SDL_OnApplicationWillResignActive() {
    return _SDL_OnApplicationWillResignActive();
  }

  late final _SDL_OnApplicationWillResignActivePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillResignActive');
  late final _SDL_OnApplicationWillResignActive =
      _SDL_OnApplicationWillResignActivePtr.asFunction<void Function()>();

  void SDL_OnApplicationDidEnterBackground() {
    return _SDL_OnApplicationDidEnterBackground();
  }

  late final _SDL_OnApplicationDidEnterBackgroundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidEnterBackground');
  late final _SDL_OnApplicationDidEnterBackground =
      _SDL_OnApplicationDidEnterBackgroundPtr.asFunction<void Function()>();

  void SDL_OnApplicationWillEnterForeground() {
    return _SDL_OnApplicationWillEnterForeground();
  }

  late final _SDL_OnApplicationWillEnterForegroundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationWillEnterForeground');
  late final _SDL_OnApplicationWillEnterForeground =
      _SDL_OnApplicationWillEnterForegroundPtr.asFunction<void Function()>();

  void SDL_OnApplicationDidBecomeActive() {
    return _SDL_OnApplicationDidBecomeActive();
  }

  late final _SDL_OnApplicationDidBecomeActivePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'SDL_OnApplicationDidBecomeActive');
  late final _SDL_OnApplicationDidBecomeActive =
      _SDL_OnApplicationDidBecomeActivePtr.asFunction<void Function()>();

  /// \brief Get the number of milliseconds since the SDL library initialization.
  ///
  /// \note This value wraps if the program runs for more than ~49 days.
  int SDL_GetTicks() {
    return _SDL_GetTicks();
  }

  late final _SDL_GetTicksPtr =
      _lookup<ffi.NativeFunction<Uint32 Function()>>('SDL_GetTicks');
  late final _SDL_GetTicks = _SDL_GetTicksPtr.asFunction<int Function()>();

  /// \brief Get the current value of the high resolution counter
  int SDL_GetPerformanceCounter() {
    return _SDL_GetPerformanceCounter();
  }

  late final _SDL_GetPerformanceCounterPtr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceCounter');
  late final _SDL_GetPerformanceCounter =
      _SDL_GetPerformanceCounterPtr.asFunction<int Function()>();

  /// \brief Get the count per second of the high resolution counter
  int SDL_GetPerformanceFrequency() {
    return _SDL_GetPerformanceFrequency();
  }

  late final _SDL_GetPerformanceFrequencyPtr =
      _lookup<ffi.NativeFunction<Uint64 Function()>>(
          'SDL_GetPerformanceFrequency');
  late final _SDL_GetPerformanceFrequency =
      _SDL_GetPerformanceFrequencyPtr.asFunction<int Function()>();

  /// \brief Wait a specified number of milliseconds before returning.
  void SDL_Delay(
    int ms,
  ) {
    return _SDL_Delay(
      ms,
    );
  }

  late final _SDL_DelayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>('SDL_Delay');
  late final _SDL_Delay = _SDL_DelayPtr.asFunction<void Function(int)>();

  /// \brief Add a new timer to the pool of timers already running.
  ///
  /// \return A timer ID, or 0 when an error occurs.
  int SDL_AddTimer(
    int interval,
    SDL_TimerCallback callback,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _SDL_AddTimer(
      interval,
      callback,
      param,
    );
  }

  late final _SDL_AddTimerPtr = _lookup<
      ffi.NativeFunction<
          SDL_TimerID Function(Uint32, SDL_TimerCallback,
              ffi.Pointer<ffi.Void>)>>('SDL_AddTimer');
  late final _SDL_AddTimer = _SDL_AddTimerPtr.asFunction<
      int Function(int, SDL_TimerCallback, ffi.Pointer<ffi.Void>)>();

  /// \brief Remove a timer knowing its ID.
  ///
  /// \return A boolean value indicating success or failure.
  ///
  /// \warning It is not safe to remove a timer multiple times.
  int SDL_RemoveTimer(
    int id,
  ) {
    return _SDL_RemoveTimer(
      id,
    );
  }

  late final _SDL_RemoveTimerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SDL_TimerID)>>(
          'SDL_RemoveTimer');
  late final _SDL_RemoveTimer =
      _SDL_RemoveTimerPtr.asFunction<int Function(int)>();

  /// \brief Get the version of SDL that is linked against your program.
  ///
  /// If you are linking to SDL dynamically, then it is possible that the
  /// current version will be different than the version you compiled against.
  /// This function returns the current version, while SDL_VERSION() is a
  /// macro that tells you what version you compiled with.
  ///
  /// \code
  /// SDL_version compiled;
  /// SDL_version linked;
  ///
  /// SDL_VERSION(&compiled);
  /// SDL_GetVersion(&linked);
  /// printf("We compiled against SDL version %d.%d.%d ...\n",
  /// compiled.major, compiled.minor, compiled.patch);
  /// printf("But we linked against SDL version %d.%d.%d.\n",
  /// linked.major, linked.minor, linked.patch);
  /// \endcode
  ///
  /// This function may be called safely at any time, even before SDL_Init().
  ///
  /// \sa SDL_VERSION
  void SDL_GetVersion(
    ffi.Pointer<SDL_version> ver,
  ) {
    return _SDL_GetVersion(
      ver,
    );
  }

  late final _SDL_GetVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SDL_version>)>>(
          'SDL_GetVersion');
  late final _SDL_GetVersion =
      _SDL_GetVersionPtr.asFunction<void Function(ffi.Pointer<SDL_version>)>();

  /// \brief Get the code revision of SDL that is linked against your program.
  ///
  /// Returns an arbitrary string (a hash value) uniquely identifying the
  /// exact revision of the SDL library in use, and is only useful in comparing
  /// against other revisions. It is NOT an incrementing number.
  ffi.Pointer<ffi.Int8> SDL_GetRevision() {
    return _SDL_GetRevision();
  }

  late final _SDL_GetRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'SDL_GetRevision');
  late final _SDL_GetRevision =
      _SDL_GetRevisionPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// \brief Get the revision number of SDL that is linked against your program.
  ///
  /// Returns a number uniquely identifying the exact revision of the SDL
  /// library in use. It is an incrementing number based on commits to
  /// hg.libsdl.org.
  int SDL_GetRevisionNumber() {
    return _SDL_GetRevisionNumber();
  }

  late final _SDL_GetRevisionNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SDL_GetRevisionNumber');
  late final _SDL_GetRevisionNumber =
      _SDL_GetRevisionNumberPtr.asFunction<int Function()>();

  /// \brief Report the user's preferred locale.
  ///
  /// This returns an array of SDL_Locale structs, the final item zeroed out.
  /// When the caller is done with this array, it should call SDL_free() on
  /// the returned value; all the memory involved is allocated in a single
  /// block, so a single SDL_free() will suffice.
  ///
  /// Returned language strings are in the format xx, where 'xx' is an ISO-639
  /// language specifier (such as "en" for English, "de" for German, etc).
  /// Country strings are in the format YY, where "YY" is an ISO-3166 country
  /// code (such as "US" for the United States, "CA" for Canada, etc). Country
  /// might be NULL if there's no specific guidance on them (so you might get
  /// { "en", "US" } for American English, but { "en", NULL } means "English
  /// language, generically"). Language strings are never NULL, except to
  /// terminate the array.
  ///
  /// Please note that not all of these strings are 2 characters; some are
  /// three or more.
  ///
  /// The returned list of locales are in the order of the user's preference.
  /// For example, a German citizen that is fluent in US English and knows
  /// enough Japanese to navigate around Tokyo might have a list like:
  /// { "de", "en_US", "jp", NULL }. Someone from England might prefer British
  /// English (where "color" is spelled "colour", etc), but will settle for
  /// anything like it: { "en_GB", "en", NULL }.
  ///
  /// This function returns NULL on error, including when the platform does not
  /// supply this information at all.
  ///
  /// This might be a "slow" call that has to query the operating system. It's
  /// best to ask for this once and save the results. However, this list can
  /// change, usually because the user has changed a system preference outside
  /// of your program; SDL will send an SDL_LOCALECHANGED event in this case,
  /// if possible, and you can call this function again to get an updated copy
  /// of preferred locales.
  ///
  /// \return array of locales, terminated with a locale with a NULL language
  /// field. Will return NULL on error.
  ffi.Pointer<SDL_Locale> SDL_GetPreferredLocales() {
    return _SDL_GetPreferredLocales();
  }

  late final _SDL_GetPreferredLocalesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SDL_Locale> Function()>>(
          'SDL_GetPreferredLocales');
  late final _SDL_GetPreferredLocales = _SDL_GetPreferredLocalesPtr.asFunction<
      ffi.Pointer<SDL_Locale> Function()>();

  /// \brief Open an URL / URI in the browser or other
  ///
  /// Open a URL in a separate, system-provided application. How this works will
  /// vary wildly depending on the platform. This will likely launch what
  /// makes sense to handle a specific URL's protocol (a web browser for http://,
  /// etc), but it might also be able to launch file managers for directories
  /// and other things.
  ///
  /// What happens when you open a URL varies wildly as well: your game window
  /// may lose focus (and may or may not lose focus if your game was fullscreen
  /// or grabbing input at the time). On mobile devices, your app will likely
  /// move to the background or your process might be paused. Any given platform
  /// may or may not handle a given URL.
  ///
  /// If this is unimplemented (or simply unavailable) for a platform, this will
  /// fail with an error. A successful result does not mean the URL loaded, just
  /// that we launched something to handle it (or at least believe we did).
  ///
  /// All this to say: this function can be useful, but you should definitely
  /// test it on every platform you target.
  ///
  /// \param url A valid URL to open.
  /// \return 0 on success, or -1 on error.
  int SDL_OpenURL(
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _SDL_OpenURL(
      url,
    );
  }

  late final _SDL_OpenURLPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'SDL_OpenURL');
  late final _SDL_OpenURL =
      _SDL_OpenURLPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// This function initializes  the subsystems specified by \c flags
  int SDL_Init(
    int flags,
  ) {
    return _SDL_Init(
      flags,
    );
  }

  late final _SDL_InitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32)>>('SDL_Init');
  late final _SDL_Init = _SDL_InitPtr.asFunction<int Function(int)>();

  /// This function initializes specific SDL subsystems
  ///
  /// Subsystem initialization is ref-counted, you must call
  /// SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly
  /// shutdown a subsystem manually (or call SDL_Quit() to force shutdown).
  /// If a subsystem is already loaded then this call will
  /// increase the ref-count and return.
  int SDL_InitSubSystem(
    int flags,
  ) {
    return _SDL_InitSubSystem(
      flags,
    );
  }

  late final _SDL_InitSubSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Uint32)>>(
          'SDL_InitSubSystem');
  late final _SDL_InitSubSystem =
      _SDL_InitSubSystemPtr.asFunction<int Function(int)>();

  /// This function cleans up specific SDL subsystems
  void SDL_QuitSubSystem(
    int flags,
  ) {
    return _SDL_QuitSubSystem(
      flags,
    );
  }

  late final _SDL_QuitSubSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Uint32)>>(
          'SDL_QuitSubSystem');
  late final _SDL_QuitSubSystem =
      _SDL_QuitSubSystemPtr.asFunction<void Function(int)>();

  /// This function returns a mask of the specified subsystems which have
  /// previously been initialized.
  ///
  /// If \c flags is 0, it returns a mask of all initialized subsystems.
  int SDL_WasInit(
    int flags,
  ) {
    return _SDL_WasInit(
      flags,
    );
  }

  late final _SDL_WasInitPtr =
      _lookup<ffi.NativeFunction<Uint32 Function(Uint32)>>('SDL_WasInit');
  late final _SDL_WasInit = _SDL_WasInitPtr.asFunction<int Function(int)>();

  /// This function cleans up all initialized subsystems. You should
  /// call it upon all exit conditions.
  void SDL_Quit() {
    return _SDL_Quit();
  }

  late final _SDL_QuitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SDL_Quit');
  late final _SDL_Quit = _SDL_QuitPtr.asFunction<void Function()>();
}

typedef va_list = ffi.Pointer<ffi.Int8>;
typedef uintptr_t = ffi.Uint64;
typedef wchar_t = ffi.Uint16;

class _crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> locale_pctype;

  @ffi.Int32()
  external int locale_mb_cur_max;

  @ffi.Uint32()
  external int locale_lc_codepage;
}

class _crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<_crt_locale_data> locinfo;

  external ffi.Pointer<_crt_multibyte_data> mbcinfo;
}

class _crt_locale_data extends ffi.Opaque {}

class _crt_multibyte_data extends ffi.Opaque {}

class Mbstatet extends ffi.Struct {
  @ffi.Uint64()
  external int Wchar;

  @ffi.Uint16()
  external int Byte;

  @ffi.Uint16()
  external int State;
}

typedef errno_t = ffi.Int32;

abstract class SDL_bool {
  static const int SDL_FALSE = 0;
  static const int SDL_TRUE = 1;
}

abstract class SDL_DUMMY_ENUM {
  static const int DUMMY_ENUM_VALUE = 0;
}

typedef size_t = ffi.Uint64;
typedef SDL_malloc_func
    = ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(size_t)>>;
typedef SDL_calloc_func = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(size_t, size_t)>>;
typedef SDL_realloc_func = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, size_t)>>;
typedef SDL_free_func
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef Uint32 = ffi.Uint32;
typedef Sint64 = ffi.Int64;
typedef Uint64 = ffi.Uint64;

class SDL_iconv_t extends ffi.Opaque {}

typedef SDL_iconv_t1 = ffi.Pointer<SDL_iconv_t>;

abstract class SDL_AssertState {
  /// < Retry the assert immediately.
  static const int SDL_ASSERTION_RETRY = 0;

  /// < Make the debugger trigger a breakpoint.
  static const int SDL_ASSERTION_BREAK = 1;

  /// < Terminate the program.
  static const int SDL_ASSERTION_ABORT = 2;

  /// < Ignore the assert.
  static const int SDL_ASSERTION_IGNORE = 3;

  /// < Ignore the assert from now on.
  static const int SDL_ASSERTION_ALWAYS_IGNORE = 4;
}

class SDL_AssertData extends ffi.Struct {
  @ffi.Int32()
  external int always_ignore;

  @ffi.Uint32()
  external int trigger_count;

  external ffi.Pointer<ffi.Int8> condition;

  external ffi.Pointer<ffi.Int8> filename;

  @ffi.Int32()
  external int linenum;

  external ffi.Pointer<ffi.Int8> function;

  external ffi.Pointer<SDL_AssertData> next;
}

typedef SDL_AssertionHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<SDL_AssertData>, ffi.Pointer<ffi.Void>)>>;
typedef SDL_SpinLock = ffi.Int32;

/// \brief A type representing an atomic integer value.  It is a struct
/// so people don't accidentally use numeric operations on it.
class SDL_atomic_t extends ffi.Struct {
  @ffi.Int32()
  external int value;
}

abstract class SDL_errorcode {
  static const int SDL_ENOMEM = 0;
  static const int SDL_EFREAD = 1;
  static const int SDL_EFWRITE = 2;
  static const int SDL_EFSEEK = 3;
  static const int SDL_UNSUPPORTED = 4;
  static const int SDL_LASTERROR = 5;
}

class SDL_mutex extends ffi.Opaque {}

class SDL_semaphore extends ffi.Opaque {}

typedef SDL_sem = SDL_semaphore;

class SDL_cond extends ffi.Opaque {}

class SDL_Thread extends ffi.Opaque {}

/// The SDL thread priority.
///
/// SDL will make system changes as necessary in order to apply the thread priority.
/// Code which attempts to control thread state related to priority should be aware
/// that calling SDL_SetThreadPriority may alter such state.
/// SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.
///
/// \note On many systems you require special privileges to set high or time critical priority.
abstract class SDL_ThreadPriority {
  static const int SDL_THREAD_PRIORITY_LOW = 0;
  static const int SDL_THREAD_PRIORITY_NORMAL = 1;
  static const int SDL_THREAD_PRIORITY_HIGH = 2;
  static const int SDL_THREAD_PRIORITY_TIME_CRITICAL = 3;
}

class exception extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external ffi.Pointer<ffi.Int8> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

class complex extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

class _double_val extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint16> Sh;

  @ffi.Double()
  external double Val;
}

class _float_val extends ffi.Union {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint16> Sh;

  @ffi.Float()
  external double Val;
}

class _ldouble_val extends ffi.Opaque {}

class _float_const extends ffi.Opaque {}

typedef _locale_t = ffi.Pointer<_crt_locale_pointers>;

abstract class _crt_argv_mode {
  static const int _crt_argv_no_arguments = 0;
  static const int _crt_argv_unexpanded_arguments = 1;
  static const int _crt_argv_expanded_arguments = 2;
}

abstract class _crt_exit_return_mode {
  static const int _crt_exit_terminate_process = 0;
  static const int _crt_exit_return_to_caller = 1;
}

abstract class _crt_exit_cleanup_mode {
  static const int _crt_exit_full_cleanup = 0;
  static const int _crt_exit_quick_cleanup = 1;
  static const int _crt_exit_no_cleanup = 2;
}

class EXCEPTION_POINTERS extends ffi.Opaque {}

abstract class _crt_app_type {
  static const int _crt_unknown_app = 0;
  static const int _crt_console_app = 1;
  static const int _crt_gui_app = 2;
}

typedef _UserMathErrorFunctionPointer = ffi
    .Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<exception>)>>;
typedef _PVFV = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;
typedef _PIFV = ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function()>>;

class onexit_table_t extends ffi.Struct {
  external ffi.Pointer<_PVFV> first;

  external ffi.Pointer<_PVFV> last;

  external ffi.Pointer<_PVFV> end;
}

typedef _onexit_t = ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function()>>;
typedef _tls_callback_type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Uint64, ffi.Pointer<ffi.Void>)>>;
typedef _beginthread_proc_type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef _beginthreadex_proc_type = ffi
    .Pointer<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Void>)>>;
typedef _GetDllProcAddrProcType
    = ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function()>>;

/// The function passed to SDL_CreateThread().
/// It is passed a void* user context parameter and returns an int.
typedef SDL_ThreadFunction = ffi
    .Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>;
typedef pfnSDL_CurrentBeginThread = ffi.Pointer<
    ffi.NativeFunction<
        uintptr_t Function(
            ffi.Pointer<ffi.Void>,
            ffi.Uint32,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Void>)>>,
            ffi.Pointer<ffi.Void>,
            ffi.Uint32,
            ffi.Pointer<ffi.Uint32>)>>;
typedef pfnSDL_CurrentEndThread
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>;
typedef SDL_threadID = ffi.Uint64;
typedef SDL_TLSID = ffi.Uint32;

/// This is the read/write operation structure -- very basic.
class SDL_RWops extends ffi.Struct {
  /// Return the size of the file in this rwops, or -1 if unknown
  external ffi
          .Pointer<ffi.NativeFunction<Sint64 Function(ffi.Pointer<SDL_RWops>)>>
      size;

  /// Seek to \c offset relative to \c whence, one of stdio's whence values:
  /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
  ///
  /// \return the final offset in the data stream, or -1 on error.
  external ffi.Pointer<
      ffi.NativeFunction<
          Sint64 Function(ffi.Pointer<SDL_RWops>, Sint64, ffi.Int32)>> seek;

  /// Read up to \c maxnum objects each of size \c size from the data
  /// stream to the area pointed at by \c ptr.
  ///
  /// \return the number of objects read, or 0 at error or end of file.
  external ffi.Pointer<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, size_t,
              size_t)>> read;

  /// Write exactly \c num objects each of size \c size from the area
  /// pointed at by \c ptr to data stream.
  ///
  /// \return the number of objects written, or 0 at error or end of file.
  external ffi.Pointer<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<SDL_RWops>, ffi.Pointer<ffi.Void>, size_t,
              size_t)>> write;

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// \return 0 if successful or -1 on write error when flushing data.
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<SDL_RWops>)>> close;

  @Uint32()
  external int type;

  external UnnamedUnion1 hidden;
}

class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 windowsio;

  external UnnamedStruct3 mem;

  external UnnamedStruct4 unknown;
}

class UnnamedStruct1 extends ffi.Struct {
  @ffi.Int32()
  external int append;

  external ffi.Pointer<ffi.Void> h;

  external UnnamedStruct2 buffer;
}

class UnnamedStruct2 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @size_t()
  external int size;

  @size_t()
  external int left;
}

class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<Uint8> base;

  external ffi.Pointer<Uint8> here;

  external ffi.Pointer<Uint8> stop;
}

typedef Uint8 = ffi.Uint8;

class UnnamedStruct4 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data1;

  external ffi.Pointer<ffi.Void> data2;
}

typedef Uint16 = ffi.Uint16;

/// The calculated values in this structure are calculated by SDL_OpenAudio().
///
/// For multi-channel audio, the default SDL channel mapping is:
/// 2:  FL FR                       (stereo)
/// 3:  FL FR LFE                   (2.1 surround)
/// 4:  FL FR BL BR                 (quad)
/// 5:  FL FR FC BL BR              (quad + center)
/// 6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)
/// 7:  FL FR FC LFE BC SL SR       (6.1 surround)
/// 8:  FL FR FC LFE BL BR SL SR    (7.1 surround)
class SDL_AudioSpec extends ffi.Struct {
  /// < DSP frequency -- samples per second
  @ffi.Int32()
  external int freq;

  /// < Audio data format
  @SDL_AudioFormat()
  external int format;

  /// < Number of channels: 1 mono, 2 stereo
  @Uint8()
  external int channels;

  /// < Audio buffer silence value (calculated)
  @Uint8()
  external int silence;

  /// < Audio buffer size in sample FRAMES (total samples divided by channel count)
  @Uint16()
  external int samples;

  /// < Necessary for some compile environments
  @Uint16()
  external int padding;

  /// < Audio buffer size in bytes (calculated)
  @Uint32()
  external int size;

  /// < Callback that feeds the audio device (NULL to use SDL_QueueAudio()).
  external SDL_AudioCallback callback;

  /// < Userdata passed to callback (ignored for NULL callbacks).
  external ffi.Pointer<ffi.Void> userdata;
}

/// \brief Audio format flags.
///
/// These are what the 16 bits in SDL_AudioFormat currently mean...
/// (Unspecified bits are always zero).
///
/// \verbatim
/// ++-----------------------sample is signed if set
/// ||
/// ||       ++-----------sample is bigendian if set
/// ||       ||
/// ||       ||          ++---sample is float if set
/// ||       ||          ||
/// ||       ||          || +---sample bit size---+
/// ||       ||          || |                     |
/// 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
/// \endverbatim
///
/// There are macros in SDL 2.0 and later to query these bits.
typedef SDL_AudioFormat = Uint16;

/// This function is called when the audio device needs more data.
///
/// \param userdata An application-specific parameter saved in
/// the SDL_AudioSpec structure
/// \param stream A pointer to the audio data buffer.
/// \param len    The length of that buffer in bytes.
///
/// Once the callback returns, the buffer will no longer be valid.
/// Stereo samples are stored in a LRLRLR ordering.
///
/// You can choose to avoid callbacks and use SDL_QueueAudio() instead, if
/// you like. Just open your audio device with a NULL callback.
typedef SDL_AudioCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<Uint8>, ffi.Int32)>>;

class SDL_AudioCVT extends ffi.Struct {
  /// < Set to 1 if conversion possible
  @ffi.Int32()
  external int needed;

  /// < Source audio format
  @SDL_AudioFormat()
  external int src_format;

  /// < Target audio format
  @SDL_AudioFormat()
  external int dst_format;

  /// < Rate conversion increment
  @ffi.Double()
  external double rate_incr;

  /// < Buffer to hold entire audio data
  external ffi.Pointer<Uint8> buf;

  /// < Length of original audio buffer
  @ffi.Int32()
  external int len;

  /// < Length of converted audio buffer
  @ffi.Int32()
  external int len_cvt;

  /// < buffer must be len*len_mult big
  @ffi.Int32()
  external int len_mult;

  /// < Given len, final size is len*len_ratio
  @ffi.Double()
  external double len_ratio;

  @ffi.Array.multi([10])
  external ffi.Array<SDL_AudioFilter> filters;

  /// < Current audio conversion function
  @ffi.Int32()
  external int filter_index;
}

typedef SDL_AudioFilter = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<SDL_AudioCVT>, SDL_AudioFormat)>>;

/// SDL Audio Device IDs.
///
/// A successful call to SDL_OpenAudio() is always device id 1, and legacy
/// SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
/// always returns devices >= 2 on success. The legacy calls are good both
/// for backwards compatibility and when you don't care about multiple,
/// specific, or capture devices.
typedef SDL_AudioDeviceID = Uint32;

abstract class SDL_AudioStatus {
  static const int SDL_AUDIO_STOPPED = 0;
  static const int SDL_AUDIO_PLAYING = 1;
  static const int SDL_AUDIO_PAUSED = 2;
}

class SDL_AudioStream extends ffi.Opaque {}

typedef SDL_AudioStream1 = SDL_AudioStream;

/// Pixel type.
abstract class SDL_PixelType {
  static const int SDL_PIXELTYPE_UNKNOWN = 0;
  static const int SDL_PIXELTYPE_INDEX1 = 1;
  static const int SDL_PIXELTYPE_INDEX4 = 2;
  static const int SDL_PIXELTYPE_INDEX8 = 3;
  static const int SDL_PIXELTYPE_PACKED8 = 4;
  static const int SDL_PIXELTYPE_PACKED16 = 5;
  static const int SDL_PIXELTYPE_PACKED32 = 6;
  static const int SDL_PIXELTYPE_ARRAYU8 = 7;
  static const int SDL_PIXELTYPE_ARRAYU16 = 8;
  static const int SDL_PIXELTYPE_ARRAYU32 = 9;
  static const int SDL_PIXELTYPE_ARRAYF16 = 10;
  static const int SDL_PIXELTYPE_ARRAYF32 = 11;
}

/// Bitmap pixel order, high bit -> low bit.
abstract class SDL_BitmapOrder {
  static const int SDL_BITMAPORDER_NONE = 0;
  static const int SDL_BITMAPORDER_4321 = 1;
  static const int SDL_BITMAPORDER_1234 = 2;
}

/// Packed component order, high bit -> low bit.
abstract class SDL_PackedOrder {
  static const int SDL_PACKEDORDER_NONE = 0;
  static const int SDL_PACKEDORDER_XRGB = 1;
  static const int SDL_PACKEDORDER_RGBX = 2;
  static const int SDL_PACKEDORDER_ARGB = 3;
  static const int SDL_PACKEDORDER_RGBA = 4;
  static const int SDL_PACKEDORDER_XBGR = 5;
  static const int SDL_PACKEDORDER_BGRX = 6;
  static const int SDL_PACKEDORDER_ABGR = 7;
  static const int SDL_PACKEDORDER_BGRA = 8;
}

/// Array component order, low byte -> high byte.
abstract class SDL_ArrayOrder {
  static const int SDL_ARRAYORDER_NONE = 0;
  static const int SDL_ARRAYORDER_RGB = 1;
  static const int SDL_ARRAYORDER_RGBA = 2;
  static const int SDL_ARRAYORDER_ARGB = 3;
  static const int SDL_ARRAYORDER_BGR = 4;
  static const int SDL_ARRAYORDER_BGRA = 5;
  static const int SDL_ARRAYORDER_ABGR = 6;
}

/// Packed component layout.
abstract class SDL_PackedLayout {
  static const int SDL_PACKEDLAYOUT_NONE = 0;
  static const int SDL_PACKEDLAYOUT_332 = 1;
  static const int SDL_PACKEDLAYOUT_4444 = 2;
  static const int SDL_PACKEDLAYOUT_1555 = 3;
  static const int SDL_PACKEDLAYOUT_5551 = 4;
  static const int SDL_PACKEDLAYOUT_565 = 5;
  static const int SDL_PACKEDLAYOUT_8888 = 6;
  static const int SDL_PACKEDLAYOUT_2101010 = 7;
  static const int SDL_PACKEDLAYOUT_1010102 = 8;
}

abstract class SDL_PixelFormatEnum {
  static const int SDL_PIXELFORMAT_UNKNOWN = 0;
  static const int SDL_PIXELFORMAT_INDEX1LSB = 286261504;
  static const int SDL_PIXELFORMAT_INDEX1MSB = 287310080;
  static const int SDL_PIXELFORMAT_INDEX4LSB = 303039488;
  static const int SDL_PIXELFORMAT_INDEX4MSB = 304088064;
  static const int SDL_PIXELFORMAT_INDEX8 = 318769153;
  static const int SDL_PIXELFORMAT_RGB332 = 336660481;
  static const int SDL_PIXELFORMAT_XRGB4444 = 353504258;
  static const int SDL_PIXELFORMAT_RGB444 = 353504258;
  static const int SDL_PIXELFORMAT_XBGR4444 = 357698562;
  static const int SDL_PIXELFORMAT_BGR444 = 357698562;
  static const int SDL_PIXELFORMAT_XRGB1555 = 353570562;
  static const int SDL_PIXELFORMAT_RGB555 = 353570562;
  static const int SDL_PIXELFORMAT_XBGR1555 = 357764866;
  static const int SDL_PIXELFORMAT_BGR555 = 357764866;
  static const int SDL_PIXELFORMAT_ARGB4444 = 355602434;
  static const int SDL_PIXELFORMAT_RGBA4444 = 356651010;
  static const int SDL_PIXELFORMAT_ABGR4444 = 359796738;
  static const int SDL_PIXELFORMAT_BGRA4444 = 360845314;
  static const int SDL_PIXELFORMAT_ARGB1555 = 355667970;
  static const int SDL_PIXELFORMAT_RGBA5551 = 356782082;
  static const int SDL_PIXELFORMAT_ABGR1555 = 359862274;
  static const int SDL_PIXELFORMAT_BGRA5551 = 360976386;
  static const int SDL_PIXELFORMAT_RGB565 = 353701890;
  static const int SDL_PIXELFORMAT_BGR565 = 357896194;
  static const int SDL_PIXELFORMAT_RGB24 = 386930691;
  static const int SDL_PIXELFORMAT_BGR24 = 390076419;
  static const int SDL_PIXELFORMAT_XRGB8888 = 370546692;
  static const int SDL_PIXELFORMAT_RGB888 = 370546692;
  static const int SDL_PIXELFORMAT_RGBX8888 = 371595268;
  static const int SDL_PIXELFORMAT_XBGR8888 = 374740996;
  static const int SDL_PIXELFORMAT_BGR888 = 374740996;
  static const int SDL_PIXELFORMAT_BGRX8888 = 375789572;
  static const int SDL_PIXELFORMAT_ARGB8888 = 372645892;
  static const int SDL_PIXELFORMAT_RGBA8888 = 373694468;
  static const int SDL_PIXELFORMAT_ABGR8888 = 376840196;
  static const int SDL_PIXELFORMAT_BGRA8888 = 377888772;
  static const int SDL_PIXELFORMAT_ARGB2101010 = 372711428;
  static const int SDL_PIXELFORMAT_RGBA32 = 376840196;
  static const int SDL_PIXELFORMAT_ARGB32 = 377888772;
  static const int SDL_PIXELFORMAT_BGRA32 = 372645892;
  static const int SDL_PIXELFORMAT_ABGR32 = 373694468;

  /// < Planar mode: Y + V + U  (3 planes)
  static const int SDL_PIXELFORMAT_YV12 = 842094169;

  /// < Planar mode: Y + U + V  (3 planes)
  static const int SDL_PIXELFORMAT_IYUV = 1448433993;

  /// < Packed mode: Y0+U0+Y1+V0 (1 plane)
  static const int SDL_PIXELFORMAT_YUY2 = 844715353;

  /// < Packed mode: U0+Y0+V0+Y1 (1 plane)
  static const int SDL_PIXELFORMAT_UYVY = 1498831189;

  /// < Packed mode: Y0+V0+Y1+U0 (1 plane)
  static const int SDL_PIXELFORMAT_YVYU = 1431918169;

  /// < Planar mode: Y + U/V interleaved  (2 planes)
  static const int SDL_PIXELFORMAT_NV12 = 842094158;

  /// < Planar mode: Y + V/U interleaved  (2 planes)
  static const int SDL_PIXELFORMAT_NV21 = 825382478;

  /// < Android video texture format
  static const int SDL_PIXELFORMAT_EXTERNAL_OES = 542328143;
}

class SDL_Color extends ffi.Struct {
  @Uint8()
  external int r;

  @Uint8()
  external int g;

  @Uint8()
  external int b;

  @Uint8()
  external int a;
}

class SDL_Palette extends ffi.Struct {
  @ffi.Int32()
  external int ncolors;

  external ffi.Pointer<SDL_Color> colors;

  @Uint32()
  external int version;

  @ffi.Int32()
  external int refcount;
}

/// \note Everything in the pixel format structure is read-only.
class SDL_PixelFormat extends ffi.Struct {
  @Uint32()
  external int format;

  external ffi.Pointer<SDL_Palette> palette;

  @Uint8()
  external int BitsPerPixel;

  @Uint8()
  external int BytesPerPixel;

  @ffi.Array.multi([2])
  external ffi.Array<Uint8> padding;

  @Uint32()
  external int Rmask;

  @Uint32()
  external int Gmask;

  @Uint32()
  external int Bmask;

  @Uint32()
  external int Amask;

  @Uint8()
  external int Rloss;

  @Uint8()
  external int Gloss;

  @Uint8()
  external int Bloss;

  @Uint8()
  external int Aloss;

  @Uint8()
  external int Rshift;

  @Uint8()
  external int Gshift;

  @Uint8()
  external int Bshift;

  @Uint8()
  external int Ashift;

  @ffi.Int32()
  external int refcount;

  external ffi.Pointer<SDL_PixelFormat> next;
}

/// \brief  The structure that defines a point (integer)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
class SDL_Point extends ffi.Struct {
  @ffi.Int32()
  external int x;

  @ffi.Int32()
  external int y;
}

/// \brief  The structure that defines a point (floating point)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
class SDL_FPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

/// \brief A rectangle, with the origin at the upper left (integer).
///
/// \sa SDL_RectEmpty
/// \sa SDL_RectEquals
/// \sa SDL_HasIntersection
/// \sa SDL_IntersectRect
/// \sa SDL_UnionRect
/// \sa SDL_EnclosePoints
class SDL_Rect extends ffi.Struct {
  @ffi.Int32()
  external int x;

  @ffi.Int32()
  external int y;

  @ffi.Int32()
  external int w;

  @ffi.Int32()
  external int h;
}

/// \brief A rectangle, with the origin at the upper left (floating point).
class SDL_FRect extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;
}

/// \brief The blend mode used in SDL_RenderCopy() and drawing operations.
abstract class SDL_BlendMode {
  /// < no blending
  /// dstRGBA = srcRGBA
  static const int SDL_BLENDMODE_NONE = 0;

  /// < alpha blending
  /// dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
  /// dstA = srcA + (dstA * (1-srcA))
  static const int SDL_BLENDMODE_BLEND = 1;

  /// < additive blending
  /// dstRGB = (srcRGB * srcA) + dstRGB
  /// dstA = dstA
  static const int SDL_BLENDMODE_ADD = 2;

  /// < color modulate
  /// dstRGB = srcRGB * dstRGB
  /// dstA = dstA
  static const int SDL_BLENDMODE_MOD = 4;

  /// < color multiply
  /// dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
  /// dstA = (srcA * dstA) + (dstA * (1-srcA))
  static const int SDL_BLENDMODE_MUL = 8;
  static const int SDL_BLENDMODE_INVALID = 2147483647;
}

/// \brief The blend operation used when combining source and destination pixel components
abstract class SDL_BlendOperation {
  /// < dst + src: supported by all renderers
  static const int SDL_BLENDOPERATION_ADD = 1;

  /// < dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES
  static const int SDL_BLENDOPERATION_SUBTRACT = 2;

  /// < src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES
  static const int SDL_BLENDOPERATION_REV_SUBTRACT = 3;

  /// < min(dst, src) : supported by D3D11
  static const int SDL_BLENDOPERATION_MINIMUM = 4;

  /// < max(dst, src) : supported by D3D11
  static const int SDL_BLENDOPERATION_MAXIMUM = 5;
}

/// \brief The normalized factor used to multiply pixel components
abstract class SDL_BlendFactor {
  /// < 0, 0, 0, 0
  static const int SDL_BLENDFACTOR_ZERO = 1;

  /// < 1, 1, 1, 1
  static const int SDL_BLENDFACTOR_ONE = 2;

  /// < srcR, srcG, srcB, srcA
  static const int SDL_BLENDFACTOR_SRC_COLOR = 3;

  /// < 1-srcR, 1-srcG, 1-srcB, 1-srcA
  static const int SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4;

  /// < srcA, srcA, srcA, srcA
  static const int SDL_BLENDFACTOR_SRC_ALPHA = 5;

  /// < 1-srcA, 1-srcA, 1-srcA, 1-srcA
  static const int SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6;

  /// < dstR, dstG, dstB, dstA
  static const int SDL_BLENDFACTOR_DST_COLOR = 7;

  /// < 1-dstR, 1-dstG, 1-dstB, 1-dstA
  static const int SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8;

  /// < dstA, dstA, dstA, dstA
  static const int SDL_BLENDFACTOR_DST_ALPHA = 9;

  /// < 1-dstA, 1-dstA, 1-dstA, 1-dstA
  static const int SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10;
}

/// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
/// which, if not NULL, contains the raw pixel data for the surface.
class SDL_Surface extends ffi.Struct {
  /// < Read-only
  @Uint32()
  external int flags;

  /// < Read-only
  external ffi.Pointer<SDL_PixelFormat> format;

  /// < Read-only
  @ffi.Int32()
  external int w;

  @ffi.Int32()
  external int h;

  /// < Read-only
  @ffi.Int32()
  external int pitch;

  /// < Read-write
  external ffi.Pointer<ffi.Void> pixels;

  /// < Read-write
  external ffi.Pointer<ffi.Void> userdata;

  /// < Read-only
  @ffi.Int32()
  external int locked;

  /// < Private
  external ffi.Pointer<ffi.Void> list_blitmap;

  /// < Read-only
  external SDL_Rect clip_rect;

  /// < Private
  external ffi.Pointer<SDL_BlitMap> map;

  /// < Read-mostly
  @ffi.Int32()
  external int refcount;
}

class SDL_BlitMap extends ffi.Opaque {}

/// \brief The formula used for converting between YUV and RGB
abstract class SDL_YUV_CONVERSION_MODE {
  /// < Full range JPEG
  static const int SDL_YUV_CONVERSION_JPEG = 0;

  /// < BT.601 (the default)
  static const int SDL_YUV_CONVERSION_BT601 = 1;

  /// < BT.709
  static const int SDL_YUV_CONVERSION_BT709 = 2;

  /// < BT.601 for SD content, BT.709 for HD content
  static const int SDL_YUV_CONVERSION_AUTOMATIC = 3;
}

/// \brief  The structure that defines a display mode
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
/// \sa SDL_GetDesktopDisplayMode()
/// \sa SDL_GetCurrentDisplayMode()
/// \sa SDL_GetClosestDisplayMode()
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode()
class SDL_DisplayMode extends ffi.Struct {
  /// < pixel format
  @Uint32()
  external int format;

  /// < width, in screen coordinates
  @ffi.Int32()
  external int w;

  /// < height, in screen coordinates
  @ffi.Int32()
  external int h;

  /// < refresh rate (or zero for unspecified)
  @ffi.Int32()
  external int refresh_rate;

  /// < driver-specific data, initialize to 0
  external ffi.Pointer<ffi.Void> driverdata;
}

class SDL_Window extends ffi.Opaque {}

/// \brief The flags on a window
///
/// \sa SDL_GetWindowFlags()
abstract class SDL_WindowFlags {
  /// < fullscreen window
  static const int SDL_WINDOW_FULLSCREEN = 1;

  /// < window usable with OpenGL context
  static const int SDL_WINDOW_OPENGL = 2;

  /// < window is visible
  static const int SDL_WINDOW_SHOWN = 4;

  /// < window is not visible
  static const int SDL_WINDOW_HIDDEN = 8;

  /// < no window decoration
  static const int SDL_WINDOW_BORDERLESS = 16;

  /// < window can be resized
  static const int SDL_WINDOW_RESIZABLE = 32;

  /// < window is minimized
  static const int SDL_WINDOW_MINIMIZED = 64;

  /// < window is maximized
  static const int SDL_WINDOW_MAXIMIZED = 128;

  /// < window has grabbed input focus
  static const int SDL_WINDOW_INPUT_GRABBED = 256;

  /// < window has input focus
  static const int SDL_WINDOW_INPUT_FOCUS = 512;

  /// < window has mouse focus
  static const int SDL_WINDOW_MOUSE_FOCUS = 1024;
  static const int SDL_WINDOW_FULLSCREEN_DESKTOP = 4097;

  /// < window not created by SDL
  static const int SDL_WINDOW_FOREIGN = 2048;

  /// < window should be created in high-DPI mode if supported.
  /// On macOS NSHighResolutionCapable must be set true in the
  /// application's Info.plist for this to have any effect.
  static const int SDL_WINDOW_ALLOW_HIGHDPI = 8192;

  /// < window has mouse captured (unrelated to INPUT_GRABBED)
  static const int SDL_WINDOW_MOUSE_CAPTURE = 16384;

  /// < window should always be above others
  static const int SDL_WINDOW_ALWAYS_ON_TOP = 32768;

  /// < window should not be added to the taskbar
  static const int SDL_WINDOW_SKIP_TASKBAR = 65536;

  /// < window should be treated as a utility window
  static const int SDL_WINDOW_UTILITY = 131072;

  /// < window should be treated as a tooltip
  static const int SDL_WINDOW_TOOLTIP = 262144;

  /// < window should be treated as a popup menu
  static const int SDL_WINDOW_POPUP_MENU = 524288;

  /// < window usable for Vulkan surface
  static const int SDL_WINDOW_VULKAN = 268435456;

  /// < window usable for Metal view
  static const int SDL_WINDOW_METAL = 536870912;
}

/// \brief Event subtype for window events
abstract class SDL_WindowEventID {
  /// < Never used
  static const int SDL_WINDOWEVENT_NONE = 0;

  /// < Window has been shown
  static const int SDL_WINDOWEVENT_SHOWN = 1;

  /// < Window has been hidden
  static const int SDL_WINDOWEVENT_HIDDEN = 2;

  /// < Window has been exposed and should be
  /// redrawn
  static const int SDL_WINDOWEVENT_EXPOSED = 3;

  /// < Window has been moved to data1, data2
  static const int SDL_WINDOWEVENT_MOVED = 4;

  /// < Window has been resized to data1xdata2
  static const int SDL_WINDOWEVENT_RESIZED = 5;

  /// < The window size has changed, either as
  /// a result of an API call or through the
  /// system or user changing the window size.
  static const int SDL_WINDOWEVENT_SIZE_CHANGED = 6;

  /// < Window has been minimized
  static const int SDL_WINDOWEVENT_MINIMIZED = 7;

  /// < Window has been maximized
  static const int SDL_WINDOWEVENT_MAXIMIZED = 8;

  /// < Window has been restored to normal size
  /// and position
  static const int SDL_WINDOWEVENT_RESTORED = 9;

  /// < Window has gained mouse focus
  static const int SDL_WINDOWEVENT_ENTER = 10;

  /// < Window has lost mouse focus
  static const int SDL_WINDOWEVENT_LEAVE = 11;

  /// < Window has gained keyboard focus
  static const int SDL_WINDOWEVENT_FOCUS_GAINED = 12;

  /// < Window has lost keyboard focus
  static const int SDL_WINDOWEVENT_FOCUS_LOST = 13;

  /// < The window manager requests that the window be closed
  static const int SDL_WINDOWEVENT_CLOSE = 14;

  /// < Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)
  static const int SDL_WINDOWEVENT_TAKE_FOCUS = 15;

  /// < Window had a hit test that wasn't SDL_HITTEST_NORMAL.
  static const int SDL_WINDOWEVENT_HIT_TEST = 16;
}

/// \brief Event subtype for display events
abstract class SDL_DisplayEventID {
  /// < Never used
  static const int SDL_DISPLAYEVENT_NONE = 0;

  /// < Display orientation has changed to data1
  static const int SDL_DISPLAYEVENT_ORIENTATION = 1;

  /// < Display has been added to the system
  static const int SDL_DISPLAYEVENT_CONNECTED = 2;

  /// < Display has been removed from the system
  static const int SDL_DISPLAYEVENT_DISCONNECTED = 3;
}

abstract class SDL_DisplayOrientation {
  /// < The display orientation can't be determined
  static const int SDL_ORIENTATION_UNKNOWN = 0;

  /// < The display is in landscape mode, with the right side up, relative to portrait mode
  static const int SDL_ORIENTATION_LANDSCAPE = 1;

  /// < The display is in landscape mode, with the left side up, relative to portrait mode
  static const int SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2;

  /// < The display is in portrait mode
  static const int SDL_ORIENTATION_PORTRAIT = 3;

  /// < The display is in portrait mode, upside down
  static const int SDL_ORIENTATION_PORTRAIT_FLIPPED = 4;
}

/// \brief OpenGL configuration attributes
abstract class SDL_GLattr {
  static const int SDL_GL_RED_SIZE = 0;
  static const int SDL_GL_GREEN_SIZE = 1;
  static const int SDL_GL_BLUE_SIZE = 2;
  static const int SDL_GL_ALPHA_SIZE = 3;
  static const int SDL_GL_BUFFER_SIZE = 4;
  static const int SDL_GL_DOUBLEBUFFER = 5;
  static const int SDL_GL_DEPTH_SIZE = 6;
  static const int SDL_GL_STENCIL_SIZE = 7;
  static const int SDL_GL_ACCUM_RED_SIZE = 8;
  static const int SDL_GL_ACCUM_GREEN_SIZE = 9;
  static const int SDL_GL_ACCUM_BLUE_SIZE = 10;
  static const int SDL_GL_ACCUM_ALPHA_SIZE = 11;
  static const int SDL_GL_STEREO = 12;
  static const int SDL_GL_MULTISAMPLEBUFFERS = 13;
  static const int SDL_GL_MULTISAMPLESAMPLES = 14;
  static const int SDL_GL_ACCELERATED_VISUAL = 15;
  static const int SDL_GL_RETAINED_BACKING = 16;
  static const int SDL_GL_CONTEXT_MAJOR_VERSION = 17;
  static const int SDL_GL_CONTEXT_MINOR_VERSION = 18;
  static const int SDL_GL_CONTEXT_EGL = 19;
  static const int SDL_GL_CONTEXT_FLAGS = 20;
  static const int SDL_GL_CONTEXT_PROFILE_MASK = 21;
  static const int SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22;
  static const int SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23;
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24;
  static const int SDL_GL_CONTEXT_RESET_NOTIFICATION = 25;
  static const int SDL_GL_CONTEXT_NO_ERROR = 26;
}

abstract class SDL_GLprofile {
  static const int SDL_GL_CONTEXT_PROFILE_CORE = 1;
  static const int SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2;

  /// < GLX_CONTEXT_ES2_PROFILE_BIT_EXT
  static const int SDL_GL_CONTEXT_PROFILE_ES = 4;
}

abstract class SDL_GLcontextFlag {
  static const int SDL_GL_CONTEXT_DEBUG_FLAG = 1;
  static const int SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2;
  static const int SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4;
  static const int SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8;
}

abstract class SDL_GLcontextReleaseFlag {
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0;
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1;
}

abstract class SDL_GLContextResetNotification {
  static const int SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0;
  static const int SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1;
}

/// \brief Possible return values from the SDL_HitTest callback.
///
/// \sa SDL_HitTest
abstract class SDL_HitTestResult {
  /// < Region is normal. No special properties.
  static const int SDL_HITTEST_NORMAL = 0;

  /// < Region can drag entire window.
  static const int SDL_HITTEST_DRAGGABLE = 1;
  static const int SDL_HITTEST_RESIZE_TOPLEFT = 2;
  static const int SDL_HITTEST_RESIZE_TOP = 3;
  static const int SDL_HITTEST_RESIZE_TOPRIGHT = 4;
  static const int SDL_HITTEST_RESIZE_RIGHT = 5;
  static const int SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6;
  static const int SDL_HITTEST_RESIZE_BOTTOM = 7;
  static const int SDL_HITTEST_RESIZE_BOTTOMLEFT = 8;
  static const int SDL_HITTEST_RESIZE_LEFT = 9;
}

/// \brief Callback used for hit-testing.
///
/// \sa SDL_SetWindowHitTest
typedef SDL_HitTest = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<SDL_Window>, ffi.Pointer<SDL_Point>,
            ffi.Pointer<ffi.Void>)>>;

/// \brief An opaque handle to an OpenGL context.
typedef SDL_GLContext = ffi.Pointer<ffi.Void>;

/// \brief The SDL keyboard scancode representation.
///
/// Values of this type are used to represent keyboard keys, among other places
/// in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
/// SDL_Event structure.
///
/// The values in this enumeration are based on the USB usage page standard:
/// https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
abstract class SDL_Scancode {
  static const int SDL_SCANCODE_UNKNOWN = 0;
  static const int SDL_SCANCODE_A = 4;
  static const int SDL_SCANCODE_B = 5;
  static const int SDL_SCANCODE_C = 6;
  static const int SDL_SCANCODE_D = 7;
  static const int SDL_SCANCODE_E = 8;
  static const int SDL_SCANCODE_F = 9;
  static const int SDL_SCANCODE_G = 10;
  static const int SDL_SCANCODE_H = 11;
  static const int SDL_SCANCODE_I = 12;
  static const int SDL_SCANCODE_J = 13;
  static const int SDL_SCANCODE_K = 14;
  static const int SDL_SCANCODE_L = 15;
  static const int SDL_SCANCODE_M = 16;
  static const int SDL_SCANCODE_N = 17;
  static const int SDL_SCANCODE_O = 18;
  static const int SDL_SCANCODE_P = 19;
  static const int SDL_SCANCODE_Q = 20;
  static const int SDL_SCANCODE_R = 21;
  static const int SDL_SCANCODE_S = 22;
  static const int SDL_SCANCODE_T = 23;
  static const int SDL_SCANCODE_U = 24;
  static const int SDL_SCANCODE_V = 25;
  static const int SDL_SCANCODE_W = 26;
  static const int SDL_SCANCODE_X = 27;
  static const int SDL_SCANCODE_Y = 28;
  static const int SDL_SCANCODE_Z = 29;
  static const int SDL_SCANCODE_1 = 30;
  static const int SDL_SCANCODE_2 = 31;
  static const int SDL_SCANCODE_3 = 32;
  static const int SDL_SCANCODE_4 = 33;
  static const int SDL_SCANCODE_5 = 34;
  static const int SDL_SCANCODE_6 = 35;
  static const int SDL_SCANCODE_7 = 36;
  static const int SDL_SCANCODE_8 = 37;
  static const int SDL_SCANCODE_9 = 38;
  static const int SDL_SCANCODE_0 = 39;
  static const int SDL_SCANCODE_RETURN = 40;
  static const int SDL_SCANCODE_ESCAPE = 41;
  static const int SDL_SCANCODE_BACKSPACE = 42;
  static const int SDL_SCANCODE_TAB = 43;
  static const int SDL_SCANCODE_SPACE = 44;
  static const int SDL_SCANCODE_MINUS = 45;
  static const int SDL_SCANCODE_EQUALS = 46;
  static const int SDL_SCANCODE_LEFTBRACKET = 47;
  static const int SDL_SCANCODE_RIGHTBRACKET = 48;

  /// < Located at the lower left of the return
  /// key on ISO keyboards and at the right end
  /// of the QWERTY row on ANSI keyboards.
  /// Produces REVERSE SOLIDUS (backslash) and
  /// VERTICAL LINE in a US layout, REVERSE
  /// SOLIDUS and VERTICAL LINE in a UK Mac
  /// layout, NUMBER SIGN and TILDE in a UK
  /// Windows layout, DOLLAR SIGN and POUND SIGN
  /// in a Swiss German layout, NUMBER SIGN and
  /// APOSTROPHE in a German layout, GRAVE
  /// ACCENT and POUND SIGN in a French Mac
  /// layout, and ASTERISK and MICRO SIGN in a
  /// French Windows layout.
  static const int SDL_SCANCODE_BACKSLASH = 49;

  /// < ISO USB keyboards actually use this code
  /// instead of 49 for the same key, but all
  /// OSes I've seen treat the two codes
  /// identically. So, as an implementor, unless
  /// your keyboard generates both of those
  /// codes and your OS treats them differently,
  /// you should generate SDL_SCANCODE_BACKSLASH
  /// instead of this code. As a user, you
  /// should not rely on this code because SDL
  /// will never generate it with most (all?)
  /// keyboards.
  static const int SDL_SCANCODE_NONUSHASH = 50;
  static const int SDL_SCANCODE_SEMICOLON = 51;
  static const int SDL_SCANCODE_APOSTROPHE = 52;

  /// < Located in the top left corner (on both ANSI
  /// and ISO keyboards). Produces GRAVE ACCENT and
  /// TILDE in a US Windows layout and in US and UK
  /// Mac layouts on ANSI keyboards, GRAVE ACCENT
  /// and NOT SIGN in a UK Windows layout, SECTION
  /// SIGN and PLUS-MINUS SIGN in US and UK Mac
  /// layouts on ISO keyboards, SECTION SIGN and
  /// DEGREE SIGN in a Swiss German layout (Mac:
  /// only on ISO keyboards), CIRCUMFLEX ACCENT and
  /// DEGREE SIGN in a German layout (Mac: only on
  /// ISO keyboards), SUPERSCRIPT TWO and TILDE in a
  /// French Windows layout, COMMERCIAL AT and
  /// NUMBER SIGN in a French Mac layout on ISO
  /// keyboards, and LESS-THAN SIGN and GREATER-THAN
  /// SIGN in a Swiss German, German, or French Mac
  /// layout on ANSI keyboards.
  static const int SDL_SCANCODE_GRAVE = 53;
  static const int SDL_SCANCODE_COMMA = 54;
  static const int SDL_SCANCODE_PERIOD = 55;
  static const int SDL_SCANCODE_SLASH = 56;
  static const int SDL_SCANCODE_CAPSLOCK = 57;
  static const int SDL_SCANCODE_F1 = 58;
  static const int SDL_SCANCODE_F2 = 59;
  static const int SDL_SCANCODE_F3 = 60;
  static const int SDL_SCANCODE_F4 = 61;
  static const int SDL_SCANCODE_F5 = 62;
  static const int SDL_SCANCODE_F6 = 63;
  static const int SDL_SCANCODE_F7 = 64;
  static const int SDL_SCANCODE_F8 = 65;
  static const int SDL_SCANCODE_F9 = 66;
  static const int SDL_SCANCODE_F10 = 67;
  static const int SDL_SCANCODE_F11 = 68;
  static const int SDL_SCANCODE_F12 = 69;
  static const int SDL_SCANCODE_PRINTSCREEN = 70;
  static const int SDL_SCANCODE_SCROLLLOCK = 71;
  static const int SDL_SCANCODE_PAUSE = 72;

  /// < insert on PC, help on some Mac keyboards (but
  /// does send code 73, not 117)
  static const int SDL_SCANCODE_INSERT = 73;
  static const int SDL_SCANCODE_HOME = 74;
  static const int SDL_SCANCODE_PAGEUP = 75;
  static const int SDL_SCANCODE_DELETE = 76;
  static const int SDL_SCANCODE_END = 77;
  static const int SDL_SCANCODE_PAGEDOWN = 78;
  static const int SDL_SCANCODE_RIGHT = 79;
  static const int SDL_SCANCODE_LEFT = 80;
  static const int SDL_SCANCODE_DOWN = 81;
  static const int SDL_SCANCODE_UP = 82;

  /// < num lock on PC, clear on Mac keyboards
  static const int SDL_SCANCODE_NUMLOCKCLEAR = 83;
  static const int SDL_SCANCODE_KP_DIVIDE = 84;
  static const int SDL_SCANCODE_KP_MULTIPLY = 85;
  static const int SDL_SCANCODE_KP_MINUS = 86;
  static const int SDL_SCANCODE_KP_PLUS = 87;
  static const int SDL_SCANCODE_KP_ENTER = 88;
  static const int SDL_SCANCODE_KP_1 = 89;
  static const int SDL_SCANCODE_KP_2 = 90;
  static const int SDL_SCANCODE_KP_3 = 91;
  static const int SDL_SCANCODE_KP_4 = 92;
  static const int SDL_SCANCODE_KP_5 = 93;
  static const int SDL_SCANCODE_KP_6 = 94;
  static const int SDL_SCANCODE_KP_7 = 95;
  static const int SDL_SCANCODE_KP_8 = 96;
  static const int SDL_SCANCODE_KP_9 = 97;
  static const int SDL_SCANCODE_KP_0 = 98;
  static const int SDL_SCANCODE_KP_PERIOD = 99;

  /// < This is the additional key that ISO
  /// keyboards have over ANSI ones,
  /// located between left shift and Y.
  /// Produces GRAVE ACCENT and TILDE in a
  /// US or UK Mac layout, REVERSE SOLIDUS
  /// (backslash) and VERTICAL LINE in a
  /// US or UK Windows layout, and
  /// LESS-THAN SIGN and GREATER-THAN SIGN
  /// in a Swiss German, German, or French
  /// layout.
  static const int SDL_SCANCODE_NONUSBACKSLASH = 100;

  /// < windows contextual menu, compose
  static const int SDL_SCANCODE_APPLICATION = 101;

  /// < The USB document says this is a status flag,
  /// not a physical key - but some Mac keyboards
  /// do have a power key.
  static const int SDL_SCANCODE_POWER = 102;
  static const int SDL_SCANCODE_KP_EQUALS = 103;
  static const int SDL_SCANCODE_F13 = 104;
  static const int SDL_SCANCODE_F14 = 105;
  static const int SDL_SCANCODE_F15 = 106;
  static const int SDL_SCANCODE_F16 = 107;
  static const int SDL_SCANCODE_F17 = 108;
  static const int SDL_SCANCODE_F18 = 109;
  static const int SDL_SCANCODE_F19 = 110;
  static const int SDL_SCANCODE_F20 = 111;
  static const int SDL_SCANCODE_F21 = 112;
  static const int SDL_SCANCODE_F22 = 113;
  static const int SDL_SCANCODE_F23 = 114;
  static const int SDL_SCANCODE_F24 = 115;
  static const int SDL_SCANCODE_EXECUTE = 116;
  static const int SDL_SCANCODE_HELP = 117;
  static const int SDL_SCANCODE_MENU = 118;
  static const int SDL_SCANCODE_SELECT = 119;
  static const int SDL_SCANCODE_STOP = 120;

  /// < redo
  static const int SDL_SCANCODE_AGAIN = 121;
  static const int SDL_SCANCODE_UNDO = 122;
  static const int SDL_SCANCODE_CUT = 123;
  static const int SDL_SCANCODE_COPY = 124;
  static const int SDL_SCANCODE_PASTE = 125;
  static const int SDL_SCANCODE_FIND = 126;
  static const int SDL_SCANCODE_MUTE = 127;
  static const int SDL_SCANCODE_VOLUMEUP = 128;
  static const int SDL_SCANCODE_VOLUMEDOWN = 129;
  static const int SDL_SCANCODE_KP_COMMA = 133;
  static const int SDL_SCANCODE_KP_EQUALSAS400 = 134;

  /// < used on Asian keyboards, see
  /// footnotes in USB doc
  static const int SDL_SCANCODE_INTERNATIONAL1 = 135;
  static const int SDL_SCANCODE_INTERNATIONAL2 = 136;

  /// < Yen
  static const int SDL_SCANCODE_INTERNATIONAL3 = 137;
  static const int SDL_SCANCODE_INTERNATIONAL4 = 138;
  static const int SDL_SCANCODE_INTERNATIONAL5 = 139;
  static const int SDL_SCANCODE_INTERNATIONAL6 = 140;
  static const int SDL_SCANCODE_INTERNATIONAL7 = 141;
  static const int SDL_SCANCODE_INTERNATIONAL8 = 142;
  static const int SDL_SCANCODE_INTERNATIONAL9 = 143;

  /// < Hangul/English toggle
  static const int SDL_SCANCODE_LANG1 = 144;

  /// < Hanja conversion
  static const int SDL_SCANCODE_LANG2 = 145;

  /// < Katakana
  static const int SDL_SCANCODE_LANG3 = 146;

  /// < Hiragana
  static const int SDL_SCANCODE_LANG4 = 147;

  /// < Zenkaku/Hankaku
  static const int SDL_SCANCODE_LANG5 = 148;

  /// < reserved
  static const int SDL_SCANCODE_LANG6 = 149;

  /// < reserved
  static const int SDL_SCANCODE_LANG7 = 150;

  /// < reserved
  static const int SDL_SCANCODE_LANG8 = 151;

  /// < reserved
  static const int SDL_SCANCODE_LANG9 = 152;

  /// < Erase-Eaze
  static const int SDL_SCANCODE_ALTERASE = 153;
  static const int SDL_SCANCODE_SYSREQ = 154;
  static const int SDL_SCANCODE_CANCEL = 155;
  static const int SDL_SCANCODE_CLEAR = 156;
  static const int SDL_SCANCODE_PRIOR = 157;
  static const int SDL_SCANCODE_RETURN2 = 158;
  static const int SDL_SCANCODE_SEPARATOR = 159;
  static const int SDL_SCANCODE_OUT = 160;
  static const int SDL_SCANCODE_OPER = 161;
  static const int SDL_SCANCODE_CLEARAGAIN = 162;
  static const int SDL_SCANCODE_CRSEL = 163;
  static const int SDL_SCANCODE_EXSEL = 164;
  static const int SDL_SCANCODE_KP_00 = 176;
  static const int SDL_SCANCODE_KP_000 = 177;
  static const int SDL_SCANCODE_THOUSANDSSEPARATOR = 178;
  static const int SDL_SCANCODE_DECIMALSEPARATOR = 179;
  static const int SDL_SCANCODE_CURRENCYUNIT = 180;
  static const int SDL_SCANCODE_CURRENCYSUBUNIT = 181;
  static const int SDL_SCANCODE_KP_LEFTPAREN = 182;
  static const int SDL_SCANCODE_KP_RIGHTPAREN = 183;
  static const int SDL_SCANCODE_KP_LEFTBRACE = 184;
  static const int SDL_SCANCODE_KP_RIGHTBRACE = 185;
  static const int SDL_SCANCODE_KP_TAB = 186;
  static const int SDL_SCANCODE_KP_BACKSPACE = 187;
  static const int SDL_SCANCODE_KP_A = 188;
  static const int SDL_SCANCODE_KP_B = 189;
  static const int SDL_SCANCODE_KP_C = 190;
  static const int SDL_SCANCODE_KP_D = 191;
  static const int SDL_SCANCODE_KP_E = 192;
  static const int SDL_SCANCODE_KP_F = 193;
  static const int SDL_SCANCODE_KP_XOR = 194;
  static const int SDL_SCANCODE_KP_POWER = 195;
  static const int SDL_SCANCODE_KP_PERCENT = 196;
  static const int SDL_SCANCODE_KP_LESS = 197;
  static const int SDL_SCANCODE_KP_GREATER = 198;
  static const int SDL_SCANCODE_KP_AMPERSAND = 199;
  static const int SDL_SCANCODE_KP_DBLAMPERSAND = 200;
  static const int SDL_SCANCODE_KP_VERTICALBAR = 201;
  static const int SDL_SCANCODE_KP_DBLVERTICALBAR = 202;
  static const int SDL_SCANCODE_KP_COLON = 203;
  static const int SDL_SCANCODE_KP_HASH = 204;
  static const int SDL_SCANCODE_KP_SPACE = 205;
  static const int SDL_SCANCODE_KP_AT = 206;
  static const int SDL_SCANCODE_KP_EXCLAM = 207;
  static const int SDL_SCANCODE_KP_MEMSTORE = 208;
  static const int SDL_SCANCODE_KP_MEMRECALL = 209;
  static const int SDL_SCANCODE_KP_MEMCLEAR = 210;
  static const int SDL_SCANCODE_KP_MEMADD = 211;
  static const int SDL_SCANCODE_KP_MEMSUBTRACT = 212;
  static const int SDL_SCANCODE_KP_MEMMULTIPLY = 213;
  static const int SDL_SCANCODE_KP_MEMDIVIDE = 214;
  static const int SDL_SCANCODE_KP_PLUSMINUS = 215;
  static const int SDL_SCANCODE_KP_CLEAR = 216;
  static const int SDL_SCANCODE_KP_CLEARENTRY = 217;
  static const int SDL_SCANCODE_KP_BINARY = 218;
  static const int SDL_SCANCODE_KP_OCTAL = 219;
  static const int SDL_SCANCODE_KP_DECIMAL = 220;
  static const int SDL_SCANCODE_KP_HEXADECIMAL = 221;
  static const int SDL_SCANCODE_LCTRL = 224;
  static const int SDL_SCANCODE_LSHIFT = 225;

  /// < alt, option
  static const int SDL_SCANCODE_LALT = 226;

  /// < windows, command (apple), meta
  static const int SDL_SCANCODE_LGUI = 227;
  static const int SDL_SCANCODE_RCTRL = 228;
  static const int SDL_SCANCODE_RSHIFT = 229;

  /// < alt gr, option
  static const int SDL_SCANCODE_RALT = 230;

  /// < windows, command (apple), meta
  static const int SDL_SCANCODE_RGUI = 231;

  /// < I'm not sure if this is really not covered
  /// by any of the above, but since there's a
  /// special KMOD_MODE for it I'm adding it here
  static const int SDL_SCANCODE_MODE = 257;
  static const int SDL_SCANCODE_AUDIONEXT = 258;
  static const int SDL_SCANCODE_AUDIOPREV = 259;
  static const int SDL_SCANCODE_AUDIOSTOP = 260;
  static const int SDL_SCANCODE_AUDIOPLAY = 261;
  static const int SDL_SCANCODE_AUDIOMUTE = 262;
  static const int SDL_SCANCODE_MEDIASELECT = 263;
  static const int SDL_SCANCODE_WWW = 264;
  static const int SDL_SCANCODE_MAIL = 265;
  static const int SDL_SCANCODE_CALCULATOR = 266;
  static const int SDL_SCANCODE_COMPUTER = 267;
  static const int SDL_SCANCODE_AC_SEARCH = 268;
  static const int SDL_SCANCODE_AC_HOME = 269;
  static const int SDL_SCANCODE_AC_BACK = 270;
  static const int SDL_SCANCODE_AC_FORWARD = 271;
  static const int SDL_SCANCODE_AC_STOP = 272;
  static const int SDL_SCANCODE_AC_REFRESH = 273;
  static const int SDL_SCANCODE_AC_BOOKMARKS = 274;
  static const int SDL_SCANCODE_BRIGHTNESSDOWN = 275;
  static const int SDL_SCANCODE_BRIGHTNESSUP = 276;

  /// < display mirroring/dual display
  /// switch, video mode switch
  static const int SDL_SCANCODE_DISPLAYSWITCH = 277;
  static const int SDL_SCANCODE_KBDILLUMTOGGLE = 278;
  static const int SDL_SCANCODE_KBDILLUMDOWN = 279;
  static const int SDL_SCANCODE_KBDILLUMUP = 280;
  static const int SDL_SCANCODE_EJECT = 281;
  static const int SDL_SCANCODE_SLEEP = 282;
  static const int SDL_SCANCODE_APP1 = 283;
  static const int SDL_SCANCODE_APP2 = 284;
  static const int SDL_SCANCODE_AUDIOREWIND = 285;
  static const int SDL_SCANCODE_AUDIOFASTFORWARD = 286;

  /// < not a key, just marks the number of scancodes
  /// for array bounds
  static const int SDL_NUM_SCANCODES = 512;
}

abstract class SDL_KeyCode {
  static const int SDLK_UNKNOWN = 0;
  static const int SDLK_RETURN = 13;
  static const int SDLK_ESCAPE = 27;
  static const int SDLK_BACKSPACE = 8;
  static const int SDLK_TAB = 9;
  static const int SDLK_SPACE = 32;
  static const int SDLK_EXCLAIM = 33;
  static const int SDLK_QUOTEDBL = 34;
  static const int SDLK_HASH = 35;
  static const int SDLK_PERCENT = 37;
  static const int SDLK_DOLLAR = 36;
  static const int SDLK_AMPERSAND = 38;
  static const int SDLK_QUOTE = 39;
  static const int SDLK_LEFTPAREN = 40;
  static const int SDLK_RIGHTPAREN = 41;
  static const int SDLK_ASTERISK = 42;
  static const int SDLK_PLUS = 43;
  static const int SDLK_COMMA = 44;
  static const int SDLK_MINUS = 45;
  static const int SDLK_PERIOD = 46;
  static const int SDLK_SLASH = 47;
  static const int SDLK_0 = 48;
  static const int SDLK_1 = 49;
  static const int SDLK_2 = 50;
  static const int SDLK_3 = 51;
  static const int SDLK_4 = 52;
  static const int SDLK_5 = 53;
  static const int SDLK_6 = 54;
  static const int SDLK_7 = 55;
  static const int SDLK_8 = 56;
  static const int SDLK_9 = 57;
  static const int SDLK_COLON = 58;
  static const int SDLK_SEMICOLON = 59;
  static const int SDLK_LESS = 60;
  static const int SDLK_EQUALS = 61;
  static const int SDLK_GREATER = 62;
  static const int SDLK_QUESTION = 63;
  static const int SDLK_AT = 64;
  static const int SDLK_LEFTBRACKET = 91;
  static const int SDLK_BACKSLASH = 92;
  static const int SDLK_RIGHTBRACKET = 93;
  static const int SDLK_CARET = 94;
  static const int SDLK_UNDERSCORE = 95;
  static const int SDLK_BACKQUOTE = 96;
  static const int SDLK_a = 97;
  static const int SDLK_b = 98;
  static const int SDLK_c = 99;
  static const int SDLK_d = 100;
  static const int SDLK_e = 101;
  static const int SDLK_f = 102;
  static const int SDLK_g = 103;
  static const int SDLK_h = 104;
  static const int SDLK_i = 105;
  static const int SDLK_j = 106;
  static const int SDLK_k = 107;
  static const int SDLK_l = 108;
  static const int SDLK_m = 109;
  static const int SDLK_n = 110;
  static const int SDLK_o = 111;
  static const int SDLK_p = 112;
  static const int SDLK_q = 113;
  static const int SDLK_r = 114;
  static const int SDLK_s = 115;
  static const int SDLK_t = 116;
  static const int SDLK_u = 117;
  static const int SDLK_v = 118;
  static const int SDLK_w = 119;
  static const int SDLK_x = 120;
  static const int SDLK_y = 121;
  static const int SDLK_z = 122;
  static const int SDLK_CAPSLOCK = 1073741881;
  static const int SDLK_F1 = 1073741882;
  static const int SDLK_F2 = 1073741883;
  static const int SDLK_F3 = 1073741884;
  static const int SDLK_F4 = 1073741885;
  static const int SDLK_F5 = 1073741886;
  static const int SDLK_F6 = 1073741887;
  static const int SDLK_F7 = 1073741888;
  static const int SDLK_F8 = 1073741889;
  static const int SDLK_F9 = 1073741890;
  static const int SDLK_F10 = 1073741891;
  static const int SDLK_F11 = 1073741892;
  static const int SDLK_F12 = 1073741893;
  static const int SDLK_PRINTSCREEN = 1073741894;
  static const int SDLK_SCROLLLOCK = 1073741895;
  static const int SDLK_PAUSE = 1073741896;
  static const int SDLK_INSERT = 1073741897;
  static const int SDLK_HOME = 1073741898;
  static const int SDLK_PAGEUP = 1073741899;
  static const int SDLK_DELETE = 127;
  static const int SDLK_END = 1073741901;
  static const int SDLK_PAGEDOWN = 1073741902;
  static const int SDLK_RIGHT = 1073741903;
  static const int SDLK_LEFT = 1073741904;
  static const int SDLK_DOWN = 1073741905;
  static const int SDLK_UP = 1073741906;
  static const int SDLK_NUMLOCKCLEAR = 1073741907;
  static const int SDLK_KP_DIVIDE = 1073741908;
  static const int SDLK_KP_MULTIPLY = 1073741909;
  static const int SDLK_KP_MINUS = 1073741910;
  static const int SDLK_KP_PLUS = 1073741911;
  static const int SDLK_KP_ENTER = 1073741912;
  static const int SDLK_KP_1 = 1073741913;
  static const int SDLK_KP_2 = 1073741914;
  static const int SDLK_KP_3 = 1073741915;
  static const int SDLK_KP_4 = 1073741916;
  static const int SDLK_KP_5 = 1073741917;
  static const int SDLK_KP_6 = 1073741918;
  static const int SDLK_KP_7 = 1073741919;
  static const int SDLK_KP_8 = 1073741920;
  static const int SDLK_KP_9 = 1073741921;
  static const int SDLK_KP_0 = 1073741922;
  static const int SDLK_KP_PERIOD = 1073741923;
  static const int SDLK_APPLICATION = 1073741925;
  static const int SDLK_POWER = 1073741926;
  static const int SDLK_KP_EQUALS = 1073741927;
  static const int SDLK_F13 = 1073741928;
  static const int SDLK_F14 = 1073741929;
  static const int SDLK_F15 = 1073741930;
  static const int SDLK_F16 = 1073741931;
  static const int SDLK_F17 = 1073741932;
  static const int SDLK_F18 = 1073741933;
  static const int SDLK_F19 = 1073741934;
  static const int SDLK_F20 = 1073741935;
  static const int SDLK_F21 = 1073741936;
  static const int SDLK_F22 = 1073741937;
  static const int SDLK_F23 = 1073741938;
  static const int SDLK_F24 = 1073741939;
  static const int SDLK_EXECUTE = 1073741940;
  static const int SDLK_HELP = 1073741941;
  static const int SDLK_MENU = 1073741942;
  static const int SDLK_SELECT = 1073741943;
  static const int SDLK_STOP = 1073741944;
  static const int SDLK_AGAIN = 1073741945;
  static const int SDLK_UNDO = 1073741946;
  static const int SDLK_CUT = 1073741947;
  static const int SDLK_COPY = 1073741948;
  static const int SDLK_PASTE = 1073741949;
  static const int SDLK_FIND = 1073741950;
  static const int SDLK_MUTE = 1073741951;
  static const int SDLK_VOLUMEUP = 1073741952;
  static const int SDLK_VOLUMEDOWN = 1073741953;
  static const int SDLK_KP_COMMA = 1073741957;
  static const int SDLK_KP_EQUALSAS400 = 1073741958;
  static const int SDLK_ALTERASE = 1073741977;
  static const int SDLK_SYSREQ = 1073741978;
  static const int SDLK_CANCEL = 1073741979;
  static const int SDLK_CLEAR = 1073741980;
  static const int SDLK_PRIOR = 1073741981;
  static const int SDLK_RETURN2 = 1073741982;
  static const int SDLK_SEPARATOR = 1073741983;
  static const int SDLK_OUT = 1073741984;
  static const int SDLK_OPER = 1073741985;
  static const int SDLK_CLEARAGAIN = 1073741986;
  static const int SDLK_CRSEL = 1073741987;
  static const int SDLK_EXSEL = 1073741988;
  static const int SDLK_KP_00 = 1073742000;
  static const int SDLK_KP_000 = 1073742001;
  static const int SDLK_THOUSANDSSEPARATOR = 1073742002;
  static const int SDLK_DECIMALSEPARATOR = 1073742003;
  static const int SDLK_CURRENCYUNIT = 1073742004;
  static const int SDLK_CURRENCYSUBUNIT = 1073742005;
  static const int SDLK_KP_LEFTPAREN = 1073742006;
  static const int SDLK_KP_RIGHTPAREN = 1073742007;
  static const int SDLK_KP_LEFTBRACE = 1073742008;
  static const int SDLK_KP_RIGHTBRACE = 1073742009;
  static const int SDLK_KP_TAB = 1073742010;
  static const int SDLK_KP_BACKSPACE = 1073742011;
  static const int SDLK_KP_A = 1073742012;
  static const int SDLK_KP_B = 1073742013;
  static const int SDLK_KP_C = 1073742014;
  static const int SDLK_KP_D = 1073742015;
  static const int SDLK_KP_E = 1073742016;
  static const int SDLK_KP_F = 1073742017;
  static const int SDLK_KP_XOR = 1073742018;
  static const int SDLK_KP_POWER = 1073742019;
  static const int SDLK_KP_PERCENT = 1073742020;
  static const int SDLK_KP_LESS = 1073742021;
  static const int SDLK_KP_GREATER = 1073742022;
  static const int SDLK_KP_AMPERSAND = 1073742023;
  static const int SDLK_KP_DBLAMPERSAND = 1073742024;
  static const int SDLK_KP_VERTICALBAR = 1073742025;
  static const int SDLK_KP_DBLVERTICALBAR = 1073742026;
  static const int SDLK_KP_COLON = 1073742027;
  static const int SDLK_KP_HASH = 1073742028;
  static const int SDLK_KP_SPACE = 1073742029;
  static const int SDLK_KP_AT = 1073742030;
  static const int SDLK_KP_EXCLAM = 1073742031;
  static const int SDLK_KP_MEMSTORE = 1073742032;
  static const int SDLK_KP_MEMRECALL = 1073742033;
  static const int SDLK_KP_MEMCLEAR = 1073742034;
  static const int SDLK_KP_MEMADD = 1073742035;
  static const int SDLK_KP_MEMSUBTRACT = 1073742036;
  static const int SDLK_KP_MEMMULTIPLY = 1073742037;
  static const int SDLK_KP_MEMDIVIDE = 1073742038;
  static const int SDLK_KP_PLUSMINUS = 1073742039;
  static const int SDLK_KP_CLEAR = 1073742040;
  static const int SDLK_KP_CLEARENTRY = 1073742041;
  static const int SDLK_KP_BINARY = 1073742042;
  static const int SDLK_KP_OCTAL = 1073742043;
  static const int SDLK_KP_DECIMAL = 1073742044;
  static const int SDLK_KP_HEXADECIMAL = 1073742045;
  static const int SDLK_LCTRL = 1073742048;
  static const int SDLK_LSHIFT = 1073742049;
  static const int SDLK_LALT = 1073742050;
  static const int SDLK_LGUI = 1073742051;
  static const int SDLK_RCTRL = 1073742052;
  static const int SDLK_RSHIFT = 1073742053;
  static const int SDLK_RALT = 1073742054;
  static const int SDLK_RGUI = 1073742055;
  static const int SDLK_MODE = 1073742081;
  static const int SDLK_AUDIONEXT = 1073742082;
  static const int SDLK_AUDIOPREV = 1073742083;
  static const int SDLK_AUDIOSTOP = 1073742084;
  static const int SDLK_AUDIOPLAY = 1073742085;
  static const int SDLK_AUDIOMUTE = 1073742086;
  static const int SDLK_MEDIASELECT = 1073742087;
  static const int SDLK_WWW = 1073742088;
  static const int SDLK_MAIL = 1073742089;
  static const int SDLK_CALCULATOR = 1073742090;
  static const int SDLK_COMPUTER = 1073742091;
  static const int SDLK_AC_SEARCH = 1073742092;
  static const int SDLK_AC_HOME = 1073742093;
  static const int SDLK_AC_BACK = 1073742094;
  static const int SDLK_AC_FORWARD = 1073742095;
  static const int SDLK_AC_STOP = 1073742096;
  static const int SDLK_AC_REFRESH = 1073742097;
  static const int SDLK_AC_BOOKMARKS = 1073742098;
  static const int SDLK_BRIGHTNESSDOWN = 1073742099;
  static const int SDLK_BRIGHTNESSUP = 1073742100;
  static const int SDLK_DISPLAYSWITCH = 1073742101;
  static const int SDLK_KBDILLUMTOGGLE = 1073742102;
  static const int SDLK_KBDILLUMDOWN = 1073742103;
  static const int SDLK_KBDILLUMUP = 1073742104;
  static const int SDLK_EJECT = 1073742105;
  static const int SDLK_SLEEP = 1073742106;
  static const int SDLK_APP1 = 1073742107;
  static const int SDLK_APP2 = 1073742108;
  static const int SDLK_AUDIOREWIND = 1073742109;
  static const int SDLK_AUDIOFASTFORWARD = 1073742110;
}

/// \brief Enumeration of valid key mods (possibly OR'd together).
abstract class SDL_Keymod {
  static const int KMOD_NONE = 0;
  static const int KMOD_LSHIFT = 1;
  static const int KMOD_RSHIFT = 2;
  static const int KMOD_LCTRL = 64;
  static const int KMOD_RCTRL = 128;
  static const int KMOD_LALT = 256;
  static const int KMOD_RALT = 512;
  static const int KMOD_LGUI = 1024;
  static const int KMOD_RGUI = 2048;
  static const int KMOD_NUM = 4096;
  static const int KMOD_CAPS = 8192;
  static const int KMOD_MODE = 16384;
  static const int KMOD_RESERVED = 32768;
  static const int KMOD_CTRL = 192;
  static const int KMOD_SHIFT = 3;
  static const int KMOD_ALT = 768;
  static const int KMOD_GUI = 3072;
}

/// \brief The SDL keysym structure, used in key events.
///
/// \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
class SDL_Keysym extends ffi.Struct {
  /// < SDL physical key code - see ::SDL_Scancode for details
  @ffi.Int32()
  external int scancode;

  /// < SDL virtual key code - see ::SDL_Keycode for details
  @SDL_Keycode()
  external int sym;

  /// < current key modifiers
  @Uint16()
  external int mod;

  @Uint32()
  external int unused;
}

/// \brief The SDL virtual key representation.
///
/// Values of this type are used to represent keyboard keys using the current
/// layout of the keyboard.  These values include Unicode values representing
/// the unmodified character that would be generated by pressing the key, or
/// an SDLK_* constant for those keys that do not generate characters.
///
/// A special exception is the number keys at the top of the keyboard which
/// always map to SDLK_0...SDLK_9, regardless of layout.
typedef SDL_Keycode = Sint32;
typedef Sint32 = ffi.Int32;

class SDL_Cursor extends ffi.Opaque {}

/// \brief Cursor types for SDL_CreateSystemCursor().
abstract class SDL_SystemCursor {
  /// < Arrow
  static const int SDL_SYSTEM_CURSOR_ARROW = 0;

  /// < I-beam
  static const int SDL_SYSTEM_CURSOR_IBEAM = 1;

  /// < Wait
  static const int SDL_SYSTEM_CURSOR_WAIT = 2;

  /// < Crosshair
  static const int SDL_SYSTEM_CURSOR_CROSSHAIR = 3;

  /// < Small wait cursor (or Wait if not available)
  static const int SDL_SYSTEM_CURSOR_WAITARROW = 4;

  /// < Double arrow pointing northwest and southeast
  static const int SDL_SYSTEM_CURSOR_SIZENWSE = 5;

  /// < Double arrow pointing northeast and southwest
  static const int SDL_SYSTEM_CURSOR_SIZENESW = 6;

  /// < Double arrow pointing west and east
  static const int SDL_SYSTEM_CURSOR_SIZEWE = 7;

  /// < Double arrow pointing north and south
  static const int SDL_SYSTEM_CURSOR_SIZENS = 8;

  /// < Four pointed arrow pointing north, south, east, and west
  static const int SDL_SYSTEM_CURSOR_SIZEALL = 9;

  /// < Slashed circle or crossbones
  static const int SDL_SYSTEM_CURSOR_NO = 10;

  /// < Hand
  static const int SDL_SYSTEM_CURSOR_HAND = 11;
  static const int SDL_NUM_SYSTEM_CURSORS = 12;
}

/// \brief Scroll direction types for the Scroll event
abstract class SDL_MouseWheelDirection {
  /// < The scroll direction is normal
  static const int SDL_MOUSEWHEEL_NORMAL = 0;

  /// < The scroll direction is flipped / natural
  static const int SDL_MOUSEWHEEL_FLIPPED = 1;
}

/// The joystick structure used to identify an SDL joystick
class SDL_Joystick extends ffi.Opaque {}

class SDL_JoystickGUID extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<Uint8> data;
}

abstract class SDL_JoystickType {
  static const int SDL_JOYSTICK_TYPE_UNKNOWN = 0;
  static const int SDL_JOYSTICK_TYPE_GAMECONTROLLER = 1;
  static const int SDL_JOYSTICK_TYPE_WHEEL = 2;
  static const int SDL_JOYSTICK_TYPE_ARCADE_STICK = 3;
  static const int SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4;
  static const int SDL_JOYSTICK_TYPE_DANCE_PAD = 5;
  static const int SDL_JOYSTICK_TYPE_GUITAR = 6;
  static const int SDL_JOYSTICK_TYPE_DRUM_KIT = 7;
  static const int SDL_JOYSTICK_TYPE_ARCADE_PAD = 8;
  static const int SDL_JOYSTICK_TYPE_THROTTLE = 9;
}

abstract class SDL_JoystickPowerLevel {
  static const int SDL_JOYSTICK_POWER_UNKNOWN = -1;
  static const int SDL_JOYSTICK_POWER_EMPTY = 0;
  static const int SDL_JOYSTICK_POWER_LOW = 1;
  static const int SDL_JOYSTICK_POWER_MEDIUM = 2;
  static const int SDL_JOYSTICK_POWER_FULL = 3;
  static const int SDL_JOYSTICK_POWER_WIRED = 4;
  static const int SDL_JOYSTICK_POWER_MAX = 5;
}

/// This is a unique ID for a joystick for the time it is connected to the system,
/// and is never reused for the lifetime of the application. If the joystick is
/// disconnected and reconnected, it will get a new ID.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
typedef SDL_JoystickID = Sint32;
typedef SDL_Joystick1 = SDL_Joystick;
typedef Sint16 = ffi.Int16;

/// \brief SDL_sensor.h
///
/// In order to use these functions, SDL_Init() must have been called
/// with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system
/// for sensors, and load appropriate drivers.
class SDL_Sensor extends ffi.Opaque {}

abstract class SDL_SensorType {
  /// < Returned for an invalid sensor
  static const int SDL_SENSOR_INVALID = -1;

  /// < Unknown sensor type
  static const int SDL_SENSOR_UNKNOWN = 0;

  /// < Accelerometer
  static const int SDL_SENSOR_ACCEL = 1;

  /// < Gyroscope
  static const int SDL_SENSOR_GYRO = 2;
}

/// This is a unique ID for a sensor for the time it is connected to the system,
/// and is never reused for the lifetime of the application.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
typedef SDL_SensorID = Sint32;
typedef SDL_Sensor1 = SDL_Sensor;

/// The gamecontroller structure used to identify an SDL game controller
class SDL_GameController extends ffi.Opaque {}

abstract class SDL_GameControllerType {
  static const int SDL_CONTROLLER_TYPE_UNKNOWN = 0;
  static const int SDL_CONTROLLER_TYPE_XBOX360 = 1;
  static const int SDL_CONTROLLER_TYPE_XBOXONE = 2;
  static const int SDL_CONTROLLER_TYPE_PS3 = 3;
  static const int SDL_CONTROLLER_TYPE_PS4 = 4;
  static const int SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO = 5;
  static const int SDL_CONTROLLER_TYPE_VIRTUAL = 6;
  static const int SDL_CONTROLLER_TYPE_PS5 = 7;
}

abstract class SDL_GameControllerBindType {
  static const int SDL_CONTROLLER_BINDTYPE_NONE = 0;
  static const int SDL_CONTROLLER_BINDTYPE_BUTTON = 1;
  static const int SDL_CONTROLLER_BINDTYPE_AXIS = 2;
  static const int SDL_CONTROLLER_BINDTYPE_HAT = 3;
}

/// Get the SDL joystick layer binding for this controller button/axis mapping
class SDL_GameControllerButtonBind extends ffi.Struct {
  @ffi.Int32()
  external int bindType;

  external UnnamedUnion2 value;
}

class UnnamedUnion2 extends ffi.Union {
  @ffi.Int32()
  external int button;

  @ffi.Int32()
  external int axis;

  external UnnamedStruct5 hat;
}

class UnnamedStruct5 extends ffi.Struct {
  @ffi.Int32()
  external int hat;

  @ffi.Int32()
  external int hat_mask;
}

typedef SDL_GameController1 = SDL_GameController;

/// The list of axes available from a controller
///
/// Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,
/// and are centered within ~8000 of zero, though advanced UI will allow users to set
/// or autodetect the dead zone, which varies between controllers.
///
/// Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX.
abstract class SDL_GameControllerAxis {
  static const int SDL_CONTROLLER_AXIS_INVALID = -1;
  static const int SDL_CONTROLLER_AXIS_LEFTX = 0;
  static const int SDL_CONTROLLER_AXIS_LEFTY = 1;
  static const int SDL_CONTROLLER_AXIS_RIGHTX = 2;
  static const int SDL_CONTROLLER_AXIS_RIGHTY = 3;
  static const int SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4;
  static const int SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5;
  static const int SDL_CONTROLLER_AXIS_MAX = 6;
}

/// The list of buttons available from a controller
abstract class SDL_GameControllerButton {
  static const int SDL_CONTROLLER_BUTTON_INVALID = -1;
  static const int SDL_CONTROLLER_BUTTON_A = 0;
  static const int SDL_CONTROLLER_BUTTON_B = 1;
  static const int SDL_CONTROLLER_BUTTON_X = 2;
  static const int SDL_CONTROLLER_BUTTON_Y = 3;
  static const int SDL_CONTROLLER_BUTTON_BACK = 4;
  static const int SDL_CONTROLLER_BUTTON_GUIDE = 5;
  static const int SDL_CONTROLLER_BUTTON_START = 6;
  static const int SDL_CONTROLLER_BUTTON_LEFTSTICK = 7;
  static const int SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8;
  static const int SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9;
  static const int SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10;
  static const int SDL_CONTROLLER_BUTTON_DPAD_UP = 11;
  static const int SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12;
  static const int SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13;
  static const int SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14;
  static const int SDL_CONTROLLER_BUTTON_MISC1 = 15;
  static const int SDL_CONTROLLER_BUTTON_PADDLE1 = 16;
  static const int SDL_CONTROLLER_BUTTON_PADDLE2 = 17;
  static const int SDL_CONTROLLER_BUTTON_PADDLE3 = 18;
  static const int SDL_CONTROLLER_BUTTON_PADDLE4 = 19;
  static const int SDL_CONTROLLER_BUTTON_TOUCHPAD = 20;
  static const int SDL_CONTROLLER_BUTTON_MAX = 21;
}

abstract class SDL_TouchDeviceType {
  static const int SDL_TOUCH_DEVICE_INVALID = -1;
  static const int SDL_TOUCH_DEVICE_DIRECT = 0;
  static const int SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1;
  static const int SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2;
}

class SDL_Finger extends ffi.Struct {
  @SDL_FingerID()
  external int id;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double pressure;
}

typedef SDL_FingerID = Sint64;
typedef SDL_TouchID = Sint64;
typedef SDL_GestureID = Sint64;

/// \brief The types of events that can be delivered.
abstract class SDL_EventType {
  /// < Unused (do not remove)
  static const int SDL_FIRSTEVENT = 0;

  /// < User-requested quit
  static const int SDL_QUIT = 256;

  /// < The application is being terminated by the OS
  /// Called on iOS in applicationWillTerminate()
  /// Called on Android in onDestroy()
  static const int SDL_APP_TERMINATING = 257;

  /// < The application is low on memory, free memory if possible.
  /// Called on iOS in applicationDidReceiveMemoryWarning()
  /// Called on Android in onLowMemory()
  static const int SDL_APP_LOWMEMORY = 258;

  /// < The application is about to enter the background
  /// Called on iOS in applicationWillResignActive()
  /// Called on Android in onPause()
  static const int SDL_APP_WILLENTERBACKGROUND = 259;

  /// < The application did enter the background and may not get CPU for some time
  /// Called on iOS in applicationDidEnterBackground()
  /// Called on Android in onPause()
  static const int SDL_APP_DIDENTERBACKGROUND = 260;

  /// < The application is about to enter the foreground
  /// Called on iOS in applicationWillEnterForeground()
  /// Called on Android in onResume()
  static const int SDL_APP_WILLENTERFOREGROUND = 261;

  /// < The application is now interactive
  /// Called on iOS in applicationDidBecomeActive()
  /// Called on Android in onResume()
  static const int SDL_APP_DIDENTERFOREGROUND = 262;

  /// < The user's locale preferences have changed.
  static const int SDL_LOCALECHANGED = 263;

  /// < Display state change
  static const int SDL_DISPLAYEVENT = 336;

  /// < Window state change
  static const int SDL_WINDOWEVENT = 512;

  /// < System specific event
  static const int SDL_SYSWMEVENT = 513;

  /// < Key pressed
  static const int SDL_KEYDOWN = 768;

  /// < Key released
  static const int SDL_KEYUP = 769;

  /// < Keyboard text editing (composition)
  static const int SDL_TEXTEDITING = 770;

  /// < Keyboard text input
  static const int SDL_TEXTINPUT = 771;

  /// < Keymap changed due to a system event such as an
  /// input language or keyboard layout change.
  static const int SDL_KEYMAPCHANGED = 772;

  /// < Mouse moved
  static const int SDL_MOUSEMOTION = 1024;

  /// < Mouse button pressed
  static const int SDL_MOUSEBUTTONDOWN = 1025;

  /// < Mouse button released
  static const int SDL_MOUSEBUTTONUP = 1026;

  /// < Mouse wheel motion
  static const int SDL_MOUSEWHEEL = 1027;

  /// < Joystick axis motion
  static const int SDL_JOYAXISMOTION = 1536;

  /// < Joystick trackball motion
  static const int SDL_JOYBALLMOTION = 1537;

  /// < Joystick hat position change
  static const int SDL_JOYHATMOTION = 1538;

  /// < Joystick button pressed
  static const int SDL_JOYBUTTONDOWN = 1539;

  /// < Joystick button released
  static const int SDL_JOYBUTTONUP = 1540;

  /// < A new joystick has been inserted into the system
  static const int SDL_JOYDEVICEADDED = 1541;

  /// < An opened joystick has been removed
  static const int SDL_JOYDEVICEREMOVED = 1542;

  /// < Game controller axis motion
  static const int SDL_CONTROLLERAXISMOTION = 1616;

  /// < Game controller button pressed
  static const int SDL_CONTROLLERBUTTONDOWN = 1617;

  /// < Game controller button released
  static const int SDL_CONTROLLERBUTTONUP = 1618;

  /// < A new Game controller has been inserted into the system
  static const int SDL_CONTROLLERDEVICEADDED = 1619;

  /// < An opened Game controller has been removed
  static const int SDL_CONTROLLERDEVICEREMOVED = 1620;

  /// < The controller mapping was updated
  static const int SDL_CONTROLLERDEVICEREMAPPED = 1621;

  /// < Game controller touchpad was touched
  static const int SDL_CONTROLLERTOUCHPADDOWN = 1622;

  /// < Game controller touchpad finger was moved
  static const int SDL_CONTROLLERTOUCHPADMOTION = 1623;

  /// < Game controller touchpad finger was lifted
  static const int SDL_CONTROLLERTOUCHPADUP = 1624;

  /// < Game controller sensor was updated
  static const int SDL_CONTROLLERSENSORUPDATE = 1625;
  static const int SDL_FINGERDOWN = 1792;
  static const int SDL_FINGERUP = 1793;
  static const int SDL_FINGERMOTION = 1794;
  static const int SDL_DOLLARGESTURE = 2048;
  static const int SDL_DOLLARRECORD = 2049;
  static const int SDL_MULTIGESTURE = 2050;

  /// < The clipboard changed
  static const int SDL_CLIPBOARDUPDATE = 2304;

  /// < The system requests a file open
  static const int SDL_DROPFILE = 4096;

  /// < text/plain drag-and-drop event
  static const int SDL_DROPTEXT = 4097;

  /// < A new set of drops is beginning (NULL filename)
  static const int SDL_DROPBEGIN = 4098;

  /// < Current set of drops is now complete (NULL filename)
  static const int SDL_DROPCOMPLETE = 4099;

  /// < A new audio device is available
  static const int SDL_AUDIODEVICEADDED = 4352;

  /// < An audio device has been removed.
  static const int SDL_AUDIODEVICEREMOVED = 4353;

  /// < A sensor was updated
  static const int SDL_SENSORUPDATE = 4608;

  /// < The render targets have been reset and their contents need to be updated
  static const int SDL_RENDER_TARGETS_RESET = 8192;

  /// < The device has been reset and all textures need to be recreated
  static const int SDL_RENDER_DEVICE_RESET = 8193;

  /// Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
  /// and should be allocated with SDL_RegisterEvents()
  static const int SDL_USEREVENT = 32768;

  /// This last event is only for bounding internal arrays
  static const int SDL_LASTEVENT = 65535;
}

/// \brief Fields shared by every event
class SDL_CommonEvent extends ffi.Struct {
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief Display state change event data (event.display.*)
class SDL_DisplayEvent extends ffi.Struct {
  /// < ::SDL_DISPLAYEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated display index
  @Uint32()
  external int display;

  /// < ::SDL_DisplayEventID
  @Uint8()
  external int event;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < event dependent data
  @Sint32()
  external int data1;
}

/// \brief Window state change event data (event.window.*)
class SDL_WindowEvent extends ffi.Struct {
  /// < ::SDL_WINDOWEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated window
  @Uint32()
  external int windowID;

  /// < ::SDL_WindowEventID
  @Uint8()
  external int event;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < event dependent data
  @Sint32()
  external int data1;

  /// < event dependent data
  @Sint32()
  external int data2;
}

/// \brief Keyboard button event structure (event.key.*)
class SDL_KeyboardEvent extends ffi.Struct {
  /// < ::SDL_KEYDOWN or ::SDL_KEYUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  /// < Non-zero if this is a key repeat
  @Uint8()
  external int repeat;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The key that was pressed or released
  external SDL_Keysym keysym;
}

/// \brief Keyboard text editing event structure (event.edit.*)
class SDL_TextEditingEvent extends ffi.Struct {
  /// < ::SDL_TEXTEDITING
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Int8> text;

  /// < The start cursor of selected editing text
  @Sint32()
  external int start;

  /// < The length of selected editing text
  @Sint32()
  external int length;
}

/// \brief Keyboard text input event structure (event.text.*)
class SDL_TextInputEvent extends ffi.Struct {
  /// < ::SDL_TEXTINPUT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @Uint32()
  external int windowID;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Int8> text;
}

/// \brief Mouse motion event structure (event.motion.*)
class SDL_MouseMotionEvent extends ffi.Struct {
  /// < ::SDL_MOUSEMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The current button state
  @Uint32()
  external int state;

  /// < X coordinate, relative to window
  @Sint32()
  external int x;

  /// < Y coordinate, relative to window
  @Sint32()
  external int y;

  /// < The relative motion in the X direction
  @Sint32()
  external int xrel;

  /// < The relative motion in the Y direction
  @Sint32()
  external int yrel;
}

/// \brief Mouse button event structure (event.button.*)
class SDL_MouseButtonEvent extends ffi.Struct {
  /// < ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The mouse button index
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  /// < 1 for single-click, 2 for double-click, etc.
  @Uint8()
  external int clicks;

  @Uint8()
  external int padding1;

  /// < X coordinate, relative to window
  @Sint32()
  external int x;

  /// < Y coordinate, relative to window
  @Sint32()
  external int y;
}

/// \brief Mouse wheel event structure (event.wheel.*)
class SDL_MouseWheelEvent extends ffi.Struct {
  /// < ::SDL_MOUSEWHEEL
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @Uint32()
  external int which;

  /// < The amount scrolled horizontally, positive to the right and negative to the left
  @Sint32()
  external int x;

  /// < The amount scrolled vertically, positive away from the user and negative toward the user
  @Sint32()
  external int y;

  /// < Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back
  @Uint32()
  external int direction;
}

/// \brief Joystick axis motion event structure (event.jaxis.*)
class SDL_JoyAxisEvent extends ffi.Struct {
  /// < ::SDL_JOYAXISMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick axis index
  @Uint8()
  external int axis;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @Sint16()
  external int value;

  @Uint16()
  external int padding4;
}

/// \brief Joystick trackball motion event structure (event.jball.*)
class SDL_JoyBallEvent extends ffi.Struct {
  /// < ::SDL_JOYBALLMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick trackball index
  @Uint8()
  external int ball;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The relative motion in the X direction
  @Sint16()
  external int xrel;

  /// < The relative motion in the Y direction
  @Sint16()
  external int yrel;
}

/// \brief Joystick hat position change event structure (event.jhat.*)
class SDL_JoyHatEvent extends ffi.Struct {
  /// < ::SDL_JOYHATMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick hat index
  @Uint8()
  external int hat;

  /// < The hat position value.
  /// \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
  /// \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
  /// \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
  ///
  /// Note that zero means the POV is centered.
  @Uint8()
  external int value;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Joystick button event structure (event.jbutton.*)
class SDL_JoyButtonEvent extends ffi.Struct {
  /// < ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The joystick button index
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Joystick device event structure (event.jdevice.*)
class SDL_JoyDeviceEvent extends ffi.Struct {
  /// < ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED event
  @Sint32()
  external int which;
}

/// \brief Game controller axis motion event structure (event.caxis.*)
class SDL_ControllerAxisEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERAXISMOTION
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The controller axis (SDL_GameControllerAxis)
  @Uint8()
  external int axis;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @Sint16()
  external int value;

  @Uint16()
  external int padding4;
}

/// \brief Game controller button event structure (event.cbutton.*)
class SDL_ControllerButtonEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The controller button (SDL_GameControllerButton)
  @Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @Uint8()
  external int state;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;
}

/// \brief Controller device event structure (event.cdevice.*)
class SDL_ControllerDeviceEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event
  @Sint32()
  external int which;
}

/// \brief Game controller touchpad event structure (event.ctouchpad.*)
class SDL_ControllerTouchpadEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERTOUCHPADDOWN or ::SDL_CONTROLLERTOUCHPADMOTION or ::SDL_CONTROLLERTOUCHPADUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The index of the touchpad
  @Sint32()
  external int touchpad;

  /// < The index of the finger on the touchpad
  @Sint32()
  external int finger;

  /// < Normalized in the range 0...1 with 0 being on the left
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1 with 0 being at the top
  @ffi.Float()
  external double y;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;
}

/// \brief Game controller sensor event structure (event.csensor.*)
class SDL_ControllerSensorEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERSENSORUPDATE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The joystick instance id
  @SDL_JoystickID()
  external int which;

  /// < The type of the sensor, one of the values of ::SDL_SensorType
  @Sint32()
  external int sensor;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Float> data;
}

/// \brief Audio device event structure (event.adevice.*)
class SDL_AudioDeviceEvent extends ffi.Struct {
  /// < ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event
  @Uint32()
  external int which;

  /// < zero if an output device, non-zero if a capture device.
  @Uint8()
  external int iscapture;

  @Uint8()
  external int padding1;

  @Uint8()
  external int padding2;

  @Uint8()
  external int padding3;
}

/// \brief Touch finger event structure (event.tfinger.*)
class SDL_TouchFingerEvent extends ffi.Struct {
  /// < ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @SDL_FingerID()
  external int fingerId;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double y;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dx;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dy;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;

  /// < The window underneath the finger, if any
  @Uint32()
  external int windowID;
}

/// \brief Multiple Finger Gesture Event (event.mgesture.*)
class SDL_MultiGestureEvent extends ffi.Struct {
  /// < ::SDL_MULTIGESTURE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @ffi.Float()
  external double dTheta;

  @ffi.Float()
  external double dDist;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @Uint16()
  external int numFingers;

  @Uint16()
  external int padding;
}

/// \brief Dollar Gesture Event (event.dgesture.*)
class SDL_DollarGestureEvent extends ffi.Struct {
  /// < ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The touch device id
  @SDL_TouchID()
  external int touchId;

  @SDL_GestureID()
  external int gestureId;

  @Uint32()
  external int numFingers;

  @ffi.Float()
  external double error;

  /// < Normalized center of gesture
  @ffi.Float()
  external double x;

  /// < Normalized center of gesture
  @ffi.Float()
  external double y;
}

/// \brief An event used to request a file open by the system (event.drop.*)
/// This event is enabled by default, you can disable it with SDL_EventState().
/// \note If this event is enabled, you must free the filename in the event.
class SDL_DropEvent extends ffi.Struct {
  /// < ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The file name, which should be freed with SDL_free(), is NULL on begin/complete
  external ffi.Pointer<ffi.Int8> file;

  /// < The window that was dropped on, if any
  @Uint32()
  external int windowID;
}

/// \brief Sensor event structure (event.sensor.*)
class SDL_SensorEvent extends ffi.Struct {
  /// < ::SDL_SENSORUPDATE
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The instance ID of the sensor
  @Sint32()
  external int which;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Float> data;
}

/// \brief The "quit requested" event
class SDL_QuitEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief OS Specific event
class SDL_OSEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;
}

/// \brief A user-defined event type (event.user.*)
class SDL_UserEvent extends ffi.Struct {
  /// < ::SDL_USEREVENT through ::SDL_LASTEVENT-1
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < The associated window if any
  @Uint32()
  external int windowID;

  /// < User defined event code
  @Sint32()
  external int code;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data1;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data2;
}

class SDL_SysWMmsg extends ffi.Opaque {}

/// \brief A video driver dependent system event (event.syswm.*)
/// This event is disabled by default, you can enable it with SDL_EventState()
///
/// \note If you want to use this event, you should include SDL_syswm.h.
class SDL_SysWMEvent extends ffi.Struct {
  /// < ::SDL_SYSWMEVENT
  @Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @Uint32()
  external int timestamp;

  /// < driver dependent data, defined in SDL_syswm.h
  external ffi.Pointer<SDL_SysWMmsg> msg;
}

/// \brief General event structure
class SDL_Event extends ffi.Union {
  /// < Event type, shared with all events
  @Uint32()
  external int type;

  /// < Common event data
  external SDL_CommonEvent common;

  /// < Display event data
  external SDL_DisplayEvent display;

  /// < Window event data
  external SDL_WindowEvent window;

  /// < Keyboard event data
  external SDL_KeyboardEvent key;

  /// < Text editing event data
  external SDL_TextEditingEvent edit;

  /// < Text input event data
  external SDL_TextInputEvent text;

  /// < Mouse motion event data
  external SDL_MouseMotionEvent motion;

  /// < Mouse button event data
  external SDL_MouseButtonEvent button;

  /// < Mouse wheel event data
  external SDL_MouseWheelEvent wheel;

  /// < Joystick axis event data
  external SDL_JoyAxisEvent jaxis;

  /// < Joystick ball event data
  external SDL_JoyBallEvent jball;

  /// < Joystick hat event data
  external SDL_JoyHatEvent jhat;

  /// < Joystick button event data
  external SDL_JoyButtonEvent jbutton;

  /// < Joystick device change event data
  external SDL_JoyDeviceEvent jdevice;

  /// < Game Controller axis event data
  external SDL_ControllerAxisEvent caxis;

  /// < Game Controller button event data
  external SDL_ControllerButtonEvent cbutton;

  /// < Game Controller device event data
  external SDL_ControllerDeviceEvent cdevice;

  /// < Game Controller touchpad event data
  external SDL_ControllerTouchpadEvent ctouchpad;

  /// < Game Controller sensor event data
  external SDL_ControllerSensorEvent csensor;

  /// < Audio device event data
  external SDL_AudioDeviceEvent adevice;

  /// < Sensor event data
  external SDL_SensorEvent sensor;

  /// < Quit request event data
  external SDL_QuitEvent quit;

  /// < Custom event data
  external SDL_UserEvent user;

  /// < System dependent window event data
  external SDL_SysWMEvent syswm;

  /// < Touch finger event data
  external SDL_TouchFingerEvent tfinger;

  /// < Gesture event data
  external SDL_MultiGestureEvent mgesture;

  /// < Gesture event data
  external SDL_DollarGestureEvent dgesture;

  /// < Drag and drop event data
  external SDL_DropEvent drop;

  @ffi.Array.multi([56])
  external ffi.Array<Uint8> padding;
}

abstract class SDL_eventaction {
  static const int SDL_ADDEVENT = 0;
  static const int SDL_PEEKEVENT = 1;
  static const int SDL_GETEVENT = 2;
}

typedef SDL_EventFilter = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<SDL_Event>)>>;

/// \typedef SDL_Haptic
///
/// \brief The haptic structure used to identify an SDL haptic.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticOpenFromJoystick
/// \sa SDL_HapticClose
class SDL_Haptic extends ffi.Opaque {}

/// \brief Structure that represents a haptic direction.
///
/// This is the direction where the force comes from,
/// instead of the direction in which the force is exerted.
///
/// Directions can be specified by:
/// - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
/// - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
/// - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
///
/// Cardinal directions of the haptic device are relative to the positioning
/// of the device.  North is considered to be away from the user.
///
/// The following diagram represents the cardinal directions:
/// \verbatim
/// .--.
/// |__| .-------.
/// |=.| |.-----.|
/// |--| ||     ||
/// |  | |'-----'|
/// |__|~')_____('
/// [ COMPUTER ]
///
///
/// North (0,-1)
/// ^
/// |
/// |
/// (-1,0)  West <----[ HAPTIC ]----> East (1,0)
/// |
/// |
/// v
/// South (0,1)
///
///
/// [ USER ]
/// \|||/
/// (o o)
/// ---ooO-(_)-Ooo---
/// \endverbatim
///
/// If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
/// degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
/// the first \c dir parameter.  The cardinal directions would be:
/// - North: 0 (0 degrees)
/// - East: 9000 (90 degrees)
/// - South: 18000 (180 degrees)
/// - West: 27000 (270 degrees)
///
/// If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
/// (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
/// the first three \c dir parameters.  The cardinal directions would be:
/// - North:  0,-1, 0
/// - East:   1, 0, 0
/// - South:  0, 1, 0
/// - West:  -1, 0, 0
///
/// The Z axis represents the height of the effect if supported, otherwise
/// it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
/// can use any multiple you want, only the direction matters.
///
/// If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
/// The first two \c dir parameters are used.  The \c dir parameters are as
/// follows (all values are in hundredths of degrees):
/// - Degrees from (1, 0) rotated towards (0, 1).
/// - Degrees towards (0, 0, 1) (device needs at least 3 axes).
///
///
/// Example of force coming from the south with all encodings (force coming
/// from the south means the user will have to pull the stick to counteract):
/// \code
/// SDL_HapticDirection direction;
///
/// // Cartesian directions
/// direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
/// direction.dir[0] = 0; // X position
/// direction.dir[1] = 1; // Y position
/// // Assuming the device has 2 axes, we don't need to specify third parameter.
///
/// // Polar directions
/// direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
/// direction.dir[0] = 18000; // Polar only uses first parameter
///
/// // Spherical coordinates
/// direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
/// direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
/// \endcode
///
/// \sa SDL_HAPTIC_POLAR
/// \sa SDL_HAPTIC_CARTESIAN
/// \sa SDL_HAPTIC_SPHERICAL
/// \sa SDL_HAPTIC_STEERING_AXIS
/// \sa SDL_HapticEffect
/// \sa SDL_HapticNumAxes
class SDL_HapticDirection extends ffi.Struct {
  /// < The type of encoding.
  @Uint8()
  external int type;

  @ffi.Array.multi([3])
  external ffi.Array<Sint32> dir;
}

/// \brief A structure containing a template for a Constant effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.
///
/// A constant effect applies a constant force in the specified direction
/// to the joystick.
///
/// \sa SDL_HAPTIC_CONSTANT
/// \sa SDL_HapticEffect
class SDL_HapticConstant extends ffi.Struct {
  /// < ::SDL_HAPTIC_CONSTANT
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Strength of the constant effect.
  @Sint16()
  external int level;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief A structure containing a template for a Periodic effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SINE
/// - ::SDL_HAPTIC_LEFTRIGHT
/// - ::SDL_HAPTIC_TRIANGLE
/// - ::SDL_HAPTIC_SAWTOOTHUP
/// - ::SDL_HAPTIC_SAWTOOTHDOWN
///
/// A periodic effect consists in a wave-shaped effect that repeats itself
/// over time.  The type determines the shape of the wave and the parameters
/// determine the dimensions of the wave.
///
/// Phase is given by hundredth of a degree meaning that giving the phase a value
/// of 9000 will displace it 25% of its period.  Here are sample values:
/// -     0: No phase displacement.
/// -  9000: Displaced 25% of its period.
/// - 18000: Displaced 50% of its period.
/// - 27000: Displaced 75% of its period.
/// - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
///
/// Examples:
/// \verbatim
/// SDL_HAPTIC_SINE
/// __      __      __      __
/// /  \    /  \    /  \    /
/// /    \__/    \__/    \__/
///
/// SDL_HAPTIC_SQUARE
/// __    __    __    __    __
/// |  |  |  |  |  |  |  |  |  |
/// |  |__|  |__|  |__|  |__|  |
///
/// SDL_HAPTIC_TRIANGLE
/// /\    /\    /\    /\    /\
/// /  \  /  \  /  \  /  \  /
/// /    \/    \/    \/    \/
///
/// SDL_HAPTIC_SAWTOOTHUP
/// /|  /|  /|  /|  /|  /|  /|
/// / | / | / | / | / | / | / |
/// /  |/  |/  |/  |/  |/  |/  |
///
/// SDL_HAPTIC_SAWTOOTHDOWN
/// \  |\  |\  |\  |\  |\  |\  |
/// \ | \ | \ | \ | \ | \ | \ |
/// \|  \|  \|  \|  \|  \|  \|
/// \endverbatim
///
/// \sa SDL_HAPTIC_SINE
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HAPTIC_TRIANGLE
/// \sa SDL_HAPTIC_SAWTOOTHUP
/// \sa SDL_HAPTIC_SAWTOOTHDOWN
/// \sa SDL_HapticEffect
class SDL_HapticPeriodic extends ffi.Struct {
  /// < ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,
  /// ::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or
  /// ::SDL_HAPTIC_SAWTOOTHDOWN
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Period of the wave.
  @Uint16()
  external int period;

  /// < Peak value; if negative, equivalent to 180 degrees extra phase shift.
  @Sint16()
  external int magnitude;

  /// < Mean value of the wave.
  @Sint16()
  external int offset;

  /// < Positive phase shift given by hundredth of a degree.
  @Uint16()
  external int phase;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief A structure containing a template for a Condition effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SPRING: Effect based on axes position.
/// - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
/// - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
/// - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
///
/// Direction is handled by condition internals instead of a direction member.
/// The condition effect specific members have three parameters.  The first
/// refers to the X axis, the second refers to the Y axis and the third
/// refers to the Z axis.  The right terms refer to the positive side of the
/// axis and the left terms refer to the negative side of the axis.  Please
/// refer to the ::SDL_HapticDirection diagram for which side is positive and
/// which is negative.
///
/// \sa SDL_HapticDirection
/// \sa SDL_HAPTIC_SPRING
/// \sa SDL_HAPTIC_DAMPER
/// \sa SDL_HAPTIC_INERTIA
/// \sa SDL_HAPTIC_FRICTION
/// \sa SDL_HapticEffect
class SDL_HapticCondition extends ffi.Struct {
  /// < ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,
  /// ::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION
  @Uint16()
  external int type;

  /// < Direction of the effect - Not used ATM.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  @ffi.Array.multi([3])
  external ffi.Array<Uint16> right_sat;

  @ffi.Array.multi([3])
  external ffi.Array<Uint16> left_sat;

  @ffi.Array.multi([3])
  external ffi.Array<Sint16> right_coeff;

  @ffi.Array.multi([3])
  external ffi.Array<Sint16> left_coeff;

  @ffi.Array.multi([3])
  external ffi.Array<Uint16> deadband;

  @ffi.Array.multi([3])
  external ffi.Array<Sint16> center;
}

/// \brief A structure containing a template for a Ramp effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
///
/// The ramp effect starts at start strength and ends at end strength.
/// It augments in linear fashion.  If you use attack and fade with a ramp
/// the effects get added to the ramp effect making the effect become
/// quadratic instead of linear.
///
/// \sa SDL_HAPTIC_RAMP
/// \sa SDL_HapticEffect
class SDL_HapticRamp extends ffi.Struct {
  /// < ::SDL_HAPTIC_RAMP
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Beginning strength level.
  @Sint16()
  external int start;

  /// < Ending strength level.
  @Sint16()
  external int end;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief A structure containing a template for a Left/Right effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
///
/// The Left/Right effect is used to explicitly control the large and small
/// motors, commonly found in modern game controllers. The small (right) motor
/// is high frequency, and the large (left) motor is low frequency.
///
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HapticEffect
class SDL_HapticLeftRight extends ffi.Struct {
  /// < ::SDL_HAPTIC_LEFTRIGHT
  @Uint16()
  external int type;

  /// < Duration of the effect in milliseconds.
  @Uint32()
  external int length;

  /// < Control of the large controller motor.
  @Uint16()
  external int large_magnitude;

  /// < Control of the small controller motor.
  @Uint16()
  external int small_magnitude;
}

/// \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.
///
/// A custom force feedback effect is much like a periodic effect, where the
/// application can define its exact shape.  You will have to allocate the
/// data yourself.  Data should consist of channels * samples Uint16 samples.
///
/// If channels is one, the effect is rotated using the defined direction.
/// Otherwise it uses the samples in data for the different axes.
///
/// \sa SDL_HAPTIC_CUSTOM
/// \sa SDL_HapticEffect
class SDL_HapticCustom extends ffi.Struct {
  /// < ::SDL_HAPTIC_CUSTOM
  @Uint16()
  external int type;

  /// < Direction of the effect.
  external SDL_HapticDirection direction;

  /// < Duration of the effect.
  @Uint32()
  external int length;

  /// < Delay before starting the effect.
  @Uint16()
  external int delay;

  /// < Button that triggers the effect.
  @Uint16()
  external int button;

  /// < How soon it can be triggered again after button.
  @Uint16()
  external int interval;

  /// < Axes to use, minimum of one.
  @Uint8()
  external int channels;

  /// < Sample periods.
  @Uint16()
  external int period;

  /// < Amount of samples.
  @Uint16()
  external int samples;

  /// < Should contain channels*samples items.
  external ffi.Pointer<Uint16> data;

  /// < Duration of the attack.
  @Uint16()
  external int attack_length;

  /// < Level at the start of the attack.
  @Uint16()
  external int attack_level;

  /// < Duration of the fade.
  @Uint16()
  external int fade_length;

  /// < Level at the end of the fade.
  @Uint16()
  external int fade_level;
}

/// \brief The generic template for any haptic effect.
///
/// All values max at 32767 (0x7FFF).  Signed values also can be negative.
/// Time values unless specified otherwise are in milliseconds.
///
/// You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767
/// value.  Neither delay, interval, attack_length nor fade_length support
/// ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
///
/// Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of
/// ::SDL_HAPTIC_INFINITY.
///
/// Button triggers may not be supported on all devices, it is advised to not
/// use them if possible.  Buttons start at index 1 instead of index 0 like
/// the joystick.
///
/// If both attack_length and fade_level are 0, the envelope is not used,
/// otherwise both values are used.
///
/// Common parts:
/// \code
/// // Replay - All effects have this
/// Uint32 length;        // Duration of effect (ms).
/// Uint16 delay;         // Delay before starting effect.
///
/// // Trigger - All effects have this
/// Uint16 button;        // Button that triggers effect.
/// Uint16 interval;      // How soon before effect can be triggered again.
///
/// // Envelope - All effects except condition effects have this
/// Uint16 attack_length; // Duration of the attack (ms).
/// Uint16 attack_level;  // Level at the start of the attack.
/// Uint16 fade_length;   // Duration of the fade out (ms).
/// Uint16 fade_level;    // Level at the end of the fade.
/// \endcode
///
///
/// Here we have an example of a constant effect evolution in time:
/// \verbatim
/// Strength
/// ^
/// |
/// |    effect level -->  _________________
/// |                     /                 \
/// |                    /                   \
/// |                   /                     \
/// |                  /                       \
/// | attack_level --> |                        \
/// |                  |                        |  <---  fade_level
/// |
/// +--------------------------------------------------> Time
/// [--]                 [---]
/// attack_length        fade_length
///
/// [------------------][-----------------------]
/// delay               length
/// \endverbatim
///
/// Note either the attack_level or the fade_level may be above the actual
/// effect level.
///
/// \sa SDL_HapticConstant
/// \sa SDL_HapticPeriodic
/// \sa SDL_HapticCondition
/// \sa SDL_HapticRamp
/// \sa SDL_HapticLeftRight
/// \sa SDL_HapticCustom
class SDL_HapticEffect extends ffi.Union {
  /// < Effect type.
  @Uint16()
  external int type;

  /// < Constant effect.
  external SDL_HapticConstant constant;

  /// < Periodic effect.
  external SDL_HapticPeriodic periodic;

  /// < Condition effect.
  external SDL_HapticCondition condition;

  /// < Ramp effect.
  external SDL_HapticRamp ramp;

  /// < Left/Right effect.
  external SDL_HapticLeftRight leftright;

  /// < Custom effect.
  external SDL_HapticCustom custom;
}

typedef SDL_Haptic1 = SDL_Haptic;

/// \brief  An enumeration of hint priorities
abstract class SDL_HintPriority {
  static const int SDL_HINT_DEFAULT = 0;
  static const int SDL_HINT_NORMAL = 1;
  static const int SDL_HINT_OVERRIDE = 2;
}

/// \brief type definition of the hint callback function.
typedef SDL_HintCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int8>,
            ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>>;

/// \brief The predefined log categories
///
/// By default the application category is enabled at the INFO level,
/// the assert category is enabled at the WARN level, test is enabled
/// at the VERBOSE level and all other categories are enabled at the
/// CRITICAL level.
abstract class SDL_LogCategory {
  static const int SDL_LOG_CATEGORY_APPLICATION = 0;
  static const int SDL_LOG_CATEGORY_ERROR = 1;
  static const int SDL_LOG_CATEGORY_ASSERT = 2;
  static const int SDL_LOG_CATEGORY_SYSTEM = 3;
  static const int SDL_LOG_CATEGORY_AUDIO = 4;
  static const int SDL_LOG_CATEGORY_VIDEO = 5;
  static const int SDL_LOG_CATEGORY_RENDER = 6;
  static const int SDL_LOG_CATEGORY_INPUT = 7;
  static const int SDL_LOG_CATEGORY_TEST = 8;
  static const int SDL_LOG_CATEGORY_RESERVED1 = 9;
  static const int SDL_LOG_CATEGORY_RESERVED2 = 10;
  static const int SDL_LOG_CATEGORY_RESERVED3 = 11;
  static const int SDL_LOG_CATEGORY_RESERVED4 = 12;
  static const int SDL_LOG_CATEGORY_RESERVED5 = 13;
  static const int SDL_LOG_CATEGORY_RESERVED6 = 14;
  static const int SDL_LOG_CATEGORY_RESERVED7 = 15;
  static const int SDL_LOG_CATEGORY_RESERVED8 = 16;
  static const int SDL_LOG_CATEGORY_RESERVED9 = 17;
  static const int SDL_LOG_CATEGORY_RESERVED10 = 18;
  static const int SDL_LOG_CATEGORY_CUSTOM = 19;
}

/// \brief The predefined log priorities
abstract class SDL_LogPriority {
  static const int SDL_LOG_PRIORITY_VERBOSE = 1;
  static const int SDL_LOG_PRIORITY_DEBUG = 2;
  static const int SDL_LOG_PRIORITY_INFO = 3;
  static const int SDL_LOG_PRIORITY_WARN = 4;
  static const int SDL_LOG_PRIORITY_ERROR = 5;
  static const int SDL_LOG_PRIORITY_CRITICAL = 6;
  static const int SDL_NUM_LOG_PRIORITIES = 7;
}

/// \brief The prototype for the log output function
typedef SDL_LogOutputFunction = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
            ffi.Pointer<ffi.Int8>)>>;

/// \brief SDL_MessageBox flags. If supported will display warning icon, etc.
abstract class SDL_MessageBoxFlags {
  /// < error dialog
  static const int SDL_MESSAGEBOX_ERROR = 16;

  /// < warning dialog
  static const int SDL_MESSAGEBOX_WARNING = 32;

  /// < informational dialog
  static const int SDL_MESSAGEBOX_INFORMATION = 64;

  /// < buttons placed left to right
  static const int SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = 128;

  /// < buttons placed right to left
  static const int SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = 256;
}

/// \brief Flags for SDL_MessageBoxButtonData.
abstract class SDL_MessageBoxButtonFlags {
  /// < Marks the default button when return is hit
  static const int SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1;

  /// < Marks the default button when escape is hit
  static const int SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2;
}

/// \brief Individual button data.
class SDL_MessageBoxButtonData extends ffi.Struct {
  /// < ::SDL_MessageBoxButtonFlags
  @Uint32()
  external int flags;

  /// < User defined button id (value returned via SDL_ShowMessageBox)
  @ffi.Int32()
  external int buttonid;

  /// < The UTF-8 button text
  external ffi.Pointer<ffi.Int8> text;
}

/// \brief RGB value used in a message box color scheme
class SDL_MessageBoxColor extends ffi.Struct {
  @Uint8()
  external int r;

  @Uint8()
  external int g;

  @Uint8()
  external int b;
}

abstract class SDL_MessageBoxColorType {
  static const int SDL_MESSAGEBOX_COLOR_BACKGROUND = 0;
  static const int SDL_MESSAGEBOX_COLOR_TEXT = 1;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4;
  static const int SDL_MESSAGEBOX_COLOR_MAX = 5;
}

/// \brief A set of colors to use for message box dialogs
class SDL_MessageBoxColorScheme extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<SDL_MessageBoxColor> colors;
}

/// \brief MessageBox structure containing title, text, window, etc.
class SDL_MessageBoxData extends ffi.Struct {
  /// < ::SDL_MessageBoxFlags
  @Uint32()
  external int flags;

  /// < Parent window, can be NULL
  external ffi.Pointer<SDL_Window> window;

  /// < UTF-8 title
  external ffi.Pointer<ffi.Int8> title;

  /// < UTF-8 message text
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int numbuttons;

  external ffi.Pointer<SDL_MessageBoxButtonData> buttons;

  /// < ::SDL_MessageBoxColorScheme, can be NULL to use system settings
  external ffi.Pointer<SDL_MessageBoxColorScheme> colorScheme;
}

/// \brief A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS).
///
/// \note This can be cast directly to an NSView or UIView.
typedef SDL_MetalView = ffi.Pointer<ffi.Void>;

/// \brief The basic state for the system's power supply.
abstract class SDL_PowerState {
  /// < cannot determine power status
  static const int SDL_POWERSTATE_UNKNOWN = 0;

  /// < Not plugged in, running on the battery
  static const int SDL_POWERSTATE_ON_BATTERY = 1;

  /// < Plugged in, no battery available
  static const int SDL_POWERSTATE_NO_BATTERY = 2;

  /// < Plugged in, charging battery
  static const int SDL_POWERSTATE_CHARGING = 3;

  /// < Plugged in, battery charged
  static const int SDL_POWERSTATE_CHARGED = 4;
}

/// \brief Flags used when creating a rendering context
abstract class SDL_RendererFlags {
  /// < The renderer is a software fallback
  static const int SDL_RENDERER_SOFTWARE = 1;

  /// < The renderer uses hardware
  /// acceleration
  static const int SDL_RENDERER_ACCELERATED = 2;

  /// < Present is synchronized
  /// with the refresh rate
  static const int SDL_RENDERER_PRESENTVSYNC = 4;

  /// < The renderer supports
  /// rendering to texture
  static const int SDL_RENDERER_TARGETTEXTURE = 8;
}

/// \brief Information on the capabilities of a render driver or context.
class SDL_RendererInfo extends ffi.Struct {
  /// < The name of the renderer
  external ffi.Pointer<ffi.Int8> name;

  /// < Supported ::SDL_RendererFlags
  @Uint32()
  external int flags;

  /// < The number of available texture formats
  @Uint32()
  external int num_texture_formats;

  @ffi.Array.multi([16])
  external ffi.Array<Uint32> texture_formats;

  /// < The maximum texture width
  @ffi.Int32()
  external int max_texture_width;

  /// < The maximum texture height
  @ffi.Int32()
  external int max_texture_height;
}

/// \brief The scaling mode for a texture.
abstract class SDL_ScaleMode {
  /// < nearest pixel sampling
  static const int SDL_ScaleModeNearest = 0;

  /// < linear filtering
  static const int SDL_ScaleModeLinear = 1;

  /// < anisotropic filtering
  static const int SDL_ScaleModeBest = 2;
}

/// \brief The access pattern allowed for a texture.
abstract class SDL_TextureAccess {
  /// < Changes rarely, not lockable
  static const int SDL_TEXTUREACCESS_STATIC = 0;

  /// < Changes frequently, lockable
  static const int SDL_TEXTUREACCESS_STREAMING = 1;

  /// < Texture can be used as a render target
  static const int SDL_TEXTUREACCESS_TARGET = 2;
}

/// \brief The texture channel modulation used in SDL_RenderCopy().
abstract class SDL_TextureModulate {
  /// < No modulation
  static const int SDL_TEXTUREMODULATE_NONE = 0;

  /// < srcC = srcC * color
  static const int SDL_TEXTUREMODULATE_COLOR = 1;

  /// < srcA = srcA * alpha
  static const int SDL_TEXTUREMODULATE_ALPHA = 2;
}

/// \brief Flip constants for SDL_RenderCopyEx
abstract class SDL_RendererFlip {
  /// < Do not flip
  static const int SDL_FLIP_NONE = 0;

  /// < flip horizontally
  static const int SDL_FLIP_HORIZONTAL = 1;

  /// < flip vertically
  static const int SDL_FLIP_VERTICAL = 2;
}

/// \brief A structure representing rendering state
class SDL_Renderer extends ffi.Opaque {}

/// \brief An efficient driver-specific representation of pixel data
class SDL_Texture extends ffi.Opaque {}

/// \brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union.
abstract class WindowShapeMode {
  /// \brief The default mode, a binarized alpha cutoff of 1.
  static const int ShapeModeDefault = 0;

  /// \brief A binarized alpha cutoff with a given integer value.
  static const int ShapeModeBinarizeAlpha = 1;

  /// \brief A binarized alpha cutoff with a given integer value, but with the opposite comparison.
  static const int ShapeModeReverseBinarizeAlpha = 2;

  /// \brief A color key is applied.
  static const int ShapeModeColorKey = 3;
}

/// \brief A union containing parameters for shaped windows.
class SDL_WindowShapeParams extends ffi.Union {
  /// \brief A cutoff alpha value for binarization of the window shape's alpha channel.
  @Uint8()
  external int binarizationCutoff;

  external SDL_Color colorKey;
}

/// \brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents.
class SDL_WindowShapeMode extends ffi.Struct {
  /// \brief The mode of these window-shape parameters.
  @ffi.Int32()
  external int mode;

  /// \brief Window-shape parameters.
  external SDL_WindowShapeParams parameters;
}

/// \brief Set a function that is called for every windows message, before TranslateMessage()
typedef SDL_WindowsMessageHook = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
            ffi.Uint32, Uint64, Sint64)>>;

class IDirect3DDevice9 extends ffi.Opaque {}

/// Definition of the timer ID type.
typedef SDL_TimerID = ffi.Int32;

/// Function prototype for the timer callback function.
///
/// The callback function is passed the current timer interval and returns
/// the next timer interval.  If the returned value is the same as the one
/// passed in, the periodic alarm continues, otherwise a new alarm is
/// scheduled.  If the callback returns 0, the periodic alarm is cancelled.
typedef SDL_TimerCallback = ffi.Pointer<
    ffi.NativeFunction<Uint32 Function(Uint32, ffi.Pointer<ffi.Void>)>>;

/// \brief Information the version of SDL in use.
///
/// Represents the library's version as three levels: major revision
/// (increments with massive changes, additions, and enhancements),
/// minor revision (increments with backwards-compatible changes to the
/// major revision), and patchlevel (increments with fixes to the minor
/// revision).
///
/// \sa SDL_VERSION
/// \sa SDL_GetVersion
class SDL_version extends ffi.Struct {
  /// < major version
  @Uint8()
  external int major;

  /// < minor version
  @Uint8()
  external int minor;

  /// < update version
  @Uint8()
  external int patch;
}

class SDL_Locale extends ffi.Struct {
  /// < A language name, like "en" for English.
  external ffi.Pointer<ffi.Int8> language;

  /// < A country, like "US" for America. Can be NULL.
  external ffi.Pointer<ffi.Int8> country;
}

const int HAVE_WINAPIFAMILY_H = 1;

const int WINAPI_PARTITION_SERVER = 0;

const int WINAPI_PARTITION_PKG_WINTRUST = 0;

const int WINAPI_PARTITION_PKG_WEBSERVICES = 0;

const int WINAPI_PARTITION_PKG_EVENTLOGSERVICE = 0;

const int WINAPI_PARTITION_PKG_VHD = 0;

const int WINAPI_PARTITION_PKG_PERFCOUNTER = 0;

const int WINAPI_PARTITION_PKG_SECURESTARTUP = 0;

const int WINAPI_PARTITION_PKG_REMOTEFS = 0;

const int WINAPI_PARTITION_PKG_BOOTABLESKU = 0;

const int WINAPI_PARTITION_PKG_CMDTOOLS = 0;

const int WINAPI_PARTITION_PKG_DISM = 0;

const int WINAPI_PARTITION_PKG_CORESETUP = 0;

const int WINAPI_PARTITION_PKG_APPRUNTIME = 0;

const int WINAPI_PARTITION_PKG_ESENT = 0;

const int WINAPI_PARTITION_PKG_WINMGMT = 0;

const int WINAPI_PARTITION_PKG_WNV = 0;

const int WINAPI_PARTITION_PKG_CLUSTER = 0;

const int WINAPI_PARTITION_PKG_VSS = 0;

const int WINAPI_PARTITION_PKG_TRAFFIC = 0;

const int WINAPI_PARTITION_PKG_ISCSI = 0;

const int WINAPI_PARTITION_PKG_STORAGE = 0;

const int WINAPI_PARTITION_PKG_MPSSVC = 0;

const int WINAPI_PARTITION_PKG_APPXDEPLOYMENT = 0;

const int WINAPI_PARTITION_PKG_WER = 0;

const int WINAPI_FAMILY_PC_APP = 2;

const int WINAPI_FAMILY_PHONE_APP = 3;

const int WINAPI_FAMILY_SYSTEM = 4;

const int WINAPI_FAMILY_SERVER = 5;

const int WINAPI_FAMILY_GAMES = 6;

const int WINAPI_FAMILY_DESKTOP_APP = 100;

const int WINAPI_FAMILY_APP = 2;

const int WINAPI_FAMILY = 100;

const int WINAPI_PARTITION_DESKTOP = 1;

const int WINAPI_PARTITION_APP = 1;

const int WINAPI_PARTITION_PC_APP = 1;

const int WINAPI_PARTITION_PHONE_APP = 0;

const int WINAPI_PARTITION_GAMES = 1;

const int WINAPI_PARTITION_SYSTEM = 0;

const int WINAPI_PARTITION_PHONE = 0;

const int WINAPI_FAMILY_WINRT = 0;

const int __WINDOWS__ = 1;

const int __WIN32__ = 1;

const int NULL = 0;

const int SIZEOF_VOIDP = 8;

const int HAVE_DDRAW_H = 1;

const int HAVE_DINPUT_H = 1;

const int HAVE_DSOUND_H = 1;

const int HAVE_DXGI_H = 1;

const int HAVE_XINPUT_H = 1;

const int HAVE_MMDEVICEAPI_H = 1;

const int HAVE_AUDIOCLIENT_H = 1;

const int HAVE_STDARG_H = 1;

const int HAVE_STDDEF_H = 1;

const int _WIN32_WINNT_NT4 = 1024;

const int _WIN32_WINNT_WIN2K = 1280;

const int _WIN32_WINNT_WINXP = 1281;

const int _WIN32_WINNT_WS03 = 1282;

const int _WIN32_WINNT_WIN6 = 1536;

const int _WIN32_WINNT_VISTA = 1536;

const int _WIN32_WINNT_WS08 = 1536;

const int _WIN32_WINNT_LONGHORN = 1536;

const int _WIN32_WINNT_WIN7 = 1537;

const int _WIN32_WINNT_WIN8 = 1538;

const int _WIN32_WINNT_WINBLUE = 1539;

const int _WIN32_WINNT_WINTHRESHOLD = 2560;

const int _WIN32_WINNT_WIN10 = 2560;

const int _WIN32_IE_IE20 = 512;

const int _WIN32_IE_IE30 = 768;

const int _WIN32_IE_IE302 = 770;

const int _WIN32_IE_IE40 = 1024;

const int _WIN32_IE_IE401 = 1025;

const int _WIN32_IE_IE50 = 1280;

const int _WIN32_IE_IE501 = 1281;

const int _WIN32_IE_IE55 = 1360;

const int _WIN32_IE_IE60 = 1536;

const int _WIN32_IE_IE60SP1 = 1537;

const int _WIN32_IE_IE60SP2 = 1539;

const int _WIN32_IE_IE70 = 1792;

const int _WIN32_IE_IE80 = 2048;

const int _WIN32_IE_IE90 = 2304;

const int _WIN32_IE_IE100 = 2560;

const int _WIN32_IE_IE110 = 2560;

const int _WIN32_IE_NT4 = 512;

const int _WIN32_IE_NT4SP1 = 512;

const int _WIN32_IE_NT4SP2 = 512;

const int _WIN32_IE_NT4SP3 = 770;

const int _WIN32_IE_NT4SP4 = 1025;

const int _WIN32_IE_NT4SP5 = 1025;

const int _WIN32_IE_NT4SP6 = 1280;

const int _WIN32_IE_WIN98 = 1025;

const int _WIN32_IE_WIN98SE = 1280;

const int _WIN32_IE_WINME = 1360;

const int _WIN32_IE_WIN2K = 1281;

const int _WIN32_IE_WIN2KSP1 = 1281;

const int _WIN32_IE_WIN2KSP2 = 1281;

const int _WIN32_IE_WIN2KSP3 = 1281;

const int _WIN32_IE_WIN2KSP4 = 1281;

const int _WIN32_IE_XP = 1536;

const int _WIN32_IE_XPSP1 = 1537;

const int _WIN32_IE_XPSP2 = 1539;

const int _WIN32_IE_WS03 = 1538;

const int _WIN32_IE_WS03SP1 = 1539;

const int _WIN32_IE_WIN6 = 1792;

const int _WIN32_IE_LONGHORN = 1792;

const int _WIN32_IE_WIN7 = 2048;

const int _WIN32_IE_WIN8 = 2560;

const int _WIN32_IE_WINBLUE = 2560;

const int _WIN32_IE_WINTHRESHOLD = 2560;

const int _WIN32_IE_WIN10 = 2560;

const int NTDDI_WIN2K = 83886080;

const int NTDDI_WIN2KSP1 = 83886336;

const int NTDDI_WIN2KSP2 = 83886592;

const int NTDDI_WIN2KSP3 = 83886848;

const int NTDDI_WIN2KSP4 = 83887104;

const int NTDDI_WINXP = 83951616;

const int NTDDI_WINXPSP1 = 83951872;

const int NTDDI_WINXPSP2 = 83952128;

const int NTDDI_WINXPSP3 = 83952384;

const int NTDDI_WINXPSP4 = 83952640;

const int NTDDI_WS03 = 84017152;

const int NTDDI_WS03SP1 = 84017408;

const int NTDDI_WS03SP2 = 84017664;

const int NTDDI_WS03SP3 = 84017920;

const int NTDDI_WS03SP4 = 84018176;

const int NTDDI_WIN6 = 100663296;

const int NTDDI_WIN6SP1 = 100663552;

const int NTDDI_WIN6SP2 = 100663808;

const int NTDDI_WIN6SP3 = 100664064;

const int NTDDI_WIN6SP4 = 100664320;

const int NTDDI_VISTA = 100663296;

const int NTDDI_VISTASP1 = 100663552;

const int NTDDI_VISTASP2 = 100663808;

const int NTDDI_VISTASP3 = 100664064;

const int NTDDI_VISTASP4 = 100664320;

const int NTDDI_LONGHORN = 100663296;

const int NTDDI_WS08 = 100663552;

const int NTDDI_WS08SP2 = 100663808;

const int NTDDI_WS08SP3 = 100664064;

const int NTDDI_WS08SP4 = 100664320;

const int NTDDI_WIN7 = 100728832;

const int NTDDI_WIN8 = 100794368;

const int NTDDI_WINBLUE = 100859904;

const int NTDDI_WINTHRESHOLD = 167772160;

const int NTDDI_WIN10 = 167772160;

const int NTDDI_WIN10_TH2 = 167772161;

const int NTDDI_WIN10_RS1 = 167772162;

const int NTDDI_WIN10_RS2 = 167772163;

const int NTDDI_WIN10_RS3 = 167772164;

const int NTDDI_WIN10_RS4 = 167772165;

const int NTDDI_WIN10_RS5 = 167772166;

const int NTDDI_WIN10_19H1 = 167772167;

const int WDK_NTDDI_VERSION = 167772167;

const int OSVERSION_MASK = 4294901760;

const int SPVERSION_MASK = 65280;

const int SUBVERSION_MASK = 255;

const int _WIN32_WINNT = 2560;

const int NTDDI_VERSION = 167772167;

const int WINVER = 2560;

const int _WIN32_IE = 2560;

const int SDL_AUDIO_DRIVER_WASAPI = 1;

const int SDL_AUDIO_DRIVER_DSOUND = 1;

const int SDL_AUDIO_DRIVER_WINMM = 1;

const int SDL_AUDIO_DRIVER_DISK = 1;

const int SDL_AUDIO_DRIVER_DUMMY = 1;

const int SDL_JOYSTICK_DINPUT = 1;

const int SDL_JOYSTICK_HIDAPI = 1;

const int SDL_JOYSTICK_RAWINPUT = 1;

const int SDL_JOYSTICK_VIRTUAL = 1;

const int SDL_JOYSTICK_WGI = 1;

const int SDL_JOYSTICK_XINPUT = 1;

const int SDL_HAPTIC_DINPUT = 1;

const int SDL_HAPTIC_XINPUT = 1;

const int SDL_SENSOR_WINDOWS = 1;

const int SDL_LOADSO_WINDOWS = 1;

const int SDL_THREAD_WINDOWS = 1;

const int SDL_TIMER_WINDOWS = 1;

const int SDL_VIDEO_DRIVER_DUMMY = 1;

const int SDL_VIDEO_DRIVER_WINDOWS = 1;

const int SDL_VIDEO_RENDER_D3D = 1;

const int SDL_VIDEO_RENDER_D3D11 = 1;

const int SDL_VIDEO_OPENGL = 1;

const int SDL_VIDEO_OPENGL_WGL = 1;

const int SDL_VIDEO_RENDER_OGL = 1;

const int SDL_VIDEO_RENDER_OGL_ES2 = 1;

const int SDL_VIDEO_OPENGL_ES2 = 1;

const int SDL_VIDEO_OPENGL_EGL = 1;

const int SDL_VIDEO_VULKAN = 1;

const int SDL_POWER_WINDOWS = 1;

const int SDL_FILESYSTEM_WINDOWS = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_NODISCARD = 1;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int SDL_MAX_SINT8 = 127;

const int SDL_MIN_SINT8 = -128;

const int SDL_MAX_UINT8 = 255;

const int SDL_MIN_UINT8 = 0;

const int SDL_MAX_SINT16 = 32767;

const int SDL_MIN_SINT16 = -32768;

const int SDL_MAX_UINT16 = 65535;

const int SDL_MIN_UINT16 = 0;

const int SDL_MAX_SINT32 = 2147483647;

const int SDL_MIN_SINT32 = -2147483648;

const int SDL_MAX_UINT32 = 4294967295;

const int SDL_MIN_UINT32 = 0;

const int SDL_MAX_SINT64 = 9223372036854775807;

const int SDL_MIN_SINT64 = -9223372036854775808;

const int SDL_MAX_UINT64 = -1;

const int SDL_MIN_UINT64 = 0;

const String SDL_PRIs64 = 'I64d';

const String SDL_PRIu64 = 'I64u';

const String SDL_PRIx64 = 'I64x';

const String SDL_PRIX64 = 'I64X';

const double M_PI = 3.141592653589793;

const int SDL_ICONV_ERROR = -1;

const int SDL_ICONV_E2BIG = -2;

const int SDL_ICONV_EILSEQ = -3;

const int SDL_ICONV_EINVAL = -4;

const int SDL_ASSERT_LEVEL = 1;

const String SDL_FILE = 'temp_for_macros.hpp';

const int SDL_LINE = 622;

const int SDL_NULL_WHILE_LOOP_CONDITION = 0;

const int SDL_LIL_ENDIAN = 1234;

const int SDL_BIG_ENDIAN = 4321;

const int SDL_BYTEORDER = 1234;

const int SDL_MUTEX_TIMEDOUT = 1;

const int SDL_MUTEX_MAXWAIT = 4294967295;

const int _DOMAIN = 1;

const int _SING = 2;

const int _OVERFLOW = 3;

const int _UNDERFLOW = 4;

const int _TLOSS = 5;

const int _PLOSS = 6;

const double _HUGE_ENUF = 1e+300;

const double INFINITY = double.infinity;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double NAN = double.nan;

const int _DENORM = -2;

const int _FINITE = -1;

const int _INFCODE = 1;

const int _NANCODE = 2;

const int FP_INFINITE = 1;

const int FP_NAN = 2;

const int FP_NORMAL = -1;

const int FP_SUBNORMAL = -2;

const int FP_ZERO = 0;

const int _C2 = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = 2147483647;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const int math_errhandling = 3;

const int _FE_DIVBYZERO = 4;

const int _FE_INEXACT = 32;

const int _FE_INVALID = 1;

const int _FE_OVERFLOW = 8;

const int _FE_UNDERFLOW = 16;

const int _D0_C = 3;

const int _D1_C = 2;

const int _D2_C = 1;

const int _D3_C = 0;

const int _DBIAS = 1022;

const int _DOFF = 4;

const int _F0_C = 1;

const int _F1_C = 0;

const int _FBIAS = 126;

const int _FOFF = 7;

const int _FRND = 1;

const int _L0_C = 3;

const int _L1_C = 2;

const int _L2_C = 1;

const int _L3_C = 0;

const int _LBIAS = 1022;

const int _LOFF = 4;

const int _DFRAC = 15;

const int _DMASK = 32752;

const int _DMAX = 2047;

const int _DSIGN = 32768;

const int _FFRAC = 127;

const int _FMASK = 32640;

const int _FMAX = 255;

const int _FSIGN = 32768;

const int _LFRAC = 65535;

const int _LMASK = 32767;

const int _LMAX = 32767;

const int _LSIGN = 32768;

const int _DHUGE_EXP = 1842;

const int _FHUGE_EXP = 229;

const int _LHUGE_EXP = 29490;

const int _FP_LT = 1;

const int _FP_EQ = 2;

const int _FP_GT = 4;

const int DOMAIN = 1;

const int SING = 2;

const int OVERFLOW = 3;

const int UNDERFLOW = 4;

const int TLOSS = 5;

const int PLOSS = 6;

const int _P_WAIT = 0;

const int _P_NOWAIT = 1;

const int _OLD_P_OVERLAY = 2;

const int _P_NOWAITO = 3;

const int _P_DETACH = 4;

const int _P_OVERLAY = 2;

const int _WAIT_CHILD = 0;

const int _WAIT_GRANDCHILD = 1;

const int P_WAIT = 0;

const int P_NOWAIT = 1;

const int P_OVERLAY = 2;

const int OLD_P_OVERLAY = 2;

const int P_NOWAITO = 3;

const int P_DETACH = 4;

const int WAIT_CHILD = 0;

const int WAIT_GRANDCHILD = 1;

const int SDL_RWOPS_UNKNOWN = 0;

const int SDL_RWOPS_WINFILE = 1;

const int SDL_RWOPS_STDFILE = 2;

const int SDL_RWOPS_JNIFILE = 3;

const int SDL_RWOPS_MEMORY = 4;

const int SDL_RWOPS_MEMORY_RO = 5;

const int RW_SEEK_SET = 0;

const int RW_SEEK_CUR = 1;

const int RW_SEEK_END = 2;

const int SDL_AUDIO_MASK_BITSIZE = 255;

const int SDL_AUDIO_MASK_DATATYPE = 256;

const int SDL_AUDIO_MASK_ENDIAN = 4096;

const int SDL_AUDIO_MASK_SIGNED = 32768;

const int AUDIO_U8 = 8;

const int AUDIO_S8 = 32776;

const int AUDIO_U16LSB = 16;

const int AUDIO_S16LSB = 32784;

const int AUDIO_U16MSB = 4112;

const int AUDIO_S16MSB = 36880;

const int AUDIO_U16 = 16;

const int AUDIO_S16 = 32784;

const int AUDIO_S32LSB = 32800;

const int AUDIO_S32MSB = 36896;

const int AUDIO_S32 = 32800;

const int AUDIO_F32LSB = 33056;

const int AUDIO_F32MSB = 37152;

const int AUDIO_F32 = 33056;

const int AUDIO_U16SYS = 16;

const int AUDIO_S16SYS = 32784;

const int AUDIO_S32SYS = 32800;

const int AUDIO_F32SYS = 33056;

const int SDL_AUDIO_ALLOW_FREQUENCY_CHANGE = 1;

const int SDL_AUDIO_ALLOW_FORMAT_CHANGE = 2;

const int SDL_AUDIO_ALLOW_CHANNELS_CHANGE = 4;

const int SDL_AUDIO_ALLOW_SAMPLES_CHANGE = 8;

const int SDL_AUDIO_ALLOW_ANY_CHANGE = 15;

const int SDL_AUDIOCVT_MAX_FILTERS = 9;

const int SDL_MIX_MAXVOLUME = 128;

const int SDL_CACHELINE_SIZE = 128;

const int SDL_ALPHA_OPAQUE = 255;

const int SDL_ALPHA_TRANSPARENT = 0;

const int SDL_SWSURFACE = 0;

const int SDL_PREALLOC = 1;

const int SDL_RLEACCEL = 2;

const int SDL_DONTFREE = 4;

const int SDL_SIMD_ALIGNED = 8;

const int SDL_WINDOWPOS_UNDEFINED_MASK = 536805376;

const int SDL_WINDOWPOS_UNDEFINED = 536805376;

const int SDL_WINDOWPOS_CENTERED_MASK = 805240832;

const int SDL_WINDOWPOS_CENTERED = 805240832;

const int SDLK_SCANCODE_MASK = 1073741824;

const int SDL_BUTTON_LEFT = 1;

const int SDL_BUTTON_MIDDLE = 2;

const int SDL_BUTTON_RIGHT = 3;

const int SDL_BUTTON_X1 = 4;

const int SDL_BUTTON_X2 = 5;

const int SDL_BUTTON_LMASK = 1;

const int SDL_BUTTON_MMASK = 2;

const int SDL_BUTTON_RMASK = 4;

const int SDL_BUTTON_X1MASK = 8;

const int SDL_BUTTON_X2MASK = 16;

const double SDL_IPHONE_MAX_GFORCE = 5.0;

const int SDL_JOYSTICK_AXIS_MAX = 32767;

const int SDL_JOYSTICK_AXIS_MIN = -32768;

const int SDL_HAT_CENTERED = 0;

const int SDL_HAT_UP = 1;

const int SDL_HAT_RIGHT = 2;

const int SDL_HAT_DOWN = 4;

const int SDL_HAT_LEFT = 8;

const int SDL_HAT_RIGHTUP = 3;

const int SDL_HAT_RIGHTDOWN = 6;

const int SDL_HAT_LEFTUP = 9;

const int SDL_HAT_LEFTDOWN = 12;

const double SDL_STANDARD_GRAVITY = 9.806650161743164;

const int SDL_TOUCH_MOUSEID = 4294967295;

const int SDL_MOUSE_TOUCHID = -1;

const int SDL_RELEASED = 0;

const int SDL_PRESSED = 1;

const int SDL_TEXTEDITINGEVENT_TEXT_SIZE = 32;

const int SDL_TEXTINPUTEVENT_TEXT_SIZE = 32;

const int SDL_QUERY = -1;

const int SDL_IGNORE = 0;

const int SDL_DISABLE = 0;

const int SDL_ENABLE = 1;

const int SDL_HAPTIC_CONSTANT = 1;

const int SDL_HAPTIC_SINE = 2;

const int SDL_HAPTIC_LEFTRIGHT = 4;

const int SDL_HAPTIC_TRIANGLE = 8;

const int SDL_HAPTIC_SAWTOOTHUP = 16;

const int SDL_HAPTIC_SAWTOOTHDOWN = 32;

const int SDL_HAPTIC_RAMP = 64;

const int SDL_HAPTIC_SPRING = 128;

const int SDL_HAPTIC_DAMPER = 256;

const int SDL_HAPTIC_INERTIA = 512;

const int SDL_HAPTIC_FRICTION = 1024;

const int SDL_HAPTIC_CUSTOM = 2048;

const int SDL_HAPTIC_GAIN = 4096;

const int SDL_HAPTIC_AUTOCENTER = 8192;

const int SDL_HAPTIC_STATUS = 16384;

const int SDL_HAPTIC_PAUSE = 32768;

const int SDL_HAPTIC_POLAR = 0;

const int SDL_HAPTIC_CARTESIAN = 1;

const int SDL_HAPTIC_SPHERICAL = 2;

const int SDL_HAPTIC_STEERING_AXIS = 3;

const int SDL_HAPTIC_INFINITY = 4294967295;

const String SDL_HINT_FRAMEBUFFER_ACCELERATION = 'SDL_FRAMEBUFFER_ACCELERATION';

const String SDL_HINT_RENDER_DRIVER = 'SDL_RENDER_DRIVER';

const String SDL_HINT_RENDER_OPENGL_SHADERS = 'SDL_RENDER_OPENGL_SHADERS';

const String SDL_HINT_RENDER_DIRECT3D_THREADSAFE =
    'SDL_RENDER_DIRECT3D_THREADSAFE';

const String SDL_HINT_RENDER_DIRECT3D11_DEBUG = 'SDL_RENDER_DIRECT3D11_DEBUG';

const String SDL_HINT_RENDER_LOGICAL_SIZE_MODE = 'SDL_RENDER_LOGICAL_SIZE_MODE';

const String SDL_HINT_RENDER_SCALE_QUALITY = 'SDL_RENDER_SCALE_QUALITY';

const String SDL_HINT_RENDER_VSYNC = 'SDL_RENDER_VSYNC';

const String SDL_HINT_VIDEO_ALLOW_SCREENSAVER = 'SDL_VIDEO_ALLOW_SCREENSAVER';

const String SDL_HINT_VIDEO_EXTERNAL_CONTEXT = 'SDL_VIDEO_EXTERNAL_CONTEXT';

const String SDL_HINT_VIDEO_X11_XVIDMODE = 'SDL_VIDEO_X11_XVIDMODE';

const String SDL_HINT_VIDEO_X11_XINERAMA = 'SDL_VIDEO_X11_XINERAMA';

const String SDL_HINT_VIDEO_X11_XRANDR = 'SDL_VIDEO_X11_XRANDR';

const String SDL_HINT_VIDEO_X11_WINDOW_VISUALID =
    'SDL_VIDEO_X11_WINDOW_VISUALID';

const String SDL_HINT_VIDEO_X11_NET_WM_PING = 'SDL_VIDEO_X11_NET_WM_PING';

const String SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR =
    'SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR';

const String SDL_HINT_VIDEO_X11_FORCE_EGL = 'SDL_VIDEO_X11_FORCE_EGL';

const String SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN =
    'SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN';

const String SDL_HINT_WINDOWS_INTRESOURCE_ICON = 'SDL_WINDOWS_INTRESOURCE_ICON';

const String SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL =
    'SDL_WINDOWS_INTRESOURCE_ICON_SMALL';

const String SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP =
    'SDL_WINDOWS_ENABLE_MESSAGELOOP';

const String SDL_HINT_GRAB_KEYBOARD = 'SDL_GRAB_KEYBOARD';

const String SDL_HINT_MOUSE_DOUBLE_CLICK_TIME = 'SDL_MOUSE_DOUBLE_CLICK_TIME';

const String SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS =
    'SDL_MOUSE_DOUBLE_CLICK_RADIUS';

const String SDL_HINT_MOUSE_NORMAL_SPEED_SCALE = 'SDL_MOUSE_NORMAL_SPEED_SCALE';

const String SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE =
    'SDL_MOUSE_RELATIVE_SPEED_SCALE';

const String SDL_HINT_MOUSE_RELATIVE_SCALING = 'SDL_MOUSE_RELATIVE_SCALING';

const String SDL_HINT_MOUSE_RELATIVE_MODE_WARP = 'SDL_MOUSE_RELATIVE_MODE_WARP';

const String SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH = 'SDL_MOUSE_FOCUS_CLICKTHROUGH';

const String SDL_HINT_TOUCH_MOUSE_EVENTS = 'SDL_TOUCH_MOUSE_EVENTS';

const String SDL_HINT_MOUSE_TOUCH_EVENTS = 'SDL_MOUSE_TOUCH_EVENTS';

const String SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS =
    'SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS';

const String SDL_HINT_IDLE_TIMER_DISABLED = 'SDL_IOS_IDLE_TIMER_DISABLED';

const String SDL_HINT_ORIENTATIONS = 'SDL_IOS_ORIENTATIONS';

const String SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS =
    'SDL_APPLE_TV_CONTROLLER_UI_EVENTS';

const String SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION =
    'SDL_APPLE_TV_REMOTE_ALLOW_ROTATION';

const String SDL_HINT_IOS_HIDE_HOME_INDICATOR = 'SDL_IOS_HIDE_HOME_INDICATOR';

const String SDL_HINT_ACCELEROMETER_AS_JOYSTICK =
    'SDL_ACCELEROMETER_AS_JOYSTICK';

const String SDL_HINT_TV_REMOTE_AS_JOYSTICK = 'SDL_TV_REMOTE_AS_JOYSTICK';

const String SDL_HINT_XINPUT_ENABLED = 'SDL_XINPUT_ENABLED';

const String SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING =
    'SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING';

const String SDL_HINT_GAMECONTROLLERTYPE = 'SDL_GAMECONTROLLERTYPE';

const String SDL_HINT_GAMECONTROLLERCONFIG = 'SDL_GAMECONTROLLERCONFIG';

const String SDL_HINT_GAMECONTROLLERCONFIG_FILE =
    'SDL_GAMECONTROLLERCONFIG_FILE';

const String SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES =
    'SDL_GAMECONTROLLER_IGNORE_DEVICES';

const String SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT =
    'SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT';

const String SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS =
    'SDL_GAMECONTROLLER_USE_BUTTON_LABELS';

const String SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS =
    'SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS';

const String SDL_HINT_JOYSTICK_HIDAPI = 'SDL_JOYSTICK_HIDAPI';

const String SDL_HINT_JOYSTICK_HIDAPI_PS4 = 'SDL_JOYSTICK_HIDAPI_PS4';

const String SDL_HINT_JOYSTICK_HIDAPI_PS5 = 'SDL_JOYSTICK_HIDAPI_PS5';

const String SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE =
    'SDL_JOYSTICK_HIDAPI_PS4_RUMBLE';

const String SDL_HINT_JOYSTICK_HIDAPI_STEAM = 'SDL_JOYSTICK_HIDAPI_STEAM';

const String SDL_HINT_JOYSTICK_HIDAPI_SWITCH = 'SDL_JOYSTICK_HIDAPI_SWITCH';

const String SDL_HINT_JOYSTICK_HIDAPI_XBOX = 'SDL_JOYSTICK_HIDAPI_XBOX';

const String SDL_HINT_JOYSTICK_HIDAPI_CORRELATE_XINPUT =
    'SDL_JOYSTICK_HIDAPI_CORRELATE_XINPUT';

const String SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE = 'SDL_JOYSTICK_HIDAPI_GAMECUBE';

const String SDL_HINT_ENABLE_STEAM_CONTROLLERS = 'SDL_ENABLE_STEAM_CONTROLLERS';

const String SDL_HINT_JOYSTICK_RAWINPUT = 'SDL_JOYSTICK_RAWINPUT';

const String SDL_HINT_JOYSTICK_THREAD = 'SDL_JOYSTICK_THREAD';

const String SDL_HINT_LINUX_JOYSTICK_DEADZONES = 'SDL_LINUX_JOYSTICK_DEADZONES';

const String SDL_HINT_ALLOW_TOPMOST = 'SDL_ALLOW_TOPMOST';

const String SDL_HINT_TIMER_RESOLUTION = 'SDL_TIMER_RESOLUTION';

const String SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION =
    'SDL_QTWAYLAND_CONTENT_ORIENTATION';

const String SDL_HINT_QTWAYLAND_WINDOW_FLAGS = 'SDL_QTWAYLAND_WINDOW_FLAGS';

const String SDL_HINT_THREAD_STACK_SIZE = 'SDL_THREAD_STACK_SIZE';

const String SDL_HINT_THREAD_PRIORITY_POLICY = 'SDL_THREAD_PRIORITY_POLICY';

const String SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL =
    'SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL';

const String SDL_HINT_VIDEO_HIGHDPI_DISABLED = 'SDL_VIDEO_HIGHDPI_DISABLED';

const String SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK =
    'SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK';

const String SDL_HINT_VIDEO_WIN_D3DCOMPILER = 'SDL_VIDEO_WIN_D3DCOMPILER';

const String SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT =
    'SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT';

const String SDL_HINT_WINRT_PRIVACY_POLICY_URL = 'SDL_WINRT_PRIVACY_POLICY_URL';

const String SDL_HINT_WINRT_PRIVACY_POLICY_LABEL =
    'SDL_WINRT_PRIVACY_POLICY_LABEL';

const String SDL_HINT_WINRT_HANDLE_BACK_BUTTON = 'SDL_WINRT_HANDLE_BACK_BUTTON';

const String SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES =
    'SDL_VIDEO_MAC_FULLSCREEN_SPACES';

const String SDL_HINT_MAC_BACKGROUND_APP = 'SDL_MAC_BACKGROUND_APP';

const String SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION =
    'SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION';

const String SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION =
    'SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION';

const String SDL_HINT_IME_INTERNAL_EDITING = 'SDL_IME_INTERNAL_EDITING';

const String SDL_HINT_ANDROID_TRAP_BACK_BUTTON = 'SDL_ANDROID_TRAP_BACK_BUTTON';

const String SDL_HINT_ANDROID_BLOCK_ON_PAUSE = 'SDL_ANDROID_BLOCK_ON_PAUSE';

const String SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO =
    'SDL_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO';

const String SDL_HINT_RETURN_KEY_HIDES_IME = 'SDL_RETURN_KEY_HIDES_IME';

const String SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT =
    'SDL_EMSCRIPTEN_KEYBOARD_ELEMENT';

const String SDL_HINT_EMSCRIPTEN_ASYNCIFY = 'SDL_EMSCRIPTEN_ASYNCIFY';

const String SDL_HINT_NO_SIGNAL_HANDLERS = 'SDL_NO_SIGNAL_HANDLERS';

const String SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4 =
    'SDL_WINDOWS_NO_CLOSE_ON_ALT_F4';

const String SDL_HINT_BMP_SAVE_LEGACY_FORMAT = 'SDL_BMP_SAVE_LEGACY_FORMAT';

const String SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING =
    'SDL_WINDOWS_DISABLE_THREAD_NAMING';

const String SDL_HINT_RPI_VIDEO_LAYER = 'SDL_RPI_VIDEO_LAYER';

const String SDL_HINT_VIDEO_DOUBLE_BUFFER = 'SDL_VIDEO_DOUBLE_BUFFER';

const String SDL_HINT_OPENGL_ES_DRIVER = 'SDL_OPENGL_ES_DRIVER';

const String SDL_HINT_AUDIO_RESAMPLING_MODE = 'SDL_AUDIO_RESAMPLING_MODE';

const String SDL_HINT_AUDIO_CATEGORY = 'SDL_AUDIO_CATEGORY';

const String SDL_HINT_RENDER_BATCHING = 'SDL_RENDER_BATCHING';

const String SDL_HINT_AUTO_UPDATE_JOYSTICKS = 'SDL_AUTO_UPDATE_JOYSTICKS';

const String SDL_HINT_AUTO_UPDATE_SENSORS = 'SDL_AUTO_UPDATE_SENSORS';

const String SDL_HINT_EVENT_LOGGING = 'SDL_EVENT_LOGGING';

const String SDL_HINT_WAVE_RIFF_CHUNK_SIZE = 'SDL_WAVE_RIFF_CHUNK_SIZE';

const String SDL_HINT_WAVE_TRUNCATION = 'SDL_WAVE_TRUNCATION';

const String SDL_HINT_WAVE_FACT_CHUNK = 'SDL_WAVE_FACT_CHUNK';

const String SDL_HINT_DISPLAY_USABLE_BOUNDS = 'SDL_DISPLAY_USABLE_BOUNDS';

const String SDL_HINT_AUDIO_DEVICE_APP_NAME = 'SDL_AUDIO_DEVICE_APP_NAME';

const String SDL_HINT_AUDIO_DEVICE_STREAM_NAME = 'SDL_AUDIO_DEVICE_STREAM_NAME';

const String SDL_HINT_PREFERRED_LOCALES = 'SDL_PREFERRED_LOCALES';

const int SDL_MAX_LOG_MESSAGE = 4096;

const int SDL_NONSHAPEABLE_WINDOW = -1;

const int SDL_INVALID_SHAPE_ARGUMENT = -2;

const int SDL_WINDOW_LACKS_SHAPE = -3;

const int SDL_MAJOR_VERSION = 2;

const int SDL_MINOR_VERSION = 0;

const int SDL_PATCHLEVEL = 14;

const int SDL_COMPILEDVERSION = 2014;

const int SDL_INIT_TIMER = 1;

const int SDL_INIT_AUDIO = 16;

const int SDL_INIT_VIDEO = 32;

const int SDL_INIT_JOYSTICK = 512;

const int SDL_INIT_HAPTIC = 4096;

const int SDL_INIT_GAMECONTROLLER = 8192;

const int SDL_INIT_EVENTS = 16384;

const int SDL_INIT_SENSOR = 32768;

const int SDL_INIT_NOPARACHUTE = 1048576;

const int SDL_INIT_EVERYTHING = 62001;

const String SDL_REVISION = 'hg-14525:e52d96ea04fc';

const int SDL_REVISION_NUMBER = 14525;

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for SDL
class DartSdl {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DartSdl(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DartSdl.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// \brief Gets the name of the platform.
  ffi.Pointer<ffi.Int8> SDL_GetPlatform() {
    return _SDL_GetPlatform();
  }

  late final _SDL_GetPlatform_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPlatform>>('SDL_GetPlatform');
  late final _dart_SDL_GetPlatform _SDL_GetPlatform =
      _SDL_GetPlatform_ptr.asFunction<_dart_SDL_GetPlatform>();

  void __va_start(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_start_ptr =
      _lookup<ffi.NativeFunction<_c___va_start>>('__va_start');
  late final _dart___va_start ___va_start =
      ___va_start_ptr.asFunction<_dart___va_start>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookie_ptr =
      _lookup<ffi.NativeFunction<_c___security_init_cookie>>(
          '__security_init_cookie');
  late final _dart___security_init_cookie ___security_init_cookie =
      ___security_init_cookie_ptr.asFunction<_dart___security_init_cookie>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookie_ptr =
      _lookup<ffi.NativeFunction<_c___security_check_cookie>>(
          '__security_check_cookie');
  late final _dart___security_check_cookie ___security_check_cookie =
      ___security_check_cookie_ptr.asFunction<_dart___security_check_cookie>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailure_ptr =
      _lookup<ffi.NativeFunction<_c___report_gsfailure>>('__report_gsfailure');
  late final _dart___report_gsfailure ___report_gsfailure =
      ___report_gsfailure_ptr.asFunction<_dart___report_gsfailure>();

  late final ffi.Pointer<ffi.Uint64> ___security_cookie =
      _lookup<ffi.Uint64>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfo_ptr =
      _lookup<ffi.NativeFunction<_c__invalid_parameter_noinfo>>(
          '_invalid_parameter_noinfo');
  late final _dart__invalid_parameter_noinfo __invalid_parameter_noinfo =
      __invalid_parameter_noinfo_ptr
          .asFunction<_dart__invalid_parameter_noinfo>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturn_ptr =
      _lookup<ffi.NativeFunction<_c__invalid_parameter_noinfo_noreturn>>(
          '_invalid_parameter_noinfo_noreturn');
  late final _dart__invalid_parameter_noinfo_noreturn
      __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturn_ptr
          .asFunction<_dart__invalid_parameter_noinfo_noreturn>();

  void _invoke_watson(
    ffi.Pointer<ffi.Uint16> _Expression,
    ffi.Pointer<ffi.Uint16> _FunctionName,
    ffi.Pointer<ffi.Uint16> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watson_ptr =
      _lookup<ffi.NativeFunction<_c__invoke_watson>>('_invoke_watson');
  late final _dart__invoke_watson __invoke_watson =
      __invoke_watson_ptr.asFunction<_dart__invoke_watson>();

  ffi.Pointer<ffi.Int32> _errno() {
    return __errno();
  }

  late final __errno_ptr = _lookup<ffi.NativeFunction<_c__errno>>('_errno');
  late final _dart__errno __errno = __errno_ptr.asFunction<_dart__errno>();

  int _set_errno(
    int _Value,
  ) {
    return __set_errno(
      _Value,
    );
  }

  late final __set_errno_ptr =
      _lookup<ffi.NativeFunction<_c__set_errno>>('_set_errno');
  late final _dart__set_errno __set_errno =
      __set_errno_ptr.asFunction<_dart__set_errno>();

  int _get_errno(
    ffi.Pointer<ffi.Int32> _Value,
  ) {
    return __get_errno(
      _Value,
    );
  }

  late final __get_errno_ptr =
      _lookup<ffi.NativeFunction<_c__get_errno>>('_get_errno');
  late final _dart__get_errno __get_errno =
      __get_errno_ptr.asFunction<_dart__get_errno>();

  int __threadid() {
    return ___threadid();
  }

  late final ___threadid_ptr =
      _lookup<ffi.NativeFunction<_c___threadid>>('__threadid');
  late final _dart___threadid ___threadid =
      ___threadid_ptr.asFunction<_dart___threadid>();

  int __threadhandle() {
    return ___threadhandle();
  }

  late final ___threadhandle_ptr =
      _lookup<ffi.NativeFunction<_c___threadhandle>>('__threadhandle');
  late final _dart___threadhandle ___threadhandle =
      ___threadhandle_ptr.asFunction<_dart___threadhandle>();

  ffi.Pointer<ffi.Void> SDL_malloc(
    int size,
  ) {
    return _SDL_malloc(
      size,
    );
  }

  late final _SDL_malloc_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_malloc>>('SDL_malloc');
  late final _dart_SDL_malloc _SDL_malloc =
      _SDL_malloc_ptr.asFunction<_dart_SDL_malloc>();

  ffi.Pointer<ffi.Void> SDL_calloc(
    int nmemb,
    int size,
  ) {
    return _SDL_calloc(
      nmemb,
      size,
    );
  }

  late final _SDL_calloc_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_calloc>>('SDL_calloc');
  late final _dart_SDL_calloc _SDL_calloc =
      _SDL_calloc_ptr.asFunction<_dart_SDL_calloc>();

  ffi.Pointer<ffi.Void> SDL_realloc(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_realloc(
      mem,
      size,
    );
  }

  late final _SDL_realloc_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_realloc>>('SDL_realloc');
  late final _dart_SDL_realloc _SDL_realloc =
      _SDL_realloc_ptr.asFunction<_dart_SDL_realloc>();

  void SDL_free(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _SDL_free(
      mem,
    );
  }

  late final _SDL_free_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_free>>('SDL_free');
  late final _dart_SDL_free _SDL_free =
      _SDL_free_ptr.asFunction<_dart_SDL_free>();

  /// \brief Get the current set of SDL memory functions
  void SDL_GetMemoryFunctions(
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_malloc_func>>> malloc_func,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_calloc_func>>> calloc_func,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_realloc_func>>> realloc_func,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_free_func>>> free_func,
  ) {
    return _SDL_GetMemoryFunctions(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_GetMemoryFunctions_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetMemoryFunctions>>(
          'SDL_GetMemoryFunctions');
  late final _dart_SDL_GetMemoryFunctions _SDL_GetMemoryFunctions =
      _SDL_GetMemoryFunctions_ptr.asFunction<_dart_SDL_GetMemoryFunctions>();

  /// \brief Replace SDL's memory allocation functions with a custom set
  ///
  /// \note If you are replacing SDL's memory functions, you should call
  /// SDL_GetNumAllocations() and be very careful if it returns non-zero.
  /// That means that your free function will be called with memory
  /// allocated by the previous memory allocation functions.
  int SDL_SetMemoryFunctions(
    ffi.Pointer<ffi.NativeFunction<SDL_malloc_func>> malloc_func,
    ffi.Pointer<ffi.NativeFunction<SDL_calloc_func>> calloc_func,
    ffi.Pointer<ffi.NativeFunction<SDL_realloc_func>> realloc_func,
    ffi.Pointer<ffi.NativeFunction<SDL_free_func>> free_func,
  ) {
    return _SDL_SetMemoryFunctions(
      malloc_func,
      calloc_func,
      realloc_func,
      free_func,
    );
  }

  late final _SDL_SetMemoryFunctions_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetMemoryFunctions>>(
          'SDL_SetMemoryFunctions');
  late final _dart_SDL_SetMemoryFunctions _SDL_SetMemoryFunctions =
      _SDL_SetMemoryFunctions_ptr.asFunction<_dart_SDL_SetMemoryFunctions>();

  /// \brief Get the number of outstanding (unfreed) allocations
  int SDL_GetNumAllocations() {
    return _SDL_GetNumAllocations();
  }

  late final _SDL_GetNumAllocations_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumAllocations>>(
          'SDL_GetNumAllocations');
  late final _dart_SDL_GetNumAllocations _SDL_GetNumAllocations =
      _SDL_GetNumAllocations_ptr.asFunction<_dart_SDL_GetNumAllocations>();

  ffi.Pointer<ffi.Int8> SDL_getenv(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_getenv(
      name,
    );
  }

  late final _SDL_getenv_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_getenv>>('SDL_getenv');
  late final _dart_SDL_getenv _SDL_getenv =
      _SDL_getenv_ptr.asFunction<_dart_SDL_getenv>();

  int SDL_setenv(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
    int overwrite,
  ) {
    return _SDL_setenv(
      name,
      value,
      overwrite,
    );
  }

  late final _SDL_setenv_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_setenv>>('SDL_setenv');
  late final _dart_SDL_setenv _SDL_setenv =
      _SDL_setenv_ptr.asFunction<_dart_SDL_setenv>();

  void SDL_qsort(
    ffi.Pointer<ffi.Void> base,
    int nmemb,
    int size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_1>> compare,
  ) {
    return _SDL_qsort(
      base,
      nmemb,
      size,
      compare,
    );
  }

  late final _SDL_qsort_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_qsort>>('SDL_qsort');
  late final _dart_SDL_qsort _SDL_qsort =
      _SDL_qsort_ptr.asFunction<_dart_SDL_qsort>();

  int SDL_abs(
    int x,
  ) {
    return _SDL_abs(
      x,
    );
  }

  late final _SDL_abs_ptr = _lookup<ffi.NativeFunction<_c_SDL_abs>>('SDL_abs');
  late final _dart_SDL_abs _SDL_abs = _SDL_abs_ptr.asFunction<_dart_SDL_abs>();

  int SDL_isdigit(
    int x,
  ) {
    return _SDL_isdigit(
      x,
    );
  }

  late final _SDL_isdigit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_isdigit>>('SDL_isdigit');
  late final _dart_SDL_isdigit _SDL_isdigit =
      _SDL_isdigit_ptr.asFunction<_dart_SDL_isdigit>();

  int SDL_isspace(
    int x,
  ) {
    return _SDL_isspace(
      x,
    );
  }

  late final _SDL_isspace_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_isspace>>('SDL_isspace');
  late final _dart_SDL_isspace _SDL_isspace =
      _SDL_isspace_ptr.asFunction<_dart_SDL_isspace>();

  int SDL_isupper(
    int x,
  ) {
    return _SDL_isupper(
      x,
    );
  }

  late final _SDL_isupper_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_isupper>>('SDL_isupper');
  late final _dart_SDL_isupper _SDL_isupper =
      _SDL_isupper_ptr.asFunction<_dart_SDL_isupper>();

  int SDL_islower(
    int x,
  ) {
    return _SDL_islower(
      x,
    );
  }

  late final _SDL_islower_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_islower>>('SDL_islower');
  late final _dart_SDL_islower _SDL_islower =
      _SDL_islower_ptr.asFunction<_dart_SDL_islower>();

  int SDL_toupper(
    int x,
  ) {
    return _SDL_toupper(
      x,
    );
  }

  late final _SDL_toupper_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_toupper>>('SDL_toupper');
  late final _dart_SDL_toupper _SDL_toupper =
      _SDL_toupper_ptr.asFunction<_dart_SDL_toupper>();

  int SDL_tolower(
    int x,
  ) {
    return _SDL_tolower(
      x,
    );
  }

  late final _SDL_tolower_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_tolower>>('SDL_tolower');
  late final _dart_SDL_tolower _SDL_tolower =
      _SDL_tolower_ptr.asFunction<_dart_SDL_tolower>();

  int SDL_crc32(
    int crc,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_crc32(
      crc,
      data,
      len,
    );
  }

  late final _SDL_crc32_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_crc32>>('SDL_crc32');
  late final _dart_SDL_crc32 _SDL_crc32 =
      _SDL_crc32_ptr.asFunction<_dart_SDL_crc32>();

  ffi.Pointer<ffi.Void> SDL_memset(
    ffi.Pointer<ffi.Void> dst,
    int c,
    int len,
  ) {
    return _SDL_memset(
      dst,
      c,
      len,
    );
  }

  late final _SDL_memset_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_memset>>('SDL_memset');
  late final _dart_SDL_memset _SDL_memset =
      _SDL_memset_ptr.asFunction<_dart_SDL_memset>();

  ffi.Pointer<ffi.Void> SDL_memcpy(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memcpy(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memcpy_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_memcpy>>('SDL_memcpy');
  late final _dart_SDL_memcpy _SDL_memcpy =
      _SDL_memcpy_ptr.asFunction<_dart_SDL_memcpy>();

  ffi.Pointer<ffi.Void> SDL_memmove(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Void> src,
    int len,
  ) {
    return _SDL_memmove(
      dst,
      src,
      len,
    );
  }

  late final _SDL_memmove_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_memmove>>('SDL_memmove');
  late final _dart_SDL_memmove _SDL_memmove =
      _SDL_memmove_ptr.asFunction<_dart_SDL_memmove>();

  int SDL_memcmp(
    ffi.Pointer<ffi.Void> s1,
    ffi.Pointer<ffi.Void> s2,
    int len,
  ) {
    return _SDL_memcmp(
      s1,
      s2,
      len,
    );
  }

  late final _SDL_memcmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_memcmp>>('SDL_memcmp');
  late final _dart_SDL_memcmp _SDL_memcmp =
      _SDL_memcmp_ptr.asFunction<_dart_SDL_memcmp>();

  int SDL_wcslen(
    ffi.Pointer<ffi.Uint16> wstr,
  ) {
    return _SDL_wcslen(
      wstr,
    );
  }

  late final _SDL_wcslen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcslen>>('SDL_wcslen');
  late final _dart_SDL_wcslen _SDL_wcslen =
      _SDL_wcslen_ptr.asFunction<_dart_SDL_wcslen>();

  int SDL_wcslcpy(
    ffi.Pointer<ffi.Uint16> dst,
    ffi.Pointer<ffi.Uint16> src,
    int maxlen,
  ) {
    return _SDL_wcslcpy(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcpy_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcslcpy>>('SDL_wcslcpy');
  late final _dart_SDL_wcslcpy _SDL_wcslcpy =
      _SDL_wcslcpy_ptr.asFunction<_dart_SDL_wcslcpy>();

  int SDL_wcslcat(
    ffi.Pointer<ffi.Uint16> dst,
    ffi.Pointer<ffi.Uint16> src,
    int maxlen,
  ) {
    return _SDL_wcslcat(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_wcslcat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcslcat>>('SDL_wcslcat');
  late final _dart_SDL_wcslcat _SDL_wcslcat =
      _SDL_wcslcat_ptr.asFunction<_dart_SDL_wcslcat>();

  ffi.Pointer<ffi.Uint16> SDL_wcsdup(
    ffi.Pointer<ffi.Uint16> wstr,
  ) {
    return _SDL_wcsdup(
      wstr,
    );
  }

  late final _SDL_wcsdup_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcsdup>>('SDL_wcsdup');
  late final _dart_SDL_wcsdup _SDL_wcsdup =
      _SDL_wcsdup_ptr.asFunction<_dart_SDL_wcsdup>();

  ffi.Pointer<ffi.Uint16> SDL_wcsstr(
    ffi.Pointer<ffi.Uint16> haystack,
    ffi.Pointer<ffi.Uint16> needle,
  ) {
    return _SDL_wcsstr(
      haystack,
      needle,
    );
  }

  late final _SDL_wcsstr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcsstr>>('SDL_wcsstr');
  late final _dart_SDL_wcsstr _SDL_wcsstr =
      _SDL_wcsstr_ptr.asFunction<_dart_SDL_wcsstr>();

  int SDL_wcscmp(
    ffi.Pointer<ffi.Uint16> str1,
    ffi.Pointer<ffi.Uint16> str2,
  ) {
    return _SDL_wcscmp(
      str1,
      str2,
    );
  }

  late final _SDL_wcscmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcscmp>>('SDL_wcscmp');
  late final _dart_SDL_wcscmp _SDL_wcscmp =
      _SDL_wcscmp_ptr.asFunction<_dart_SDL_wcscmp>();

  int SDL_wcsncmp(
    ffi.Pointer<ffi.Uint16> str1,
    ffi.Pointer<ffi.Uint16> str2,
    int maxlen,
  ) {
    return _SDL_wcsncmp(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_wcsncmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcsncmp>>('SDL_wcsncmp');
  late final _dart_SDL_wcsncmp _SDL_wcsncmp =
      _SDL_wcsncmp_ptr.asFunction<_dart_SDL_wcsncmp>();

  int SDL_wcscasecmp(
    ffi.Pointer<ffi.Uint16> str1,
    ffi.Pointer<ffi.Uint16> str2,
  ) {
    return _SDL_wcscasecmp(
      str1,
      str2,
    );
  }

  late final _SDL_wcscasecmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcscasecmp>>('SDL_wcscasecmp');
  late final _dart_SDL_wcscasecmp _SDL_wcscasecmp =
      _SDL_wcscasecmp_ptr.asFunction<_dart_SDL_wcscasecmp>();

  int SDL_wcsncasecmp(
    ffi.Pointer<ffi.Uint16> str1,
    ffi.Pointer<ffi.Uint16> str2,
    int len,
  ) {
    return _SDL_wcsncasecmp(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_wcsncasecmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_wcsncasecmp>>('SDL_wcsncasecmp');
  late final _dart_SDL_wcsncasecmp _SDL_wcsncasecmp =
      _SDL_wcsncasecmp_ptr.asFunction<_dart_SDL_wcsncasecmp>();

  int SDL_strlen(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strlen(
      str,
    );
  }

  late final _SDL_strlen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strlen>>('SDL_strlen');
  late final _dart_SDL_strlen _SDL_strlen =
      _SDL_strlen_ptr.asFunction<_dart_SDL_strlen>();

  int SDL_strlcpy(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int maxlen,
  ) {
    return _SDL_strlcpy(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcpy_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strlcpy>>('SDL_strlcpy');
  late final _dart_SDL_strlcpy _SDL_strlcpy =
      _SDL_strlcpy_ptr.asFunction<_dart_SDL_strlcpy>();

  int SDL_utf8strlcpy(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int dst_bytes,
  ) {
    return _SDL_utf8strlcpy(
      dst,
      src,
      dst_bytes,
    );
  }

  late final _SDL_utf8strlcpy_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_utf8strlcpy>>('SDL_utf8strlcpy');
  late final _dart_SDL_utf8strlcpy _SDL_utf8strlcpy =
      _SDL_utf8strlcpy_ptr.asFunction<_dart_SDL_utf8strlcpy>();

  int SDL_strlcat(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int maxlen,
  ) {
    return _SDL_strlcat(
      dst,
      src,
      maxlen,
    );
  }

  late final _SDL_strlcat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strlcat>>('SDL_strlcat');
  late final _dart_SDL_strlcat _SDL_strlcat =
      _SDL_strlcat_ptr.asFunction<_dart_SDL_strlcat>();

  ffi.Pointer<ffi.Int8> SDL_strdup(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strdup(
      str,
    );
  }

  late final _SDL_strdup_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strdup>>('SDL_strdup');
  late final _dart_SDL_strdup _SDL_strdup =
      _SDL_strdup_ptr.asFunction<_dart_SDL_strdup>();

  ffi.Pointer<ffi.Int8> SDL_strrev(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strrev(
      str,
    );
  }

  late final _SDL_strrev_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strrev>>('SDL_strrev');
  late final _dart_SDL_strrev _SDL_strrev =
      _SDL_strrev_ptr.asFunction<_dart_SDL_strrev>();

  ffi.Pointer<ffi.Int8> SDL_strupr(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strupr(
      str,
    );
  }

  late final _SDL_strupr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strupr>>('SDL_strupr');
  late final _dart_SDL_strupr _SDL_strupr =
      _SDL_strupr_ptr.asFunction<_dart_SDL_strupr>();

  ffi.Pointer<ffi.Int8> SDL_strlwr(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_strlwr(
      str,
    );
  }

  late final _SDL_strlwr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strlwr>>('SDL_strlwr');
  late final _dart_SDL_strlwr _SDL_strlwr =
      _SDL_strlwr_ptr.asFunction<_dart_SDL_strlwr>();

  ffi.Pointer<ffi.Int8> SDL_strchr(
    ffi.Pointer<ffi.Int8> str,
    int c,
  ) {
    return _SDL_strchr(
      str,
      c,
    );
  }

  late final _SDL_strchr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strchr>>('SDL_strchr');
  late final _dart_SDL_strchr _SDL_strchr =
      _SDL_strchr_ptr.asFunction<_dart_SDL_strchr>();

  ffi.Pointer<ffi.Int8> SDL_strrchr(
    ffi.Pointer<ffi.Int8> str,
    int c,
  ) {
    return _SDL_strrchr(
      str,
      c,
    );
  }

  late final _SDL_strrchr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strrchr>>('SDL_strrchr');
  late final _dart_SDL_strrchr _SDL_strrchr =
      _SDL_strrchr_ptr.asFunction<_dart_SDL_strrchr>();

  ffi.Pointer<ffi.Int8> SDL_strstr(
    ffi.Pointer<ffi.Int8> haystack,
    ffi.Pointer<ffi.Int8> needle,
  ) {
    return _SDL_strstr(
      haystack,
      needle,
    );
  }

  late final _SDL_strstr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strstr>>('SDL_strstr');
  late final _dart_SDL_strstr _SDL_strstr =
      _SDL_strstr_ptr.asFunction<_dart_SDL_strstr>();

  ffi.Pointer<ffi.Int8> SDL_strtokr(
    ffi.Pointer<ffi.Int8> s1,
    ffi.Pointer<ffi.Int8> s2,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
  ) {
    return _SDL_strtokr(
      s1,
      s2,
      saveptr,
    );
  }

  late final _SDL_strtokr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strtokr>>('SDL_strtokr');
  late final _dart_SDL_strtokr _SDL_strtokr =
      _SDL_strtokr_ptr.asFunction<_dart_SDL_strtokr>();

  int SDL_utf8strlen(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_utf8strlen(
      str,
    );
  }

  late final _SDL_utf8strlen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_utf8strlen>>('SDL_utf8strlen');
  late final _dart_SDL_utf8strlen _SDL_utf8strlen =
      _SDL_utf8strlen_ptr.asFunction<_dart_SDL_utf8strlen>();

  ffi.Pointer<ffi.Int8> SDL_itoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_itoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_itoa_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_itoa>>('SDL_itoa');
  late final _dart_SDL_itoa _SDL_itoa =
      _SDL_itoa_ptr.asFunction<_dart_SDL_itoa>();

  ffi.Pointer<ffi.Int8> SDL_uitoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_uitoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_uitoa_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_uitoa>>('SDL_uitoa');
  late final _dart_SDL_uitoa _SDL_uitoa =
      _SDL_uitoa_ptr.asFunction<_dart_SDL_uitoa>();

  ffi.Pointer<ffi.Int8> SDL_ltoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_ltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ltoa_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ltoa>>('SDL_ltoa');
  late final _dart_SDL_ltoa _SDL_ltoa =
      _SDL_ltoa_ptr.asFunction<_dart_SDL_ltoa>();

  ffi.Pointer<ffi.Int8> SDL_ultoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_ultoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ultoa_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ultoa>>('SDL_ultoa');
  late final _dart_SDL_ultoa _SDL_ultoa =
      _SDL_ultoa_ptr.asFunction<_dart_SDL_ultoa>();

  ffi.Pointer<ffi.Int8> SDL_lltoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_lltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_lltoa_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_lltoa>>('SDL_lltoa');
  late final _dart_SDL_lltoa _SDL_lltoa =
      _SDL_lltoa_ptr.asFunction<_dart_SDL_lltoa>();

  ffi.Pointer<ffi.Int8> SDL_ulltoa(
    int value,
    ffi.Pointer<ffi.Int8> str,
    int radix,
  ) {
    return _SDL_ulltoa(
      value,
      str,
      radix,
    );
  }

  late final _SDL_ulltoa_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ulltoa>>('SDL_ulltoa');
  late final _dart_SDL_ulltoa _SDL_ulltoa =
      _SDL_ulltoa_ptr.asFunction<_dart_SDL_ulltoa>();

  int SDL_atoi(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_atoi(
      str,
    );
  }

  late final _SDL_atoi_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_atoi>>('SDL_atoi');
  late final _dart_SDL_atoi _SDL_atoi =
      _SDL_atoi_ptr.asFunction<_dart_SDL_atoi>();

  double SDL_atof(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _SDL_atof(
      str,
    );
  }

  late final _SDL_atof_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_atof>>('SDL_atof');
  late final _dart_SDL_atof _SDL_atof =
      _SDL_atof_ptr.asFunction<_dart_SDL_atof>();

  int SDL_strtol(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtol(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtol_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strtol>>('SDL_strtol');
  late final _dart_SDL_strtol _SDL_strtol =
      _SDL_strtol_ptr.asFunction<_dart_SDL_strtol>();

  int SDL_strtoul(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtoul(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoul_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strtoul>>('SDL_strtoul');
  late final _dart_SDL_strtoul _SDL_strtoul =
      _SDL_strtoul_ptr.asFunction<_dart_SDL_strtoul>();

  int SDL_strtoll(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtoll(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoll_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strtoll>>('SDL_strtoll');
  late final _dart_SDL_strtoll _SDL_strtoll =
      _SDL_strtoll_ptr.asFunction<_dart_SDL_strtoll>();

  int SDL_strtoull(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
    int base,
  ) {
    return _SDL_strtoull(
      str,
      endp,
      base,
    );
  }

  late final _SDL_strtoull_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strtoull>>('SDL_strtoull');
  late final _dart_SDL_strtoull _SDL_strtoull =
      _SDL_strtoull_ptr.asFunction<_dart_SDL_strtoull>();

  double SDL_strtod(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  ) {
    return _SDL_strtod(
      str,
      endp,
    );
  }

  late final _SDL_strtod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strtod>>('SDL_strtod');
  late final _dart_SDL_strtod _SDL_strtod =
      _SDL_strtod_ptr.asFunction<_dart_SDL_strtod>();

  int SDL_strcmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
  ) {
    return _SDL_strcmp(
      str1,
      str2,
    );
  }

  late final _SDL_strcmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strcmp>>('SDL_strcmp');
  late final _dart_SDL_strcmp _SDL_strcmp =
      _SDL_strcmp_ptr.asFunction<_dart_SDL_strcmp>();

  int SDL_strncmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
    int maxlen,
  ) {
    return _SDL_strncmp(
      str1,
      str2,
      maxlen,
    );
  }

  late final _SDL_strncmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strncmp>>('SDL_strncmp');
  late final _dart_SDL_strncmp _SDL_strncmp =
      _SDL_strncmp_ptr.asFunction<_dart_SDL_strncmp>();

  int SDL_strcasecmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
  ) {
    return _SDL_strcasecmp(
      str1,
      str2,
    );
  }

  late final _SDL_strcasecmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strcasecmp>>('SDL_strcasecmp');
  late final _dart_SDL_strcasecmp _SDL_strcasecmp =
      _SDL_strcasecmp_ptr.asFunction<_dart_SDL_strcasecmp>();

  int SDL_strncasecmp(
    ffi.Pointer<ffi.Int8> str1,
    ffi.Pointer<ffi.Int8> str2,
    int len,
  ) {
    return _SDL_strncasecmp(
      str1,
      str2,
      len,
    );
  }

  late final _SDL_strncasecmp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_strncasecmp>>('SDL_strncasecmp');
  late final _dart_SDL_strncasecmp _SDL_strncasecmp =
      _SDL_strncasecmp_ptr.asFunction<_dart_SDL_strncasecmp>();

  int SDL_sscanf(
    ffi.Pointer<ffi.Int8> text,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_sscanf(
      text,
      fmt,
    );
  }

  late final _SDL_sscanf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_sscanf>>('SDL_sscanf');
  late final _dart_SDL_sscanf _SDL_sscanf =
      _SDL_sscanf_ptr.asFunction<_dart_SDL_sscanf>();

  int SDL_vsscanf(
    ffi.Pointer<ffi.Int8> text,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<ffi.Int8> ap,
  ) {
    return _SDL_vsscanf(
      text,
      fmt,
      ap,
    );
  }

  late final _SDL_vsscanf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_vsscanf>>('SDL_vsscanf');
  late final _dart_SDL_vsscanf _SDL_vsscanf =
      _SDL_vsscanf_ptr.asFunction<_dart_SDL_vsscanf>();

  int SDL_snprintf(
    ffi.Pointer<ffi.Int8> text,
    int maxlen,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_snprintf(
      text,
      maxlen,
      fmt,
    );
  }

  late final _SDL_snprintf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_snprintf>>('SDL_snprintf');
  late final _dart_SDL_snprintf _SDL_snprintf =
      _SDL_snprintf_ptr.asFunction<_dart_SDL_snprintf>();

  int SDL_vsnprintf(
    ffi.Pointer<ffi.Int8> text,
    int maxlen,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<ffi.Int8> ap,
  ) {
    return _SDL_vsnprintf(
      text,
      maxlen,
      fmt,
      ap,
    );
  }

  late final _SDL_vsnprintf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_vsnprintf>>('SDL_vsnprintf');
  late final _dart_SDL_vsnprintf _SDL_vsnprintf =
      _SDL_vsnprintf_ptr.asFunction<_dart_SDL_vsnprintf>();

  double SDL_acos(
    double x,
  ) {
    return _SDL_acos(
      x,
    );
  }

  late final _SDL_acos_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_acos>>('SDL_acos');
  late final _dart_SDL_acos _SDL_acos =
      _SDL_acos_ptr.asFunction<_dart_SDL_acos>();

  double SDL_acosf(
    double x,
  ) {
    return _SDL_acosf(
      x,
    );
  }

  late final _SDL_acosf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_acosf>>('SDL_acosf');
  late final _dart_SDL_acosf _SDL_acosf =
      _SDL_acosf_ptr.asFunction<_dart_SDL_acosf>();

  double SDL_asin(
    double x,
  ) {
    return _SDL_asin(
      x,
    );
  }

  late final _SDL_asin_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_asin>>('SDL_asin');
  late final _dart_SDL_asin _SDL_asin =
      _SDL_asin_ptr.asFunction<_dart_SDL_asin>();

  double SDL_asinf(
    double x,
  ) {
    return _SDL_asinf(
      x,
    );
  }

  late final _SDL_asinf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_asinf>>('SDL_asinf');
  late final _dart_SDL_asinf _SDL_asinf =
      _SDL_asinf_ptr.asFunction<_dart_SDL_asinf>();

  double SDL_atan(
    double x,
  ) {
    return _SDL_atan(
      x,
    );
  }

  late final _SDL_atan_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_atan>>('SDL_atan');
  late final _dart_SDL_atan _SDL_atan =
      _SDL_atan_ptr.asFunction<_dart_SDL_atan>();

  double SDL_atanf(
    double x,
  ) {
    return _SDL_atanf(
      x,
    );
  }

  late final _SDL_atanf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_atanf>>('SDL_atanf');
  late final _dart_SDL_atanf _SDL_atanf =
      _SDL_atanf_ptr.asFunction<_dart_SDL_atanf>();

  double SDL_atan2(
    double x,
    double y,
  ) {
    return _SDL_atan2(
      x,
      y,
    );
  }

  late final _SDL_atan2_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_atan2>>('SDL_atan2');
  late final _dart_SDL_atan2 _SDL_atan2 =
      _SDL_atan2_ptr.asFunction<_dart_SDL_atan2>();

  double SDL_atan2f(
    double x,
    double y,
  ) {
    return _SDL_atan2f(
      x,
      y,
    );
  }

  late final _SDL_atan2f_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_atan2f>>('SDL_atan2f');
  late final _dart_SDL_atan2f _SDL_atan2f =
      _SDL_atan2f_ptr.asFunction<_dart_SDL_atan2f>();

  double SDL_ceil(
    double x,
  ) {
    return _SDL_ceil(
      x,
    );
  }

  late final _SDL_ceil_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ceil>>('SDL_ceil');
  late final _dart_SDL_ceil _SDL_ceil =
      _SDL_ceil_ptr.asFunction<_dart_SDL_ceil>();

  double SDL_ceilf(
    double x,
  ) {
    return _SDL_ceilf(
      x,
    );
  }

  late final _SDL_ceilf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ceilf>>('SDL_ceilf');
  late final _dart_SDL_ceilf _SDL_ceilf =
      _SDL_ceilf_ptr.asFunction<_dart_SDL_ceilf>();

  double SDL_copysign(
    double x,
    double y,
  ) {
    return _SDL_copysign(
      x,
      y,
    );
  }

  late final _SDL_copysign_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_copysign>>('SDL_copysign');
  late final _dart_SDL_copysign _SDL_copysign =
      _SDL_copysign_ptr.asFunction<_dart_SDL_copysign>();

  double SDL_copysignf(
    double x,
    double y,
  ) {
    return _SDL_copysignf(
      x,
      y,
    );
  }

  late final _SDL_copysignf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_copysignf>>('SDL_copysignf');
  late final _dart_SDL_copysignf _SDL_copysignf =
      _SDL_copysignf_ptr.asFunction<_dart_SDL_copysignf>();

  double SDL_cos(
    double x,
  ) {
    return _SDL_cos(
      x,
    );
  }

  late final _SDL_cos_ptr = _lookup<ffi.NativeFunction<_c_SDL_cos>>('SDL_cos');
  late final _dart_SDL_cos _SDL_cos = _SDL_cos_ptr.asFunction<_dart_SDL_cos>();

  double SDL_cosf(
    double x,
  ) {
    return _SDL_cosf(
      x,
    );
  }

  late final _SDL_cosf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_cosf>>('SDL_cosf');
  late final _dart_SDL_cosf _SDL_cosf =
      _SDL_cosf_ptr.asFunction<_dart_SDL_cosf>();

  double SDL_exp(
    double x,
  ) {
    return _SDL_exp(
      x,
    );
  }

  late final _SDL_exp_ptr = _lookup<ffi.NativeFunction<_c_SDL_exp>>('SDL_exp');
  late final _dart_SDL_exp _SDL_exp = _SDL_exp_ptr.asFunction<_dart_SDL_exp>();

  double SDL_expf(
    double x,
  ) {
    return _SDL_expf(
      x,
    );
  }

  late final _SDL_expf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_expf>>('SDL_expf');
  late final _dart_SDL_expf _SDL_expf =
      _SDL_expf_ptr.asFunction<_dart_SDL_expf>();

  double SDL_fabs(
    double x,
  ) {
    return _SDL_fabs(
      x,
    );
  }

  late final _SDL_fabs_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_fabs>>('SDL_fabs');
  late final _dart_SDL_fabs _SDL_fabs =
      _SDL_fabs_ptr.asFunction<_dart_SDL_fabs>();

  double SDL_fabsf(
    double x,
  ) {
    return _SDL_fabsf(
      x,
    );
  }

  late final _SDL_fabsf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_fabsf>>('SDL_fabsf');
  late final _dart_SDL_fabsf _SDL_fabsf =
      _SDL_fabsf_ptr.asFunction<_dart_SDL_fabsf>();

  double SDL_floor(
    double x,
  ) {
    return _SDL_floor(
      x,
    );
  }

  late final _SDL_floor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_floor>>('SDL_floor');
  late final _dart_SDL_floor _SDL_floor =
      _SDL_floor_ptr.asFunction<_dart_SDL_floor>();

  double SDL_floorf(
    double x,
  ) {
    return _SDL_floorf(
      x,
    );
  }

  late final _SDL_floorf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_floorf>>('SDL_floorf');
  late final _dart_SDL_floorf _SDL_floorf =
      _SDL_floorf_ptr.asFunction<_dart_SDL_floorf>();

  double SDL_trunc(
    double x,
  ) {
    return _SDL_trunc(
      x,
    );
  }

  late final _SDL_trunc_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_trunc>>('SDL_trunc');
  late final _dart_SDL_trunc _SDL_trunc =
      _SDL_trunc_ptr.asFunction<_dart_SDL_trunc>();

  double SDL_truncf(
    double x,
  ) {
    return _SDL_truncf(
      x,
    );
  }

  late final _SDL_truncf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_truncf>>('SDL_truncf');
  late final _dart_SDL_truncf _SDL_truncf =
      _SDL_truncf_ptr.asFunction<_dart_SDL_truncf>();

  double SDL_fmod(
    double x,
    double y,
  ) {
    return _SDL_fmod(
      x,
      y,
    );
  }

  late final _SDL_fmod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_fmod>>('SDL_fmod');
  late final _dart_SDL_fmod _SDL_fmod =
      _SDL_fmod_ptr.asFunction<_dart_SDL_fmod>();

  double SDL_fmodf(
    double x,
    double y,
  ) {
    return _SDL_fmodf(
      x,
      y,
    );
  }

  late final _SDL_fmodf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_fmodf>>('SDL_fmodf');
  late final _dart_SDL_fmodf _SDL_fmodf =
      _SDL_fmodf_ptr.asFunction<_dart_SDL_fmodf>();

  double SDL_log(
    double x,
  ) {
    return _SDL_log(
      x,
    );
  }

  late final _SDL_log_ptr = _lookup<ffi.NativeFunction<_c_SDL_log>>('SDL_log');
  late final _dart_SDL_log _SDL_log = _SDL_log_ptr.asFunction<_dart_SDL_log>();

  double SDL_logf(
    double x,
  ) {
    return _SDL_logf(
      x,
    );
  }

  late final _SDL_logf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_logf>>('SDL_logf');
  late final _dart_SDL_logf _SDL_logf =
      _SDL_logf_ptr.asFunction<_dart_SDL_logf>();

  double SDL_log10(
    double x,
  ) {
    return _SDL_log10(
      x,
    );
  }

  late final _SDL_log10_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_log10>>('SDL_log10');
  late final _dart_SDL_log10 _SDL_log10 =
      _SDL_log10_ptr.asFunction<_dart_SDL_log10>();

  double SDL_log10f(
    double x,
  ) {
    return _SDL_log10f(
      x,
    );
  }

  late final _SDL_log10f_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_log10f>>('SDL_log10f');
  late final _dart_SDL_log10f _SDL_log10f =
      _SDL_log10f_ptr.asFunction<_dart_SDL_log10f>();

  double SDL_pow(
    double x,
    double y,
  ) {
    return _SDL_pow(
      x,
      y,
    );
  }

  late final _SDL_pow_ptr = _lookup<ffi.NativeFunction<_c_SDL_pow>>('SDL_pow');
  late final _dart_SDL_pow _SDL_pow = _SDL_pow_ptr.asFunction<_dart_SDL_pow>();

  double SDL_powf(
    double x,
    double y,
  ) {
    return _SDL_powf(
      x,
      y,
    );
  }

  late final _SDL_powf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_powf>>('SDL_powf');
  late final _dart_SDL_powf _SDL_powf =
      _SDL_powf_ptr.asFunction<_dart_SDL_powf>();

  double SDL_scalbn(
    double x,
    int n,
  ) {
    return _SDL_scalbn(
      x,
      n,
    );
  }

  late final _SDL_scalbn_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_scalbn>>('SDL_scalbn');
  late final _dart_SDL_scalbn _SDL_scalbn =
      _SDL_scalbn_ptr.asFunction<_dart_SDL_scalbn>();

  double SDL_scalbnf(
    double x,
    int n,
  ) {
    return _SDL_scalbnf(
      x,
      n,
    );
  }

  late final _SDL_scalbnf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_scalbnf>>('SDL_scalbnf');
  late final _dart_SDL_scalbnf _SDL_scalbnf =
      _SDL_scalbnf_ptr.asFunction<_dart_SDL_scalbnf>();

  double SDL_sin(
    double x,
  ) {
    return _SDL_sin(
      x,
    );
  }

  late final _SDL_sin_ptr = _lookup<ffi.NativeFunction<_c_SDL_sin>>('SDL_sin');
  late final _dart_SDL_sin _SDL_sin = _SDL_sin_ptr.asFunction<_dart_SDL_sin>();

  double SDL_sinf(
    double x,
  ) {
    return _SDL_sinf(
      x,
    );
  }

  late final _SDL_sinf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_sinf>>('SDL_sinf');
  late final _dart_SDL_sinf _SDL_sinf =
      _SDL_sinf_ptr.asFunction<_dart_SDL_sinf>();

  double SDL_sqrt(
    double x,
  ) {
    return _SDL_sqrt(
      x,
    );
  }

  late final _SDL_sqrt_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_sqrt>>('SDL_sqrt');
  late final _dart_SDL_sqrt _SDL_sqrt =
      _SDL_sqrt_ptr.asFunction<_dart_SDL_sqrt>();

  double SDL_sqrtf(
    double x,
  ) {
    return _SDL_sqrtf(
      x,
    );
  }

  late final _SDL_sqrtf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_sqrtf>>('SDL_sqrtf');
  late final _dart_SDL_sqrtf _SDL_sqrtf =
      _SDL_sqrtf_ptr.asFunction<_dart_SDL_sqrtf>();

  double SDL_tan(
    double x,
  ) {
    return _SDL_tan(
      x,
    );
  }

  late final _SDL_tan_ptr = _lookup<ffi.NativeFunction<_c_SDL_tan>>('SDL_tan');
  late final _dart_SDL_tan _SDL_tan = _SDL_tan_ptr.asFunction<_dart_SDL_tan>();

  double SDL_tanf(
    double x,
  ) {
    return _SDL_tanf(
      x,
    );
  }

  late final _SDL_tanf_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_tanf>>('SDL_tanf');
  late final _dart_SDL_tanf _SDL_tanf =
      _SDL_tanf_ptr.asFunction<_dart_SDL_tanf>();

  ffi.Pointer<_SDL_iconv_t> SDL_iconv_open(
    ffi.Pointer<ffi.Int8> tocode,
    ffi.Pointer<ffi.Int8> fromcode,
  ) {
    return _SDL_iconv_open(
      tocode,
      fromcode,
    );
  }

  late final _SDL_iconv_open_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_iconv_open>>('SDL_iconv_open');
  late final _dart_SDL_iconv_open _SDL_iconv_open =
      _SDL_iconv_open_ptr.asFunction<_dart_SDL_iconv_open>();

  int SDL_iconv_close(
    ffi.Pointer<_SDL_iconv_t> cd,
  ) {
    return _SDL_iconv_close(
      cd,
    );
  }

  late final _SDL_iconv_close_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_iconv_close>>('SDL_iconv_close');
  late final _dart_SDL_iconv_close _SDL_iconv_close =
      _SDL_iconv_close_ptr.asFunction<_dart_SDL_iconv_close>();

  int SDL_iconv(
    ffi.Pointer<_SDL_iconv_t> cd,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> inbuf,
    ffi.Pointer<ffi.Uint64> inbytesleft,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> outbuf,
    ffi.Pointer<ffi.Uint64> outbytesleft,
  ) {
    return _SDL_iconv(
      cd,
      inbuf,
      inbytesleft,
      outbuf,
      outbytesleft,
    );
  }

  late final _SDL_iconv_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_iconv>>('SDL_iconv');
  late final _dart_SDL_iconv _SDL_iconv =
      _SDL_iconv_ptr.asFunction<_dart_SDL_iconv>();

  /// This function converts a string between encodings in one pass, returning a
  /// string that must be freed with SDL_free() or NULL on error.
  ffi.Pointer<ffi.Int8> SDL_iconv_string(
    ffi.Pointer<ffi.Int8> tocode,
    ffi.Pointer<ffi.Int8> fromcode,
    ffi.Pointer<ffi.Int8> inbuf,
    int inbytesleft,
  ) {
    return _SDL_iconv_string(
      tocode,
      fromcode,
      inbuf,
      inbytesleft,
    );
  }

  late final _SDL_iconv_string_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_iconv_string>>('SDL_iconv_string');
  late final _dart_SDL_iconv_string _SDL_iconv_string =
      _SDL_iconv_string_ptr.asFunction<_dart_SDL_iconv_string>();

  int SDL_main(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ) {
    return _SDL_main(
      argc,
      argv,
    );
  }

  late final _SDL_main_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_main>>('SDL_main');
  late final _dart_SDL_main _SDL_main =
      _SDL_main_ptr.asFunction<_dart_SDL_main>();

  /// This is called by the real SDL main function to let the rest of the
  /// library know that initialization was done properly.
  ///
  /// Calling this yourself without knowing what you're doing can cause
  /// crashes and hard to diagnose problems with your application.
  void SDL_SetMainReady() {
    return _SDL_SetMainReady();
  }

  late final _SDL_SetMainReady_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetMainReady>>('SDL_SetMainReady');
  late final _dart_SDL_SetMainReady _SDL_SetMainReady =
      _SDL_SetMainReady_ptr.asFunction<_dart_SDL_SetMainReady>();

  /// This can be called to set the application class at startup
  int SDL_RegisterApp(
    ffi.Pointer<ffi.Int8> name,
    int style,
    ffi.Pointer<ffi.Void> hInst,
  ) {
    return _SDL_RegisterApp(
      name,
      style,
      hInst,
    );
  }

  late final _SDL_RegisterApp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RegisterApp>>('SDL_RegisterApp');
  late final _dart_SDL_RegisterApp _SDL_RegisterApp =
      _SDL_RegisterApp_ptr.asFunction<_dart_SDL_RegisterApp>();

  void SDL_UnregisterApp() {
    return _SDL_UnregisterApp();
  }

  late final _SDL_UnregisterApp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnregisterApp>>('SDL_UnregisterApp');
  late final _dart_SDL_UnregisterApp _SDL_UnregisterApp =
      _SDL_UnregisterApp_ptr.asFunction<_dart_SDL_UnregisterApp>();

  void __debugbreak() {
    return ___debugbreak();
  }

  late final ___debugbreak_ptr =
      _lookup<ffi.NativeFunction<_c___debugbreak>>('__debugbreak');
  late final _dart___debugbreak ___debugbreak =
      ___debugbreak_ptr.asFunction<_dart___debugbreak>();

  int SDL_ReportAssertion(
    ffi.Pointer<SDL_AssertData> arg0,
    ffi.Pointer<ffi.Int8> arg1,
    ffi.Pointer<ffi.Int8> arg2,
    int arg3,
  ) {
    return _SDL_ReportAssertion(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _SDL_ReportAssertion_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReportAssertion>>(
          'SDL_ReportAssertion');
  late final _dart_SDL_ReportAssertion _SDL_ReportAssertion =
      _SDL_ReportAssertion_ptr.asFunction<_dart_SDL_ReportAssertion>();

  /// \brief Set an application-defined assertion handler.
  ///
  /// This allows an app to show its own assertion UI and/or force the
  /// response to an assertion failure. If the app doesn't provide this, SDL
  /// will try to do the right thing, popping up a system-specific GUI dialog,
  /// and probably minimizing any fullscreen windows.
  ///
  /// This callback may fire from any thread, but it runs wrapped in a mutex, so
  /// it will only fire from one thread at a time.
  ///
  /// Setting the callback to NULL restores SDL's original internal handler.
  ///
  /// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
  ///
  /// Return SDL_AssertState value of how to handle the assertion failure.
  ///
  /// \param handler Callback function, called when an assertion fails.
  /// \param userdata A pointer passed to the callback as-is.
  void SDL_SetAssertionHandler(
    ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> handler,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetAssertionHandler(
      handler,
      userdata,
    );
  }

  late final _SDL_SetAssertionHandler_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetAssertionHandler>>(
          'SDL_SetAssertionHandler');
  late final _dart_SDL_SetAssertionHandler _SDL_SetAssertionHandler =
      _SDL_SetAssertionHandler_ptr.asFunction<_dart_SDL_SetAssertionHandler>();

  /// \brief Get the default assertion handler.
  ///
  /// This returns the function pointer that is called by default when an
  /// assertion is triggered. This is an internal function provided by SDL,
  /// that is used for assertions when SDL_SetAssertionHandler() hasn't been
  /// used to provide a different function.
  ///
  /// \return The default SDL_AssertionHandler that is called when an assert triggers.
  ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>>
      SDL_GetDefaultAssertionHandler() {
    return _SDL_GetDefaultAssertionHandler();
  }

  late final _SDL_GetDefaultAssertionHandler_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDefaultAssertionHandler>>(
          'SDL_GetDefaultAssertionHandler');
  late final _dart_SDL_GetDefaultAssertionHandler
      _SDL_GetDefaultAssertionHandler = _SDL_GetDefaultAssertionHandler_ptr
          .asFunction<_dart_SDL_GetDefaultAssertionHandler>();

  /// \brief Get the current assertion handler.
  ///
  /// This returns the function pointer that is called when an assertion is
  /// triggered. This is either the value last passed to
  /// SDL_SetAssertionHandler(), or if no application-specified function is
  /// set, is equivalent to calling SDL_GetDefaultAssertionHandler().
  ///
  /// \param puserdata Pointer to a void*, which will store the "userdata"
  /// pointer that was passed to SDL_SetAssertionHandler().
  /// This value will always be NULL for the default handler.
  /// If you don't care about this data, it is safe to pass
  /// a NULL pointer to this function to ignore it.
  /// \return The SDL_AssertionHandler that is called when an assert triggers.
  ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> SDL_GetAssertionHandler(
    ffi.Pointer<ffi.Pointer<ffi.Void>> puserdata,
  ) {
    return _SDL_GetAssertionHandler(
      puserdata,
    );
  }

  late final _SDL_GetAssertionHandler_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetAssertionHandler>>(
          'SDL_GetAssertionHandler');
  late final _dart_SDL_GetAssertionHandler _SDL_GetAssertionHandler =
      _SDL_GetAssertionHandler_ptr.asFunction<_dart_SDL_GetAssertionHandler>();

  /// \brief Get a list of all assertion failures.
  ///
  /// Get all assertions triggered since last call to SDL_ResetAssertionReport(),
  /// or the start of the program.
  ///
  /// The proper way to examine this data looks something like this:
  ///
  /// <code>
  /// const SDL_AssertData *item = SDL_GetAssertionReport();
  /// while (item) {
  /// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
  /// item->condition, item->function, item->filename,
  /// item->linenum, item->trigger_count,
  /// item->always_ignore ? "yes" : "no");
  /// item = item->next;
  /// }
  /// </code>
  ///
  /// \return List of all assertions.
  /// \sa SDL_ResetAssertionReport
  ffi.Pointer<SDL_AssertData> SDL_GetAssertionReport() {
    return _SDL_GetAssertionReport();
  }

  late final _SDL_GetAssertionReport_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetAssertionReport>>(
          'SDL_GetAssertionReport');
  late final _dart_SDL_GetAssertionReport _SDL_GetAssertionReport =
      _SDL_GetAssertionReport_ptr.asFunction<_dart_SDL_GetAssertionReport>();

  /// \brief Reset the list of all assertion failures.
  ///
  /// Reset list of all assertions triggered.
  ///
  /// \sa SDL_GetAssertionReport
  void SDL_ResetAssertionReport() {
    return _SDL_ResetAssertionReport();
  }

  late final _SDL_ResetAssertionReport_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ResetAssertionReport>>(
          'SDL_ResetAssertionReport');
  late final _dart_SDL_ResetAssertionReport _SDL_ResetAssertionReport =
      _SDL_ResetAssertionReport_ptr.asFunction<
          _dart_SDL_ResetAssertionReport>();

  /// \brief Try to lock a spin lock by setting it to a non-zero value.
  ///
  /// \param lock Points to the lock.
  ///
  /// \return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held.
  int SDL_AtomicTryLock(
    ffi.Pointer<ffi.Int32> lock,
  ) {
    return _SDL_AtomicTryLock(
      lock,
    );
  }

  late final _SDL_AtomicTryLock_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicTryLock>>('SDL_AtomicTryLock');
  late final _dart_SDL_AtomicTryLock _SDL_AtomicTryLock =
      _SDL_AtomicTryLock_ptr.asFunction<_dart_SDL_AtomicTryLock>();

  /// \brief Lock a spin lock by setting it to a non-zero value.
  ///
  /// \param lock Points to the lock.
  void SDL_AtomicLock(
    ffi.Pointer<ffi.Int32> lock,
  ) {
    return _SDL_AtomicLock(
      lock,
    );
  }

  late final _SDL_AtomicLock_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicLock>>('SDL_AtomicLock');
  late final _dart_SDL_AtomicLock _SDL_AtomicLock =
      _SDL_AtomicLock_ptr.asFunction<_dart_SDL_AtomicLock>();

  /// \brief Unlock a spin lock by setting it to 0. Always returns immediately
  ///
  /// \param lock Points to the lock.
  void SDL_AtomicUnlock(
    ffi.Pointer<ffi.Int32> lock,
  ) {
    return _SDL_AtomicUnlock(
      lock,
    );
  }

  late final _SDL_AtomicUnlock_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicUnlock>>('SDL_AtomicUnlock');
  late final _dart_SDL_AtomicUnlock _SDL_AtomicUnlock =
      _SDL_AtomicUnlock_ptr.asFunction<_dart_SDL_AtomicUnlock>();

  /// Memory barriers are designed to prevent reads and writes from being
  /// reordered by the compiler and being seen out of order on multi-core CPUs.
  ///
  /// A typical pattern would be for thread A to write some data and a flag,
  /// and for thread B to read the flag and get the data. In this case you
  /// would insert a release barrier between writing the data and the flag,
  /// guaranteeing that the data write completes no later than the flag is
  /// written, and you would insert an acquire barrier between reading the
  /// flag and reading the data, to ensure that all the reads associated
  /// with the flag have completed.
  ///
  /// In this pattern you should always see a release barrier paired with
  /// an acquire barrier and you should gate the data reads/writes with a
  /// single flag variable.
  ///
  /// For more information on these semantics, take a look at the blog post:
  /// http://preshing.com/20120913/acquire-and-release-semantics
  void SDL_MemoryBarrierReleaseFunction() {
    return _SDL_MemoryBarrierReleaseFunction();
  }

  late final _SDL_MemoryBarrierReleaseFunction_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MemoryBarrierReleaseFunction>>(
          'SDL_MemoryBarrierReleaseFunction');
  late final _dart_SDL_MemoryBarrierReleaseFunction
      _SDL_MemoryBarrierReleaseFunction = _SDL_MemoryBarrierReleaseFunction_ptr
          .asFunction<_dart_SDL_MemoryBarrierReleaseFunction>();

  void SDL_MemoryBarrierAcquireFunction() {
    return _SDL_MemoryBarrierAcquireFunction();
  }

  late final _SDL_MemoryBarrierAcquireFunction_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MemoryBarrierAcquireFunction>>(
          'SDL_MemoryBarrierAcquireFunction');
  late final _dart_SDL_MemoryBarrierAcquireFunction
      _SDL_MemoryBarrierAcquireFunction = _SDL_MemoryBarrierAcquireFunction_ptr
          .asFunction<_dart_SDL_MemoryBarrierAcquireFunction>();

  /// \brief Set an atomic variable to a new value if it is currently an old value.
  ///
  /// \return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
  ///
  /// \note If you don't know what this function is for, you shouldn't use it!
  int SDL_AtomicCAS(
    ffi.Pointer<SDL_atomic_t> a,
    int oldval,
    int newval,
  ) {
    return _SDL_AtomicCAS(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCAS_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicCAS>>('SDL_AtomicCAS');
  late final _dart_SDL_AtomicCAS _SDL_AtomicCAS =
      _SDL_AtomicCAS_ptr.asFunction<_dart_SDL_AtomicCAS>();

  /// \brief Set an atomic variable to a value.
  ///
  /// \return The previous value of the atomic variable.
  int SDL_AtomicSet(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicSet(
      a,
      v,
    );
  }

  late final _SDL_AtomicSet_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicSet>>('SDL_AtomicSet');
  late final _dart_SDL_AtomicSet _SDL_AtomicSet =
      _SDL_AtomicSet_ptr.asFunction<_dart_SDL_AtomicSet>();

  /// \brief Get the value of an atomic variable
  int SDL_AtomicGet(
    ffi.Pointer<SDL_atomic_t> a,
  ) {
    return _SDL_AtomicGet(
      a,
    );
  }

  late final _SDL_AtomicGet_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicGet>>('SDL_AtomicGet');
  late final _dart_SDL_AtomicGet _SDL_AtomicGet =
      _SDL_AtomicGet_ptr.asFunction<_dart_SDL_AtomicGet>();

  /// \brief Add to an atomic variable.
  ///
  /// \return The previous value of the atomic variable.
  ///
  /// \note This same style can be used for any number operation
  int SDL_AtomicAdd(
    ffi.Pointer<SDL_atomic_t> a,
    int v,
  ) {
    return _SDL_AtomicAdd(
      a,
      v,
    );
  }

  late final _SDL_AtomicAdd_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicAdd>>('SDL_AtomicAdd');
  late final _dart_SDL_AtomicAdd _SDL_AtomicAdd =
      _SDL_AtomicAdd_ptr.asFunction<_dart_SDL_AtomicAdd>();

  /// \brief Set a pointer to a new value if it is currently an old value.
  ///
  /// \return SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
  ///
  /// \note If you don't know what this function is for, you shouldn't use it!
  int SDL_AtomicCASPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> oldval,
    ffi.Pointer<ffi.Void> newval,
  ) {
    return _SDL_AtomicCASPtr(
      a,
      oldval,
      newval,
    );
  }

  late final _SDL_AtomicCASPtr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicCASPtr>>('SDL_AtomicCASPtr');
  late final _dart_SDL_AtomicCASPtr _SDL_AtomicCASPtr =
      _SDL_AtomicCASPtr_ptr.asFunction<_dart_SDL_AtomicCASPtr>();

  /// \brief Set a pointer to a value atomically.
  ///
  /// \return The previous value of the pointer.
  ffi.Pointer<ffi.Void> SDL_AtomicSetPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
    ffi.Pointer<ffi.Void> v,
  ) {
    return _SDL_AtomicSetPtr(
      a,
      v,
    );
  }

  late final _SDL_AtomicSetPtr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicSetPtr>>('SDL_AtomicSetPtr');
  late final _dart_SDL_AtomicSetPtr _SDL_AtomicSetPtr =
      _SDL_AtomicSetPtr_ptr.asFunction<_dart_SDL_AtomicSetPtr>();

  /// \brief Get the value of a pointer atomically.
  ffi.Pointer<ffi.Void> SDL_AtomicGetPtr(
    ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ) {
    return _SDL_AtomicGetPtr(
      a,
    );
  }

  late final _SDL_AtomicGetPtr_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AtomicGetPtr>>('SDL_AtomicGetPtr');
  late final _dart_SDL_AtomicGetPtr _SDL_AtomicGetPtr =
      _SDL_AtomicGetPtr_ptr.asFunction<_dart_SDL_AtomicGetPtr>();

  /// \brief Set the error message for the current thread
  ///
  /// \return -1, there is no error handling for this function
  int SDL_SetError(
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_SetError(
      fmt,
    );
  }

  late final _SDL_SetError_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetError>>('SDL_SetError');
  late final _dart_SDL_SetError _SDL_SetError =
      _SDL_SetError_ptr.asFunction<_dart_SDL_SetError>();

  /// \brief Get the last error message that was set
  ///
  /// SDL API functions may set error messages and then succeed, so you should
  /// only use the error value if a function fails.
  ///
  /// This returns a pointer to a static buffer for convenience and should not
  /// be called by multiple threads simultaneously.
  ///
  /// \return a pointer to the last error message that was set
  ffi.Pointer<ffi.Int8> SDL_GetError() {
    return _SDL_GetError();
  }

  late final _SDL_GetError_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetError>>('SDL_GetError');
  late final _dart_SDL_GetError _SDL_GetError =
      _SDL_GetError_ptr.asFunction<_dart_SDL_GetError>();

  /// \brief Get the last error message that was set for the current thread
  ///
  /// SDL API functions may set error messages and then succeed, so you should
  /// only use the error value if a function fails.
  ///
  /// \param errstr A buffer to fill with the last error message that was set
  /// for the current thread
  /// \param maxlen The size of the buffer pointed to by the errstr parameter
  ///
  /// \return errstr
  ffi.Pointer<ffi.Int8> SDL_GetErrorMsg(
    ffi.Pointer<ffi.Int8> errstr,
    int maxlen,
  ) {
    return _SDL_GetErrorMsg(
      errstr,
      maxlen,
    );
  }

  late final _SDL_GetErrorMsg_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetErrorMsg>>('SDL_GetErrorMsg');
  late final _dart_SDL_GetErrorMsg _SDL_GetErrorMsg =
      _SDL_GetErrorMsg_ptr.asFunction<_dart_SDL_GetErrorMsg>();

  /// \brief Clear the error message for the current thread
  void SDL_ClearError() {
    return _SDL_ClearError();
  }

  late final _SDL_ClearError_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ClearError>>('SDL_ClearError');
  late final _dart_SDL_ClearError _SDL_ClearError =
      _SDL_ClearError_ptr.asFunction<_dart_SDL_ClearError>();

  int SDL_Error(
    int code,
  ) {
    return _SDL_Error(
      code,
    );
  }

  late final _SDL_Error_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Error>>('SDL_Error');
  late final _dart_SDL_Error _SDL_Error =
      _SDL_Error_ptr.asFunction<_dart_SDL_Error>();

  /// Create a mutex, initialized unlocked.
  ffi.Pointer<SDL_mutex> SDL_CreateMutex() {
    return _SDL_CreateMutex();
  }

  late final _SDL_CreateMutex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateMutex>>('SDL_CreateMutex');
  late final _dart_SDL_CreateMutex _SDL_CreateMutex =
      _SDL_CreateMutex_ptr.asFunction<_dart_SDL_CreateMutex>();

  int SDL_LockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_LockMutex(
      mutex,
    );
  }

  late final _SDL_LockMutex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockMutex>>('SDL_LockMutex');
  late final _dart_SDL_LockMutex _SDL_LockMutex =
      _SDL_LockMutex_ptr.asFunction<_dart_SDL_LockMutex>();

  /// Try to lock the mutex
  ///
  /// \return 0, SDL_MUTEX_TIMEDOUT, or -1 on error
  int SDL_TryLockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_TryLockMutex(
      mutex,
    );
  }

  late final _SDL_TryLockMutex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_TryLockMutex>>('SDL_TryLockMutex');
  late final _dart_SDL_TryLockMutex _SDL_TryLockMutex =
      _SDL_TryLockMutex_ptr.asFunction<_dart_SDL_TryLockMutex>();

  int SDL_UnlockMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_UnlockMutex(
      mutex,
    );
  }

  late final _SDL_UnlockMutex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockMutex>>('SDL_UnlockMutex');
  late final _dart_SDL_UnlockMutex _SDL_UnlockMutex =
      _SDL_UnlockMutex_ptr.asFunction<_dart_SDL_UnlockMutex>();

  /// Destroy a mutex.
  void SDL_DestroyMutex(
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_DestroyMutex(
      mutex,
    );
  }

  late final _SDL_DestroyMutex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DestroyMutex>>('SDL_DestroyMutex');
  late final _dart_SDL_DestroyMutex _SDL_DestroyMutex =
      _SDL_DestroyMutex_ptr.asFunction<_dart_SDL_DestroyMutex>();

  /// Create a semaphore, initialized with value, returns NULL on failure.
  ffi.Pointer<SDL_semaphore> SDL_CreateSemaphore(
    int initial_value,
  ) {
    return _SDL_CreateSemaphore(
      initial_value,
    );
  }

  late final _SDL_CreateSemaphore_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateSemaphore>>(
          'SDL_CreateSemaphore');
  late final _dart_SDL_CreateSemaphore _SDL_CreateSemaphore =
      _SDL_CreateSemaphore_ptr.asFunction<_dart_SDL_CreateSemaphore>();

  /// Destroy a semaphore.
  void SDL_DestroySemaphore(
    ffi.Pointer<SDL_semaphore> sem,
  ) {
    return _SDL_DestroySemaphore(
      sem,
    );
  }

  late final _SDL_DestroySemaphore_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DestroySemaphore>>(
          'SDL_DestroySemaphore');
  late final _dart_SDL_DestroySemaphore _SDL_DestroySemaphore =
      _SDL_DestroySemaphore_ptr.asFunction<_dart_SDL_DestroySemaphore>();

  /// This function suspends the calling thread until the semaphore pointed
  /// to by \c sem has a positive count. It then atomically decreases the
  /// semaphore count.
  int SDL_SemWait(
    ffi.Pointer<SDL_semaphore> sem,
  ) {
    return _SDL_SemWait(
      sem,
    );
  }

  late final _SDL_SemWait_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SemWait>>('SDL_SemWait');
  late final _dart_SDL_SemWait _SDL_SemWait =
      _SDL_SemWait_ptr.asFunction<_dart_SDL_SemWait>();

  /// Non-blocking variant of SDL_SemWait().
  ///
  /// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would
  /// block, and -1 on error.
  int SDL_SemTryWait(
    ffi.Pointer<SDL_semaphore> sem,
  ) {
    return _SDL_SemTryWait(
      sem,
    );
  }

  late final _SDL_SemTryWait_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SemTryWait>>('SDL_SemTryWait');
  late final _dart_SDL_SemTryWait _SDL_SemTryWait =
      _SDL_SemTryWait_ptr.asFunction<_dart_SDL_SemTryWait>();

  /// Variant of SDL_SemWait() with a timeout in milliseconds.
  ///
  /// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not
  /// succeed in the allotted time, and -1 on error.
  ///
  /// \warning On some platforms this function is implemented by looping with a
  /// delay of 1 ms, and so should be avoided if possible.
  int SDL_SemWaitTimeout(
    ffi.Pointer<SDL_semaphore> sem,
    int ms,
  ) {
    return _SDL_SemWaitTimeout(
      sem,
      ms,
    );
  }

  late final _SDL_SemWaitTimeout_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SemWaitTimeout>>('SDL_SemWaitTimeout');
  late final _dart_SDL_SemWaitTimeout _SDL_SemWaitTimeout =
      _SDL_SemWaitTimeout_ptr.asFunction<_dart_SDL_SemWaitTimeout>();

  /// Atomically increases the semaphore's count (not blocking).
  ///
  /// \return 0, or -1 on error.
  int SDL_SemPost(
    ffi.Pointer<SDL_semaphore> sem,
  ) {
    return _SDL_SemPost(
      sem,
    );
  }

  late final _SDL_SemPost_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SemPost>>('SDL_SemPost');
  late final _dart_SDL_SemPost _SDL_SemPost =
      _SDL_SemPost_ptr.asFunction<_dart_SDL_SemPost>();

  /// Returns the current count of the semaphore.
  int SDL_SemValue(
    ffi.Pointer<SDL_semaphore> sem,
  ) {
    return _SDL_SemValue(
      sem,
    );
  }

  late final _SDL_SemValue_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SemValue>>('SDL_SemValue');
  late final _dart_SDL_SemValue _SDL_SemValue =
      _SDL_SemValue_ptr.asFunction<_dart_SDL_SemValue>();

  /// Create a condition variable.
  ///
  /// Typical use of condition variables:
  ///
  /// Thread A:
  /// SDL_LockMutex(lock);
  /// while ( ! condition ) {
  /// SDL_CondWait(cond, lock);
  /// }
  /// SDL_UnlockMutex(lock);
  ///
  /// Thread B:
  /// SDL_LockMutex(lock);
  /// ...
  /// condition = true;
  /// ...
  /// SDL_CondSignal(cond);
  /// SDL_UnlockMutex(lock);
  ///
  /// There is some discussion whether to signal the condition variable
  /// with the mutex locked or not.  There is some potential performance
  /// benefit to unlocking first on some platforms, but there are some
  /// potential race conditions depending on how your code is structured.
  ///
  /// In general it's safer to signal the condition variable while the
  /// mutex is locked.
  ffi.Pointer<SDL_cond> SDL_CreateCond() {
    return _SDL_CreateCond();
  }

  late final _SDL_CreateCond_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateCond>>('SDL_CreateCond');
  late final _dart_SDL_CreateCond _SDL_CreateCond =
      _SDL_CreateCond_ptr.asFunction<_dart_SDL_CreateCond>();

  /// Destroy a condition variable.
  void SDL_DestroyCond(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_DestroyCond(
      cond,
    );
  }

  late final _SDL_DestroyCond_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DestroyCond>>('SDL_DestroyCond');
  late final _dart_SDL_DestroyCond _SDL_DestroyCond =
      _SDL_DestroyCond_ptr.asFunction<_dart_SDL_DestroyCond>();

  /// Restart one of the threads that are waiting on the condition variable.
  ///
  /// \return 0 or -1 on error.
  int SDL_CondSignal(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondSignal(
      cond,
    );
  }

  late final _SDL_CondSignal_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CondSignal>>('SDL_CondSignal');
  late final _dart_SDL_CondSignal _SDL_CondSignal =
      _SDL_CondSignal_ptr.asFunction<_dart_SDL_CondSignal>();

  /// Restart all threads that are waiting on the condition variable.
  ///
  /// \return 0 or -1 on error.
  int SDL_CondBroadcast(
    ffi.Pointer<SDL_cond> cond,
  ) {
    return _SDL_CondBroadcast(
      cond,
    );
  }

  late final _SDL_CondBroadcast_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CondBroadcast>>('SDL_CondBroadcast');
  late final _dart_SDL_CondBroadcast _SDL_CondBroadcast =
      _SDL_CondBroadcast_ptr.asFunction<_dart_SDL_CondBroadcast>();

  /// Wait on the condition variable, unlocking the provided mutex.
  ///
  /// \warning The mutex must be locked before entering this function!
  ///
  /// The mutex is re-locked once the condition variable is signaled.
  ///
  /// \return 0 when it is signaled, or -1 on error.
  int SDL_CondWait(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
  ) {
    return _SDL_CondWait(
      cond,
      mutex,
    );
  }

  late final _SDL_CondWait_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CondWait>>('SDL_CondWait');
  late final _dart_SDL_CondWait _SDL_CondWait =
      _SDL_CondWait_ptr.asFunction<_dart_SDL_CondWait>();

  /// Waits for at most \c ms milliseconds, and returns 0 if the condition
  /// variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not
  /// signaled in the allotted time, and -1 on error.
  ///
  /// \warning On some platforms this function is implemented by looping with a
  /// delay of 1 ms, and so should be avoided if possible.
  int SDL_CondWaitTimeout(
    ffi.Pointer<SDL_cond> cond,
    ffi.Pointer<SDL_mutex> mutex,
    int ms,
  ) {
    return _SDL_CondWaitTimeout(
      cond,
      mutex,
      ms,
    );
  }

  late final _SDL_CondWaitTimeout_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CondWaitTimeout>>(
          'SDL_CondWaitTimeout');
  late final _dart_SDL_CondWaitTimeout _SDL_CondWaitTimeout =
      _SDL_CondWaitTimeout_ptr.asFunction<_dart_SDL_CondWaitTimeout>();

  late final ffi.Pointer<ffi.Double> __HUGE = _lookup<ffi.Double>('_HUGE');

  double get _HUGE => __HUGE.value;

  set _HUGE(double value) => __HUGE.value = value;

  void _fperrraise(
    int _Except,
  ) {
    return __fperrraise(
      _Except,
    );
  }

  late final __fperrraise_ptr =
      _lookup<ffi.NativeFunction<_c__fperrraise>>('_fperrraise');
  late final _dart__fperrraise __fperrraise =
      __fperrraise_ptr.asFunction<_dart__fperrraise>();

  int _dclass(
    double _X,
  ) {
    return __dclass(
      _X,
    );
  }

  late final __dclass_ptr = _lookup<ffi.NativeFunction<_c__dclass>>('_dclass');
  late final _dart__dclass __dclass = __dclass_ptr.asFunction<_dart__dclass>();

  int _fdclass(
    double _X,
  ) {
    return __fdclass(
      _X,
    );
  }

  late final __fdclass_ptr =
      _lookup<ffi.NativeFunction<_c__fdclass>>('_fdclass');
  late final _dart__fdclass __fdclass =
      __fdclass_ptr.asFunction<_dart__fdclass>();

  int _dsign(
    double _X,
  ) {
    return __dsign(
      _X,
    );
  }

  late final __dsign_ptr = _lookup<ffi.NativeFunction<_c__dsign>>('_dsign');
  late final _dart__dsign __dsign = __dsign_ptr.asFunction<_dart__dsign>();

  int _fdsign(
    double _X,
  ) {
    return __fdsign(
      _X,
    );
  }

  late final __fdsign_ptr = _lookup<ffi.NativeFunction<_c__fdsign>>('_fdsign');
  late final _dart__fdsign __fdsign = __fdsign_ptr.asFunction<_dart__fdsign>();

  int _dpcomp(
    double _X,
    double _Y,
  ) {
    return __dpcomp(
      _X,
      _Y,
    );
  }

  late final __dpcomp_ptr = _lookup<ffi.NativeFunction<_c__dpcomp>>('_dpcomp');
  late final _dart__dpcomp __dpcomp = __dpcomp_ptr.asFunction<_dart__dpcomp>();

  int _fdpcomp(
    double _X,
    double _Y,
  ) {
    return __fdpcomp(
      _X,
      _Y,
    );
  }

  late final __fdpcomp_ptr =
      _lookup<ffi.NativeFunction<_c__fdpcomp>>('_fdpcomp');
  late final _dart__fdpcomp __fdpcomp =
      __fdpcomp_ptr.asFunction<_dart__fdpcomp>();

  int _dtest(
    ffi.Pointer<ffi.Double> _Px,
  ) {
    return __dtest(
      _Px,
    );
  }

  late final __dtest_ptr = _lookup<ffi.NativeFunction<_c__dtest>>('_dtest');
  late final _dart__dtest __dtest = __dtest_ptr.asFunction<_dart__dtest>();

  int _fdtest(
    ffi.Pointer<ffi.Float> _Px,
  ) {
    return __fdtest(
      _Px,
    );
  }

  late final __fdtest_ptr = _lookup<ffi.NativeFunction<_c__fdtest>>('_fdtest');
  late final _dart__fdtest __fdtest = __fdtest_ptr.asFunction<_dart__fdtest>();

  int _d_int(
    ffi.Pointer<ffi.Double> _Px,
    int _Xexp,
  ) {
    return __d_int(
      _Px,
      _Xexp,
    );
  }

  late final __d_int_ptr = _lookup<ffi.NativeFunction<_c__d_int>>('_d_int');
  late final _dart__d_int __d_int = __d_int_ptr.asFunction<_dart__d_int>();

  int _fd_int(
    ffi.Pointer<ffi.Float> _Px,
    int _Xexp,
  ) {
    return __fd_int(
      _Px,
      _Xexp,
    );
  }

  late final __fd_int_ptr = _lookup<ffi.NativeFunction<_c__fd_int>>('_fd_int');
  late final _dart__fd_int __fd_int = __fd_int_ptr.asFunction<_dart__fd_int>();

  int _dscale(
    ffi.Pointer<ffi.Double> _Px,
    int _Lexp,
  ) {
    return __dscale(
      _Px,
      _Lexp,
    );
  }

  late final __dscale_ptr = _lookup<ffi.NativeFunction<_c__dscale>>('_dscale');
  late final _dart__dscale __dscale = __dscale_ptr.asFunction<_dart__dscale>();

  int _fdscale(
    ffi.Pointer<ffi.Float> _Px,
    int _Lexp,
  ) {
    return __fdscale(
      _Px,
      _Lexp,
    );
  }

  late final __fdscale_ptr =
      _lookup<ffi.NativeFunction<_c__fdscale>>('_fdscale');
  late final _dart__fdscale __fdscale =
      __fdscale_ptr.asFunction<_dart__fdscale>();

  int _dunscale(
    ffi.Pointer<ffi.Int16> _Pex,
    ffi.Pointer<ffi.Double> _Px,
  ) {
    return __dunscale(
      _Pex,
      _Px,
    );
  }

  late final __dunscale_ptr =
      _lookup<ffi.NativeFunction<_c__dunscale>>('_dunscale');
  late final _dart__dunscale __dunscale =
      __dunscale_ptr.asFunction<_dart__dunscale>();

  int _fdunscale(
    ffi.Pointer<ffi.Int16> _Pex,
    ffi.Pointer<ffi.Float> _Px,
  ) {
    return __fdunscale(
      _Pex,
      _Px,
    );
  }

  late final __fdunscale_ptr =
      _lookup<ffi.NativeFunction<_c__fdunscale>>('_fdunscale');
  late final _dart__fdunscale __fdunscale =
      __fdunscale_ptr.asFunction<_dart__fdunscale>();

  int _dexp(
    ffi.Pointer<ffi.Double> _Px,
    double _Y,
    int _Eoff,
  ) {
    return __dexp(
      _Px,
      _Y,
      _Eoff,
    );
  }

  late final __dexp_ptr = _lookup<ffi.NativeFunction<_c__dexp>>('_dexp');
  late final _dart__dexp __dexp = __dexp_ptr.asFunction<_dart__dexp>();

  int _fdexp(
    ffi.Pointer<ffi.Float> _Px,
    double _Y,
    int _Eoff,
  ) {
    return __fdexp(
      _Px,
      _Y,
      _Eoff,
    );
  }

  late final __fdexp_ptr = _lookup<ffi.NativeFunction<_c__fdexp>>('_fdexp');
  late final _dart__fdexp __fdexp = __fdexp_ptr.asFunction<_dart__fdexp>();

  int _dnorm(
    ffi.Pointer<ffi.Uint16> _Ps,
  ) {
    return __dnorm(
      _Ps,
    );
  }

  late final __dnorm_ptr = _lookup<ffi.NativeFunction<_c__dnorm>>('_dnorm');
  late final _dart__dnorm __dnorm = __dnorm_ptr.asFunction<_dart__dnorm>();

  int _fdnorm(
    ffi.Pointer<ffi.Uint16> _Ps,
  ) {
    return __fdnorm(
      _Ps,
    );
  }

  late final __fdnorm_ptr = _lookup<ffi.NativeFunction<_c__fdnorm>>('_fdnorm');
  late final _dart__fdnorm __fdnorm = __fdnorm_ptr.asFunction<_dart__fdnorm>();

  double _dpoly(
    double _X,
    ffi.Pointer<ffi.Double> _Tab,
    int _N,
  ) {
    return __dpoly(
      _X,
      _Tab,
      _N,
    );
  }

  late final __dpoly_ptr = _lookup<ffi.NativeFunction<_c__dpoly>>('_dpoly');
  late final _dart__dpoly __dpoly = __dpoly_ptr.asFunction<_dart__dpoly>();

  double _fdpoly(
    double _X,
    ffi.Pointer<ffi.Float> _Tab,
    int _N,
  ) {
    return __fdpoly(
      _X,
      _Tab,
      _N,
    );
  }

  late final __fdpoly_ptr = _lookup<ffi.NativeFunction<_c__fdpoly>>('_fdpoly');
  late final _dart__fdpoly __fdpoly = __fdpoly_ptr.asFunction<_dart__fdpoly>();

  double _dlog(
    double _X,
    int _Baseflag,
  ) {
    return __dlog(
      _X,
      _Baseflag,
    );
  }

  late final __dlog_ptr = _lookup<ffi.NativeFunction<_c__dlog>>('_dlog');
  late final _dart__dlog __dlog = __dlog_ptr.asFunction<_dart__dlog>();

  double _fdlog(
    double _X,
    int _Baseflag,
  ) {
    return __fdlog(
      _X,
      _Baseflag,
    );
  }

  late final __fdlog_ptr = _lookup<ffi.NativeFunction<_c__fdlog>>('_fdlog');
  late final _dart__fdlog __fdlog = __fdlog_ptr.asFunction<_dart__fdlog>();

  double _dsin(
    double _X,
    int _Qoff,
  ) {
    return __dsin(
      _X,
      _Qoff,
    );
  }

  late final __dsin_ptr = _lookup<ffi.NativeFunction<_c__dsin>>('_dsin');
  late final _dart__dsin __dsin = __dsin_ptr.asFunction<_dart__dsin>();

  double _fdsin(
    double _X,
    int _Qoff,
  ) {
    return __fdsin(
      _X,
      _Qoff,
    );
  }

  late final __fdsin_ptr = _lookup<ffi.NativeFunction<_c__fdsin>>('_fdsin');
  late final _dart__fdsin __fdsin = __fdsin_ptr.asFunction<_dart__fdsin>();

  late final ffi.Pointer<ffi.Double> __Zero_C = _lookup<ffi.Double>('_Zero_C');

  double get _Zero_C => __Zero_C.value;

  set _Zero_C(double value) => __Zero_C.value = value;

  late final ffi.Pointer<ffi.Double> __Xbig_C = _lookup<ffi.Double>('_Xbig_C');

  double get _Xbig_C => __Xbig_C.value;

  set _Xbig_C(double value) => __Xbig_C.value = value;

  late final ffi.Pointer<ffi.Float> __FZero_C = _lookup<ffi.Float>('_FZero_C');

  double get _FZero_C => __FZero_C.value;

  set _FZero_C(double value) => __FZero_C.value = value;

  late final ffi.Pointer<ffi.Float> __FXbig_C = _lookup<ffi.Float>('_FXbig_C');

  double get _FXbig_C => __FXbig_C.value;

  set _FXbig_C(double value) => __FXbig_C.value = value;

  int abs(
    int _X,
  ) {
    return _abs(
      _X,
    );
  }

  late final _abs_ptr = _lookup<ffi.NativeFunction<_c_abs>>('abs');
  late final _dart_abs _abs = _abs_ptr.asFunction<_dart_abs>();

  int labs(
    int _X,
  ) {
    return _labs(
      _X,
    );
  }

  late final _labs_ptr = _lookup<ffi.NativeFunction<_c_labs>>('labs');
  late final _dart_labs _labs = _labs_ptr.asFunction<_dart_labs>();

  int llabs(
    int _X,
  ) {
    return _llabs(
      _X,
    );
  }

  late final _llabs_ptr = _lookup<ffi.NativeFunction<_c_llabs>>('llabs');
  late final _dart_llabs _llabs = _llabs_ptr.asFunction<_dart_llabs>();

  double acos(
    double _X,
  ) {
    return _acos(
      _X,
    );
  }

  late final _acos_ptr = _lookup<ffi.NativeFunction<_c_acos>>('acos');
  late final _dart_acos _acos = _acos_ptr.asFunction<_dart_acos>();

  double asin(
    double _X,
  ) {
    return _asin(
      _X,
    );
  }

  late final _asin_ptr = _lookup<ffi.NativeFunction<_c_asin>>('asin');
  late final _dart_asin _asin = _asin_ptr.asFunction<_dart_asin>();

  double atan(
    double _X,
  ) {
    return _atan(
      _X,
    );
  }

  late final _atan_ptr = _lookup<ffi.NativeFunction<_c_atan>>('atan');
  late final _dart_atan _atan = _atan_ptr.asFunction<_dart_atan>();

  double atan2(
    double _Y,
    double _X,
  ) {
    return _atan2(
      _Y,
      _X,
    );
  }

  late final _atan2_ptr = _lookup<ffi.NativeFunction<_c_atan2>>('atan2');
  late final _dart_atan2 _atan2 = _atan2_ptr.asFunction<_dart_atan2>();

  double cos(
    double _X,
  ) {
    return _cos(
      _X,
    );
  }

  late final _cos_ptr = _lookup<ffi.NativeFunction<_c_cos>>('cos');
  late final _dart_cos _cos = _cos_ptr.asFunction<_dart_cos>();

  double cosh(
    double _X,
  ) {
    return _cosh(
      _X,
    );
  }

  late final _cosh_ptr = _lookup<ffi.NativeFunction<_c_cosh>>('cosh');
  late final _dart_cosh _cosh = _cosh_ptr.asFunction<_dart_cosh>();

  double exp(
    double _X,
  ) {
    return _exp(
      _X,
    );
  }

  late final _exp_ptr = _lookup<ffi.NativeFunction<_c_exp>>('exp');
  late final _dart_exp _exp = _exp_ptr.asFunction<_dart_exp>();

  double fabs(
    double _X,
  ) {
    return _fabs(
      _X,
    );
  }

  late final _fabs_ptr = _lookup<ffi.NativeFunction<_c_fabs>>('fabs');
  late final _dart_fabs _fabs = _fabs_ptr.asFunction<_dart_fabs>();

  double fmod(
    double _X,
    double _Y,
  ) {
    return _fmod(
      _X,
      _Y,
    );
  }

  late final _fmod_ptr = _lookup<ffi.NativeFunction<_c_fmod>>('fmod');
  late final _dart_fmod _fmod = _fmod_ptr.asFunction<_dart_fmod>();

  double log(
    double _X,
  ) {
    return _log(
      _X,
    );
  }

  late final _log_ptr = _lookup<ffi.NativeFunction<_c_log>>('log');
  late final _dart_log _log = _log_ptr.asFunction<_dart_log>();

  double log10(
    double _X,
  ) {
    return _log10(
      _X,
    );
  }

  late final _log10_ptr = _lookup<ffi.NativeFunction<_c_log10>>('log10');
  late final _dart_log10 _log10 = _log10_ptr.asFunction<_dart_log10>();

  double pow(
    double _X,
    double _Y,
  ) {
    return _pow(
      _X,
      _Y,
    );
  }

  late final _pow_ptr = _lookup<ffi.NativeFunction<_c_pow>>('pow');
  late final _dart_pow _pow = _pow_ptr.asFunction<_dart_pow>();

  double sin(
    double _X,
  ) {
    return _sin(
      _X,
    );
  }

  late final _sin_ptr = _lookup<ffi.NativeFunction<_c_sin>>('sin');
  late final _dart_sin _sin = _sin_ptr.asFunction<_dart_sin>();

  double sinh(
    double _X,
  ) {
    return _sinh(
      _X,
    );
  }

  late final _sinh_ptr = _lookup<ffi.NativeFunction<_c_sinh>>('sinh');
  late final _dart_sinh _sinh = _sinh_ptr.asFunction<_dart_sinh>();

  double sqrt(
    double _X,
  ) {
    return _sqrt(
      _X,
    );
  }

  late final _sqrt_ptr = _lookup<ffi.NativeFunction<_c_sqrt>>('sqrt');
  late final _dart_sqrt _sqrt = _sqrt_ptr.asFunction<_dart_sqrt>();

  double tan(
    double _X,
  ) {
    return _tan(
      _X,
    );
  }

  late final _tan_ptr = _lookup<ffi.NativeFunction<_c_tan>>('tan');
  late final _dart_tan _tan = _tan_ptr.asFunction<_dart_tan>();

  double tanh(
    double _X,
  ) {
    return _tanh(
      _X,
    );
  }

  late final _tanh_ptr = _lookup<ffi.NativeFunction<_c_tanh>>('tanh');
  late final _dart_tanh _tanh = _tanh_ptr.asFunction<_dart_tanh>();

  double acosh(
    double _X,
  ) {
    return _acosh(
      _X,
    );
  }

  late final _acosh_ptr = _lookup<ffi.NativeFunction<_c_acosh>>('acosh');
  late final _dart_acosh _acosh = _acosh_ptr.asFunction<_dart_acosh>();

  double asinh(
    double _X,
  ) {
    return _asinh(
      _X,
    );
  }

  late final _asinh_ptr = _lookup<ffi.NativeFunction<_c_asinh>>('asinh');
  late final _dart_asinh _asinh = _asinh_ptr.asFunction<_dart_asinh>();

  double atanh(
    double _X,
  ) {
    return _atanh(
      _X,
    );
  }

  late final _atanh_ptr = _lookup<ffi.NativeFunction<_c_atanh>>('atanh');
  late final _dart_atanh _atanh = _atanh_ptr.asFunction<_dart_atanh>();

  double atof(
    ffi.Pointer<ffi.Int8> _String,
  ) {
    return _atof(
      _String,
    );
  }

  late final _atof_ptr = _lookup<ffi.NativeFunction<_c_atof>>('atof');
  late final _dart_atof _atof = _atof_ptr.asFunction<_dart_atof>();

  double _atof_l(
    ffi.Pointer<ffi.Int8> _String,
    ffi.Pointer<__crt_locale_pointers> _Locale,
  ) {
    return __atof_l(
      _String,
      _Locale,
    );
  }

  late final __atof_l_ptr = _lookup<ffi.NativeFunction<_c__atof_l>>('_atof_l');
  late final _dart__atof_l __atof_l = __atof_l_ptr.asFunction<_dart__atof_l>();

  double _cabs(
    _complex _Complex_value,
  ) {
    return __cabs(
      _Complex_value,
    );
  }

  late final __cabs_ptr = _lookup<ffi.NativeFunction<_c__cabs>>('_cabs');
  late final _dart__cabs __cabs = __cabs_ptr.asFunction<_dart__cabs>();

  double cbrt(
    double _X,
  ) {
    return _cbrt(
      _X,
    );
  }

  late final _cbrt_ptr = _lookup<ffi.NativeFunction<_c_cbrt>>('cbrt');
  late final _dart_cbrt _cbrt = _cbrt_ptr.asFunction<_dart_cbrt>();

  double ceil(
    double _X,
  ) {
    return _ceil(
      _X,
    );
  }

  late final _ceil_ptr = _lookup<ffi.NativeFunction<_c_ceil>>('ceil');
  late final _dart_ceil _ceil = _ceil_ptr.asFunction<_dart_ceil>();

  double _chgsign(
    double _X,
  ) {
    return __chgsign(
      _X,
    );
  }

  late final __chgsign_ptr =
      _lookup<ffi.NativeFunction<_c__chgsign>>('_chgsign');
  late final _dart__chgsign __chgsign =
      __chgsign_ptr.asFunction<_dart__chgsign>();

  double copysign(
    double _Number,
    double _Sign,
  ) {
    return _copysign_1(
      _Number,
      _Sign,
    );
  }

  late final _copysign_ptr =
      _lookup<ffi.NativeFunction<_c_copysign>>('copysign');
  late final _dart_copysign _copysign_1 =
      _copysign_ptr.asFunction<_dart_copysign>();

  double _copysign(
    double _Number,
    double _Sign,
  ) {
    return __copysign(
      _Number,
      _Sign,
    );
  }

  late final __copysign_ptr =
      _lookup<ffi.NativeFunction<_c__copysign>>('_copysign');
  late final _dart__copysign __copysign =
      __copysign_ptr.asFunction<_dart__copysign>();

  double erf(
    double _X,
  ) {
    return _erf(
      _X,
    );
  }

  late final _erf_ptr = _lookup<ffi.NativeFunction<_c_erf>>('erf');
  late final _dart_erf _erf = _erf_ptr.asFunction<_dart_erf>();

  double erfc(
    double _X,
  ) {
    return _erfc(
      _X,
    );
  }

  late final _erfc_ptr = _lookup<ffi.NativeFunction<_c_erfc>>('erfc');
  late final _dart_erfc _erfc = _erfc_ptr.asFunction<_dart_erfc>();

  double exp2(
    double _X,
  ) {
    return _exp2(
      _X,
    );
  }

  late final _exp2_ptr = _lookup<ffi.NativeFunction<_c_exp2>>('exp2');
  late final _dart_exp2 _exp2 = _exp2_ptr.asFunction<_dart_exp2>();

  double expm1(
    double _X,
  ) {
    return _expm1(
      _X,
    );
  }

  late final _expm1_ptr = _lookup<ffi.NativeFunction<_c_expm1>>('expm1');
  late final _dart_expm1 _expm1 = _expm1_ptr.asFunction<_dart_expm1>();

  double fdim(
    double _X,
    double _Y,
  ) {
    return _fdim(
      _X,
      _Y,
    );
  }

  late final _fdim_ptr = _lookup<ffi.NativeFunction<_c_fdim>>('fdim');
  late final _dart_fdim _fdim = _fdim_ptr.asFunction<_dart_fdim>();

  double floor(
    double _X,
  ) {
    return _floor(
      _X,
    );
  }

  late final _floor_ptr = _lookup<ffi.NativeFunction<_c_floor>>('floor');
  late final _dart_floor _floor = _floor_ptr.asFunction<_dart_floor>();

  double fma(
    double _X,
    double _Y,
    double _Z,
  ) {
    return _fma(
      _X,
      _Y,
      _Z,
    );
  }

  late final _fma_ptr = _lookup<ffi.NativeFunction<_c_fma>>('fma');
  late final _dart_fma _fma = _fma_ptr.asFunction<_dart_fma>();

  double fmax(
    double _X,
    double _Y,
  ) {
    return _fmax(
      _X,
      _Y,
    );
  }

  late final _fmax_ptr = _lookup<ffi.NativeFunction<_c_fmax>>('fmax');
  late final _dart_fmax _fmax = _fmax_ptr.asFunction<_dart_fmax>();

  double fmin(
    double _X,
    double _Y,
  ) {
    return _fmin(
      _X,
      _Y,
    );
  }

  late final _fmin_ptr = _lookup<ffi.NativeFunction<_c_fmin>>('fmin');
  late final _dart_fmin _fmin = _fmin_ptr.asFunction<_dart_fmin>();

  double frexp(
    double _X,
    ffi.Pointer<ffi.Int32> _Y,
  ) {
    return _frexp(
      _X,
      _Y,
    );
  }

  late final _frexp_ptr = _lookup<ffi.NativeFunction<_c_frexp>>('frexp');
  late final _dart_frexp _frexp = _frexp_ptr.asFunction<_dart_frexp>();

  double hypot(
    double _X,
    double _Y,
  ) {
    return _hypot_1(
      _X,
      _Y,
    );
  }

  late final _hypot_ptr = _lookup<ffi.NativeFunction<_c_hypot>>('hypot');
  late final _dart_hypot _hypot_1 = _hypot_ptr.asFunction<_dart_hypot>();

  double _hypot(
    double _X,
    double _Y,
  ) {
    return __hypot(
      _X,
      _Y,
    );
  }

  late final __hypot_ptr = _lookup<ffi.NativeFunction<_c__hypot>>('_hypot');
  late final _dart__hypot __hypot = __hypot_ptr.asFunction<_dart__hypot>();

  int ilogb(
    double _X,
  ) {
    return _ilogb(
      _X,
    );
  }

  late final _ilogb_ptr = _lookup<ffi.NativeFunction<_c_ilogb>>('ilogb');
  late final _dart_ilogb _ilogb = _ilogb_ptr.asFunction<_dart_ilogb>();

  double ldexp(
    double _X,
    int _Y,
  ) {
    return _ldexp(
      _X,
      _Y,
    );
  }

  late final _ldexp_ptr = _lookup<ffi.NativeFunction<_c_ldexp>>('ldexp');
  late final _dart_ldexp _ldexp = _ldexp_ptr.asFunction<_dart_ldexp>();

  double lgamma(
    double _X,
  ) {
    return _lgamma(
      _X,
    );
  }

  late final _lgamma_ptr = _lookup<ffi.NativeFunction<_c_lgamma>>('lgamma');
  late final _dart_lgamma _lgamma = _lgamma_ptr.asFunction<_dart_lgamma>();

  int llrint(
    double _X,
  ) {
    return _llrint(
      _X,
    );
  }

  late final _llrint_ptr = _lookup<ffi.NativeFunction<_c_llrint>>('llrint');
  late final _dart_llrint _llrint = _llrint_ptr.asFunction<_dart_llrint>();

  int llround(
    double _X,
  ) {
    return _llround(
      _X,
    );
  }

  late final _llround_ptr = _lookup<ffi.NativeFunction<_c_llround>>('llround');
  late final _dart_llround _llround = _llround_ptr.asFunction<_dart_llround>();

  double log1p(
    double _X,
  ) {
    return _log1p(
      _X,
    );
  }

  late final _log1p_ptr = _lookup<ffi.NativeFunction<_c_log1p>>('log1p');
  late final _dart_log1p _log1p = _log1p_ptr.asFunction<_dart_log1p>();

  double log2(
    double _X,
  ) {
    return _log2(
      _X,
    );
  }

  late final _log2_ptr = _lookup<ffi.NativeFunction<_c_log2>>('log2');
  late final _dart_log2 _log2 = _log2_ptr.asFunction<_dart_log2>();

  double logb(
    double _X,
  ) {
    return _logb(
      _X,
    );
  }

  late final _logb_ptr = _lookup<ffi.NativeFunction<_c_logb>>('logb');
  late final _dart_logb _logb = _logb_ptr.asFunction<_dart_logb>();

  int lrint(
    double _X,
  ) {
    return _lrint(
      _X,
    );
  }

  late final _lrint_ptr = _lookup<ffi.NativeFunction<_c_lrint>>('lrint');
  late final _dart_lrint _lrint = _lrint_ptr.asFunction<_dart_lrint>();

  int lround(
    double _X,
  ) {
    return _lround(
      _X,
    );
  }

  late final _lround_ptr = _lookup<ffi.NativeFunction<_c_lround>>('lround');
  late final _dart_lround _lround = _lround_ptr.asFunction<_dart_lround>();

  int _matherr(
    ffi.Pointer<_exception> _Except,
  ) {
    return __matherr(
      _Except,
    );
  }

  late final __matherr_ptr =
      _lookup<ffi.NativeFunction<_c__matherr>>('_matherr');
  late final _dart__matherr __matherr =
      __matherr_ptr.asFunction<_dart__matherr>();

  double modf(
    double _X,
    ffi.Pointer<ffi.Double> _Y,
  ) {
    return _modf(
      _X,
      _Y,
    );
  }

  late final _modf_ptr = _lookup<ffi.NativeFunction<_c_modf>>('modf');
  late final _dart_modf _modf = _modf_ptr.asFunction<_dart_modf>();

  double nan(
    ffi.Pointer<ffi.Int8> _X,
  ) {
    return _nan(
      _X,
    );
  }

  late final _nan_ptr = _lookup<ffi.NativeFunction<_c_nan>>('nan');
  late final _dart_nan _nan = _nan_ptr.asFunction<_dart_nan>();

  double nearbyint(
    double _X,
  ) {
    return _nearbyint(
      _X,
    );
  }

  late final _nearbyint_ptr =
      _lookup<ffi.NativeFunction<_c_nearbyint>>('nearbyint');
  late final _dart_nearbyint _nearbyint =
      _nearbyint_ptr.asFunction<_dart_nearbyint>();

  double nextafter(
    double _X,
    double _Y,
  ) {
    return _nextafter(
      _X,
      _Y,
    );
  }

  late final _nextafter_ptr =
      _lookup<ffi.NativeFunction<_c_nextafter>>('nextafter');
  late final _dart_nextafter _nextafter =
      _nextafter_ptr.asFunction<_dart_nextafter>();

  double remainder(
    double _X,
    double _Y,
  ) {
    return _remainder(
      _X,
      _Y,
    );
  }

  late final _remainder_ptr =
      _lookup<ffi.NativeFunction<_c_remainder>>('remainder');
  late final _dart_remainder _remainder =
      _remainder_ptr.asFunction<_dart_remainder>();

  double remquo(
    double _X,
    double _Y,
    ffi.Pointer<ffi.Int32> _Z,
  ) {
    return _remquo(
      _X,
      _Y,
      _Z,
    );
  }

  late final _remquo_ptr = _lookup<ffi.NativeFunction<_c_remquo>>('remquo');
  late final _dart_remquo _remquo = _remquo_ptr.asFunction<_dart_remquo>();

  double rint(
    double _X,
  ) {
    return _rint(
      _X,
    );
  }

  late final _rint_ptr = _lookup<ffi.NativeFunction<_c_rint>>('rint');
  late final _dart_rint _rint = _rint_ptr.asFunction<_dart_rint>();

  double round(
    double _X,
  ) {
    return _round(
      _X,
    );
  }

  late final _round_ptr = _lookup<ffi.NativeFunction<_c_round>>('round');
  late final _dart_round _round = _round_ptr.asFunction<_dart_round>();

  double scalbln(
    double _X,
    int _Y,
  ) {
    return _scalbln(
      _X,
      _Y,
    );
  }

  late final _scalbln_ptr = _lookup<ffi.NativeFunction<_c_scalbln>>('scalbln');
  late final _dart_scalbln _scalbln = _scalbln_ptr.asFunction<_dart_scalbln>();

  double scalbn(
    double _X,
    int _Y,
  ) {
    return _scalbn(
      _X,
      _Y,
    );
  }

  late final _scalbn_ptr = _lookup<ffi.NativeFunction<_c_scalbn>>('scalbn');
  late final _dart_scalbn _scalbn = _scalbn_ptr.asFunction<_dart_scalbn>();

  double tgamma(
    double _X,
  ) {
    return _tgamma(
      _X,
    );
  }

  late final _tgamma_ptr = _lookup<ffi.NativeFunction<_c_tgamma>>('tgamma');
  late final _dart_tgamma _tgamma = _tgamma_ptr.asFunction<_dart_tgamma>();

  double trunc(
    double _X,
  ) {
    return _trunc(
      _X,
    );
  }

  late final _trunc_ptr = _lookup<ffi.NativeFunction<_c_trunc>>('trunc');
  late final _dart_trunc _trunc = _trunc_ptr.asFunction<_dart_trunc>();

  double _j0(
    double _X,
  ) {
    return __j0(
      _X,
    );
  }

  late final __j0_ptr = _lookup<ffi.NativeFunction<_c__j0>>('_j0');
  late final _dart__j0 __j0 = __j0_ptr.asFunction<_dart__j0>();

  double _j1(
    double _X,
  ) {
    return __j1(
      _X,
    );
  }

  late final __j1_ptr = _lookup<ffi.NativeFunction<_c__j1>>('_j1');
  late final _dart__j1 __j1 = __j1_ptr.asFunction<_dart__j1>();

  double _jn(
    int _X,
    double _Y,
  ) {
    return __jn(
      _X,
      _Y,
    );
  }

  late final __jn_ptr = _lookup<ffi.NativeFunction<_c__jn>>('_jn');
  late final _dart__jn __jn = __jn_ptr.asFunction<_dart__jn>();

  double _y0(
    double _X,
  ) {
    return __y0(
      _X,
    );
  }

  late final __y0_ptr = _lookup<ffi.NativeFunction<_c__y0>>('_y0');
  late final _dart__y0 __y0 = __y0_ptr.asFunction<_dart__y0>();

  double _y1(
    double _X,
  ) {
    return __y1(
      _X,
    );
  }

  late final __y1_ptr = _lookup<ffi.NativeFunction<_c__y1>>('_y1');
  late final _dart__y1 __y1 = __y1_ptr.asFunction<_dart__y1>();

  double _yn(
    int _X,
    double _Y,
  ) {
    return __yn(
      _X,
      _Y,
    );
  }

  late final __yn_ptr = _lookup<ffi.NativeFunction<_c__yn>>('_yn');
  late final _dart__yn __yn = __yn_ptr.asFunction<_dart__yn>();

  double acoshf(
    double _X,
  ) {
    return _acoshf(
      _X,
    );
  }

  late final _acoshf_ptr = _lookup<ffi.NativeFunction<_c_acoshf>>('acoshf');
  late final _dart_acoshf _acoshf = _acoshf_ptr.asFunction<_dart_acoshf>();

  double asinhf(
    double _X,
  ) {
    return _asinhf(
      _X,
    );
  }

  late final _asinhf_ptr = _lookup<ffi.NativeFunction<_c_asinhf>>('asinhf');
  late final _dart_asinhf _asinhf = _asinhf_ptr.asFunction<_dart_asinhf>();

  double atanhf(
    double _X,
  ) {
    return _atanhf(
      _X,
    );
  }

  late final _atanhf_ptr = _lookup<ffi.NativeFunction<_c_atanhf>>('atanhf');
  late final _dart_atanhf _atanhf = _atanhf_ptr.asFunction<_dart_atanhf>();

  double cbrtf(
    double _X,
  ) {
    return _cbrtf(
      _X,
    );
  }

  late final _cbrtf_ptr = _lookup<ffi.NativeFunction<_c_cbrtf>>('cbrtf');
  late final _dart_cbrtf _cbrtf = _cbrtf_ptr.asFunction<_dart_cbrtf>();

  double _chgsignf(
    double _X,
  ) {
    return __chgsignf(
      _X,
    );
  }

  late final __chgsignf_ptr =
      _lookup<ffi.NativeFunction<_c__chgsignf>>('_chgsignf');
  late final _dart__chgsignf __chgsignf =
      __chgsignf_ptr.asFunction<_dart__chgsignf>();

  double copysignf(
    double _Number,
    double _Sign,
  ) {
    return _copysignf_1(
      _Number,
      _Sign,
    );
  }

  late final _copysignf_ptr =
      _lookup<ffi.NativeFunction<_c_copysignf>>('copysignf');
  late final _dart_copysignf _copysignf_1 =
      _copysignf_ptr.asFunction<_dart_copysignf>();

  double _copysignf(
    double _Number,
    double _Sign,
  ) {
    return __copysignf(
      _Number,
      _Sign,
    );
  }

  late final __copysignf_ptr =
      _lookup<ffi.NativeFunction<_c__copysignf>>('_copysignf');
  late final _dart__copysignf __copysignf =
      __copysignf_ptr.asFunction<_dart__copysignf>();

  double erff(
    double _X,
  ) {
    return _erff(
      _X,
    );
  }

  late final _erff_ptr = _lookup<ffi.NativeFunction<_c_erff>>('erff');
  late final _dart_erff _erff = _erff_ptr.asFunction<_dart_erff>();

  double erfcf(
    double _X,
  ) {
    return _erfcf(
      _X,
    );
  }

  late final _erfcf_ptr = _lookup<ffi.NativeFunction<_c_erfcf>>('erfcf');
  late final _dart_erfcf _erfcf = _erfcf_ptr.asFunction<_dart_erfcf>();

  double expm1f(
    double _X,
  ) {
    return _expm1f(
      _X,
    );
  }

  late final _expm1f_ptr = _lookup<ffi.NativeFunction<_c_expm1f>>('expm1f');
  late final _dart_expm1f _expm1f = _expm1f_ptr.asFunction<_dart_expm1f>();

  double exp2f(
    double _X,
  ) {
    return _exp2f(
      _X,
    );
  }

  late final _exp2f_ptr = _lookup<ffi.NativeFunction<_c_exp2f>>('exp2f');
  late final _dart_exp2f _exp2f = _exp2f_ptr.asFunction<_dart_exp2f>();

  double fdimf(
    double _X,
    double _Y,
  ) {
    return _fdimf(
      _X,
      _Y,
    );
  }

  late final _fdimf_ptr = _lookup<ffi.NativeFunction<_c_fdimf>>('fdimf');
  late final _dart_fdimf _fdimf = _fdimf_ptr.asFunction<_dart_fdimf>();

  double fmaf(
    double _X,
    double _Y,
    double _Z,
  ) {
    return _fmaf(
      _X,
      _Y,
      _Z,
    );
  }

  late final _fmaf_ptr = _lookup<ffi.NativeFunction<_c_fmaf>>('fmaf');
  late final _dart_fmaf _fmaf = _fmaf_ptr.asFunction<_dart_fmaf>();

  double fmaxf(
    double _X,
    double _Y,
  ) {
    return _fmaxf(
      _X,
      _Y,
    );
  }

  late final _fmaxf_ptr = _lookup<ffi.NativeFunction<_c_fmaxf>>('fmaxf');
  late final _dart_fmaxf _fmaxf = _fmaxf_ptr.asFunction<_dart_fmaxf>();

  double fminf(
    double _X,
    double _Y,
  ) {
    return _fminf(
      _X,
      _Y,
    );
  }

  late final _fminf_ptr = _lookup<ffi.NativeFunction<_c_fminf>>('fminf');
  late final _dart_fminf _fminf = _fminf_ptr.asFunction<_dart_fminf>();

  double _hypotf(
    double _X,
    double _Y,
  ) {
    return __hypotf(
      _X,
      _Y,
    );
  }

  late final __hypotf_ptr = _lookup<ffi.NativeFunction<_c__hypotf>>('_hypotf');
  late final _dart__hypotf __hypotf = __hypotf_ptr.asFunction<_dart__hypotf>();

  int ilogbf(
    double _X,
  ) {
    return _ilogbf(
      _X,
    );
  }

  late final _ilogbf_ptr = _lookup<ffi.NativeFunction<_c_ilogbf>>('ilogbf');
  late final _dart_ilogbf _ilogbf = _ilogbf_ptr.asFunction<_dart_ilogbf>();

  double lgammaf(
    double _X,
  ) {
    return _lgammaf(
      _X,
    );
  }

  late final _lgammaf_ptr = _lookup<ffi.NativeFunction<_c_lgammaf>>('lgammaf');
  late final _dart_lgammaf _lgammaf = _lgammaf_ptr.asFunction<_dart_lgammaf>();

  int llrintf(
    double _X,
  ) {
    return _llrintf(
      _X,
    );
  }

  late final _llrintf_ptr = _lookup<ffi.NativeFunction<_c_llrintf>>('llrintf');
  late final _dart_llrintf _llrintf = _llrintf_ptr.asFunction<_dart_llrintf>();

  int llroundf(
    double _X,
  ) {
    return _llroundf(
      _X,
    );
  }

  late final _llroundf_ptr =
      _lookup<ffi.NativeFunction<_c_llroundf>>('llroundf');
  late final _dart_llroundf _llroundf =
      _llroundf_ptr.asFunction<_dart_llroundf>();

  double log1pf(
    double _X,
  ) {
    return _log1pf(
      _X,
    );
  }

  late final _log1pf_ptr = _lookup<ffi.NativeFunction<_c_log1pf>>('log1pf');
  late final _dart_log1pf _log1pf = _log1pf_ptr.asFunction<_dart_log1pf>();

  double log2f(
    double _X,
  ) {
    return _log2f(
      _X,
    );
  }

  late final _log2f_ptr = _lookup<ffi.NativeFunction<_c_log2f>>('log2f');
  late final _dart_log2f _log2f = _log2f_ptr.asFunction<_dart_log2f>();

  double logbf(
    double _X,
  ) {
    return _logbf_1(
      _X,
    );
  }

  late final _logbf_ptr = _lookup<ffi.NativeFunction<_c_logbf>>('logbf');
  late final _dart_logbf _logbf_1 = _logbf_ptr.asFunction<_dart_logbf>();

  int lrintf(
    double _X,
  ) {
    return _lrintf(
      _X,
    );
  }

  late final _lrintf_ptr = _lookup<ffi.NativeFunction<_c_lrintf>>('lrintf');
  late final _dart_lrintf _lrintf = _lrintf_ptr.asFunction<_dart_lrintf>();

  int lroundf(
    double _X,
  ) {
    return _lroundf(
      _X,
    );
  }

  late final _lroundf_ptr = _lookup<ffi.NativeFunction<_c_lroundf>>('lroundf');
  late final _dart_lroundf _lroundf = _lroundf_ptr.asFunction<_dart_lroundf>();

  double nanf(
    ffi.Pointer<ffi.Int8> _X,
  ) {
    return _nanf(
      _X,
    );
  }

  late final _nanf_ptr = _lookup<ffi.NativeFunction<_c_nanf>>('nanf');
  late final _dart_nanf _nanf = _nanf_ptr.asFunction<_dart_nanf>();

  double nearbyintf(
    double _X,
  ) {
    return _nearbyintf(
      _X,
    );
  }

  late final _nearbyintf_ptr =
      _lookup<ffi.NativeFunction<_c_nearbyintf>>('nearbyintf');
  late final _dart_nearbyintf _nearbyintf =
      _nearbyintf_ptr.asFunction<_dart_nearbyintf>();

  double nextafterf(
    double _X,
    double _Y,
  ) {
    return _nextafterf_1(
      _X,
      _Y,
    );
  }

  late final _nextafterf_ptr =
      _lookup<ffi.NativeFunction<_c_nextafterf>>('nextafterf');
  late final _dart_nextafterf _nextafterf_1 =
      _nextafterf_ptr.asFunction<_dart_nextafterf>();

  double remainderf(
    double _X,
    double _Y,
  ) {
    return _remainderf(
      _X,
      _Y,
    );
  }

  late final _remainderf_ptr =
      _lookup<ffi.NativeFunction<_c_remainderf>>('remainderf');
  late final _dart_remainderf _remainderf =
      _remainderf_ptr.asFunction<_dart_remainderf>();

  double remquof(
    double _X,
    double _Y,
    ffi.Pointer<ffi.Int32> _Z,
  ) {
    return _remquof(
      _X,
      _Y,
      _Z,
    );
  }

  late final _remquof_ptr = _lookup<ffi.NativeFunction<_c_remquof>>('remquof');
  late final _dart_remquof _remquof = _remquof_ptr.asFunction<_dart_remquof>();

  double rintf(
    double _X,
  ) {
    return _rintf(
      _X,
    );
  }

  late final _rintf_ptr = _lookup<ffi.NativeFunction<_c_rintf>>('rintf');
  late final _dart_rintf _rintf = _rintf_ptr.asFunction<_dart_rintf>();

  double roundf(
    double _X,
  ) {
    return _roundf(
      _X,
    );
  }

  late final _roundf_ptr = _lookup<ffi.NativeFunction<_c_roundf>>('roundf');
  late final _dart_roundf _roundf = _roundf_ptr.asFunction<_dart_roundf>();

  double scalblnf(
    double _X,
    int _Y,
  ) {
    return _scalblnf(
      _X,
      _Y,
    );
  }

  late final _scalblnf_ptr =
      _lookup<ffi.NativeFunction<_c_scalblnf>>('scalblnf');
  late final _dart_scalblnf _scalblnf =
      _scalblnf_ptr.asFunction<_dart_scalblnf>();

  double scalbnf(
    double _X,
    int _Y,
  ) {
    return _scalbnf(
      _X,
      _Y,
    );
  }

  late final _scalbnf_ptr = _lookup<ffi.NativeFunction<_c_scalbnf>>('scalbnf');
  late final _dart_scalbnf _scalbnf = _scalbnf_ptr.asFunction<_dart_scalbnf>();

  double tgammaf(
    double _X,
  ) {
    return _tgammaf(
      _X,
    );
  }

  late final _tgammaf_ptr = _lookup<ffi.NativeFunction<_c_tgammaf>>('tgammaf');
  late final _dart_tgammaf _tgammaf = _tgammaf_ptr.asFunction<_dart_tgammaf>();

  double truncf(
    double _X,
  ) {
    return _truncf(
      _X,
    );
  }

  late final _truncf_ptr = _lookup<ffi.NativeFunction<_c_truncf>>('truncf');
  late final _dart_truncf _truncf = _truncf_ptr.asFunction<_dart_truncf>();

  double _logbf(
    double _X,
  ) {
    return __logbf(
      _X,
    );
  }

  late final __logbf_ptr = _lookup<ffi.NativeFunction<_c__logbf>>('_logbf');
  late final _dart__logbf __logbf = __logbf_ptr.asFunction<_dart__logbf>();

  double _nextafterf(
    double _X,
    double _Y,
  ) {
    return __nextafterf(
      _X,
      _Y,
    );
  }

  late final __nextafterf_ptr =
      _lookup<ffi.NativeFunction<_c__nextafterf>>('_nextafterf');
  late final _dart__nextafterf __nextafterf =
      __nextafterf_ptr.asFunction<_dart__nextafterf>();

  int _finitef(
    double _X,
  ) {
    return __finitef(
      _X,
    );
  }

  late final __finitef_ptr =
      _lookup<ffi.NativeFunction<_c__finitef>>('_finitef');
  late final _dart__finitef __finitef =
      __finitef_ptr.asFunction<_dart__finitef>();

  int _isnanf(
    double _X,
  ) {
    return __isnanf(
      _X,
    );
  }

  late final __isnanf_ptr = _lookup<ffi.NativeFunction<_c__isnanf>>('_isnanf');
  late final _dart__isnanf __isnanf = __isnanf_ptr.asFunction<_dart__isnanf>();

  int _fpclassf(
    double _X,
  ) {
    return __fpclassf(
      _X,
    );
  }

  late final __fpclassf_ptr =
      _lookup<ffi.NativeFunction<_c__fpclassf>>('_fpclassf');
  late final _dart__fpclassf __fpclassf =
      __fpclassf_ptr.asFunction<_dart__fpclassf>();

  int _set_FMA3_enable(
    int _Flag,
  ) {
    return __set_FMA3_enable(
      _Flag,
    );
  }

  late final __set_FMA3_enable_ptr =
      _lookup<ffi.NativeFunction<_c__set_FMA3_enable>>('_set_FMA3_enable');
  late final _dart__set_FMA3_enable __set_FMA3_enable =
      __set_FMA3_enable_ptr.asFunction<_dart__set_FMA3_enable>();

  int _get_FMA3_enable() {
    return __get_FMA3_enable();
  }

  late final __get_FMA3_enable_ptr =
      _lookup<ffi.NativeFunction<_c__get_FMA3_enable>>('_get_FMA3_enable');
  late final _dart__get_FMA3_enable __get_FMA3_enable =
      __get_FMA3_enable_ptr.asFunction<_dart__get_FMA3_enable>();

  double acosf(
    double _X,
  ) {
    return _acosf(
      _X,
    );
  }

  late final _acosf_ptr = _lookup<ffi.NativeFunction<_c_acosf>>('acosf');
  late final _dart_acosf _acosf = _acosf_ptr.asFunction<_dart_acosf>();

  double asinf(
    double _X,
  ) {
    return _asinf(
      _X,
    );
  }

  late final _asinf_ptr = _lookup<ffi.NativeFunction<_c_asinf>>('asinf');
  late final _dart_asinf _asinf = _asinf_ptr.asFunction<_dart_asinf>();

  double atan2f(
    double _Y,
    double _X,
  ) {
    return _atan2f(
      _Y,
      _X,
    );
  }

  late final _atan2f_ptr = _lookup<ffi.NativeFunction<_c_atan2f>>('atan2f');
  late final _dart_atan2f _atan2f = _atan2f_ptr.asFunction<_dart_atan2f>();

  double atanf(
    double _X,
  ) {
    return _atanf(
      _X,
    );
  }

  late final _atanf_ptr = _lookup<ffi.NativeFunction<_c_atanf>>('atanf');
  late final _dart_atanf _atanf = _atanf_ptr.asFunction<_dart_atanf>();

  double ceilf(
    double _X,
  ) {
    return _ceilf(
      _X,
    );
  }

  late final _ceilf_ptr = _lookup<ffi.NativeFunction<_c_ceilf>>('ceilf');
  late final _dart_ceilf _ceilf = _ceilf_ptr.asFunction<_dart_ceilf>();

  double cosf(
    double _X,
  ) {
    return _cosf(
      _X,
    );
  }

  late final _cosf_ptr = _lookup<ffi.NativeFunction<_c_cosf>>('cosf');
  late final _dart_cosf _cosf = _cosf_ptr.asFunction<_dart_cosf>();

  double coshf(
    double _X,
  ) {
    return _coshf(
      _X,
    );
  }

  late final _coshf_ptr = _lookup<ffi.NativeFunction<_c_coshf>>('coshf');
  late final _dart_coshf _coshf = _coshf_ptr.asFunction<_dart_coshf>();

  double expf(
    double _X,
  ) {
    return _expf(
      _X,
    );
  }

  late final _expf_ptr = _lookup<ffi.NativeFunction<_c_expf>>('expf');
  late final _dart_expf _expf = _expf_ptr.asFunction<_dart_expf>();

  double floorf(
    double _X,
  ) {
    return _floorf(
      _X,
    );
  }

  late final _floorf_ptr = _lookup<ffi.NativeFunction<_c_floorf>>('floorf');
  late final _dart_floorf _floorf = _floorf_ptr.asFunction<_dart_floorf>();

  double fmodf(
    double _X,
    double _Y,
  ) {
    return _fmodf(
      _X,
      _Y,
    );
  }

  late final _fmodf_ptr = _lookup<ffi.NativeFunction<_c_fmodf>>('fmodf');
  late final _dart_fmodf _fmodf = _fmodf_ptr.asFunction<_dart_fmodf>();

  double log10f(
    double _X,
  ) {
    return _log10f(
      _X,
    );
  }

  late final _log10f_ptr = _lookup<ffi.NativeFunction<_c_log10f>>('log10f');
  late final _dart_log10f _log10f = _log10f_ptr.asFunction<_dart_log10f>();

  double logf(
    double _X,
  ) {
    return _logf(
      _X,
    );
  }

  late final _logf_ptr = _lookup<ffi.NativeFunction<_c_logf>>('logf');
  late final _dart_logf _logf = _logf_ptr.asFunction<_dart_logf>();

  double modff(
    double _X,
    ffi.Pointer<ffi.Float> _Y,
  ) {
    return _modff(
      _X,
      _Y,
    );
  }

  late final _modff_ptr = _lookup<ffi.NativeFunction<_c_modff>>('modff');
  late final _dart_modff _modff = _modff_ptr.asFunction<_dart_modff>();

  double powf(
    double _X,
    double _Y,
  ) {
    return _powf(
      _X,
      _Y,
    );
  }

  late final _powf_ptr = _lookup<ffi.NativeFunction<_c_powf>>('powf');
  late final _dart_powf _powf = _powf_ptr.asFunction<_dart_powf>();

  double sinf(
    double _X,
  ) {
    return _sinf(
      _X,
    );
  }

  late final _sinf_ptr = _lookup<ffi.NativeFunction<_c_sinf>>('sinf');
  late final _dart_sinf _sinf = _sinf_ptr.asFunction<_dart_sinf>();

  double sinhf(
    double _X,
  ) {
    return _sinhf(
      _X,
    );
  }

  late final _sinhf_ptr = _lookup<ffi.NativeFunction<_c_sinhf>>('sinhf');
  late final _dart_sinhf _sinhf = _sinhf_ptr.asFunction<_dart_sinhf>();

  double sqrtf(
    double _X,
  ) {
    return _sqrtf(
      _X,
    );
  }

  late final _sqrtf_ptr = _lookup<ffi.NativeFunction<_c_sqrtf>>('sqrtf');
  late final _dart_sqrtf _sqrtf = _sqrtf_ptr.asFunction<_dart_sqrtf>();

  double tanf(
    double _X,
  ) {
    return _tanf(
      _X,
    );
  }

  late final _tanf_ptr = _lookup<ffi.NativeFunction<_c_tanf>>('tanf');
  late final _dart_tanf _tanf = _tanf_ptr.asFunction<_dart_tanf>();

  double tanhf(
    double _X,
  ) {
    return _tanhf(
      _X,
    );
  }

  late final _tanhf_ptr = _lookup<ffi.NativeFunction<_c_tanhf>>('tanhf');
  late final _dart_tanhf _tanhf = _tanhf_ptr.asFunction<_dart_tanhf>();

  late final ffi.Pointer<ffi.Double> _HUGE_1 = _lookup<ffi.Double>('HUGE');

  double get HUGE => _HUGE_1.value;

  set HUGE(double value) => _HUGE_1.value = value;

  double j0(
    double _X,
  ) {
    return _j0_1(
      _X,
    );
  }

  late final _j0_ptr = _lookup<ffi.NativeFunction<_c_j0>>('j0');
  late final _dart_j0 _j0_1 = _j0_ptr.asFunction<_dart_j0>();

  double j1(
    double _X,
  ) {
    return _j1_1(
      _X,
    );
  }

  late final _j1_ptr = _lookup<ffi.NativeFunction<_c_j1>>('j1');
  late final _dart_j1 _j1_1 = _j1_ptr.asFunction<_dart_j1>();

  double jn(
    int _X,
    double _Y,
  ) {
    return _jn_1(
      _X,
      _Y,
    );
  }

  late final _jn_ptr = _lookup<ffi.NativeFunction<_c_jn>>('jn');
  late final _dart_jn _jn_1 = _jn_ptr.asFunction<_dart_jn>();

  double y0(
    double _X,
  ) {
    return _y0_1(
      _X,
    );
  }

  late final _y0_ptr = _lookup<ffi.NativeFunction<_c_y0>>('y0');
  late final _dart_y0 _y0_1 = _y0_ptr.asFunction<_dart_y0>();

  double y1(
    double _X,
  ) {
    return _y1_1(
      _X,
    );
  }

  late final _y1_ptr = _lookup<ffi.NativeFunction<_c_y1>>('y1');
  late final _dart_y1 _y1_1 = _y1_ptr.asFunction<_dart_y1>();

  double yn(
    int _X,
    double _Y,
  ) {
    return _yn_1(
      _X,
      _Y,
    );
  }

  late final _yn_ptr = _lookup<ffi.NativeFunction<_c_yn>>('yn');
  late final _dart_yn _yn_1 = _yn_ptr.asFunction<_dart_yn>();

  late final ffi.Pointer<ffi.Int32> ___current_exit_return_mode =
      _lookup<ffi.Int32>('__current_exit_return_mode');

  int get __current_exit_return_mode => ___current_exit_return_mode.value;

  set __current_exit_return_mode(int value) =>
      ___current_exit_return_mode.value = value;

  bool __vcrt_initialize() {
    return ___vcrt_initialize() != 0;
  }

  late final ___vcrt_initialize_ptr =
      _lookup<ffi.NativeFunction<_c___vcrt_initialize>>('__vcrt_initialize');
  late final _dart___vcrt_initialize ___vcrt_initialize =
      ___vcrt_initialize_ptr.asFunction<_dart___vcrt_initialize>();

  bool __vcrt_uninitialize(
    bool _Terminating,
  ) {
    return ___vcrt_uninitialize(
          _Terminating ? 1 : 0,
        ) !=
        0;
  }

  late final ___vcrt_uninitialize_ptr =
      _lookup<ffi.NativeFunction<_c___vcrt_uninitialize>>(
          '__vcrt_uninitialize');
  late final _dart___vcrt_uninitialize ___vcrt_uninitialize =
      ___vcrt_uninitialize_ptr.asFunction<_dart___vcrt_uninitialize>();

  bool __vcrt_uninitialize_critical() {
    return ___vcrt_uninitialize_critical() != 0;
  }

  late final ___vcrt_uninitialize_critical_ptr =
      _lookup<ffi.NativeFunction<_c___vcrt_uninitialize_critical>>(
          '__vcrt_uninitialize_critical');
  late final _dart___vcrt_uninitialize_critical ___vcrt_uninitialize_critical =
      ___vcrt_uninitialize_critical_ptr
          .asFunction<_dart___vcrt_uninitialize_critical>();

  bool __vcrt_thread_attach() {
    return ___vcrt_thread_attach() != 0;
  }

  late final ___vcrt_thread_attach_ptr =
      _lookup<ffi.NativeFunction<_c___vcrt_thread_attach>>(
          '__vcrt_thread_attach');
  late final _dart___vcrt_thread_attach ___vcrt_thread_attach =
      ___vcrt_thread_attach_ptr.asFunction<_dart___vcrt_thread_attach>();

  bool __vcrt_thread_detach() {
    return ___vcrt_thread_detach() != 0;
  }

  late final ___vcrt_thread_detach_ptr =
      _lookup<ffi.NativeFunction<_c___vcrt_thread_detach>>(
          '__vcrt_thread_detach');
  late final _dart___vcrt_thread_detach ___vcrt_thread_detach =
      ___vcrt_thread_detach_ptr.asFunction<_dart___vcrt_thread_detach>();

  int __isa_available_init() {
    return ___isa_available_init();
  }

  late final ___isa_available_init_ptr =
      _lookup<ffi.NativeFunction<_c___isa_available_init>>(
          '__isa_available_init');
  late final _dart___isa_available_init ___isa_available_init =
      ___isa_available_init_ptr.asFunction<_dart___isa_available_init>();

  int _get_startup_argv_mode() {
    return __get_startup_argv_mode();
  }

  late final __get_startup_argv_mode_ptr =
      _lookup<ffi.NativeFunction<_c__get_startup_argv_mode>>(
          '_get_startup_argv_mode');
  late final _dart__get_startup_argv_mode __get_startup_argv_mode =
      __get_startup_argv_mode_ptr.asFunction<_dart__get_startup_argv_mode>();

  int _seh_filter_dll(
    int _ExceptionNum,
    ffi.Pointer<_EXCEPTION_POINTERS> _ExceptionPtr,
  ) {
    return __seh_filter_dll(
      _ExceptionNum,
      _ExceptionPtr,
    );
  }

  late final __seh_filter_dll_ptr =
      _lookup<ffi.NativeFunction<_c__seh_filter_dll>>('_seh_filter_dll');
  late final _dart__seh_filter_dll __seh_filter_dll =
      __seh_filter_dll_ptr.asFunction<_dart__seh_filter_dll>();

  int _seh_filter_exe(
    int _ExceptionNum,
    ffi.Pointer<_EXCEPTION_POINTERS> _ExceptionPtr,
  ) {
    return __seh_filter_exe(
      _ExceptionNum,
      _ExceptionPtr,
    );
  }

  late final __seh_filter_exe_ptr =
      _lookup<ffi.NativeFunction<_c__seh_filter_exe>>('_seh_filter_exe');
  late final _dart__seh_filter_exe __seh_filter_exe =
      __seh_filter_exe_ptr.asFunction<_dart__seh_filter_exe>();

  int _query_app_type() {
    return __query_app_type();
  }

  late final __query_app_type_ptr =
      _lookup<ffi.NativeFunction<_c__query_app_type>>('_query_app_type');
  late final _dart__query_app_type __query_app_type =
      __query_app_type_ptr.asFunction<_dart__query_app_type>();

  void _set_app_type(
    int _Type,
  ) {
    return __set_app_type(
      _Type,
    );
  }

  late final __set_app_type_ptr =
      _lookup<ffi.NativeFunction<_c__set_app_type>>('_set_app_type');
  late final _dart__set_app_type __set_app_type =
      __set_app_type_ptr.asFunction<_dart__set_app_type>();

  void __setusermatherr(
    ffi.Pointer<ffi.NativeFunction<_UserMathErrorFunctionPointer>>
        _UserMathErrorFunction,
  ) {
    return ___setusermatherr(
      _UserMathErrorFunction,
    );
  }

  late final ___setusermatherr_ptr =
      _lookup<ffi.NativeFunction<_c___setusermatherr>>('__setusermatherr');
  late final _dart___setusermatherr ___setusermatherr =
      ___setusermatherr_ptr.asFunction<_dart___setusermatherr>();

  int _is_c_termination_complete() {
    return __is_c_termination_complete();
  }

  late final __is_c_termination_complete_ptr =
      _lookup<ffi.NativeFunction<_c__is_c_termination_complete>>(
          '_is_c_termination_complete');
  late final _dart__is_c_termination_complete __is_c_termination_complete =
      __is_c_termination_complete_ptr
          .asFunction<_dart__is_c_termination_complete>();

  int _configure_narrow_argv(
    int mode,
  ) {
    return __configure_narrow_argv(
      mode,
    );
  }

  late final __configure_narrow_argv_ptr =
      _lookup<ffi.NativeFunction<_c__configure_narrow_argv>>(
          '_configure_narrow_argv');
  late final _dart__configure_narrow_argv __configure_narrow_argv =
      __configure_narrow_argv_ptr.asFunction<_dart__configure_narrow_argv>();

  int _configure_wide_argv(
    int mode,
  ) {
    return __configure_wide_argv(
      mode,
    );
  }

  late final __configure_wide_argv_ptr =
      _lookup<ffi.NativeFunction<_c__configure_wide_argv>>(
          '_configure_wide_argv');
  late final _dart__configure_wide_argv __configure_wide_argv =
      __configure_wide_argv_ptr.asFunction<_dart__configure_wide_argv>();

  int _initialize_narrow_environment() {
    return __initialize_narrow_environment();
  }

  late final __initialize_narrow_environment_ptr =
      _lookup<ffi.NativeFunction<_c__initialize_narrow_environment>>(
          '_initialize_narrow_environment');
  late final _dart__initialize_narrow_environment
      __initialize_narrow_environment = __initialize_narrow_environment_ptr
          .asFunction<_dart__initialize_narrow_environment>();

  int _initialize_wide_environment() {
    return __initialize_wide_environment();
  }

  late final __initialize_wide_environment_ptr =
      _lookup<ffi.NativeFunction<_c__initialize_wide_environment>>(
          '_initialize_wide_environment');
  late final _dart__initialize_wide_environment __initialize_wide_environment =
      __initialize_wide_environment_ptr
          .asFunction<_dart__initialize_wide_environment>();

  ffi.Pointer<ffi.Pointer<ffi.Int8>> _get_initial_narrow_environment() {
    return __get_initial_narrow_environment();
  }

  late final __get_initial_narrow_environment_ptr =
      _lookup<ffi.NativeFunction<_c__get_initial_narrow_environment>>(
          '_get_initial_narrow_environment');
  late final _dart__get_initial_narrow_environment
      __get_initial_narrow_environment = __get_initial_narrow_environment_ptr
          .asFunction<_dart__get_initial_narrow_environment>();

  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _get_initial_wide_environment() {
    return __get_initial_wide_environment();
  }

  late final __get_initial_wide_environment_ptr =
      _lookup<ffi.NativeFunction<_c__get_initial_wide_environment>>(
          '_get_initial_wide_environment');
  late final _dart__get_initial_wide_environment
      __get_initial_wide_environment = __get_initial_wide_environment_ptr
          .asFunction<_dart__get_initial_wide_environment>();

  ffi.Pointer<ffi.Int8> _get_narrow_winmain_command_line() {
    return __get_narrow_winmain_command_line();
  }

  late final __get_narrow_winmain_command_line_ptr =
      _lookup<ffi.NativeFunction<_c__get_narrow_winmain_command_line>>(
          '_get_narrow_winmain_command_line');
  late final _dart__get_narrow_winmain_command_line
      __get_narrow_winmain_command_line = __get_narrow_winmain_command_line_ptr
          .asFunction<_dart__get_narrow_winmain_command_line>();

  ffi.Pointer<ffi.Uint16> _get_wide_winmain_command_line() {
    return __get_wide_winmain_command_line();
  }

  late final __get_wide_winmain_command_line_ptr =
      _lookup<ffi.NativeFunction<_c__get_wide_winmain_command_line>>(
          '_get_wide_winmain_command_line');
  late final _dart__get_wide_winmain_command_line
      __get_wide_winmain_command_line = __get_wide_winmain_command_line_ptr
          .asFunction<_dart__get_wide_winmain_command_line>();

  ffi.Pointer<ffi.Pointer<ffi.Int8>> __p__acmdln() {
    return ___p__acmdln();
  }

  late final ___p__acmdln_ptr =
      _lookup<ffi.NativeFunction<_c___p__acmdln>>('__p__acmdln');
  late final _dart___p__acmdln ___p__acmdln =
      ___p__acmdln_ptr.asFunction<_dart___p__acmdln>();

  ffi.Pointer<ffi.Pointer<ffi.Uint16>> __p__wcmdln() {
    return ___p__wcmdln();
  }

  late final ___p__wcmdln_ptr =
      _lookup<ffi.NativeFunction<_c___p__wcmdln>>('__p__wcmdln');
  late final _dart___p__wcmdln ___p__wcmdln =
      ___p__wcmdln_ptr.asFunction<_dart___p__wcmdln>();

  void _initterm(
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _First,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _Last,
  ) {
    return __initterm(
      _First,
      _Last,
    );
  }

  late final __initterm_ptr =
      _lookup<ffi.NativeFunction<_c__initterm>>('_initterm');
  late final _dart__initterm __initterm =
      __initterm_ptr.asFunction<_dart__initterm>();

  int _initterm_e(
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PIFV>>> _First,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PIFV>>> _Last,
  ) {
    return __initterm_e(
      _First,
      _Last,
    );
  }

  late final __initterm_e_ptr =
      _lookup<ffi.NativeFunction<_c__initterm_e>>('_initterm_e');
  late final _dart__initterm_e __initterm_e =
      __initterm_e_ptr.asFunction<_dart__initterm_e>();

  int _initialize_onexit_table(
    ffi.Pointer<_onexit_table_t> _Table,
  ) {
    return __initialize_onexit_table(
      _Table,
    );
  }

  late final __initialize_onexit_table_ptr =
      _lookup<ffi.NativeFunction<_c__initialize_onexit_table>>(
          '_initialize_onexit_table');
  late final _dart__initialize_onexit_table __initialize_onexit_table =
      __initialize_onexit_table_ptr
          .asFunction<_dart__initialize_onexit_table>();

  int _register_onexit_function(
    ffi.Pointer<_onexit_table_t> _Table,
    ffi.Pointer<ffi.NativeFunction<_onexit_t>> _Function,
  ) {
    return __register_onexit_function(
      _Table,
      _Function,
    );
  }

  late final __register_onexit_function_ptr =
      _lookup<ffi.NativeFunction<_c__register_onexit_function>>(
          '_register_onexit_function');
  late final _dart__register_onexit_function __register_onexit_function =
      __register_onexit_function_ptr
          .asFunction<_dart__register_onexit_function>();

  int _execute_onexit_table(
    ffi.Pointer<_onexit_table_t> _Table,
  ) {
    return __execute_onexit_table(
      _Table,
    );
  }

  late final __execute_onexit_table_ptr =
      _lookup<ffi.NativeFunction<_c__execute_onexit_table>>(
          '_execute_onexit_table');
  late final _dart__execute_onexit_table __execute_onexit_table =
      __execute_onexit_table_ptr.asFunction<_dart__execute_onexit_table>();

  int _crt_atexit(
    ffi.Pointer<ffi.NativeFunction<_PVFV>> _Function,
  ) {
    return __crt_atexit(
      _Function,
    );
  }

  late final __crt_atexit_ptr =
      _lookup<ffi.NativeFunction<_c__crt_atexit>>('_crt_atexit');
  late final _dart__crt_atexit __crt_atexit =
      __crt_atexit_ptr.asFunction<_dart__crt_atexit>();

  int _crt_at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<_PVFV>> _Function,
  ) {
    return __crt_at_quick_exit(
      _Function,
    );
  }

  late final __crt_at_quick_exit_ptr =
      _lookup<ffi.NativeFunction<_c__crt_at_quick_exit>>('_crt_at_quick_exit');
  late final _dart__crt_at_quick_exit __crt_at_quick_exit =
      __crt_at_quick_exit_ptr.asFunction<_dart__crt_at_quick_exit>();

  bool __acrt_initialize() {
    return ___acrt_initialize() != 0;
  }

  late final ___acrt_initialize_ptr =
      _lookup<ffi.NativeFunction<_c___acrt_initialize>>('__acrt_initialize');
  late final _dart___acrt_initialize ___acrt_initialize =
      ___acrt_initialize_ptr.asFunction<_dart___acrt_initialize>();

  bool __acrt_uninitialize(
    bool _Terminating,
  ) {
    return ___acrt_uninitialize(
          _Terminating ? 1 : 0,
        ) !=
        0;
  }

  late final ___acrt_uninitialize_ptr =
      _lookup<ffi.NativeFunction<_c___acrt_uninitialize>>(
          '__acrt_uninitialize');
  late final _dart___acrt_uninitialize ___acrt_uninitialize =
      ___acrt_uninitialize_ptr.asFunction<_dart___acrt_uninitialize>();

  bool __acrt_uninitialize_critical(
    bool _Terminating,
  ) {
    return ___acrt_uninitialize_critical(
          _Terminating ? 1 : 0,
        ) !=
        0;
  }

  late final ___acrt_uninitialize_critical_ptr =
      _lookup<ffi.NativeFunction<_c___acrt_uninitialize_critical>>(
          '__acrt_uninitialize_critical');
  late final _dart___acrt_uninitialize_critical ___acrt_uninitialize_critical =
      ___acrt_uninitialize_critical_ptr
          .asFunction<_dart___acrt_uninitialize_critical>();

  bool __acrt_thread_attach() {
    return ___acrt_thread_attach() != 0;
  }

  late final ___acrt_thread_attach_ptr =
      _lookup<ffi.NativeFunction<_c___acrt_thread_attach>>(
          '__acrt_thread_attach');
  late final _dart___acrt_thread_attach ___acrt_thread_attach =
      ___acrt_thread_attach_ptr.asFunction<_dart___acrt_thread_attach>();

  bool __acrt_thread_detach() {
    return ___acrt_thread_detach() != 0;
  }

  late final ___acrt_thread_detach_ptr =
      _lookup<ffi.NativeFunction<_c___acrt_thread_detach>>(
          '__acrt_thread_detach');
  late final _dart___acrt_thread_detach ___acrt_thread_detach =
      ___acrt_thread_detach_ptr.asFunction<_dart___acrt_thread_detach>();

  int _wexecl(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wexecl(
      _FileName,
      _ArgList,
    );
  }

  late final __wexecl_ptr = _lookup<ffi.NativeFunction<_c__wexecl>>('_wexecl');
  late final _dart__wexecl __wexecl = __wexecl_ptr.asFunction<_dart__wexecl>();

  int _wexecle(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wexecle(
      _FileName,
      _ArgList,
    );
  }

  late final __wexecle_ptr =
      _lookup<ffi.NativeFunction<_c__wexecle>>('_wexecle');
  late final _dart__wexecle __wexecle =
      __wexecle_ptr.asFunction<_dart__wexecle>();

  int _wexeclp(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wexeclp(
      _FileName,
      _ArgList,
    );
  }

  late final __wexeclp_ptr =
      _lookup<ffi.NativeFunction<_c__wexeclp>>('_wexeclp');
  late final _dart__wexeclp __wexeclp =
      __wexeclp_ptr.asFunction<_dart__wexeclp>();

  int _wexeclpe(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wexeclpe(
      _FileName,
      _ArgList,
    );
  }

  late final __wexeclpe_ptr =
      _lookup<ffi.NativeFunction<_c__wexeclpe>>('_wexeclpe');
  late final _dart__wexeclpe __wexeclpe =
      __wexeclpe_ptr.asFunction<_dart__wexeclpe>();

  int _wexecv(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ) {
    return __wexecv(
      _FileName,
      _ArgList,
    );
  }

  late final __wexecv_ptr = _lookup<ffi.NativeFunction<_c__wexecv>>('_wexecv');
  late final _dart__wexecv __wexecv = __wexecv_ptr.asFunction<_dart__wexecv>();

  int _wexecve(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
  ) {
    return __wexecve(
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wexecve_ptr =
      _lookup<ffi.NativeFunction<_c__wexecve>>('_wexecve');
  late final _dart__wexecve __wexecve =
      __wexecve_ptr.asFunction<_dart__wexecve>();

  int _wexecvp(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ) {
    return __wexecvp(
      _FileName,
      _ArgList,
    );
  }

  late final __wexecvp_ptr =
      _lookup<ffi.NativeFunction<_c__wexecvp>>('_wexecvp');
  late final _dart__wexecvp __wexecvp =
      __wexecvp_ptr.asFunction<_dart__wexecvp>();

  int _wexecvpe(
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
  ) {
    return __wexecvpe(
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wexecvpe_ptr =
      _lookup<ffi.NativeFunction<_c__wexecvpe>>('_wexecvpe');
  late final _dart__wexecvpe __wexecvpe =
      __wexecvpe_ptr.asFunction<_dart__wexecvpe>();

  int _wspawnl(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wspawnl(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnl_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnl>>('_wspawnl');
  late final _dart__wspawnl __wspawnl =
      __wspawnl_ptr.asFunction<_dart__wspawnl>();

  int _wspawnle(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wspawnle(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnle_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnle>>('_wspawnle');
  late final _dart__wspawnle __wspawnle =
      __wspawnle_ptr.asFunction<_dart__wspawnle>();

  int _wspawnlp(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wspawnlp(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnlp_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnlp>>('_wspawnlp');
  late final _dart__wspawnlp __wspawnlp =
      __wspawnlp_ptr.asFunction<_dart__wspawnlp>();

  int _wspawnlpe(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Uint16> _ArgList,
  ) {
    return __wspawnlpe(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnlpe_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnlpe>>('_wspawnlpe');
  late final _dart__wspawnlpe __wspawnlpe =
      __wspawnlpe_ptr.asFunction<_dart__wspawnlpe>();

  int _wspawnv(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ) {
    return __wspawnv(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnv_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnv>>('_wspawnv');
  late final _dart__wspawnv __wspawnv =
      __wspawnv_ptr.asFunction<_dart__wspawnv>();

  int _wspawnve(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
  ) {
    return __wspawnve(
      _Mode,
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wspawnve_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnve>>('_wspawnve');
  late final _dart__wspawnve __wspawnve =
      __wspawnve_ptr.asFunction<_dart__wspawnve>();

  int _wspawnvp(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ) {
    return __wspawnvp(
      _Mode,
      _FileName,
      _ArgList,
    );
  }

  late final __wspawnvp_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnvp>>('_wspawnvp');
  late final _dart__wspawnvp __wspawnvp =
      __wspawnvp_ptr.asFunction<_dart__wspawnvp>();

  int _wspawnvpe(
    int _Mode,
    ffi.Pointer<ffi.Uint16> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
    ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
  ) {
    return __wspawnvpe(
      _Mode,
      _FileName,
      _ArgList,
      _Env,
    );
  }

  late final __wspawnvpe_ptr =
      _lookup<ffi.NativeFunction<_c__wspawnvpe>>('_wspawnvpe');
  late final _dart__wspawnvpe __wspawnvpe =
      __wspawnvpe_ptr.asFunction<_dart__wspawnvpe>();

  int _wsystem(
    ffi.Pointer<ffi.Uint16> _Command,
  ) {
    return __wsystem(
      _Command,
    );
  }

  late final __wsystem_ptr =
      _lookup<ffi.NativeFunction<_c__wsystem>>('_wsystem');
  late final _dart__wsystem __wsystem =
      __wsystem_ptr.asFunction<_dart__wsystem>();

  void exit(
    int _Code,
  ) {
    return _exit_1(
      _Code,
    );
  }

  late final _exit_ptr = _lookup<ffi.NativeFunction<_c_exit1>>('exit');
  late final _dart_exit _exit_1 = _exit_ptr.asFunction<_dart_exit>();

  void _exit(
    int _Code,
  ) {
    return __exit(
      _Code,
    );
  }

  late final __exit_ptr = _lookup<ffi.NativeFunction<_c__exit>>('_exit');
  late final _dart__exit __exit = __exit_ptr.asFunction<_dart__exit>();

  void _Exit(
    int _Code,
  ) {
    return __Exit(
      _Code,
    );
  }

  late final __Exit_ptr = _lookup<ffi.NativeFunction<_c__Exit>>('_Exit');
  late final _dart__Exit __Exit = __Exit_ptr.asFunction<_dart__Exit>();

  void quick_exit(
    int _Code,
  ) {
    return _quick_exit(
      _Code,
    );
  }

  late final _quick_exit_ptr =
      _lookup<ffi.NativeFunction<_c_quick_exit>>('quick_exit');
  late final _dart_quick_exit _quick_exit =
      _quick_exit_ptr.asFunction<_dart_quick_exit>();

  void abort() {
    return _abort();
  }

  late final _abort_ptr = _lookup<ffi.NativeFunction<_c_abort>>('abort');
  late final _dart_abort _abort = _abort_ptr.asFunction<_dart_abort>();

  int system(
    ffi.Pointer<ffi.Int8> _Command,
  ) {
    return _system(
      _Command,
    );
  }

  late final _system_ptr = _lookup<ffi.NativeFunction<_c_system>>('system');
  late final _dart_system _system = _system_ptr.asFunction<_dart_system>();

  void _cexit() {
    return __cexit();
  }

  late final __cexit_ptr = _lookup<ffi.NativeFunction<_c__cexit>>('_cexit');
  late final _dart__cexit __cexit = __cexit_ptr.asFunction<_dart__cexit>();

  void _c_exit() {
    return __c_exit();
  }

  late final __c_exit_ptr = _lookup<ffi.NativeFunction<_c__c_exit>>('_c_exit');
  late final _dart__c_exit __c_exit = __c_exit_ptr.asFunction<_dart__c_exit>();

  void _register_thread_local_exe_atexit_callback(
    ffi.Pointer<ffi.NativeFunction<_tls_callback_type>> _Callback,
  ) {
    return __register_thread_local_exe_atexit_callback(
      _Callback,
    );
  }

  late final __register_thread_local_exe_atexit_callback_ptr = _lookup<
          ffi.NativeFunction<_c__register_thread_local_exe_atexit_callback>>(
      '_register_thread_local_exe_atexit_callback');
  late final _dart__register_thread_local_exe_atexit_callback
      __register_thread_local_exe_atexit_callback =
      __register_thread_local_exe_atexit_callback_ptr
          .asFunction<_dart__register_thread_local_exe_atexit_callback>();

  int _beginthread(
    ffi.Pointer<ffi.NativeFunction<_beginthread_proc_type>> _StartAddress,
    int _StackSize,
    ffi.Pointer<ffi.Void> _ArgList,
  ) {
    return __beginthread(
      _StartAddress,
      _StackSize,
      _ArgList,
    );
  }

  late final __beginthread_ptr =
      _lookup<ffi.NativeFunction<_c__beginthread>>('_beginthread');
  late final _dart__beginthread __beginthread =
      __beginthread_ptr.asFunction<_dart__beginthread>();

  void _endthread() {
    return __endthread();
  }

  late final __endthread_ptr =
      _lookup<ffi.NativeFunction<_c__endthread>>('_endthread');
  late final _dart__endthread __endthread =
      __endthread_ptr.asFunction<_dart__endthread>();

  int _beginthreadex(
    ffi.Pointer<ffi.Void> _Security,
    int _StackSize,
    ffi.Pointer<ffi.NativeFunction<_beginthreadex_proc_type>> _StartAddress,
    ffi.Pointer<ffi.Void> _ArgList,
    int _InitFlag,
    ffi.Pointer<ffi.Uint32> _ThrdAddr,
  ) {
    return __beginthreadex(
      _Security,
      _StackSize,
      _StartAddress,
      _ArgList,
      _InitFlag,
      _ThrdAddr,
    );
  }

  late final __beginthreadex_ptr =
      _lookup<ffi.NativeFunction<_c__beginthreadex>>('_beginthreadex');
  late final _dart__beginthreadex __beginthreadex =
      __beginthreadex_ptr.asFunction<_dart__beginthreadex>();

  void _endthreadex(
    int _ReturnCode,
  ) {
    return __endthreadex(
      _ReturnCode,
    );
  }

  late final __endthreadex_ptr =
      _lookup<ffi.NativeFunction<_c__endthreadex>>('_endthreadex');
  late final _dart__endthreadex __endthreadex =
      __endthreadex_ptr.asFunction<_dart__endthreadex>();

  int _getpid() {
    return __getpid();
  }

  late final __getpid_ptr = _lookup<ffi.NativeFunction<_c__getpid>>('_getpid');
  late final _dart__getpid __getpid = __getpid_ptr.asFunction<_dart__getpid>();

  int _cwait(
    ffi.Pointer<ffi.Int32> _TermStat,
    int _ProcHandle,
    int _Action,
  ) {
    return __cwait(
      _TermStat,
      _ProcHandle,
      _Action,
    );
  }

  late final __cwait_ptr = _lookup<ffi.NativeFunction<_c__cwait>>('_cwait');
  late final _dart__cwait __cwait = __cwait_ptr.asFunction<_dart__cwait>();

  int _execl(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execl(
      _FileName,
      _Arguments,
    );
  }

  late final __execl_ptr = _lookup<ffi.NativeFunction<_c__execl>>('_execl');
  late final _dart__execl __execl = __execl_ptr.asFunction<_dart__execl>();

  int _execle(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execle(
      _FileName,
      _Arguments,
    );
  }

  late final __execle_ptr = _lookup<ffi.NativeFunction<_c__execle>>('_execle');
  late final _dart__execle __execle = __execle_ptr.asFunction<_dart__execle>();

  int _execlp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execlp(
      _FileName,
      _Arguments,
    );
  }

  late final __execlp_ptr = _lookup<ffi.NativeFunction<_c__execlp>>('_execlp');
  late final _dart__execlp __execlp = __execlp_ptr.asFunction<_dart__execlp>();

  int _execlpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __execlpe(
      _FileName,
      _Arguments,
    );
  }

  late final __execlpe_ptr =
      _lookup<ffi.NativeFunction<_c__execlpe>>('_execlpe');
  late final _dart__execlpe __execlpe =
      __execlpe_ptr.asFunction<_dart__execlpe>();

  int _execv(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __execv(
      _FileName,
      _Arguments,
    );
  }

  late final __execv_ptr = _lookup<ffi.NativeFunction<_c__execv>>('_execv');
  late final _dart__execv __execv = __execv_ptr.asFunction<_dart__execv>();

  int _execve(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __execve(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __execve_ptr = _lookup<ffi.NativeFunction<_c__execve>>('_execve');
  late final _dart__execve __execve = __execve_ptr.asFunction<_dart__execve>();

  int _execvp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __execvp(
      _FileName,
      _Arguments,
    );
  }

  late final __execvp_ptr = _lookup<ffi.NativeFunction<_c__execvp>>('_execvp');
  late final _dart__execvp __execvp = __execvp_ptr.asFunction<_dart__execvp>();

  int _execvpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __execvpe(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __execvpe_ptr =
      _lookup<ffi.NativeFunction<_c__execvpe>>('_execvpe');
  late final _dart__execvpe __execvpe =
      __execvpe_ptr.asFunction<_dart__execvpe>();

  int _spawnl(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnl(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnl_ptr = _lookup<ffi.NativeFunction<_c__spawnl>>('_spawnl');
  late final _dart__spawnl __spawnl = __spawnl_ptr.asFunction<_dart__spawnl>();

  int _spawnle(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnle(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnle_ptr =
      _lookup<ffi.NativeFunction<_c__spawnle>>('_spawnle');
  late final _dart__spawnle __spawnle =
      __spawnle_ptr.asFunction<_dart__spawnle>();

  int _spawnlp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnlp(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnlp_ptr =
      _lookup<ffi.NativeFunction<_c__spawnlp>>('_spawnlp');
  late final _dart__spawnlp __spawnlp =
      __spawnlp_ptr.asFunction<_dart__spawnlp>();

  int _spawnlpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return __spawnlpe(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnlpe_ptr =
      _lookup<ffi.NativeFunction<_c__spawnlpe>>('_spawnlpe');
  late final _dart__spawnlpe __spawnlpe =
      __spawnlpe_ptr.asFunction<_dart__spawnlpe>();

  int _spawnv(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __spawnv(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnv_ptr = _lookup<ffi.NativeFunction<_c__spawnv>>('_spawnv');
  late final _dart__spawnv __spawnv = __spawnv_ptr.asFunction<_dart__spawnv>();

  int _spawnve(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __spawnve(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __spawnve_ptr =
      _lookup<ffi.NativeFunction<_c__spawnve>>('_spawnve');
  late final _dart__spawnve __spawnve =
      __spawnve_ptr.asFunction<_dart__spawnve>();

  int _spawnvp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return __spawnvp(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final __spawnvp_ptr =
      _lookup<ffi.NativeFunction<_c__spawnvp>>('_spawnvp');
  late final _dart__spawnvp __spawnvp =
      __spawnvp_ptr.asFunction<_dart__spawnvp>();

  int _spawnvpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return __spawnvpe(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final __spawnvpe_ptr =
      _lookup<ffi.NativeFunction<_c__spawnvpe>>('_spawnvpe');
  late final _dart__spawnvpe __spawnvpe =
      __spawnvpe_ptr.asFunction<_dart__spawnvpe>();

  int _loaddll(
    ffi.Pointer<ffi.Int8> _FileName,
  ) {
    return __loaddll(
      _FileName,
    );
  }

  late final __loaddll_ptr =
      _lookup<ffi.NativeFunction<_c__loaddll>>('_loaddll');
  late final _dart__loaddll __loaddll =
      __loaddll_ptr.asFunction<_dart__loaddll>();

  int _unloaddll(
    int _Handle,
  ) {
    return __unloaddll(
      _Handle,
    );
  }

  late final __unloaddll_ptr =
      _lookup<ffi.NativeFunction<_c__unloaddll>>('_unloaddll');
  late final _dart__unloaddll __unloaddll =
      __unloaddll_ptr.asFunction<_dart__unloaddll>();

  ffi.Pointer<ffi.NativeFunction<_GetDllProcAddrProcType>> _getdllprocaddr(
    int _Handle,
    ffi.Pointer<ffi.Int8> _ProcedureName,
    int _Ordinal,
  ) {
    return __getdllprocaddr(
      _Handle,
      _ProcedureName,
      _Ordinal,
    );
  }

  late final __getdllprocaddr_ptr =
      _lookup<ffi.NativeFunction<_c__getdllprocaddr>>('_getdllprocaddr');
  late final _dart__getdllprocaddr __getdllprocaddr =
      __getdllprocaddr_ptr.asFunction<_dart__getdllprocaddr>();

  int cwait(
    ffi.Pointer<ffi.Int32> _TermStat,
    int _ProcHandle,
    int _Action,
  ) {
    return _cwait_1(
      _TermStat,
      _ProcHandle,
      _Action,
    );
  }

  late final _cwait_ptr = _lookup<ffi.NativeFunction<_c_cwait>>('cwait');
  late final _dart_cwait _cwait_1 = _cwait_ptr.asFunction<_dart_cwait>();

  int execl(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execl_1(
      _FileName,
      _Arguments,
    );
  }

  late final _execl_ptr = _lookup<ffi.NativeFunction<_c_execl>>('execl');
  late final _dart_execl _execl_1 = _execl_ptr.asFunction<_dart_execl>();

  int execle(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execle_1(
      _FileName,
      _Arguments,
    );
  }

  late final _execle_ptr = _lookup<ffi.NativeFunction<_c_execle>>('execle');
  late final _dart_execle _execle_1 = _execle_ptr.asFunction<_dart_execle>();

  int execlp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execlp_1(
      _FileName,
      _Arguments,
    );
  }

  late final _execlp_ptr = _lookup<ffi.NativeFunction<_c_execlp>>('execlp');
  late final _dart_execlp _execlp_1 = _execlp_ptr.asFunction<_dart_execlp>();

  int execlpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _execlpe_1(
      _FileName,
      _Arguments,
    );
  }

  late final _execlpe_ptr = _lookup<ffi.NativeFunction<_c_execlpe>>('execlpe');
  late final _dart_execlpe _execlpe_1 =
      _execlpe_ptr.asFunction<_dart_execlpe>();

  int execv(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _execv_1(
      _FileName,
      _Arguments,
    );
  }

  late final _execv_ptr = _lookup<ffi.NativeFunction<_c_execv>>('execv');
  late final _dart_execv _execv_1 = _execv_ptr.asFunction<_dart_execv>();

  int execve(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _execve_1(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _execve_ptr = _lookup<ffi.NativeFunction<_c_execve>>('execve');
  late final _dart_execve _execve_1 = _execve_ptr.asFunction<_dart_execve>();

  int execvp(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _execvp_1(
      _FileName,
      _Arguments,
    );
  }

  late final _execvp_ptr = _lookup<ffi.NativeFunction<_c_execvp>>('execvp');
  late final _dart_execvp _execvp_1 = _execvp_ptr.asFunction<_dart_execvp>();

  int execvpe(
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _execvpe_1(
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _execvpe_ptr = _lookup<ffi.NativeFunction<_c_execvpe>>('execvpe');
  late final _dart_execvpe _execvpe_1 =
      _execvpe_ptr.asFunction<_dart_execvpe>();

  int spawnl(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnl_1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnl_ptr = _lookup<ffi.NativeFunction<_c_spawnl>>('spawnl');
  late final _dart_spawnl _spawnl_1 = _spawnl_ptr.asFunction<_dart_spawnl>();

  int spawnle(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnle_1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnle_ptr = _lookup<ffi.NativeFunction<_c_spawnle>>('spawnle');
  late final _dart_spawnle _spawnle_1 =
      _spawnle_ptr.asFunction<_dart_spawnle>();

  int spawnlp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnlp_1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnlp_ptr = _lookup<ffi.NativeFunction<_c_spawnlp>>('spawnlp');
  late final _dart_spawnlp _spawnlp_1 =
      _spawnlp_ptr.asFunction<_dart_spawnlp>();

  int spawnlpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Int8> _Arguments,
  ) {
    return _spawnlpe_1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnlpe_ptr =
      _lookup<ffi.NativeFunction<_c_spawnlpe>>('spawnlpe');
  late final _dart_spawnlpe _spawnlpe_1 =
      _spawnlpe_ptr.asFunction<_dart_spawnlpe>();

  int spawnv(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _spawnv_1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnv_ptr = _lookup<ffi.NativeFunction<_c_spawnv>>('spawnv');
  late final _dart_spawnv _spawnv_1 = _spawnv_ptr.asFunction<_dart_spawnv>();

  int spawnve(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _spawnve_1(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _spawnve_ptr = _lookup<ffi.NativeFunction<_c_spawnve>>('spawnve');
  late final _dart_spawnve _spawnve_1 =
      _spawnve_ptr.asFunction<_dart_spawnve>();

  int spawnvp(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ) {
    return _spawnvp_1(
      _Mode,
      _FileName,
      _Arguments,
    );
  }

  late final _spawnvp_ptr = _lookup<ffi.NativeFunction<_c_spawnvp>>('spawnvp');
  late final _dart_spawnvp _spawnvp_1 =
      _spawnvp_ptr.asFunction<_dart_spawnvp>();

  int spawnvpe(
    int _Mode,
    ffi.Pointer<ffi.Int8> _FileName,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
  ) {
    return _spawnvpe_1(
      _Mode,
      _FileName,
      _Arguments,
      _Environment,
    );
  }

  late final _spawnvpe_ptr =
      _lookup<ffi.NativeFunction<_c_spawnvpe>>('spawnvpe');
  late final _dart_spawnvpe _spawnvpe_1 =
      _spawnvpe_ptr.asFunction<_dart_spawnvpe>();

  int getpid() {
    return _getpid_1();
  }

  late final _getpid_ptr = _lookup<ffi.NativeFunction<_c_getpid>>('getpid');
  late final _dart_getpid _getpid_1 = _getpid_ptr.asFunction<_dart_getpid>();

  /// Create a thread.
  ffi.Pointer<SDL_Thread> SDL_CreateThread(
    ffi.Pointer<ffi.NativeFunction<SDL_ThreadFunction>> fn,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentBeginThread>> pfnBeginThread,
    ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentEndThread>> pfnEndThread,
  ) {
    return _SDL_CreateThread(
      fn,
      name,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThread_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateThread>>('SDL_CreateThread');
  late final _dart_SDL_CreateThread _SDL_CreateThread =
      _SDL_CreateThread_ptr.asFunction<_dart_SDL_CreateThread>();

  ffi.Pointer<SDL_Thread> SDL_CreateThreadWithStackSize(
    ffi.Pointer<ffi.NativeFunction<_typedefC_3>> fn,
    ffi.Pointer<ffi.Int8> name,
    int stacksize,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentBeginThread>> pfnBeginThread,
    ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentEndThread>> pfnEndThread,
  ) {
    return _SDL_CreateThreadWithStackSize(
      fn,
      name,
      stacksize,
      data,
      pfnBeginThread,
      pfnEndThread,
    );
  }

  late final _SDL_CreateThreadWithStackSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateThreadWithStackSize>>(
          'SDL_CreateThreadWithStackSize');
  late final _dart_SDL_CreateThreadWithStackSize
      _SDL_CreateThreadWithStackSize = _SDL_CreateThreadWithStackSize_ptr
          .asFunction<_dart_SDL_CreateThreadWithStackSize>();

  /// Get the thread name, as it was specified in SDL_CreateThread().
  /// This function returns a pointer to a UTF-8 string that names the
  /// specified thread, or NULL if it doesn't have a name. This is internal
  /// memory, not to be free()'d by the caller, and remains valid until the
  /// specified thread is cleaned up by SDL_WaitThread().
  ffi.Pointer<ffi.Int8> SDL_GetThreadName(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadName(
      thread,
    );
  }

  late final _SDL_GetThreadName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetThreadName>>('SDL_GetThreadName');
  late final _dart_SDL_GetThreadName _SDL_GetThreadName =
      _SDL_GetThreadName_ptr.asFunction<_dart_SDL_GetThreadName>();

  /// Get the thread identifier for the current thread.
  int SDL_ThreadID() {
    return _SDL_ThreadID();
  }

  late final _SDL_ThreadID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ThreadID>>('SDL_ThreadID');
  late final _dart_SDL_ThreadID _SDL_ThreadID =
      _SDL_ThreadID_ptr.asFunction<_dart_SDL_ThreadID>();

  /// Get the thread identifier for the specified thread.
  ///
  /// Equivalent to SDL_ThreadID() if the specified thread is NULL.
  int SDL_GetThreadID(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_GetThreadID(
      thread,
    );
  }

  late final _SDL_GetThreadID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetThreadID>>('SDL_GetThreadID');
  late final _dart_SDL_GetThreadID _SDL_GetThreadID =
      _SDL_GetThreadID_ptr.asFunction<_dart_SDL_GetThreadID>();

  /// Set the priority for the current thread
  int SDL_SetThreadPriority(
    int priority,
  ) {
    return _SDL_SetThreadPriority(
      priority,
    );
  }

  late final _SDL_SetThreadPriority_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetThreadPriority>>(
          'SDL_SetThreadPriority');
  late final _dart_SDL_SetThreadPriority _SDL_SetThreadPriority =
      _SDL_SetThreadPriority_ptr.asFunction<_dart_SDL_SetThreadPriority>();

  /// Wait for a thread to finish. Threads that haven't been detached will
  /// remain (as a "zombie") until this function cleans them up. Not doing so
  /// is a resource leak.
  ///
  /// Once a thread has been cleaned up through this function, the SDL_Thread
  /// that references it becomes invalid and should not be referenced again.
  /// As such, only one thread may call SDL_WaitThread() on another.
  ///
  /// The return code for the thread function is placed in the area
  /// pointed to by \c status, if \c status is not NULL.
  ///
  /// You may not wait on a thread that has been used in a call to
  /// SDL_DetachThread(). Use either that function or this one, but not
  /// both, or behavior is undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  void SDL_WaitThread(
    ffi.Pointer<SDL_Thread> thread,
    ffi.Pointer<ffi.Int32> status,
  ) {
    return _SDL_WaitThread(
      thread,
      status,
    );
  }

  late final _SDL_WaitThread_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WaitThread>>('SDL_WaitThread');
  late final _dart_SDL_WaitThread _SDL_WaitThread =
      _SDL_WaitThread_ptr.asFunction<_dart_SDL_WaitThread>();

  /// A thread may be "detached" to signify that it should not remain until
  /// another thread has called SDL_WaitThread() on it. Detaching a thread
  /// is useful for long-running threads that nothing needs to synchronize
  /// with or further manage. When a detached thread is done, it simply
  /// goes away.
  ///
  /// There is no way to recover the return code of a detached thread. If you
  /// need this, don't detach the thread and instead use SDL_WaitThread().
  ///
  /// Once a thread is detached, you should usually assume the SDL_Thread isn't
  /// safe to reference again, as it will become invalid immediately upon
  /// the detached thread's exit, instead of remaining until someone has called
  /// SDL_WaitThread() to finally clean it up. As such, don't detach the same
  /// thread more than once.
  ///
  /// If a thread has already exited when passed to SDL_DetachThread(), it will
  /// stop waiting for a call to SDL_WaitThread() and clean up immediately.
  /// It is not safe to detach a thread that might be used with SDL_WaitThread().
  ///
  /// You may not call SDL_WaitThread() on a thread that has been detached.
  /// Use either that function or this one, but not both, or behavior is
  /// undefined.
  ///
  /// It is safe to pass NULL to this function; it is a no-op.
  void SDL_DetachThread(
    ffi.Pointer<SDL_Thread> thread,
  ) {
    return _SDL_DetachThread(
      thread,
    );
  }

  late final _SDL_DetachThread_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DetachThread>>('SDL_DetachThread');
  late final _dart_SDL_DetachThread _SDL_DetachThread =
      _SDL_DetachThread_ptr.asFunction<_dart_SDL_DetachThread>();

  /// \brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific.
  ///
  /// \return The newly created thread local storage identifier, or 0 on error
  ///
  /// \code
  /// static SDL_SpinLock tls_lock;
  /// static SDL_TLSID thread_local_storage;
  ///
  /// void SetMyThreadData(void *value)
  /// {
  /// if (!thread_local_storage) {
  /// SDL_AtomicLock(&tls_lock);
  /// if (!thread_local_storage) {
  /// thread_local_storage = SDL_TLSCreate();
  /// }
  /// SDL_AtomicUnlock(&tls_lock);
  /// }
  /// SDL_TLSSet(thread_local_storage, value, 0);
  /// }
  ///
  /// void *GetMyThreadData(void)
  /// {
  /// return SDL_TLSGet(thread_local_storage);
  /// }
  /// \endcode
  ///
  /// \sa SDL_TLSGet()
  /// \sa SDL_TLSSet()
  int SDL_TLSCreate() {
    return _SDL_TLSCreate();
  }

  late final _SDL_TLSCreate_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_TLSCreate>>('SDL_TLSCreate');
  late final _dart_SDL_TLSCreate _SDL_TLSCreate =
      _SDL_TLSCreate_ptr.asFunction<_dart_SDL_TLSCreate>();

  /// \brief Get the value associated with a thread local storage ID for the current thread.
  ///
  /// \param id The thread local storage ID
  ///
  /// \return The value associated with the ID for the current thread, or NULL if no value has been set.
  ///
  /// \sa SDL_TLSCreate()
  /// \sa SDL_TLSSet()
  ffi.Pointer<ffi.Void> SDL_TLSGet(
    int id,
  ) {
    return _SDL_TLSGet(
      id,
    );
  }

  late final _SDL_TLSGet_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_TLSGet>>('SDL_TLSGet');
  late final _dart_SDL_TLSGet _SDL_TLSGet =
      _SDL_TLSGet_ptr.asFunction<_dart_SDL_TLSGet>();

  /// \brief Set the value associated with a thread local storage ID for the current thread.
  ///
  /// \param id The thread local storage ID
  /// \param value The value to associate with the ID for the current thread
  /// \param destructor A function called when the thread exits, to free the value.
  ///
  /// \return 0 on success, -1 on error
  ///
  /// \sa SDL_TLSCreate()
  /// \sa SDL_TLSGet()
  int SDL_TLSSet(
    int id,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.NativeFunction<_typedefC_5>> destructor,
  ) {
    return _SDL_TLSSet(
      id,
      value,
      destructor,
    );
  }

  late final _SDL_TLSSet_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_TLSSet>>('SDL_TLSSet');
  late final _dart_SDL_TLSSet _SDL_TLSSet =
      _SDL_TLSSet_ptr.asFunction<_dart_SDL_TLSSet>();

  ffi.Pointer<SDL_RWops> SDL_RWFromFile(
    ffi.Pointer<ffi.Int8> file,
    ffi.Pointer<ffi.Int8> mode,
  ) {
    return _SDL_RWFromFile(
      file,
      mode,
    );
  }

  late final _SDL_RWFromFile_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWFromFile>>('SDL_RWFromFile');
  late final _dart_SDL_RWFromFile _SDL_RWFromFile =
      _SDL_RWFromFile_ptr.asFunction<_dart_SDL_RWFromFile>();

  ffi.Pointer<SDL_RWops> SDL_RWFromFP(
    ffi.Pointer<ffi.Void> fp,
    int autoclose,
  ) {
    return _SDL_RWFromFP(
      fp,
      autoclose,
    );
  }

  late final _SDL_RWFromFP_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWFromFP>>('SDL_RWFromFP');
  late final _dart_SDL_RWFromFP _SDL_RWFromFP =
      _SDL_RWFromFP_ptr.asFunction<_dart_SDL_RWFromFP>();

  ffi.Pointer<SDL_RWops> SDL_RWFromMem(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromMem(
      mem,
      size,
    );
  }

  late final _SDL_RWFromMem_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWFromMem>>('SDL_RWFromMem');
  late final _dart_SDL_RWFromMem _SDL_RWFromMem =
      _SDL_RWFromMem_ptr.asFunction<_dart_SDL_RWFromMem>();

  ffi.Pointer<SDL_RWops> SDL_RWFromConstMem(
    ffi.Pointer<ffi.Void> mem,
    int size,
  ) {
    return _SDL_RWFromConstMem(
      mem,
      size,
    );
  }

  late final _SDL_RWFromConstMem_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWFromConstMem>>('SDL_RWFromConstMem');
  late final _dart_SDL_RWFromConstMem _SDL_RWFromConstMem =
      _SDL_RWFromConstMem_ptr.asFunction<_dart_SDL_RWFromConstMem>();

  ffi.Pointer<SDL_RWops> SDL_AllocRW() {
    return _SDL_AllocRW();
  }

  late final _SDL_AllocRW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AllocRW>>('SDL_AllocRW');
  late final _dart_SDL_AllocRW _SDL_AllocRW =
      _SDL_AllocRW_ptr.asFunction<_dart_SDL_AllocRW>();

  void SDL_FreeRW(
    ffi.Pointer<SDL_RWops> area,
  ) {
    return _SDL_FreeRW(
      area,
    );
  }

  late final _SDL_FreeRW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreeRW>>('SDL_FreeRW');
  late final _dart_SDL_FreeRW _SDL_FreeRW =
      _SDL_FreeRW_ptr.asFunction<_dart_SDL_FreeRW>();

  /// Return the size of the file in this rwops, or -1 if unknown
  int SDL_RWsize(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWsize(
      context,
    );
  }

  late final _SDL_RWsize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWsize>>('SDL_RWsize');
  late final _dart_SDL_RWsize _SDL_RWsize =
      _SDL_RWsize_ptr.asFunction<_dart_SDL_RWsize>();

  /// Seek to \c offset relative to \c whence, one of stdio's whence values:
  /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
  ///
  /// \return the final offset in the data stream, or -1 on error.
  int SDL_RWseek(
    ffi.Pointer<SDL_RWops> context,
    int offset,
    int whence,
  ) {
    return _SDL_RWseek(
      context,
      offset,
      whence,
    );
  }

  late final _SDL_RWseek_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWseek>>('SDL_RWseek');
  late final _dart_SDL_RWseek _SDL_RWseek =
      _SDL_RWseek_ptr.asFunction<_dart_SDL_RWseek>();

  /// Return the current offset in the data stream, or -1 on error.
  int SDL_RWtell(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWtell(
      context,
    );
  }

  late final _SDL_RWtell_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWtell>>('SDL_RWtell');
  late final _dart_SDL_RWtell _SDL_RWtell =
      _SDL_RWtell_ptr.asFunction<_dart_SDL_RWtell>();

  /// Read up to \c maxnum objects each of size \c size from the data
  /// stream to the area pointed at by \c ptr.
  ///
  /// \return the number of objects read, or 0 at error or end of file.
  int SDL_RWread(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int maxnum,
  ) {
    return _SDL_RWread(
      context,
      ptr,
      size,
      maxnum,
    );
  }

  late final _SDL_RWread_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWread>>('SDL_RWread');
  late final _dart_SDL_RWread _SDL_RWread =
      _SDL_RWread_ptr.asFunction<_dart_SDL_RWread>();

  /// Write exactly \c num objects each of size \c size from the area
  /// pointed at by \c ptr to data stream.
  ///
  /// \return the number of objects written, or 0 at error or end of file.
  int SDL_RWwrite(
    ffi.Pointer<SDL_RWops> context,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int num,
  ) {
    return _SDL_RWwrite(
      context,
      ptr,
      size,
      num,
    );
  }

  late final _SDL_RWwrite_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWwrite>>('SDL_RWwrite');
  late final _dart_SDL_RWwrite _SDL_RWwrite =
      _SDL_RWwrite_ptr.asFunction<_dart_SDL_RWwrite>();

  /// Close and free an allocated SDL_RWops structure.
  ///
  /// \return 0 if successful or -1 on write error when flushing data.
  int SDL_RWclose(
    ffi.Pointer<SDL_RWops> context,
  ) {
    return _SDL_RWclose(
      context,
    );
  }

  late final _SDL_RWclose_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RWclose>>('SDL_RWclose');
  late final _dart_SDL_RWclose _SDL_RWclose =
      _SDL_RWclose_ptr.asFunction<_dart_SDL_RWclose>();

  /// Load all the data from an SDL data stream.
  ///
  /// The data is allocated with a zero byte at the end (null terminated)
  ///
  /// If \c datasize is not NULL, it is filled with the size of the data read.
  ///
  /// If \c freesrc is non-zero, the stream will be closed after being read.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \return the data, or NULL if there was an error.
  ffi.Pointer<ffi.Void> SDL_LoadFile_RW(
    ffi.Pointer<SDL_RWops> src,
    ffi.Pointer<ffi.Uint64> datasize,
    int freesrc,
  ) {
    return _SDL_LoadFile_RW(
      src,
      datasize,
      freesrc,
    );
  }

  late final _SDL_LoadFile_RW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadFile_RW>>('SDL_LoadFile_RW');
  late final _dart_SDL_LoadFile_RW _SDL_LoadFile_RW =
      _SDL_LoadFile_RW_ptr.asFunction<_dart_SDL_LoadFile_RW>();

  /// Load an entire file.
  ///
  /// The data is allocated with a zero byte at the end (null terminated)
  ///
  /// If \c datasize is not NULL, it is filled with the size of the data read.
  ///
  /// If \c freesrc is non-zero, the stream will be closed after being read.
  ///
  /// The data should be freed with SDL_free().
  ///
  /// \return the data, or NULL if there was an error.
  ffi.Pointer<ffi.Void> SDL_LoadFile(
    ffi.Pointer<ffi.Int8> file,
    ffi.Pointer<ffi.Uint64> datasize,
  ) {
    return _SDL_LoadFile(
      file,
      datasize,
    );
  }

  late final _SDL_LoadFile_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadFile>>('SDL_LoadFile');
  late final _dart_SDL_LoadFile _SDL_LoadFile =
      _SDL_LoadFile_ptr.asFunction<_dart_SDL_LoadFile>();

  int SDL_ReadU8(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadU8(
      src,
    );
  }

  late final _SDL_ReadU8_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadU8>>('SDL_ReadU8');
  late final _dart_SDL_ReadU8 _SDL_ReadU8 =
      _SDL_ReadU8_ptr.asFunction<_dart_SDL_ReadU8>();

  int SDL_ReadLE16(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE16(
      src,
    );
  }

  late final _SDL_ReadLE16_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadLE16>>('SDL_ReadLE16');
  late final _dart_SDL_ReadLE16 _SDL_ReadLE16 =
      _SDL_ReadLE16_ptr.asFunction<_dart_SDL_ReadLE16>();

  int SDL_ReadBE16(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE16(
      src,
    );
  }

  late final _SDL_ReadBE16_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadBE16>>('SDL_ReadBE16');
  late final _dart_SDL_ReadBE16 _SDL_ReadBE16 =
      _SDL_ReadBE16_ptr.asFunction<_dart_SDL_ReadBE16>();

  int SDL_ReadLE32(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE32(
      src,
    );
  }

  late final _SDL_ReadLE32_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadLE32>>('SDL_ReadLE32');
  late final _dart_SDL_ReadLE32 _SDL_ReadLE32 =
      _SDL_ReadLE32_ptr.asFunction<_dart_SDL_ReadLE32>();

  int SDL_ReadBE32(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE32(
      src,
    );
  }

  late final _SDL_ReadBE32_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadBE32>>('SDL_ReadBE32');
  late final _dart_SDL_ReadBE32 _SDL_ReadBE32 =
      _SDL_ReadBE32_ptr.asFunction<_dart_SDL_ReadBE32>();

  int SDL_ReadLE64(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadLE64(
      src,
    );
  }

  late final _SDL_ReadLE64_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadLE64>>('SDL_ReadLE64');
  late final _dart_SDL_ReadLE64 _SDL_ReadLE64 =
      _SDL_ReadLE64_ptr.asFunction<_dart_SDL_ReadLE64>();

  int SDL_ReadBE64(
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_ReadBE64(
      src,
    );
  }

  late final _SDL_ReadBE64_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ReadBE64>>('SDL_ReadBE64');
  late final _dart_SDL_ReadBE64 _SDL_ReadBE64 =
      _SDL_ReadBE64_ptr.asFunction<_dart_SDL_ReadBE64>();

  int SDL_WriteU8(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteU8(
      dst,
      value,
    );
  }

  late final _SDL_WriteU8_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteU8>>('SDL_WriteU8');
  late final _dart_SDL_WriteU8 _SDL_WriteU8 =
      _SDL_WriteU8_ptr.asFunction<_dart_SDL_WriteU8>();

  int SDL_WriteLE16(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE16(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE16_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteLE16>>('SDL_WriteLE16');
  late final _dart_SDL_WriteLE16 _SDL_WriteLE16 =
      _SDL_WriteLE16_ptr.asFunction<_dart_SDL_WriteLE16>();

  int SDL_WriteBE16(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE16(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE16_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteBE16>>('SDL_WriteBE16');
  late final _dart_SDL_WriteBE16 _SDL_WriteBE16 =
      _SDL_WriteBE16_ptr.asFunction<_dart_SDL_WriteBE16>();

  int SDL_WriteLE32(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE32(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE32_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteLE32>>('SDL_WriteLE32');
  late final _dart_SDL_WriteLE32 _SDL_WriteLE32 =
      _SDL_WriteLE32_ptr.asFunction<_dart_SDL_WriteLE32>();

  int SDL_WriteBE32(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE32(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE32_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteBE32>>('SDL_WriteBE32');
  late final _dart_SDL_WriteBE32 _SDL_WriteBE32 =
      _SDL_WriteBE32_ptr.asFunction<_dart_SDL_WriteBE32>();

  int SDL_WriteLE64(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteLE64(
      dst,
      value,
    );
  }

  late final _SDL_WriteLE64_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteLE64>>('SDL_WriteLE64');
  late final _dart_SDL_WriteLE64 _SDL_WriteLE64 =
      _SDL_WriteLE64_ptr.asFunction<_dart_SDL_WriteLE64>();

  int SDL_WriteBE64(
    ffi.Pointer<SDL_RWops> dst,
    int value,
  ) {
    return _SDL_WriteBE64(
      dst,
      value,
    );
  }

  late final _SDL_WriteBE64_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WriteBE64>>('SDL_WriteBE64');
  late final _dart_SDL_WriteBE64 _SDL_WriteBE64 =
      _SDL_WriteBE64_ptr.asFunction<_dart_SDL_WriteBE64>();

  int SDL_GetNumAudioDrivers() {
    return _SDL_GetNumAudioDrivers();
  }

  late final _SDL_GetNumAudioDrivers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumAudioDrivers>>(
          'SDL_GetNumAudioDrivers');
  late final _dart_SDL_GetNumAudioDrivers _SDL_GetNumAudioDrivers =
      _SDL_GetNumAudioDrivers_ptr.asFunction<_dart_SDL_GetNumAudioDrivers>();

  ffi.Pointer<ffi.Int8> SDL_GetAudioDriver(
    int index,
  ) {
    return _SDL_GetAudioDriver(
      index,
    );
  }

  late final _SDL_GetAudioDriver_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetAudioDriver>>('SDL_GetAudioDriver');
  late final _dart_SDL_GetAudioDriver _SDL_GetAudioDriver =
      _SDL_GetAudioDriver_ptr.asFunction<_dart_SDL_GetAudioDriver>();

  int SDL_AudioInit(
    ffi.Pointer<ffi.Int8> driver_name,
  ) {
    return _SDL_AudioInit(
      driver_name,
    );
  }

  late final _SDL_AudioInit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioInit>>('SDL_AudioInit');
  late final _dart_SDL_AudioInit _SDL_AudioInit =
      _SDL_AudioInit_ptr.asFunction<_dart_SDL_AudioInit>();

  void SDL_AudioQuit() {
    return _SDL_AudioQuit();
  }

  late final _SDL_AudioQuit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioQuit>>('SDL_AudioQuit');
  late final _dart_SDL_AudioQuit _SDL_AudioQuit =
      _SDL_AudioQuit_ptr.asFunction<_dart_SDL_AudioQuit>();

  /// This function returns the name of the current audio driver, or NULL
  /// if no driver has been initialized.
  ffi.Pointer<ffi.Int8> SDL_GetCurrentAudioDriver() {
    return _SDL_GetCurrentAudioDriver();
  }

  late final _SDL_GetCurrentAudioDriver_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetCurrentAudioDriver>>(
          'SDL_GetCurrentAudioDriver');
  late final _dart_SDL_GetCurrentAudioDriver _SDL_GetCurrentAudioDriver =
      _SDL_GetCurrentAudioDriver_ptr.asFunction<
          _dart_SDL_GetCurrentAudioDriver>();

  /// This function opens the audio device with the desired parameters, and
  /// returns 0 if successful, placing the actual hardware parameters in the
  /// structure pointed to by \c obtained.  If \c obtained is NULL, the audio
  /// data passed to the callback function will be guaranteed to be in the
  /// requested format, and will be automatically converted to the hardware
  /// audio format if necessary.  This function returns -1 if it failed
  /// to open the audio device, or couldn't set up the audio thread.
  ///
  /// When filling in the desired audio spec structure,
  /// - \c desired->freq should be the desired audio frequency in samples-per-
  /// second.
  /// - \c desired->format should be the desired audio format.
  /// - \c desired->samples is the desired size of the audio buffer, in
  /// samples.  This number should be a power of two, and may be adjusted by
  /// the audio driver to a value more suitable for the hardware.  Good values
  /// seem to range between 512 and 8096 inclusive, depending on the
  /// application and CPU speed.  Smaller values yield faster response time,
  /// but can lead to underflow if the application is doing heavy processing
  /// and cannot fill the audio buffer in time.  A stereo sample consists of
  /// both right and left channels in LR ordering.
  /// Note that the number of samples is directly related to time by the
  /// following formula:  \code ms = (samples*1000)/freq \endcode
  /// - \c desired->size is the size in bytes of the audio buffer, and is
  /// calculated by SDL_OpenAudio().
  /// - \c desired->silence is the value used to set the buffer to silence,
  /// and is calculated by SDL_OpenAudio().
  /// - \c desired->callback should be set to a function that will be called
  /// when the audio device is ready for more data.  It is passed a pointer
  /// to the audio buffer, and the length in bytes of the audio buffer.
  /// This function usually runs in a separate thread, and so you should
  /// protect data structures that it accesses by calling SDL_LockAudio()
  /// and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL
  /// pointer here, and call SDL_QueueAudio() with some frequency, to queue
  /// more audio samples to be played (or for capture devices, call
  /// SDL_DequeueAudio() with some frequency, to obtain audio samples).
  /// - \c desired->userdata is passed as the first parameter to your callback
  /// function. If you passed a NULL callback, this value is ignored.
  ///
  /// The audio device starts out playing silence when it's opened, and should
  /// be enabled for playing by calling \c SDL_PauseAudio(0) when you are ready
  /// for your audio callback function to be called.  Since the audio driver
  /// may modify the requested size of the audio buffer, you should allocate
  /// any local mixing buffers after you open the audio device.
  int SDL_OpenAudio(
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
  ) {
    return _SDL_OpenAudio(
      desired,
      obtained,
    );
  }

  late final _SDL_OpenAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OpenAudio>>('SDL_OpenAudio');
  late final _dart_SDL_OpenAudio _SDL_OpenAudio =
      _SDL_OpenAudio_ptr.asFunction<_dart_SDL_OpenAudio>();

  /// Get the number of available devices exposed by the current driver.
  /// Only valid after a successfully initializing the audio subsystem.
  /// Returns -1 if an explicit list of devices can't be determined; this is
  /// not an error. For example, if SDL is set up to talk to a remote audio
  /// server, it can't list every one available on the Internet, but it will
  /// still allow a specific host to be specified to SDL_OpenAudioDevice().
  ///
  /// In many common cases, when this function returns a value <= 0, it can still
  /// successfully open the default device (NULL for first argument of
  /// SDL_OpenAudioDevice()).
  int SDL_GetNumAudioDevices(
    int iscapture,
  ) {
    return _SDL_GetNumAudioDevices(
      iscapture,
    );
  }

  late final _SDL_GetNumAudioDevices_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumAudioDevices>>(
          'SDL_GetNumAudioDevices');
  late final _dart_SDL_GetNumAudioDevices _SDL_GetNumAudioDevices =
      _SDL_GetNumAudioDevices_ptr.asFunction<_dart_SDL_GetNumAudioDevices>();

  /// Get the human-readable name of a specific audio device.
  /// Must be a value between 0 and (number of audio devices-1).
  /// Only valid after a successfully initializing the audio subsystem.
  /// The values returned by this function reflect the latest call to
  /// SDL_GetNumAudioDevices(); recall that function to redetect available
  /// hardware.
  ///
  /// The string returned by this function is UTF-8 encoded, read-only, and
  /// managed internally. You are not to free it. If you need to keep the
  /// string for any length of time, you should make your own copy of it, as it
  /// will be invalid next time any of several other SDL functions is called.
  ffi.Pointer<ffi.Int8> SDL_GetAudioDeviceName(
    int index,
    int iscapture,
  ) {
    return _SDL_GetAudioDeviceName(
      index,
      iscapture,
    );
  }

  late final _SDL_GetAudioDeviceName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetAudioDeviceName>>(
          'SDL_GetAudioDeviceName');
  late final _dart_SDL_GetAudioDeviceName _SDL_GetAudioDeviceName =
      _SDL_GetAudioDeviceName_ptr.asFunction<_dart_SDL_GetAudioDeviceName>();

  /// Open a specific audio device. Passing in a device name of NULL requests
  /// the most reasonable default (and is equivalent to calling SDL_OpenAudio()).
  ///
  /// The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
  /// some drivers allow arbitrary and driver-specific strings, such as a
  /// hostname/IP address for a remote audio server, or a filename in the
  /// diskaudio driver.
  ///
  /// \return 0 on error, a valid device ID that is >= 2 on success.
  ///
  /// SDL_OpenAudio(), unlike this function, always acts on device ID 1.
  int SDL_OpenAudioDevice(
    ffi.Pointer<ffi.Int8> device,
    int iscapture,
    ffi.Pointer<SDL_AudioSpec> desired,
    ffi.Pointer<SDL_AudioSpec> obtained,
    int allowed_changes,
  ) {
    return _SDL_OpenAudioDevice(
      device,
      iscapture,
      desired,
      obtained,
      allowed_changes,
    );
  }

  late final _SDL_OpenAudioDevice_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OpenAudioDevice>>(
          'SDL_OpenAudioDevice');
  late final _dart_SDL_OpenAudioDevice _SDL_OpenAudioDevice =
      _SDL_OpenAudioDevice_ptr.asFunction<_dart_SDL_OpenAudioDevice>();

  int SDL_GetAudioStatus() {
    return _SDL_GetAudioStatus();
  }

  late final _SDL_GetAudioStatus_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetAudioStatus>>('SDL_GetAudioStatus');
  late final _dart_SDL_GetAudioStatus _SDL_GetAudioStatus =
      _SDL_GetAudioStatus_ptr.asFunction<_dart_SDL_GetAudioStatus>();

  int SDL_GetAudioDeviceStatus(
    int dev,
  ) {
    return _SDL_GetAudioDeviceStatus(
      dev,
    );
  }

  late final _SDL_GetAudioDeviceStatus_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetAudioDeviceStatus>>(
          'SDL_GetAudioDeviceStatus');
  late final _dart_SDL_GetAudioDeviceStatus _SDL_GetAudioDeviceStatus =
      _SDL_GetAudioDeviceStatus_ptr.asFunction<
          _dart_SDL_GetAudioDeviceStatus>();

  void SDL_PauseAudio(
    int pause_on,
  ) {
    return _SDL_PauseAudio(
      pause_on,
    );
  }

  late final _SDL_PauseAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_PauseAudio>>('SDL_PauseAudio');
  late final _dart_SDL_PauseAudio _SDL_PauseAudio =
      _SDL_PauseAudio_ptr.asFunction<_dart_SDL_PauseAudio>();

  void SDL_PauseAudioDevice(
    int dev,
    int pause_on,
  ) {
    return _SDL_PauseAudioDevice(
      dev,
      pause_on,
    );
  }

  late final _SDL_PauseAudioDevice_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_PauseAudioDevice>>(
          'SDL_PauseAudioDevice');
  late final _dart_SDL_PauseAudioDevice _SDL_PauseAudioDevice =
      _SDL_PauseAudioDevice_ptr.asFunction<_dart_SDL_PauseAudioDevice>();

  /// \brief Load the audio data of a WAVE file into memory
  ///
  /// Loading a WAVE file requires \c src, \c spec, \c audio_buf and \c audio_len
  /// to be valid pointers. The entire data portion of the file is then loaded
  /// into memory and decoded if necessary.
  ///
  /// If \c freesrc is non-zero, the data source gets automatically closed and
  /// freed before the function returns.
  ///
  /// Supported are RIFF WAVE files with the formats PCM (8, 16, 24, and 32 bits),
  /// IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and A-law and
  /// -law (8 bits). Other formats are currently unsupported and cause an error.
  ///
  /// If this function succeeds, the pointer returned by it is equal to \c spec
  /// and the pointer to the audio data allocated by the function is written to
  /// \c audio_buf and its length in bytes to \c audio_len. The \ref SDL_AudioSpec
  /// members \c freq, \c channels, and \c format are set to the values of the
  /// audio data in the buffer. The \c samples member is set to a sane default and
  /// all others are set to zero.
  ///
  /// It's necessary to use SDL_FreeWAV() to free the audio data returned in
  /// \c audio_buf when it is no longer used.
  ///
  /// Because of the underspecification of the Waveform format, there are many
  /// problematic files in the wild that cause issues with strict decoders. To
  /// provide compatibility with these files, this decoder is lenient in regards
  /// to the truncation of the file, the fact chunk, and the size of the RIFF
  /// chunk. The hints SDL_HINT_WAVE_RIFF_CHUNK_SIZE, SDL_HINT_WAVE_TRUNCATION,
  /// and SDL_HINT_WAVE_FACT_CHUNK can be used to tune the behavior of the
  /// loading process.
  ///
  /// Any file that is invalid (due to truncation, corruption, or wrong values in
  /// the headers), too big, or unsupported causes an error. Additionally, any
  /// critical I/O error from the data source will terminate the loading process
  /// with an error. The function returns NULL on error and in all cases (with the
  /// exception of \c src being NULL), an appropriate error message will be set.
  ///
  /// It is required that the data source supports seeking.
  ///
  /// Example:
  /// \code
  /// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
  /// \endcode
  ///
  /// \param src The data source with the WAVE data
  /// \param freesrc A integer value that makes the function close the data source if non-zero
  /// \param spec A pointer filled with the audio format of the audio data
  /// \param audio_buf A pointer filled with the audio data allocated by the function
  /// \param audio_len A pointer filled with the length of the audio data buffer in bytes
  /// \return NULL on error, or non-NULL on success.
  ffi.Pointer<SDL_AudioSpec> SDL_LoadWAV_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
    ffi.Pointer<SDL_AudioSpec> spec,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_buf,
    ffi.Pointer<ffi.Uint32> audio_len,
  ) {
    return _SDL_LoadWAV_RW(
      src,
      freesrc,
      spec,
      audio_buf,
      audio_len,
    );
  }

  late final _SDL_LoadWAV_RW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadWAV_RW>>('SDL_LoadWAV_RW');
  late final _dart_SDL_LoadWAV_RW _SDL_LoadWAV_RW =
      _SDL_LoadWAV_RW_ptr.asFunction<_dart_SDL_LoadWAV_RW>();

  /// This function frees data previously allocated with SDL_LoadWAV_RW()
  void SDL_FreeWAV(
    ffi.Pointer<ffi.Uint8> audio_buf,
  ) {
    return _SDL_FreeWAV(
      audio_buf,
    );
  }

  late final _SDL_FreeWAV_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreeWAV>>('SDL_FreeWAV');
  late final _dart_SDL_FreeWAV _SDL_FreeWAV =
      _SDL_FreeWAV_ptr.asFunction<_dart_SDL_FreeWAV>();

  /// This function takes a source format and rate and a destination format
  /// and rate, and initializes the \c cvt structure with information needed
  /// by SDL_ConvertAudio() to convert a buffer of audio data from one format
  /// to the other. An unsupported format causes an error and -1 will be returned.
  ///
  /// \return 0 if no conversion is needed, 1 if the audio filter is set up,
  /// or -1 on error.
  int SDL_BuildAudioCVT(
    ffi.Pointer<SDL_AudioCVT> cvt,
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_BuildAudioCVT(
      cvt,
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_BuildAudioCVT_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_BuildAudioCVT>>('SDL_BuildAudioCVT');
  late final _dart_SDL_BuildAudioCVT _SDL_BuildAudioCVT =
      _SDL_BuildAudioCVT_ptr.asFunction<_dart_SDL_BuildAudioCVT>();

  /// Once you have initialized the \c cvt structure using SDL_BuildAudioCVT(),
  /// created an audio buffer \c cvt->buf, and filled it with \c cvt->len bytes of
  /// audio data in the source format, this function will convert it in-place
  /// to the desired format.
  ///
  /// The data conversion may expand the size of the audio data, so the buffer
  /// \c cvt->buf should be allocated after the \c cvt structure is initialized by
  /// SDL_BuildAudioCVT(), and should be \c cvt->len*cvt->len_mult bytes long.
  ///
  /// \return 0 on success or -1 if \c cvt->buf is NULL.
  int SDL_ConvertAudio(
    ffi.Pointer<SDL_AudioCVT> cvt,
  ) {
    return _SDL_ConvertAudio(
      cvt,
    );
  }

  late final _SDL_ConvertAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ConvertAudio>>('SDL_ConvertAudio');
  late final _dart_SDL_ConvertAudio _SDL_ConvertAudio =
      _SDL_ConvertAudio_ptr.asFunction<_dart_SDL_ConvertAudio>();

  /// Create a new audio stream
  ///
  /// \param src_format The format of the source audio
  /// \param src_channels The number of channels of the source audio
  /// \param src_rate The sampling rate of the source audio
  /// \param dst_format The format of the desired audio output
  /// \param dst_channels The number of channels of the desired audio output
  /// \param dst_rate The sampling rate of the desired audio output
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  ffi.Pointer<_SDL_AudioStream> SDL_NewAudioStream(
    int src_format,
    int src_channels,
    int src_rate,
    int dst_format,
    int dst_channels,
    int dst_rate,
  ) {
    return _SDL_NewAudioStream(
      src_format,
      src_channels,
      src_rate,
      dst_format,
      dst_channels,
      dst_rate,
    );
  }

  late final _SDL_NewAudioStream_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_NewAudioStream>>('SDL_NewAudioStream');
  late final _dart_SDL_NewAudioStream _SDL_NewAudioStream =
      _SDL_NewAudioStream_ptr.asFunction<_dart_SDL_NewAudioStream>();

  /// Add data to be converted/resampled to the stream
  ///
  /// \param stream The stream the audio data is being added to
  /// \param buf A pointer to the audio data to add
  /// \param len The number of bytes to write to the stream
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamPut(
    ffi.Pointer<_SDL_AudioStream> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamPut(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamPut_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioStreamPut>>('SDL_AudioStreamPut');
  late final _dart_SDL_AudioStreamPut _SDL_AudioStreamPut =
      _SDL_AudioStreamPut_ptr.asFunction<_dart_SDL_AudioStreamPut>();

  /// Get converted/resampled data from the stream
  ///
  /// \param stream The stream the audio is being requested from
  /// \param buf A buffer to fill with audio data
  /// \param len The maximum number of bytes to fill
  /// \return The number of bytes read from the stream, or -1 on error
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamGet(
    ffi.Pointer<_SDL_AudioStream> stream,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _SDL_AudioStreamGet(
      stream,
      buf,
      len,
    );
  }

  late final _SDL_AudioStreamGet_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioStreamGet>>('SDL_AudioStreamGet');
  late final _dart_SDL_AudioStreamGet _SDL_AudioStreamGet =
      _SDL_AudioStreamGet_ptr.asFunction<_dart_SDL_AudioStreamGet>();

  /// Get the number of converted/resampled bytes available. The stream may be
  /// buffering data behind the scenes until it has enough to resample
  /// correctly, so this number might be lower than what you expect, or even
  /// be zero. Add more data or flush the stream if you need the data now.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamAvailable(
    ffi.Pointer<_SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamAvailable(
      stream,
    );
  }

  late final _SDL_AudioStreamAvailable_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioStreamAvailable>>(
          'SDL_AudioStreamAvailable');
  late final _dart_SDL_AudioStreamAvailable _SDL_AudioStreamAvailable =
      _SDL_AudioStreamAvailable_ptr.asFunction<
          _dart_SDL_AudioStreamAvailable>();

  /// Tell the stream that you're done sending data, and anything being buffered
  /// should be converted/resampled and made available immediately.
  ///
  /// It is legal to add more data to a stream after flushing, but there will
  /// be audio gaps in the output. Generally this is intended to signal the
  /// end of input, so the complete output becomes available.
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamClear
  /// \sa SDL_FreeAudioStream
  int SDL_AudioStreamFlush(
    ffi.Pointer<_SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamFlush(
      stream,
    );
  }

  late final _SDL_AudioStreamFlush_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioStreamFlush>>(
          'SDL_AudioStreamFlush');
  late final _dart_SDL_AudioStreamFlush _SDL_AudioStreamFlush =
      _SDL_AudioStreamFlush_ptr.asFunction<_dart_SDL_AudioStreamFlush>();

  /// Clear any pending data in the stream without converting it
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_FreeAudioStream
  void SDL_AudioStreamClear(
    ffi.Pointer<_SDL_AudioStream> stream,
  ) {
    return _SDL_AudioStreamClear(
      stream,
    );
  }

  late final _SDL_AudioStreamClear_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AudioStreamClear>>(
          'SDL_AudioStreamClear');
  late final _dart_SDL_AudioStreamClear _SDL_AudioStreamClear =
      _SDL_AudioStreamClear_ptr.asFunction<_dart_SDL_AudioStreamClear>();

  /// Free an audio stream
  ///
  /// \sa SDL_NewAudioStream
  /// \sa SDL_AudioStreamPut
  /// \sa SDL_AudioStreamGet
  /// \sa SDL_AudioStreamAvailable
  /// \sa SDL_AudioStreamFlush
  /// \sa SDL_AudioStreamClear
  void SDL_FreeAudioStream(
    ffi.Pointer<_SDL_AudioStream> stream,
  ) {
    return _SDL_FreeAudioStream(
      stream,
    );
  }

  late final _SDL_FreeAudioStream_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreeAudioStream>>(
          'SDL_FreeAudioStream');
  late final _dart_SDL_FreeAudioStream _SDL_FreeAudioStream =
      _SDL_FreeAudioStream_ptr.asFunction<_dart_SDL_FreeAudioStream>();

  /// This takes two audio buffers of the playing audio format and mixes
  /// them, performing addition, volume adjustment, and overflow clipping.
  /// The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME
  /// for full audio volume.  Note this does not change hardware volume.
  /// This is provided for convenience -- you can mix your own audio data.
  void SDL_MixAudio(
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int len,
    int volume,
  ) {
    return _SDL_MixAudio(
      dst,
      src,
      len,
      volume,
    );
  }

  late final _SDL_MixAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MixAudio>>('SDL_MixAudio');
  late final _dart_SDL_MixAudio _SDL_MixAudio =
      _SDL_MixAudio_ptr.asFunction<_dart_SDL_MixAudio>();

  /// This works like SDL_MixAudio(), but you specify the audio format instead of
  /// using the format of audio device 1. Thus it can be used when no audio
  /// device is open at all.
  void SDL_MixAudioFormat(
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int format,
    int len,
    int volume,
  ) {
    return _SDL_MixAudioFormat(
      dst,
      src,
      format,
      len,
      volume,
    );
  }

  late final _SDL_MixAudioFormat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MixAudioFormat>>('SDL_MixAudioFormat');
  late final _dart_SDL_MixAudioFormat _SDL_MixAudioFormat =
      _SDL_MixAudioFormat_ptr.asFunction<_dart_SDL_MixAudioFormat>();

  /// Queue more audio on non-callback devices.
  ///
  /// (If you are looking to retrieve queued audio from a non-callback capture
  /// device, you want SDL_DequeueAudio() instead. This will return -1 to
  /// signify an error if you use it with capture devices.)
  ///
  /// SDL offers two ways to feed audio to the device: you can either supply a
  /// callback that SDL triggers with some frequency to obtain more audio
  /// (pull method), or you can supply no callback, and then SDL will expect
  /// you to supply data at regular intervals (push method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Queued data will drain to the device as
  /// necessary without further intervention from you. If the device needs
  /// audio but there is not enough queued, it will play silence to make up
  /// the difference. This means you will have skips in your audio playback
  /// if you aren't routinely queueing sufficient data.
  ///
  /// This function copies the supplied data, so you are safe to free it when
  /// the function returns. This function is thread-safe, but queueing to the
  /// same device from two threads at once does not promise which buffer will
  /// be queued first.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; doing so returns an error. You have to use the audio callback
  /// or queue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before queueing; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev The device ID to which we will queue audio.
  /// \param data The data to queue to the device for later playback.
  /// \param len The number of bytes (not samples!) to which (data) points.
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_GetQueuedAudioSize
  /// \sa SDL_ClearQueuedAudio
  int SDL_QueueAudio(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_QueueAudio(
      dev,
      data,
      len,
    );
  }

  late final _SDL_QueueAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_QueueAudio>>('SDL_QueueAudio');
  late final _dart_SDL_QueueAudio _SDL_QueueAudio =
      _SDL_QueueAudio_ptr.asFunction<_dart_SDL_QueueAudio>();

  /// Dequeue more audio on non-callback devices.
  ///
  /// (If you are looking to queue audio for output on a non-callback playback
  /// device, you want SDL_QueueAudio() instead. This will always return 0
  /// if you use it with playback devices.)
  ///
  /// SDL offers two ways to retrieve audio from a capture device: you can
  /// either supply a callback that SDL triggers with some frequency as the
  /// device records more audio data, (push method), or you can supply no
  /// callback, and then SDL will expect you to retrieve data at regular
  /// intervals (pull method) with this function.
  ///
  /// There are no limits on the amount of data you can queue, short of
  /// exhaustion of address space. Data from the device will keep queuing as
  /// necessary without further intervention from you. This means you will
  /// eventually run out of memory if you aren't routinely dequeueing data.
  ///
  /// Capture devices will not queue data when paused; if you are expecting
  /// to not need captured audio for some length of time, use
  /// SDL_PauseAudioDevice() to stop the capture device from queueing more
  /// data. This can be useful during, say, level loading times. When
  /// unpaused, capture devices will start queueing data from that point,
  /// having flushed any capturable data available while paused.
  ///
  /// This function is thread-safe, but dequeueing from the same device from
  /// two threads at once does not promise which thread will dequeued data
  /// first.
  ///
  /// You may not dequeue audio from a device that is using an
  /// application-supplied callback; doing so returns an error. You have to use
  /// the audio callback, or dequeue audio with this function, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before queueing; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev The device ID from which we will dequeue audio.
  /// \param data A pointer into where audio data should be copied.
  /// \param len The number of bytes (not samples!) to which (data) points.
  /// \return number of bytes dequeued, which could be less than requested.
  ///
  /// \sa SDL_GetQueuedAudioSize
  /// \sa SDL_ClearQueuedAudio
  int SDL_DequeueAudio(
    int dev,
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _SDL_DequeueAudio(
      dev,
      data,
      len,
    );
  }

  late final _SDL_DequeueAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DequeueAudio>>('SDL_DequeueAudio');
  late final _dart_SDL_DequeueAudio _SDL_DequeueAudio =
      _SDL_DequeueAudio_ptr.asFunction<_dart_SDL_DequeueAudio>();

  /// Get the number of bytes of still-queued audio.
  ///
  /// For playback device:
  ///
  /// This is the number of bytes that have been queued for playback with
  /// SDL_QueueAudio(), but have not yet been sent to the hardware. This
  /// number may shrink at any time, so this only informs of pending data.
  ///
  /// Once we've sent it to the hardware, this function can not decide the
  /// exact byte boundary of what has been played. It's possible that we just
  /// gave the hardware several kilobytes right before you called this
  /// function, but it hasn't played any of it yet, or maybe half of it, etc.
  ///
  /// For capture devices:
  ///
  /// This is the number of bytes that have been captured by the device and
  /// are waiting for you to dequeue. This number may grow at any time, so
  /// this only informs of the lower-bound of available data.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; calling this function on such a device always returns 0.
  /// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
  /// the audio callback, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before querying; SDL
  /// handles locking internally for this function.
  ///
  /// \param dev The device ID of which we will query queued audio size.
  /// \return Number of bytes (not samples!) of queued audio.
  ///
  /// \sa SDL_QueueAudio
  /// \sa SDL_ClearQueuedAudio
  int SDL_GetQueuedAudioSize(
    int dev,
  ) {
    return _SDL_GetQueuedAudioSize(
      dev,
    );
  }

  late final _SDL_GetQueuedAudioSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetQueuedAudioSize>>(
          'SDL_GetQueuedAudioSize');
  late final _dart_SDL_GetQueuedAudioSize _SDL_GetQueuedAudioSize =
      _SDL_GetQueuedAudioSize_ptr.asFunction<_dart_SDL_GetQueuedAudioSize>();

  /// Drop any queued audio data. For playback devices, this is any queued data
  /// still waiting to be submitted to the hardware. For capture devices, this
  /// is any data that was queued by the device that hasn't yet been dequeued by
  /// the application.
  ///
  /// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
  /// playback devices, the hardware will start playing silence if more audio
  /// isn't queued. Unpaused capture devices will start filling the queue again
  /// as soon as they have more data available (which, depending on the state
  /// of the hardware and the thread, could be before this function call
  /// returns!).
  ///
  /// This will not prevent playback of queued audio that's already been sent
  /// to the hardware, as we can not undo that, so expect there to be some
  /// fraction of a second of audio that might still be heard. This can be
  /// useful if you want to, say, drop any pending music during a level change
  /// in your game.
  ///
  /// You may not queue audio on a device that is using an application-supplied
  /// callback; calling this function on such a device is always a no-op.
  /// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
  /// the audio callback, but not both.
  ///
  /// You should not call SDL_LockAudio() on the device before clearing the
  /// queue; SDL handles locking internally for this function.
  ///
  /// This function always succeeds and thus returns void.
  ///
  /// \param dev The device ID of which to clear the audio queue.
  ///
  /// \sa SDL_QueueAudio
  /// \sa SDL_GetQueuedAudioSize
  void SDL_ClearQueuedAudio(
    int dev,
  ) {
    return _SDL_ClearQueuedAudio(
      dev,
    );
  }

  late final _SDL_ClearQueuedAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ClearQueuedAudio>>(
          'SDL_ClearQueuedAudio');
  late final _dart_SDL_ClearQueuedAudio _SDL_ClearQueuedAudio =
      _SDL_ClearQueuedAudio_ptr.asFunction<_dart_SDL_ClearQueuedAudio>();

  void SDL_LockAudio() {
    return _SDL_LockAudio();
  }

  late final _SDL_LockAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockAudio>>('SDL_LockAudio');
  late final _dart_SDL_LockAudio _SDL_LockAudio =
      _SDL_LockAudio_ptr.asFunction<_dart_SDL_LockAudio>();

  void SDL_LockAudioDevice(
    int dev,
  ) {
    return _SDL_LockAudioDevice(
      dev,
    );
  }

  late final _SDL_LockAudioDevice_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockAudioDevice>>(
          'SDL_LockAudioDevice');
  late final _dart_SDL_LockAudioDevice _SDL_LockAudioDevice =
      _SDL_LockAudioDevice_ptr.asFunction<_dart_SDL_LockAudioDevice>();

  void SDL_UnlockAudio() {
    return _SDL_UnlockAudio();
  }

  late final _SDL_UnlockAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockAudio>>('SDL_UnlockAudio');
  late final _dart_SDL_UnlockAudio _SDL_UnlockAudio =
      _SDL_UnlockAudio_ptr.asFunction<_dart_SDL_UnlockAudio>();

  void SDL_UnlockAudioDevice(
    int dev,
  ) {
    return _SDL_UnlockAudioDevice(
      dev,
    );
  }

  late final _SDL_UnlockAudioDevice_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockAudioDevice>>(
          'SDL_UnlockAudioDevice');
  late final _dart_SDL_UnlockAudioDevice _SDL_UnlockAudioDevice =
      _SDL_UnlockAudioDevice_ptr.asFunction<_dart_SDL_UnlockAudioDevice>();

  /// This function shuts down audio processing and closes the audio device.
  void SDL_CloseAudio() {
    return _SDL_CloseAudio();
  }

  late final _SDL_CloseAudio_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CloseAudio>>('SDL_CloseAudio');
  late final _dart_SDL_CloseAudio _SDL_CloseAudio =
      _SDL_CloseAudio_ptr.asFunction<_dart_SDL_CloseAudio>();

  void SDL_CloseAudioDevice(
    int dev,
  ) {
    return _SDL_CloseAudioDevice(
      dev,
    );
  }

  late final _SDL_CloseAudioDevice_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CloseAudioDevice>>(
          'SDL_CloseAudioDevice');
  late final _dart_SDL_CloseAudioDevice _SDL_CloseAudioDevice =
      _SDL_CloseAudioDevice_ptr.asFunction<_dart_SDL_CloseAudioDevice>();

  /// \brief Put UTF-8 text into the clipboard
  ///
  /// \sa SDL_GetClipboardText()
  int SDL_SetClipboardText(
    ffi.Pointer<ffi.Int8> text,
  ) {
    return _SDL_SetClipboardText(
      text,
    );
  }

  late final _SDL_SetClipboardText_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetClipboardText>>(
          'SDL_SetClipboardText');
  late final _dart_SDL_SetClipboardText _SDL_SetClipboardText =
      _SDL_SetClipboardText_ptr.asFunction<_dart_SDL_SetClipboardText>();

  /// \brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()
  ///
  /// \sa SDL_SetClipboardText()
  ffi.Pointer<ffi.Int8> SDL_GetClipboardText() {
    return _SDL_GetClipboardText();
  }

  late final _SDL_GetClipboardText_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetClipboardText>>(
          'SDL_GetClipboardText');
  late final _dart_SDL_GetClipboardText _SDL_GetClipboardText =
      _SDL_GetClipboardText_ptr.asFunction<_dart_SDL_GetClipboardText>();

  /// \brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty
  ///
  /// \sa SDL_GetClipboardText()
  int SDL_HasClipboardText() {
    return _SDL_HasClipboardText();
  }

  late final _SDL_HasClipboardText_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasClipboardText>>(
          'SDL_HasClipboardText');
  late final _dart_SDL_HasClipboardText _SDL_HasClipboardText =
      _SDL_HasClipboardText_ptr.asFunction<_dart_SDL_HasClipboardText>();

  /// This function returns the number of CPU cores available.
  int SDL_GetCPUCount() {
    return _SDL_GetCPUCount();
  }

  late final _SDL_GetCPUCount_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetCPUCount>>('SDL_GetCPUCount');
  late final _dart_SDL_GetCPUCount _SDL_GetCPUCount =
      _SDL_GetCPUCount_ptr.asFunction<_dart_SDL_GetCPUCount>();

  /// This function returns the L1 cache line size of the CPU
  ///
  /// This is useful for determining multi-threaded structure padding
  /// or SIMD prefetch sizes.
  int SDL_GetCPUCacheLineSize() {
    return _SDL_GetCPUCacheLineSize();
  }

  late final _SDL_GetCPUCacheLineSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetCPUCacheLineSize>>(
          'SDL_GetCPUCacheLineSize');
  late final _dart_SDL_GetCPUCacheLineSize _SDL_GetCPUCacheLineSize =
      _SDL_GetCPUCacheLineSize_ptr.asFunction<_dart_SDL_GetCPUCacheLineSize>();

  /// This function returns true if the CPU has the RDTSC instruction.
  int SDL_HasRDTSC() {
    return _SDL_HasRDTSC();
  }

  late final _SDL_HasRDTSC_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasRDTSC>>('SDL_HasRDTSC');
  late final _dart_SDL_HasRDTSC _SDL_HasRDTSC =
      _SDL_HasRDTSC_ptr.asFunction<_dart_SDL_HasRDTSC>();

  /// This function returns true if the CPU has AltiVec features.
  int SDL_HasAltiVec() {
    return _SDL_HasAltiVec();
  }

  late final _SDL_HasAltiVec_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasAltiVec>>('SDL_HasAltiVec');
  late final _dart_SDL_HasAltiVec _SDL_HasAltiVec =
      _SDL_HasAltiVec_ptr.asFunction<_dart_SDL_HasAltiVec>();

  /// This function returns true if the CPU has MMX features.
  int SDL_HasMMX() {
    return _SDL_HasMMX();
  }

  late final _SDL_HasMMX_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasMMX>>('SDL_HasMMX');
  late final _dart_SDL_HasMMX _SDL_HasMMX =
      _SDL_HasMMX_ptr.asFunction<_dart_SDL_HasMMX>();

  /// This function returns true if the CPU has 3DNow! features.
  int SDL_Has3DNow() {
    return _SDL_Has3DNow();
  }

  late final _SDL_Has3DNow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Has3DNow>>('SDL_Has3DNow');
  late final _dart_SDL_Has3DNow _SDL_Has3DNow =
      _SDL_Has3DNow_ptr.asFunction<_dart_SDL_Has3DNow>();

  /// This function returns true if the CPU has SSE features.
  int SDL_HasSSE() {
    return _SDL_HasSSE();
  }

  late final _SDL_HasSSE_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasSSE>>('SDL_HasSSE');
  late final _dart_SDL_HasSSE _SDL_HasSSE =
      _SDL_HasSSE_ptr.asFunction<_dart_SDL_HasSSE>();

  /// This function returns true if the CPU has SSE2 features.
  int SDL_HasSSE2() {
    return _SDL_HasSSE2();
  }

  late final _SDL_HasSSE2_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasSSE2>>('SDL_HasSSE2');
  late final _dart_SDL_HasSSE2 _SDL_HasSSE2 =
      _SDL_HasSSE2_ptr.asFunction<_dart_SDL_HasSSE2>();

  /// This function returns true if the CPU has SSE3 features.
  int SDL_HasSSE3() {
    return _SDL_HasSSE3();
  }

  late final _SDL_HasSSE3_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasSSE3>>('SDL_HasSSE3');
  late final _dart_SDL_HasSSE3 _SDL_HasSSE3 =
      _SDL_HasSSE3_ptr.asFunction<_dart_SDL_HasSSE3>();

  /// This function returns true if the CPU has SSE4.1 features.
  int SDL_HasSSE41() {
    return _SDL_HasSSE41();
  }

  late final _SDL_HasSSE41_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasSSE41>>('SDL_HasSSE41');
  late final _dart_SDL_HasSSE41 _SDL_HasSSE41 =
      _SDL_HasSSE41_ptr.asFunction<_dart_SDL_HasSSE41>();

  /// This function returns true if the CPU has SSE4.2 features.
  int SDL_HasSSE42() {
    return _SDL_HasSSE42();
  }

  late final _SDL_HasSSE42_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasSSE42>>('SDL_HasSSE42');
  late final _dart_SDL_HasSSE42 _SDL_HasSSE42 =
      _SDL_HasSSE42_ptr.asFunction<_dart_SDL_HasSSE42>();

  /// This function returns true if the CPU has AVX features.
  int SDL_HasAVX() {
    return _SDL_HasAVX();
  }

  late final _SDL_HasAVX_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasAVX>>('SDL_HasAVX');
  late final _dart_SDL_HasAVX _SDL_HasAVX =
      _SDL_HasAVX_ptr.asFunction<_dart_SDL_HasAVX>();

  /// This function returns true if the CPU has AVX2 features.
  int SDL_HasAVX2() {
    return _SDL_HasAVX2();
  }

  late final _SDL_HasAVX2_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasAVX2>>('SDL_HasAVX2');
  late final _dart_SDL_HasAVX2 _SDL_HasAVX2 =
      _SDL_HasAVX2_ptr.asFunction<_dart_SDL_HasAVX2>();

  /// This function returns true if the CPU has AVX-512F (foundation) features.
  int SDL_HasAVX512F() {
    return _SDL_HasAVX512F();
  }

  late final _SDL_HasAVX512F_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasAVX512F>>('SDL_HasAVX512F');
  late final _dart_SDL_HasAVX512F _SDL_HasAVX512F =
      _SDL_HasAVX512F_ptr.asFunction<_dart_SDL_HasAVX512F>();

  /// This function returns true if the CPU has ARM SIMD (ARMv6) features.
  int SDL_HasARMSIMD() {
    return _SDL_HasARMSIMD();
  }

  late final _SDL_HasARMSIMD_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasARMSIMD>>('SDL_HasARMSIMD');
  late final _dart_SDL_HasARMSIMD _SDL_HasARMSIMD =
      _SDL_HasARMSIMD_ptr.asFunction<_dart_SDL_HasARMSIMD>();

  /// This function returns true if the CPU has NEON (ARM SIMD) features.
  int SDL_HasNEON() {
    return _SDL_HasNEON();
  }

  late final _SDL_HasNEON_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasNEON>>('SDL_HasNEON');
  late final _dart_SDL_HasNEON _SDL_HasNEON =
      _SDL_HasNEON_ptr.asFunction<_dart_SDL_HasNEON>();

  /// This function returns the amount of RAM configured in the system, in MB.
  int SDL_GetSystemRAM() {
    return _SDL_GetSystemRAM();
  }

  late final _SDL_GetSystemRAM_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetSystemRAM>>('SDL_GetSystemRAM');
  late final _dart_SDL_GetSystemRAM _SDL_GetSystemRAM =
      _SDL_GetSystemRAM_ptr.asFunction<_dart_SDL_GetSystemRAM>();

  /// \brief Report the alignment this system needs for SIMD allocations.
  ///
  /// This will return the minimum number of bytes to which a pointer must be
  /// aligned to be compatible with SIMD instructions on the current machine.
  /// For example, if the machine supports SSE only, it will return 16, but if
  /// it supports AVX-512F, it'll return 64 (etc). This only reports values for
  /// instruction sets SDL knows about, so if your SDL build doesn't have
  /// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
  /// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
  /// Plan accordingly.
  int SDL_SIMDGetAlignment() {
    return _SDL_SIMDGetAlignment();
  }

  late final _SDL_SIMDGetAlignment_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SIMDGetAlignment>>(
          'SDL_SIMDGetAlignment');
  late final _dart_SDL_SIMDGetAlignment _SDL_SIMDGetAlignment =
      _SDL_SIMDGetAlignment_ptr.asFunction<_dart_SDL_SIMDGetAlignment>();

  /// \brief Allocate memory in a SIMD-friendly way.
  ///
  /// This will allocate a block of memory that is suitable for use with SIMD
  /// instructions. Specifically, it will be properly aligned and padded for
  /// the system's supported vector instructions.
  ///
  /// The memory returned will be padded such that it is safe to read or write
  /// an incomplete vector at the end of the memory block. This can be useful
  /// so you don't have to drop back to a scalar fallback at the end of your
  /// SIMD processing loop to deal with the final elements without overflowing
  /// the allocated buffer.
  ///
  /// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free()
  /// or delete[], etc.
  ///
  /// Note that SDL will only deal with SIMD instruction sets it is aware of;
  /// for example, SDL 2.0.8 knows that SSE wants 16-byte vectors
  /// (SDL_HasSSE()), and AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't
  /// know that AVX-512 wants 64. To be clear: if you can't decide to use an
  /// instruction set with an SDL_Has*() function, don't use that instruction
  /// set with memory allocated through here.
  ///
  /// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't
  /// out of memory.
  ///
  /// \param len The length, in bytes, of the block to allocated. The actual
  /// allocated block might be larger due to padding, etc.
  /// \return Pointer to newly-allocated block, NULL if out of memory.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDRealloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDAlloc(
    int len,
  ) {
    return _SDL_SIMDAlloc(
      len,
    );
  }

  late final _SDL_SIMDAlloc_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SIMDAlloc>>('SDL_SIMDAlloc');
  late final _dart_SDL_SIMDAlloc _SDL_SIMDAlloc =
      _SDL_SIMDAlloc_ptr.asFunction<_dart_SDL_SIMDAlloc>();

  /// \brief Reallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
  /// SDL_malloc, memalign, new[], etc.
  ///
  /// \param mem The pointer obtained from SDL_SIMDAlloc. This function also
  /// accepts NULL, at which point this function is the same as
  /// calling SDL_realloc with a NULL pointer.
  /// \param len The length, in bytes, of the block to allocated. The actual
  /// allocated block might be larger due to padding, etc. Passing 0
  /// will return a non-NULL pointer, assuming the system isn't out of
  /// memory.
  /// \return Pointer to newly-reallocated block, NULL if out of memory.
  ///
  /// \sa SDL_SIMDAlignment
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDFree
  ffi.Pointer<ffi.Void> SDL_SIMDRealloc(
    ffi.Pointer<ffi.Void> mem,
    int len,
  ) {
    return _SDL_SIMDRealloc(
      mem,
      len,
    );
  }

  late final _SDL_SIMDRealloc_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SIMDRealloc>>('SDL_SIMDRealloc');
  late final _dart_SDL_SIMDRealloc _SDL_SIMDRealloc =
      _SDL_SIMDRealloc_ptr.asFunction<_dart_SDL_SIMDRealloc>();

  /// \brief Deallocate memory obtained from SDL_SIMDAlloc
  ///
  /// It is not valid to use this function on a pointer from anything but
  /// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
  /// SDL_malloc, memalign, new[], etc.
  ///
  /// However, SDL_SIMDFree(NULL) is a legal no-op.
  ///
  /// \sa SDL_SIMDAlloc
  /// \sa SDL_SIMDRealloc
  void SDL_SIMDFree(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _SDL_SIMDFree(
      ptr,
    );
  }

  late final _SDL_SIMDFree_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SIMDFree>>('SDL_SIMDFree');
  late final _dart_SDL_SIMDFree _SDL_SIMDFree =
      _SDL_SIMDFree_ptr.asFunction<_dart_SDL_SIMDFree>();

  /// \brief Get the human readable name of a pixel format
  ffi.Pointer<ffi.Int8> SDL_GetPixelFormatName(
    int format,
  ) {
    return _SDL_GetPixelFormatName(
      format,
    );
  }

  late final _SDL_GetPixelFormatName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPixelFormatName>>(
          'SDL_GetPixelFormatName');
  late final _dart_SDL_GetPixelFormatName _SDL_GetPixelFormatName =
      _SDL_GetPixelFormatName_ptr.asFunction<_dart_SDL_GetPixelFormatName>();

  /// \brief Convert one of the enumerated pixel formats to a bpp and RGBA masks.
  ///
  /// \return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.
  ///
  /// \sa SDL_MasksToPixelFormatEnum()
  int SDL_PixelFormatEnumToMasks(
    int format,
    ffi.Pointer<ffi.Int32> bpp,
    ffi.Pointer<ffi.Uint32> Rmask,
    ffi.Pointer<ffi.Uint32> Gmask,
    ffi.Pointer<ffi.Uint32> Bmask,
    ffi.Pointer<ffi.Uint32> Amask,
  ) {
    return _SDL_PixelFormatEnumToMasks(
      format,
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_PixelFormatEnumToMasks_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_PixelFormatEnumToMasks>>(
          'SDL_PixelFormatEnumToMasks');
  late final _dart_SDL_PixelFormatEnumToMasks _SDL_PixelFormatEnumToMasks =
      _SDL_PixelFormatEnumToMasks_ptr.asFunction<
          _dart_SDL_PixelFormatEnumToMasks>();

  /// \brief Convert a bpp and RGBA masks to an enumerated pixel format.
  ///
  /// \return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion
  /// wasn't possible.
  ///
  /// \sa SDL_PixelFormatEnumToMasks()
  int SDL_MasksToPixelFormatEnum(
    int bpp,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_MasksToPixelFormatEnum(
      bpp,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_MasksToPixelFormatEnum_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MasksToPixelFormatEnum>>(
          'SDL_MasksToPixelFormatEnum');
  late final _dart_SDL_MasksToPixelFormatEnum _SDL_MasksToPixelFormatEnum =
      _SDL_MasksToPixelFormatEnum_ptr.asFunction<
          _dart_SDL_MasksToPixelFormatEnum>();

  /// \brief Create an SDL_PixelFormat structure from a pixel format enum.
  ffi.Pointer<SDL_PixelFormat> SDL_AllocFormat(
    int pixel_format,
  ) {
    return _SDL_AllocFormat(
      pixel_format,
    );
  }

  late final _SDL_AllocFormat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AllocFormat>>('SDL_AllocFormat');
  late final _dart_SDL_AllocFormat _SDL_AllocFormat =
      _SDL_AllocFormat_ptr.asFunction<_dart_SDL_AllocFormat>();

  /// \brief Free an SDL_PixelFormat structure.
  void SDL_FreeFormat(
    ffi.Pointer<SDL_PixelFormat> format,
  ) {
    return _SDL_FreeFormat(
      format,
    );
  }

  late final _SDL_FreeFormat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreeFormat>>('SDL_FreeFormat');
  late final _dart_SDL_FreeFormat _SDL_FreeFormat =
      _SDL_FreeFormat_ptr.asFunction<_dart_SDL_FreeFormat>();

  /// \brief Create a palette structure with the specified number of color
  /// entries.
  ///
  /// \return A new palette, or NULL if there wasn't enough memory.
  ///
  /// \note The palette entries are initialized to white.
  ///
  /// \sa SDL_FreePalette()
  ffi.Pointer<SDL_Palette> SDL_AllocPalette(
    int ncolors,
  ) {
    return _SDL_AllocPalette(
      ncolors,
    );
  }

  late final _SDL_AllocPalette_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AllocPalette>>('SDL_AllocPalette');
  late final _dart_SDL_AllocPalette _SDL_AllocPalette =
      _SDL_AllocPalette_ptr.asFunction<_dart_SDL_AllocPalette>();

  /// \brief Set the palette for a pixel format structure.
  int SDL_SetPixelFormatPalette(
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetPixelFormatPalette(
      format,
      palette,
    );
  }

  late final _SDL_SetPixelFormatPalette_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetPixelFormatPalette>>(
          'SDL_SetPixelFormatPalette');
  late final _dart_SDL_SetPixelFormatPalette _SDL_SetPixelFormatPalette =
      _SDL_SetPixelFormatPalette_ptr.asFunction<
          _dart_SDL_SetPixelFormatPalette>();

  /// \brief Set a range of colors in a palette.
  ///
  /// \param palette    The palette to modify.
  /// \param colors     An array of colors to copy into the palette.
  /// \param firstcolor The index of the first palette entry to modify.
  /// \param ncolors    The number of entries to modify.
  ///
  /// \return 0 on success, or -1 if not all of the colors could be set.
  int SDL_SetPaletteColors(
    ffi.Pointer<SDL_Palette> palette,
    ffi.Pointer<SDL_Color> colors,
    int firstcolor,
    int ncolors,
  ) {
    return _SDL_SetPaletteColors(
      palette,
      colors,
      firstcolor,
      ncolors,
    );
  }

  late final _SDL_SetPaletteColors_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetPaletteColors>>(
          'SDL_SetPaletteColors');
  late final _dart_SDL_SetPaletteColors _SDL_SetPaletteColors =
      _SDL_SetPaletteColors_ptr.asFunction<_dart_SDL_SetPaletteColors>();

  /// \brief Free a palette created with SDL_AllocPalette().
  ///
  /// \sa SDL_AllocPalette()
  void SDL_FreePalette(
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_FreePalette(
      palette,
    );
  }

  late final _SDL_FreePalette_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreePalette>>('SDL_FreePalette');
  late final _dart_SDL_FreePalette _SDL_FreePalette =
      _SDL_FreePalette_ptr.asFunction<_dart_SDL_FreePalette>();

  /// \brief Maps an RGB triple to an opaque pixel value for a given pixel format.
  ///
  /// \sa SDL_MapRGBA
  int SDL_MapRGB(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
  ) {
    return _SDL_MapRGB(
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_MapRGB_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MapRGB>>('SDL_MapRGB');
  late final _dart_SDL_MapRGB _SDL_MapRGB =
      _SDL_MapRGB_ptr.asFunction<_dart_SDL_MapRGB>();

  /// \brief Maps an RGBA quadruple to a pixel value for a given pixel format.
  ///
  /// \sa SDL_MapRGB
  int SDL_MapRGBA(
    ffi.Pointer<SDL_PixelFormat> format,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_MapRGBA(
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_MapRGBA_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MapRGBA>>('SDL_MapRGBA');
  late final _dart_SDL_MapRGBA _SDL_MapRGBA =
      _SDL_MapRGBA_ptr.asFunction<_dart_SDL_MapRGBA>();

  /// \brief Get the RGB components from a pixel of the specified format.
  ///
  /// \sa SDL_GetRGBA
  void SDL_GetRGB(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<ffi.Uint8> r,
    ffi.Pointer<ffi.Uint8> g,
    ffi.Pointer<ffi.Uint8> b,
  ) {
    return _SDL_GetRGB(
      pixel,
      format,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetRGB_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRGB>>('SDL_GetRGB');
  late final _dart_SDL_GetRGB _SDL_GetRGB =
      _SDL_GetRGB_ptr.asFunction<_dart_SDL_GetRGB>();

  /// \brief Get the RGBA components from a pixel of the specified format.
  ///
  /// \sa SDL_GetRGB
  void SDL_GetRGBA(
    int pixel,
    ffi.Pointer<SDL_PixelFormat> format,
    ffi.Pointer<ffi.Uint8> r,
    ffi.Pointer<ffi.Uint8> g,
    ffi.Pointer<ffi.Uint8> b,
    ffi.Pointer<ffi.Uint8> a,
  ) {
    return _SDL_GetRGBA(
      pixel,
      format,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRGBA_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRGBA>>('SDL_GetRGBA');
  late final _dart_SDL_GetRGBA _SDL_GetRGBA =
      _SDL_GetRGBA_ptr.asFunction<_dart_SDL_GetRGBA>();

  /// \brief Calculate a 256 entry gamma ramp for a gamma value.
  void SDL_CalculateGammaRamp(
    double gamma,
    ffi.Pointer<ffi.Uint16> ramp,
  ) {
    return _SDL_CalculateGammaRamp(
      gamma,
      ramp,
    );
  }

  late final _SDL_CalculateGammaRamp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CalculateGammaRamp>>(
          'SDL_CalculateGammaRamp');
  late final _dart_SDL_CalculateGammaRamp _SDL_CalculateGammaRamp =
      _SDL_CalculateGammaRamp_ptr.asFunction<_dart_SDL_CalculateGammaRamp>();

  /// \brief Determine whether two rectangles intersect.
  ///
  /// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  int SDL_HasIntersection(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
  ) {
    return _SDL_HasIntersection(
      A,
      B,
    );
  }

  late final _SDL_HasIntersection_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasIntersection>>(
          'SDL_HasIntersection');
  late final _dart_SDL_HasIntersection _SDL_HasIntersection =
      _SDL_HasIntersection_ptr.asFunction<_dart_SDL_HasIntersection>();

  /// \brief Calculate the intersection of two rectangles.
  ///
  /// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  int SDL_IntersectRect(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_IntersectRect(
      A,
      B,
      result,
    );
  }

  late final _SDL_IntersectRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IntersectRect>>('SDL_IntersectRect');
  late final _dart_SDL_IntersectRect _SDL_IntersectRect =
      _SDL_IntersectRect_ptr.asFunction<_dart_SDL_IntersectRect>();

  /// \brief Calculate the union of two rectangles.
  void SDL_UnionRect(
    ffi.Pointer<SDL_Rect> A,
    ffi.Pointer<SDL_Rect> B,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_UnionRect(
      A,
      B,
      result,
    );
  }

  late final _SDL_UnionRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnionRect>>('SDL_UnionRect');
  late final _dart_SDL_UnionRect _SDL_UnionRect =
      _SDL_UnionRect_ptr.asFunction<_dart_SDL_UnionRect>();

  /// \brief Calculate a minimal rectangle enclosing a set of points
  ///
  /// \return SDL_TRUE if any points were within the clipping rect
  int SDL_EnclosePoints(
    ffi.Pointer<SDL_Point> points,
    int count,
    ffi.Pointer<SDL_Rect> clip,
    ffi.Pointer<SDL_Rect> result,
  ) {
    return _SDL_EnclosePoints(
      points,
      count,
      clip,
      result,
    );
  }

  late final _SDL_EnclosePoints_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_EnclosePoints>>('SDL_EnclosePoints');
  late final _dart_SDL_EnclosePoints _SDL_EnclosePoints =
      _SDL_EnclosePoints_ptr.asFunction<_dart_SDL_EnclosePoints>();

  /// \brief Calculate the intersection of a rectangle and line segment.
  ///
  /// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
  int SDL_IntersectRectAndLine(
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Int32> X1,
    ffi.Pointer<ffi.Int32> Y1,
    ffi.Pointer<ffi.Int32> X2,
    ffi.Pointer<ffi.Int32> Y2,
  ) {
    return _SDL_IntersectRectAndLine(
      rect,
      X1,
      Y1,
      X2,
      Y2,
    );
  }

  late final _SDL_IntersectRectAndLine_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IntersectRectAndLine>>(
          'SDL_IntersectRectAndLine');
  late final _dart_SDL_IntersectRectAndLine _SDL_IntersectRectAndLine =
      _SDL_IntersectRectAndLine_ptr.asFunction<
          _dart_SDL_IntersectRectAndLine>();

  /// \brief Create a custom blend mode, which may or may not be supported by a given renderer
  ///
  /// \param srcColorFactor source color factor
  /// \param dstColorFactor destination color factor
  /// \param colorOperation color operation
  /// \param srcAlphaFactor source alpha factor
  /// \param dstAlphaFactor destination alpha factor
  /// \param alphaOperation alpha operation
  ///
  /// The result of the blend mode operation will be:
  /// dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor
  /// and
  /// dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor
  int SDL_ComposeCustomBlendMode(
    int srcColorFactor,
    int dstColorFactor,
    int colorOperation,
    int srcAlphaFactor,
    int dstAlphaFactor,
    int alphaOperation,
  ) {
    return _SDL_ComposeCustomBlendMode(
      srcColorFactor,
      dstColorFactor,
      colorOperation,
      srcAlphaFactor,
      dstAlphaFactor,
      alphaOperation,
    );
  }

  late final _SDL_ComposeCustomBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ComposeCustomBlendMode>>(
          'SDL_ComposeCustomBlendMode');
  late final _dart_SDL_ComposeCustomBlendMode _SDL_ComposeCustomBlendMode =
      _SDL_ComposeCustomBlendMode_ptr.asFunction<
          _dart_SDL_ComposeCustomBlendMode>();

  /// Allocate and free an RGB surface.
  ///
  /// If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
  /// If the depth is greater than 8 bits, the pixel format is set using the
  /// flags '[RGB]mask'.
  ///
  /// If the function runs out of memory, it will return NULL.
  ///
  /// \param flags The \c flags are obsolete and should be set to 0.
  /// \param width The width in pixels of the surface to create.
  /// \param height The height in pixels of the surface to create.
  /// \param depth The depth in bits of the surface to create.
  /// \param Rmask The red mask of the surface to create.
  /// \param Gmask The green mask of the surface to create.
  /// \param Bmask The blue mask of the surface to create.
  /// \param Amask The alpha mask of the surface to create.
  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurface(
    int flags,
    int width,
    int height,
    int depth,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurface(
      flags,
      width,
      height,
      depth,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateRGBSurface>>(
          'SDL_CreateRGBSurface');
  late final _dart_SDL_CreateRGBSurface _SDL_CreateRGBSurface =
      _SDL_CreateRGBSurface_ptr.asFunction<_dart_SDL_CreateRGBSurface>();

  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormat(
    int flags,
    int width,
    int height,
    int depth,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormat(
      flags,
      width,
      height,
      depth,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateRGBSurfaceWithFormat>>(
          'SDL_CreateRGBSurfaceWithFormat');
  late final _dart_SDL_CreateRGBSurfaceWithFormat
      _SDL_CreateRGBSurfaceWithFormat = _SDL_CreateRGBSurfaceWithFormat_ptr
          .asFunction<_dart_SDL_CreateRGBSurfaceWithFormat>();

  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int Rmask,
    int Gmask,
    int Bmask,
    int Amask,
  ) {
    return _SDL_CreateRGBSurfaceFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      Rmask,
      Gmask,
      Bmask,
      Amask,
    );
  }

  late final _SDL_CreateRGBSurfaceFrom_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateRGBSurfaceFrom>>(
          'SDL_CreateRGBSurfaceFrom');
  late final _dart_SDL_CreateRGBSurfaceFrom _SDL_CreateRGBSurfaceFrom =
      _SDL_CreateRGBSurfaceFrom_ptr.asFunction<
          _dart_SDL_CreateRGBSurfaceFrom>();

  ffi.Pointer<SDL_Surface> SDL_CreateRGBSurfaceWithFormatFrom(
    ffi.Pointer<ffi.Void> pixels,
    int width,
    int height,
    int depth,
    int pitch,
    int format,
  ) {
    return _SDL_CreateRGBSurfaceWithFormatFrom(
      pixels,
      width,
      height,
      depth,
      pitch,
      format,
    );
  }

  late final _SDL_CreateRGBSurfaceWithFormatFrom_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateRGBSurfaceWithFormatFrom>>(
          'SDL_CreateRGBSurfaceWithFormatFrom');
  late final _dart_SDL_CreateRGBSurfaceWithFormatFrom
      _SDL_CreateRGBSurfaceWithFormatFrom =
      _SDL_CreateRGBSurfaceWithFormatFrom_ptr.asFunction<
          _dart_SDL_CreateRGBSurfaceWithFormatFrom>();

  void SDL_FreeSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_FreeSurface(
      surface,
    );
  }

  late final _SDL_FreeSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreeSurface>>('SDL_FreeSurface');
  late final _dart_SDL_FreeSurface _SDL_FreeSurface =
      _SDL_FreeSurface_ptr.asFunction<_dart_SDL_FreeSurface>();

  /// \brief Set the palette used by a surface.
  ///
  /// \return 0, or -1 if the surface format doesn't use a palette.
  ///
  /// \note A single palette can be shared with many surfaces.
  int SDL_SetSurfacePalette(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Palette> palette,
  ) {
    return _SDL_SetSurfacePalette(
      surface,
      palette,
    );
  }

  late final _SDL_SetSurfacePalette_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetSurfacePalette>>(
          'SDL_SetSurfacePalette');
  late final _dart_SDL_SetSurfacePalette _SDL_SetSurfacePalette =
      _SDL_SetSurfacePalette_ptr.asFunction<_dart_SDL_SetSurfacePalette>();

  /// \brief Sets up a surface for directly accessing the pixels.
  ///
  /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write
  /// to and read from \c surface->pixels, using the pixel format stored in
  /// \c surface->format.  Once you are done accessing the surface, you should
  /// use SDL_UnlockSurface() to release it.
  ///
  /// Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates
  /// to 0, then you can read and write to the surface at any time, and the
  /// pixel format of the surface will not change.
  ///
  /// No operating system or library calls should be made between lock/unlock
  /// pairs, as critical system locks may be held during this time.
  ///
  /// SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.
  ///
  /// \sa SDL_UnlockSurface()
  int SDL_LockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_LockSurface(
      surface,
    );
  }

  late final _SDL_LockSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockSurface>>('SDL_LockSurface');
  late final _dart_SDL_LockSurface _SDL_LockSurface =
      _SDL_LockSurface_ptr.asFunction<_dart_SDL_LockSurface>();

  /// \sa SDL_LockSurface()
  void SDL_UnlockSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_UnlockSurface(
      surface,
    );
  }

  late final _SDL_UnlockSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockSurface>>('SDL_UnlockSurface');
  late final _dart_SDL_UnlockSurface _SDL_UnlockSurface =
      _SDL_UnlockSurface_ptr.asFunction<_dart_SDL_UnlockSurface>();

  /// Load a surface from a seekable SDL data stream (memory or file).
  ///
  /// If \c freesrc is non-zero, the stream will be closed after being read.
  ///
  /// The new surface should be freed with SDL_FreeSurface().
  ///
  /// \return the new surface, or NULL if there was an error.
  ffi.Pointer<SDL_Surface> SDL_LoadBMP_RW(
    ffi.Pointer<SDL_RWops> src,
    int freesrc,
  ) {
    return _SDL_LoadBMP_RW(
      src,
      freesrc,
    );
  }

  late final _SDL_LoadBMP_RW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadBMP_RW>>('SDL_LoadBMP_RW');
  late final _dart_SDL_LoadBMP_RW _SDL_LoadBMP_RW =
      _SDL_LoadBMP_RW_ptr.asFunction<_dart_SDL_LoadBMP_RW>();

  /// Save a surface to a seekable SDL data stream (memory or file).
  ///
  /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
  /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
  /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
  /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
  /// not supported.
  ///
  /// If \c freedst is non-zero, the stream will be closed after being written.
  ///
  /// \return 0 if successful or -1 if there was an error.
  int SDL_SaveBMP_RW(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_RWops> dst,
    int freedst,
  ) {
    return _SDL_SaveBMP_RW(
      surface,
      dst,
      freedst,
    );
  }

  late final _SDL_SaveBMP_RW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SaveBMP_RW>>('SDL_SaveBMP_RW');
  late final _dart_SDL_SaveBMP_RW _SDL_SaveBMP_RW =
      _SDL_SaveBMP_RW_ptr.asFunction<_dart_SDL_SaveBMP_RW>();

  /// \brief Sets the RLE acceleration hint for a surface.
  ///
  /// \return 0 on success, or -1 if the surface is not valid
  ///
  /// \note If RLE is enabled, colorkey and alpha blending blits are much faster,
  /// but the surface must be locked before directly accessing the pixels.
  int SDL_SetSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
  ) {
    return _SDL_SetSurfaceRLE(
      surface,
      flag,
    );
  }

  late final _SDL_SetSurfaceRLE_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetSurfaceRLE>>('SDL_SetSurfaceRLE');
  late final _dart_SDL_SetSurfaceRLE _SDL_SetSurfaceRLE =
      _SDL_SetSurfaceRLE_ptr.asFunction<_dart_SDL_SetSurfaceRLE>();

  /// \brief Returns whether the surface is RLE enabled
  ///
  /// \return SDL_TRUE if the surface is RLE enabled, or SDL_FALSE if the surface is NULL or not RLE enabled
  int SDL_HasSurfaceRLE(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasSurfaceRLE(
      surface,
    );
  }

  late final _SDL_HasSurfaceRLE_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasSurfaceRLE>>('SDL_HasSurfaceRLE');
  late final _dart_SDL_HasSurfaceRLE _SDL_HasSurfaceRLE =
      _SDL_HasSurfaceRLE_ptr.asFunction<_dart_SDL_HasSurfaceRLE>();

  /// \brief Sets the color key (transparent pixel) in a blittable surface.
  ///
  /// \param surface The surface to update
  /// \param flag Non-zero to enable colorkey and 0 to disable colorkey
  /// \param key The transparent pixel in the native surface format
  ///
  /// \return 0 on success, or -1 if the surface is not valid
  ///
  /// You can pass SDL_RLEACCEL to enable RLE accelerated blits.
  int SDL_SetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    int flag,
    int key,
  ) {
    return _SDL_SetColorKey(
      surface,
      flag,
      key,
    );
  }

  late final _SDL_SetColorKey_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetColorKey>>('SDL_SetColorKey');
  late final _dart_SDL_SetColorKey _SDL_SetColorKey =
      _SDL_SetColorKey_ptr.asFunction<_dart_SDL_SetColorKey>();

  /// \brief Returns whether the surface has a color key
  ///
  /// \return SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key
  int SDL_HasColorKey(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_HasColorKey(
      surface,
    );
  }

  late final _SDL_HasColorKey_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasColorKey>>('SDL_HasColorKey');
  late final _dart_SDL_HasColorKey _SDL_HasColorKey =
      _SDL_HasColorKey_ptr.asFunction<_dart_SDL_HasColorKey>();

  /// \brief Gets the color key (transparent pixel) in a blittable surface.
  ///
  /// \param surface The surface to update
  /// \param key A pointer filled in with the transparent pixel in the native
  /// surface format
  ///
  /// \return 0 on success, or -1 if the surface is not valid or colorkey is not
  /// enabled.
  int SDL_GetColorKey(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Uint32> key,
  ) {
    return _SDL_GetColorKey(
      surface,
      key,
    );
  }

  late final _SDL_GetColorKey_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetColorKey>>('SDL_GetColorKey');
  late final _dart_SDL_GetColorKey _SDL_GetColorKey =
      _SDL_GetColorKey_ptr.asFunction<_dart_SDL_GetColorKey>();

  /// \brief Set an additional color value used in blit operations.
  ///
  /// \param surface The surface to update.
  /// \param r The red color value multiplied into blit operations.
  /// \param g The green color value multiplied into blit operations.
  /// \param b The blue color value multiplied into blit operations.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_GetSurfaceColorMod()
  int SDL_SetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetSurfaceColorMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetSurfaceColorMod>>(
          'SDL_SetSurfaceColorMod');
  late final _dart_SDL_SetSurfaceColorMod _SDL_SetSurfaceColorMod =
      _SDL_SetSurfaceColorMod_ptr.asFunction<_dart_SDL_SetSurfaceColorMod>();

  /// \brief Get the additional color value used in blit operations.
  ///
  /// \param surface The surface to query.
  /// \param r A pointer filled in with the current red color value.
  /// \param g A pointer filled in with the current green color value.
  /// \param b A pointer filled in with the current blue color value.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_SetSurfaceColorMod()
  int SDL_GetSurfaceColorMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Uint8> r,
    ffi.Pointer<ffi.Uint8> g,
    ffi.Pointer<ffi.Uint8> b,
  ) {
    return _SDL_GetSurfaceColorMod(
      surface,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetSurfaceColorMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetSurfaceColorMod>>(
          'SDL_GetSurfaceColorMod');
  late final _dart_SDL_GetSurfaceColorMod _SDL_GetSurfaceColorMod =
      _SDL_GetSurfaceColorMod_ptr.asFunction<_dart_SDL_GetSurfaceColorMod>();

  /// \brief Set an additional alpha value used in blit operations.
  ///
  /// \param surface The surface to update.
  /// \param alpha The alpha value multiplied into blit operations.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_GetSurfaceAlphaMod()
  int SDL_SetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    int alpha,
  ) {
    return _SDL_SetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_SetSurfaceAlphaMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetSurfaceAlphaMod>>(
          'SDL_SetSurfaceAlphaMod');
  late final _dart_SDL_SetSurfaceAlphaMod _SDL_SetSurfaceAlphaMod =
      _SDL_SetSurfaceAlphaMod_ptr.asFunction<_dart_SDL_SetSurfaceAlphaMod>();

  /// \brief Get the additional alpha value used in blit operations.
  ///
  /// \param surface The surface to query.
  /// \param alpha A pointer filled in with the current alpha value.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_SetSurfaceAlphaMod()
  int SDL_GetSurfaceAlphaMod(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Uint8> alpha,
  ) {
    return _SDL_GetSurfaceAlphaMod(
      surface,
      alpha,
    );
  }

  late final _SDL_GetSurfaceAlphaMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetSurfaceAlphaMod>>(
          'SDL_GetSurfaceAlphaMod');
  late final _dart_SDL_GetSurfaceAlphaMod _SDL_GetSurfaceAlphaMod =
      _SDL_GetSurfaceAlphaMod_ptr.asFunction<_dart_SDL_GetSurfaceAlphaMod>();

  /// \brief Set the blend mode used for blit operations.
  ///
  /// \param surface The surface to update.
  /// \param blendMode ::SDL_BlendMode to use for blit blending.
  ///
  /// \return 0 on success, or -1 if the parameters are not valid.
  ///
  /// \sa SDL_GetSurfaceBlendMode()
  int SDL_SetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    int blendMode,
  ) {
    return _SDL_SetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_SetSurfaceBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetSurfaceBlendMode>>(
          'SDL_SetSurfaceBlendMode');
  late final _dart_SDL_SetSurfaceBlendMode _SDL_SetSurfaceBlendMode =
      _SDL_SetSurfaceBlendMode_ptr.asFunction<_dart_SDL_SetSurfaceBlendMode>();

  /// \brief Get the blend mode used for blit operations.
  ///
  /// \param surface   The surface to query.
  /// \param blendMode A pointer filled in with the current blend mode.
  ///
  /// \return 0 on success, or -1 if the surface is not valid.
  ///
  /// \sa SDL_SetSurfaceBlendMode()
  int SDL_GetSurfaceBlendMode(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetSurfaceBlendMode(
      surface,
      blendMode,
    );
  }

  late final _SDL_GetSurfaceBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetSurfaceBlendMode>>(
          'SDL_GetSurfaceBlendMode');
  late final _dart_SDL_GetSurfaceBlendMode _SDL_GetSurfaceBlendMode =
      _SDL_GetSurfaceBlendMode_ptr.asFunction<_dart_SDL_GetSurfaceBlendMode>();

  /// Sets the clipping rectangle for the destination surface in a blit.
  ///
  /// If the clip rectangle is NULL, clipping will be disabled.
  ///
  /// If the clip rectangle doesn't intersect the surface, the function will
  /// return SDL_FALSE and blits will be completely clipped.  Otherwise the
  /// function returns SDL_TRUE and blits to the surface will be clipped to
  /// the intersection of the surface area and the clipping rectangle.
  ///
  /// Note that blits are automatically clipped to the edges of the source
  /// and destination surfaces.
  int SDL_SetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_SetClipRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetClipRect>>('SDL_SetClipRect');
  late final _dart_SDL_SetClipRect _SDL_SetClipRect =
      _SDL_SetClipRect_ptr.asFunction<_dart_SDL_SetClipRect>();

  /// Gets the clipping rectangle for the destination surface in a blit.
  ///
  /// \c rect must be a pointer to a valid rectangle which will be filled
  /// with the correct values.
  void SDL_GetClipRect(
    ffi.Pointer<SDL_Surface> surface,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetClipRect(
      surface,
      rect,
    );
  }

  late final _SDL_GetClipRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetClipRect>>('SDL_GetClipRect');
  late final _dart_SDL_GetClipRect _SDL_GetClipRect =
      _SDL_GetClipRect_ptr.asFunction<_dart_SDL_GetClipRect>();

  ffi.Pointer<SDL_Surface> SDL_DuplicateSurface(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_DuplicateSurface(
      surface,
    );
  }

  late final _SDL_DuplicateSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DuplicateSurface>>(
          'SDL_DuplicateSurface');
  late final _dart_SDL_DuplicateSurface _SDL_DuplicateSurface =
      _SDL_DuplicateSurface_ptr.asFunction<_dart_SDL_DuplicateSurface>();

  /// Creates a new surface of the specified format, and then copies and maps
  /// the given surface to it so the blit of the converted surface will be as
  /// fast as possible.  If this function fails, it returns NULL.
  ///
  /// The \c flags parameter is passed to SDL_CreateRGBSurface() and has those
  /// semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and
  /// SDL will try to RLE accelerate colorkey and alpha blits in the resulting
  /// surface.
  ffi.Pointer<SDL_Surface> SDL_ConvertSurface(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_PixelFormat> fmt,
    int flags,
  ) {
    return _SDL_ConvertSurface(
      src,
      fmt,
      flags,
    );
  }

  late final _SDL_ConvertSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ConvertSurface>>('SDL_ConvertSurface');
  late final _dart_SDL_ConvertSurface _SDL_ConvertSurface =
      _SDL_ConvertSurface_ptr.asFunction<_dart_SDL_ConvertSurface>();

  ffi.Pointer<SDL_Surface> SDL_ConvertSurfaceFormat(
    ffi.Pointer<SDL_Surface> src,
    int pixel_format,
    int flags,
  ) {
    return _SDL_ConvertSurfaceFormat(
      src,
      pixel_format,
      flags,
    );
  }

  late final _SDL_ConvertSurfaceFormat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ConvertSurfaceFormat>>(
          'SDL_ConvertSurfaceFormat');
  late final _dart_SDL_ConvertSurfaceFormat _SDL_ConvertSurfaceFormat =
      _SDL_ConvertSurfaceFormat_ptr.asFunction<
          _dart_SDL_ConvertSurfaceFormat>();

  /// \brief Copy a block of pixels of one format to another format
  ///
  /// \return 0 on success, or -1 if there was an error
  int SDL_ConvertPixels(
    int width,
    int height,
    int src_format,
    ffi.Pointer<ffi.Void> src,
    int src_pitch,
    int dst_format,
    ffi.Pointer<ffi.Void> dst,
    int dst_pitch,
  ) {
    return _SDL_ConvertPixels(
      width,
      height,
      src_format,
      src,
      src_pitch,
      dst_format,
      dst,
      dst_pitch,
    );
  }

  late final _SDL_ConvertPixels_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ConvertPixels>>('SDL_ConvertPixels');
  late final _dart_SDL_ConvertPixels _SDL_ConvertPixels =
      _SDL_ConvertPixels_ptr.asFunction<_dart_SDL_ConvertPixels>();

  /// Performs a fast fill of the given rectangle with \c color.
  ///
  /// If \c rect is NULL, the whole surface will be filled with \c color.
  ///
  /// The color should be a pixel of the format used by the surface, and
  /// can be generated by the SDL_MapRGB() function.
  ///
  /// \return 0 on success, or -1 on error.
  int SDL_FillRect(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rect,
    int color,
  ) {
    return _SDL_FillRect(
      dst,
      rect,
      color,
    );
  }

  late final _SDL_FillRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FillRect>>('SDL_FillRect');
  late final _dart_SDL_FillRect _SDL_FillRect =
      _SDL_FillRect_ptr.asFunction<_dart_SDL_FillRect>();

  int SDL_FillRects(
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> rects,
    int count,
    int color,
  ) {
    return _SDL_FillRects(
      dst,
      rects,
      count,
      color,
    );
  }

  late final _SDL_FillRects_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FillRects>>('SDL_FillRects');
  late final _dart_SDL_FillRects _SDL_FillRects =
      _SDL_FillRects_ptr.asFunction<_dart_SDL_FillRects>();

  /// This is the public blit function, SDL_BlitSurface(), and it performs
  /// rectangle validation and clipping before passing it to SDL_LowerBlit()
  int SDL_UpperBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UpperBlit>>('SDL_UpperBlit');
  late final _dart_SDL_UpperBlit _SDL_UpperBlit =
      _SDL_UpperBlit_ptr.asFunction<_dart_SDL_UpperBlit>();

  /// This is a semi-private blit function and it performs low-level surface
  /// blitting only.
  int SDL_LowerBlit(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlit(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LowerBlit>>('SDL_LowerBlit');
  late final _dart_SDL_LowerBlit _SDL_LowerBlit =
      _SDL_LowerBlit_ptr.asFunction<_dart_SDL_LowerBlit>();

  /// \brief Perform a fast, low quality, stretch blit between two surfaces of the
  /// same pixel format.
  ///
  /// \note This function uses a static buffer, and is not thread-safe.
  int SDL_SoftStretch(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_SoftStretch(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_SoftStretch_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SoftStretch>>('SDL_SoftStretch');
  late final _dart_SDL_SoftStretch _SDL_SoftStretch =
      _SDL_SoftStretch_ptr.asFunction<_dart_SDL_SoftStretch>();

  /// This is the public scaled blit function, SDL_BlitScaled(), and it performs
  /// rectangle validation and clipping before passing it to SDL_LowerBlitScaled()
  int SDL_UpperBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_UpperBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_UpperBlitScaled_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UpperBlitScaled>>(
          'SDL_UpperBlitScaled');
  late final _dart_SDL_UpperBlitScaled _SDL_UpperBlitScaled =
      _SDL_UpperBlitScaled_ptr.asFunction<_dart_SDL_UpperBlitScaled>();

  /// This is a semi-private blit function and it performs low-level surface
  /// scaled blitting only.
  int SDL_LowerBlitScaled(
    ffi.Pointer<SDL_Surface> src,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Surface> dst,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_LowerBlitScaled(
      src,
      srcrect,
      dst,
      dstrect,
    );
  }

  late final _SDL_LowerBlitScaled_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LowerBlitScaled>>(
          'SDL_LowerBlitScaled');
  late final _dart_SDL_LowerBlitScaled _SDL_LowerBlitScaled =
      _SDL_LowerBlitScaled_ptr.asFunction<_dart_SDL_LowerBlitScaled>();

  /// \brief Set the YUV conversion mode
  void SDL_SetYUVConversionMode(
    int mode,
  ) {
    return _SDL_SetYUVConversionMode(
      mode,
    );
  }

  late final _SDL_SetYUVConversionMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetYUVConversionMode>>(
          'SDL_SetYUVConversionMode');
  late final _dart_SDL_SetYUVConversionMode _SDL_SetYUVConversionMode =
      _SDL_SetYUVConversionMode_ptr.asFunction<
          _dart_SDL_SetYUVConversionMode>();

  /// \brief Get the YUV conversion mode
  int SDL_GetYUVConversionMode() {
    return _SDL_GetYUVConversionMode();
  }

  late final _SDL_GetYUVConversionMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetYUVConversionMode>>(
          'SDL_GetYUVConversionMode');
  late final _dart_SDL_GetYUVConversionMode _SDL_GetYUVConversionMode =
      _SDL_GetYUVConversionMode_ptr.asFunction<
          _dart_SDL_GetYUVConversionMode>();

  /// \brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
  int SDL_GetYUVConversionModeForResolution(
    int width,
    int height,
  ) {
    return _SDL_GetYUVConversionModeForResolution(
      width,
      height,
    );
  }

  late final _SDL_GetYUVConversionModeForResolution_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetYUVConversionModeForResolution>>(
          'SDL_GetYUVConversionModeForResolution');
  late final _dart_SDL_GetYUVConversionModeForResolution
      _SDL_GetYUVConversionModeForResolution =
      _SDL_GetYUVConversionModeForResolution_ptr.asFunction<
          _dart_SDL_GetYUVConversionModeForResolution>();

  /// \brief Get the number of video drivers compiled into SDL
  ///
  /// \sa SDL_GetVideoDriver()
  int SDL_GetNumVideoDrivers() {
    return _SDL_GetNumVideoDrivers();
  }

  late final _SDL_GetNumVideoDrivers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumVideoDrivers>>(
          'SDL_GetNumVideoDrivers');
  late final _dart_SDL_GetNumVideoDrivers _SDL_GetNumVideoDrivers =
      _SDL_GetNumVideoDrivers_ptr.asFunction<_dart_SDL_GetNumVideoDrivers>();

  /// \brief Get the name of a built in video driver.
  ///
  /// \note The video drivers are presented in the order in which they are
  /// normally checked during initialization.
  ///
  /// \sa SDL_GetNumVideoDrivers()
  ffi.Pointer<ffi.Int8> SDL_GetVideoDriver(
    int index,
  ) {
    return _SDL_GetVideoDriver(
      index,
    );
  }

  late final _SDL_GetVideoDriver_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetVideoDriver>>('SDL_GetVideoDriver');
  late final _dart_SDL_GetVideoDriver _SDL_GetVideoDriver =
      _SDL_GetVideoDriver_ptr.asFunction<_dart_SDL_GetVideoDriver>();

  /// \brief Initialize the video subsystem, optionally specifying a video driver.
  ///
  /// \param driver_name Initialize a specific driver by name, or NULL for the
  /// default video driver.
  ///
  /// \return 0 on success, -1 on error
  ///
  /// This function initializes the video subsystem; setting up a connection
  /// to the window manager, etc, and determines the available display modes
  /// and pixel formats, but does not initialize a window or graphics mode.
  ///
  /// \sa SDL_VideoQuit()
  int SDL_VideoInit(
    ffi.Pointer<ffi.Int8> driver_name,
  ) {
    return _SDL_VideoInit(
      driver_name,
    );
  }

  late final _SDL_VideoInit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_VideoInit>>('SDL_VideoInit');
  late final _dart_SDL_VideoInit _SDL_VideoInit =
      _SDL_VideoInit_ptr.asFunction<_dart_SDL_VideoInit>();

  /// \brief Shuts down the video subsystem.
  ///
  /// This function closes all windows, and restores the original video mode.
  ///
  /// \sa SDL_VideoInit()
  void SDL_VideoQuit() {
    return _SDL_VideoQuit();
  }

  late final _SDL_VideoQuit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_VideoQuit>>('SDL_VideoQuit');
  late final _dart_SDL_VideoQuit _SDL_VideoQuit =
      _SDL_VideoQuit_ptr.asFunction<_dart_SDL_VideoQuit>();

  /// \brief Returns the name of the currently initialized video driver.
  ///
  /// \return The name of the current video driver or NULL if no driver
  /// has been initialized
  ///
  /// \sa SDL_GetNumVideoDrivers()
  /// \sa SDL_GetVideoDriver()
  ffi.Pointer<ffi.Int8> SDL_GetCurrentVideoDriver() {
    return _SDL_GetCurrentVideoDriver();
  }

  late final _SDL_GetCurrentVideoDriver_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetCurrentVideoDriver>>(
          'SDL_GetCurrentVideoDriver');
  late final _dart_SDL_GetCurrentVideoDriver _SDL_GetCurrentVideoDriver =
      _SDL_GetCurrentVideoDriver_ptr.asFunction<
          _dart_SDL_GetCurrentVideoDriver>();

  /// \brief Returns the number of available video displays.
  ///
  /// \sa SDL_GetDisplayBounds()
  int SDL_GetNumVideoDisplays() {
    return _SDL_GetNumVideoDisplays();
  }

  late final _SDL_GetNumVideoDisplays_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumVideoDisplays>>(
          'SDL_GetNumVideoDisplays');
  late final _dart_SDL_GetNumVideoDisplays _SDL_GetNumVideoDisplays =
      _SDL_GetNumVideoDisplays_ptr.asFunction<_dart_SDL_GetNumVideoDisplays>();

  /// \brief Get the name of a display in UTF-8 encoding
  ///
  /// \return The name of a display, or NULL for an invalid display index.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  ffi.Pointer<ffi.Int8> SDL_GetDisplayName(
    int displayIndex,
  ) {
    return _SDL_GetDisplayName(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDisplayName>>('SDL_GetDisplayName');
  late final _dart_SDL_GetDisplayName _SDL_GetDisplayName =
      _SDL_GetDisplayName_ptr.asFunction<_dart_SDL_GetDisplayName>();

  /// \brief Get the desktop area represented by a display, with the primary
  /// display located at 0,0
  ///
  /// \return 0 on success, or -1 if the index is out of range.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayBounds_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDisplayBounds>>(
          'SDL_GetDisplayBounds');
  late final _dart_SDL_GetDisplayBounds _SDL_GetDisplayBounds =
      _SDL_GetDisplayBounds_ptr.asFunction<_dart_SDL_GetDisplayBounds>();

  /// \brief Get the usable desktop area represented by a display, with the
  /// primary display located at 0,0
  ///
  /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
  /// reserved by the system removed. For example, on Mac OS X, this subtracts
  /// the area occupied by the menu bar and dock.
  ///
  /// Setting a window to be fullscreen generally bypasses these unusable areas,
  /// so these are good guidelines for the maximum space available to a
  /// non-fullscreen window.
  ///
  /// \return 0 on success, or -1 if the index is out of range.
  ///
  /// \sa SDL_GetDisplayBounds()
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayUsableBounds(
    int displayIndex,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_GetDisplayUsableBounds(
      displayIndex,
      rect,
    );
  }

  late final _SDL_GetDisplayUsableBounds_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDisplayUsableBounds>>(
          'SDL_GetDisplayUsableBounds');
  late final _dart_SDL_GetDisplayUsableBounds _SDL_GetDisplayUsableBounds =
      _SDL_GetDisplayUsableBounds_ptr.asFunction<
          _dart_SDL_GetDisplayUsableBounds>();

  /// \brief Get the dots/pixels-per-inch for a display
  ///
  /// \note Diagonal, horizontal and vertical DPI can all be optionally
  /// returned if the parameter is non-NULL.
  ///
  /// \return 0 on success, or -1 if no DPI information is available or the index is out of range.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayDPI(
    int displayIndex,
    ffi.Pointer<ffi.Float> ddpi,
    ffi.Pointer<ffi.Float> hdpi,
    ffi.Pointer<ffi.Float> vdpi,
  ) {
    return _SDL_GetDisplayDPI(
      displayIndex,
      ddpi,
      hdpi,
      vdpi,
    );
  }

  late final _SDL_GetDisplayDPI_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDisplayDPI>>('SDL_GetDisplayDPI');
  late final _dart_SDL_GetDisplayDPI _SDL_GetDisplayDPI =
      _SDL_GetDisplayDPI_ptr.asFunction<_dart_SDL_GetDisplayDPI>();

  /// \brief Get the orientation of a display
  ///
  /// \return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available.
  ///
  /// \sa SDL_GetNumVideoDisplays()
  int SDL_GetDisplayOrientation(
    int displayIndex,
  ) {
    return _SDL_GetDisplayOrientation(
      displayIndex,
    );
  }

  late final _SDL_GetDisplayOrientation_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDisplayOrientation>>(
          'SDL_GetDisplayOrientation');
  late final _dart_SDL_GetDisplayOrientation _SDL_GetDisplayOrientation =
      _SDL_GetDisplayOrientation_ptr.asFunction<
          _dart_SDL_GetDisplayOrientation>();

  /// \brief Returns the number of available display modes.
  ///
  /// \sa SDL_GetDisplayMode()
  int SDL_GetNumDisplayModes(
    int displayIndex,
  ) {
    return _SDL_GetNumDisplayModes(
      displayIndex,
    );
  }

  late final _SDL_GetNumDisplayModes_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumDisplayModes>>(
          'SDL_GetNumDisplayModes');
  late final _dart_SDL_GetNumDisplayModes _SDL_GetNumDisplayModes =
      _SDL_GetNumDisplayModes_ptr.asFunction<_dart_SDL_GetNumDisplayModes>();

  /// \brief Fill in information about a specific display mode.
  ///
  /// \note The display modes are sorted in this priority:
  /// \li bits per pixel -> more colors to fewer colors
  /// \li width -> largest to smallest
  /// \li height -> largest to smallest
  /// \li refresh rate -> highest to lowest
  ///
  /// \sa SDL_GetNumDisplayModes()
  int SDL_GetDisplayMode(
    int displayIndex,
    int modeIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDisplayMode(
      displayIndex,
      modeIndex,
      mode,
    );
  }

  late final _SDL_GetDisplayMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDisplayMode>>('SDL_GetDisplayMode');
  late final _dart_SDL_GetDisplayMode _SDL_GetDisplayMode =
      _SDL_GetDisplayMode_ptr.asFunction<_dart_SDL_GetDisplayMode>();

  /// \brief Fill in information about the desktop display mode.
  int SDL_GetDesktopDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetDesktopDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetDesktopDisplayMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDesktopDisplayMode>>(
          'SDL_GetDesktopDisplayMode');
  late final _dart_SDL_GetDesktopDisplayMode _SDL_GetDesktopDisplayMode =
      _SDL_GetDesktopDisplayMode_ptr.asFunction<
          _dart_SDL_GetDesktopDisplayMode>();

  /// \brief Fill in information about the current display mode.
  int SDL_GetCurrentDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetCurrentDisplayMode(
      displayIndex,
      mode,
    );
  }

  late final _SDL_GetCurrentDisplayMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetCurrentDisplayMode>>(
          'SDL_GetCurrentDisplayMode');
  late final _dart_SDL_GetCurrentDisplayMode _SDL_GetCurrentDisplayMode =
      _SDL_GetCurrentDisplayMode_ptr.asFunction<
          _dart_SDL_GetCurrentDisplayMode>();

  /// \brief Get the closest match to the requested display mode.
  ///
  /// \param displayIndex The index of display from which mode should be queried.
  /// \param mode The desired display mode
  /// \param closest A pointer to a display mode to be filled in with the closest
  /// match of the available display modes.
  ///
  /// \return The passed in value \c closest, or NULL if no matching video mode
  /// was available.
  ///
  /// The available display modes are scanned, and \c closest is filled in with the
  /// closest mode matching the requested mode and returned.  The mode format and
  /// refresh_rate default to the desktop mode if they are 0.  The modes are
  /// scanned with size being first priority, format being second priority, and
  /// finally checking the refresh_rate.  If all the available modes are too
  /// small, then NULL is returned.
  ///
  /// \sa SDL_GetNumDisplayModes()
  /// \sa SDL_GetDisplayMode()
  ffi.Pointer<SDL_DisplayMode> SDL_GetClosestDisplayMode(
    int displayIndex,
    ffi.Pointer<SDL_DisplayMode> mode,
    ffi.Pointer<SDL_DisplayMode> closest,
  ) {
    return _SDL_GetClosestDisplayMode(
      displayIndex,
      mode,
      closest,
    );
  }

  late final _SDL_GetClosestDisplayMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetClosestDisplayMode>>(
          'SDL_GetClosestDisplayMode');
  late final _dart_SDL_GetClosestDisplayMode _SDL_GetClosestDisplayMode =
      _SDL_GetClosestDisplayMode_ptr.asFunction<
          _dart_SDL_GetClosestDisplayMode>();

  /// \brief Get the display index associated with a window.
  ///
  /// \return the display index of the display containing the center of the
  /// window, or -1 on error.
  int SDL_GetWindowDisplayIndex(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowDisplayIndex(
      window,
    );
  }

  late final _SDL_GetWindowDisplayIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowDisplayIndex>>(
          'SDL_GetWindowDisplayIndex');
  late final _dart_SDL_GetWindowDisplayIndex _SDL_GetWindowDisplayIndex =
      _SDL_GetWindowDisplayIndex_ptr.asFunction<
          _dart_SDL_GetWindowDisplayIndex>();

  /// \brief Set the display mode used when a fullscreen window is visible.
  ///
  /// By default the window's dimensions and the desktop format and refresh rate
  /// are used.
  ///
  /// \param window The window for which the display mode should be set.
  /// \param mode The mode to use, or NULL for the default mode.
  ///
  /// \return 0 on success, or -1 if setting the display mode failed.
  ///
  /// \sa SDL_GetWindowDisplayMode()
  /// \sa SDL_SetWindowFullscreen()
  int SDL_SetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_SetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_SetWindowDisplayMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowDisplayMode>>(
          'SDL_SetWindowDisplayMode');
  late final _dart_SDL_SetWindowDisplayMode _SDL_SetWindowDisplayMode =
      _SDL_SetWindowDisplayMode_ptr.asFunction<
          _dart_SDL_SetWindowDisplayMode>();

  /// \brief Fill in information about the display mode used when a fullscreen
  /// window is visible.
  ///
  /// \sa SDL_SetWindowDisplayMode()
  /// \sa SDL_SetWindowFullscreen()
  int SDL_GetWindowDisplayMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_DisplayMode> mode,
  ) {
    return _SDL_GetWindowDisplayMode(
      window,
      mode,
    );
  }

  late final _SDL_GetWindowDisplayMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowDisplayMode>>(
          'SDL_GetWindowDisplayMode');
  late final _dart_SDL_GetWindowDisplayMode _SDL_GetWindowDisplayMode =
      _SDL_GetWindowDisplayMode_ptr.asFunction<
          _dart_SDL_GetWindowDisplayMode>();

  /// \brief Get the pixel format associated with the window.
  int SDL_GetWindowPixelFormat(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowPixelFormat(
      window,
    );
  }

  late final _SDL_GetWindowPixelFormat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowPixelFormat>>(
          'SDL_GetWindowPixelFormat');
  late final _dart_SDL_GetWindowPixelFormat _SDL_GetWindowPixelFormat =
      _SDL_GetWindowPixelFormat_ptr.asFunction<
          _dart_SDL_GetWindowPixelFormat>();

  /// \brief Create a window with the specified position, dimensions, and flags.
  ///
  /// \param title The title of the window, in UTF-8 encoding.
  /// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param w     The width of the window, in screen coordinates.
  /// \param h     The height of the window, in screen coordinates.
  /// \param flags The flags for the window, a mask of any of the following:
  /// ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,
  /// ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,
  /// ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,
  /// ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,
  /// ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN
  /// ::SDL_WINDOW_METAL.
  ///
  /// \return The created window, or NULL if window creation failed.
  ///
  /// If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size
  /// in pixels may differ from its size in screen coordinates on platforms with
  /// high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query
  /// the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),
  /// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the
  /// drawable size in pixels.
  ///
  /// If the window is created with any of the SDL_WINDOW_OPENGL or
  /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
  /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
  /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
  ///
  /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
  /// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
  ///
  /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
  /// SDL_CreateWindow() will fail.
  ///
  /// \note On non-Apple devices, SDL requires you to either not link to the
  /// Vulkan loader or link to a dynamic library version. This limitation
  /// may be removed in a future version of SDL.
  ///
  /// \sa SDL_DestroyWindow()
  /// \sa SDL_GL_LoadLibrary()
  /// \sa SDL_Vulkan_LoadLibrary()
  ffi.Pointer<SDL_Window> SDL_CreateWindow(
    ffi.Pointer<ffi.Int8> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateWindow>>('SDL_CreateWindow');
  late final _dart_SDL_CreateWindow _SDL_CreateWindow =
      _SDL_CreateWindow_ptr.asFunction<_dart_SDL_CreateWindow>();

  /// \brief Create an SDL window from an existing native window.
  ///
  /// \param data A pointer to driver-dependent window creation data
  ///
  /// \return The created window, or NULL if window creation failed.
  ///
  /// \sa SDL_DestroyWindow()
  ffi.Pointer<SDL_Window> SDL_CreateWindowFrom(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _SDL_CreateWindowFrom(
      data,
    );
  }

  late final _SDL_CreateWindowFrom_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateWindowFrom>>(
          'SDL_CreateWindowFrom');
  late final _dart_SDL_CreateWindowFrom _SDL_CreateWindowFrom =
      _SDL_CreateWindowFrom_ptr.asFunction<_dart_SDL_CreateWindowFrom>();

  /// \brief Get the numeric ID of a window, for logging purposes.
  int SDL_GetWindowID(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowID(
      window,
    );
  }

  late final _SDL_GetWindowID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowID>>('SDL_GetWindowID');
  late final _dart_SDL_GetWindowID _SDL_GetWindowID =
      _SDL_GetWindowID_ptr.asFunction<_dart_SDL_GetWindowID>();

  /// \brief Get a window from a stored ID, or NULL if it doesn't exist.
  ffi.Pointer<SDL_Window> SDL_GetWindowFromID(
    int id,
  ) {
    return _SDL_GetWindowFromID(
      id,
    );
  }

  late final _SDL_GetWindowFromID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowFromID>>(
          'SDL_GetWindowFromID');
  late final _dart_SDL_GetWindowFromID _SDL_GetWindowFromID =
      _SDL_GetWindowFromID_ptr.asFunction<_dart_SDL_GetWindowFromID>();

  /// \brief Get the window flags.
  int SDL_GetWindowFlags(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowFlags(
      window,
    );
  }

  late final _SDL_GetWindowFlags_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowFlags>>('SDL_GetWindowFlags');
  late final _dart_SDL_GetWindowFlags _SDL_GetWindowFlags =
      _SDL_GetWindowFlags_ptr.asFunction<_dart_SDL_GetWindowFlags>();

  /// \brief Set the title of a window, in UTF-8 format.
  ///
  /// \sa SDL_GetWindowTitle()
  void SDL_SetWindowTitle(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int8> title,
  ) {
    return _SDL_SetWindowTitle(
      window,
      title,
    );
  }

  late final _SDL_SetWindowTitle_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowTitle>>('SDL_SetWindowTitle');
  late final _dart_SDL_SetWindowTitle _SDL_SetWindowTitle =
      _SDL_SetWindowTitle_ptr.asFunction<_dart_SDL_SetWindowTitle>();

  /// \brief Get the title of a window, in UTF-8 format.
  ///
  /// \sa SDL_SetWindowTitle()
  ffi.Pointer<ffi.Int8> SDL_GetWindowTitle(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowTitle(
      window,
    );
  }

  late final _SDL_GetWindowTitle_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowTitle>>('SDL_GetWindowTitle');
  late final _dart_SDL_GetWindowTitle _SDL_GetWindowTitle =
      _SDL_GetWindowTitle_ptr.asFunction<_dart_SDL_GetWindowTitle>();

  /// \brief Set the icon for a window.
  ///
  /// \param window The window for which the icon should be set.
  /// \param icon The icon for the window.
  void SDL_SetWindowIcon(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> icon,
  ) {
    return _SDL_SetWindowIcon(
      window,
      icon,
    );
  }

  late final _SDL_SetWindowIcon_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowIcon>>('SDL_SetWindowIcon');
  late final _dart_SDL_SetWindowIcon _SDL_SetWindowIcon =
      _SDL_SetWindowIcon_ptr.asFunction<_dart_SDL_SetWindowIcon>();

  /// \brief Associate an arbitrary named pointer with a window.
  ///
  /// \param window   The window to associate with the pointer.
  /// \param name     The name of the pointer.
  /// \param userdata The associated pointer.
  ///
  /// \return The previous value associated with 'name'
  ///
  /// \note The name is case-sensitive.
  ///
  /// \sa SDL_GetWindowData()
  ffi.Pointer<ffi.Void> SDL_SetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowData(
      window,
      name,
      userdata,
    );
  }

  late final _SDL_SetWindowData_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowData>>('SDL_SetWindowData');
  late final _dart_SDL_SetWindowData _SDL_SetWindowData =
      _SDL_SetWindowData_ptr.asFunction<_dart_SDL_SetWindowData>();

  /// \brief Retrieve the data pointer associated with a window.
  ///
  /// \param window   The window to query.
  /// \param name     The name of the pointer.
  ///
  /// \return The value associated with 'name'
  ///
  /// \sa SDL_SetWindowData()
  ffi.Pointer<ffi.Void> SDL_GetWindowData(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetWindowData(
      window,
      name,
    );
  }

  late final _SDL_GetWindowData_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowData>>('SDL_GetWindowData');
  late final _dart_SDL_GetWindowData _SDL_GetWindowData =
      _SDL_GetWindowData_ptr.asFunction<_dart_SDL_GetWindowData>();

  /// \brief Set the position of a window.
  ///
  /// \param window   The window to reposition.
  /// \param x        The x coordinate of the window in screen coordinates, or
  /// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y        The y coordinate of the window in screen coordinates, or
  /// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
  ///
  /// \note The window coordinate origin is the upper left of the display.
  ///
  /// \sa SDL_GetWindowPosition()
  void SDL_SetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_SetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_SetWindowPosition_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowPosition>>(
          'SDL_SetWindowPosition');
  late final _dart_SDL_SetWindowPosition _SDL_SetWindowPosition =
      _SDL_SetWindowPosition_ptr.asFunction<_dart_SDL_SetWindowPosition>();

  /// \brief Get the position of a window.
  ///
  /// \param window   The window to query.
  /// \param x        Pointer to variable for storing the x position, in screen
  /// coordinates. May be NULL.
  /// \param y        Pointer to variable for storing the y position, in screen
  /// coordinates. May be NULL.
  ///
  /// \sa SDL_SetWindowPosition()
  void SDL_GetWindowPosition(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetWindowPosition(
      window,
      x,
      y,
    );
  }

  late final _SDL_GetWindowPosition_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowPosition>>(
          'SDL_GetWindowPosition');
  late final _dart_SDL_GetWindowPosition _SDL_GetWindowPosition =
      _SDL_GetWindowPosition_ptr.asFunction<_dart_SDL_GetWindowPosition>();

  /// \brief Set the size of a window's client area.
  ///
  /// \param window   The window to resize.
  /// \param w        The width of the window, in screen coordinates. Must be >0.
  /// \param h        The height of the window, in screen coordinates. Must be >0.
  ///
  /// \note Fullscreen windows automatically match the size of the display mode,
  /// and you should use SDL_SetWindowDisplayMode() to change their size.
  ///
  /// The window size in screen coordinates may differ from the size in pixels, if
  /// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
  /// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// \sa SDL_GetWindowSize()
  /// \sa SDL_SetWindowDisplayMode()
  void SDL_SetWindowSize(
    ffi.Pointer<SDL_Window> window,
    int w,
    int h,
  ) {
    return _SDL_SetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_SetWindowSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowSize>>('SDL_SetWindowSize');
  late final _dart_SDL_SetWindowSize _SDL_SetWindowSize =
      _SDL_SetWindowSize_ptr.asFunction<_dart_SDL_SetWindowSize>();

  /// \brief Get the size of a window's client area.
  ///
  /// \param window   The window to query.
  /// \param w        Pointer to variable for storing the width, in screen
  /// coordinates. May be NULL.
  /// \param h        Pointer to variable for storing the height, in screen
  /// coordinates. May be NULL.
  ///
  /// The window size in screen coordinates may differ from the size in pixels, if
  /// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
  /// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
  /// SDL_GetRendererOutputSize() to get the real client area size in pixels.
  ///
  /// \sa SDL_SetWindowSize()
  void SDL_GetWindowSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetWindowSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowSize>>('SDL_GetWindowSize');
  late final _dart_SDL_GetWindowSize _SDL_GetWindowSize =
      _SDL_GetWindowSize_ptr.asFunction<_dart_SDL_GetWindowSize>();

  /// \brief Get the size of a window's borders (decorations) around the client area.
  ///
  /// \param window The window to query.
  /// \param top Pointer to variable for storing the size of the top border. NULL is permitted.
  /// \param left Pointer to variable for storing the size of the left border. NULL is permitted.
  /// \param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted.
  /// \param right Pointer to variable for storing the size of the right border. NULL is permitted.
  ///
  /// \return 0 on success, or -1 if getting this information is not supported.
  ///
  /// \note if this function fails (returns -1), the size values will be
  /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as
  /// if the window in question was borderless.
  int SDL_GetWindowBordersSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> top,
    ffi.Pointer<ffi.Int32> left,
    ffi.Pointer<ffi.Int32> bottom,
    ffi.Pointer<ffi.Int32> right,
  ) {
    return _SDL_GetWindowBordersSize(
      window,
      top,
      left,
      bottom,
      right,
    );
  }

  late final _SDL_GetWindowBordersSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowBordersSize>>(
          'SDL_GetWindowBordersSize');
  late final _dart_SDL_GetWindowBordersSize _SDL_GetWindowBordersSize =
      _SDL_GetWindowBordersSize_ptr.asFunction<
          _dart_SDL_GetWindowBordersSize>();

  /// \brief Set the minimum size of a window's client area.
  ///
  /// \param window    The window to set a new minimum size.
  /// \param min_w     The minimum width of the window, must be >0
  /// \param min_h     The minimum height of the window, must be >0
  ///
  /// \note You can't change the minimum size of a fullscreen window, it
  /// automatically matches the size of the display mode.
  ///
  /// \sa SDL_GetWindowMinimumSize()
  /// \sa SDL_SetWindowMaximumSize()
  void SDL_SetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    int min_w,
    int min_h,
  ) {
    return _SDL_SetWindowMinimumSize(
      window,
      min_w,
      min_h,
    );
  }

  late final _SDL_SetWindowMinimumSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowMinimumSize>>(
          'SDL_SetWindowMinimumSize');
  late final _dart_SDL_SetWindowMinimumSize _SDL_SetWindowMinimumSize =
      _SDL_SetWindowMinimumSize_ptr.asFunction<
          _dart_SDL_SetWindowMinimumSize>();

  /// \brief Get the minimum size of a window's client area.
  ///
  /// \param window   The window to query.
  /// \param w        Pointer to variable for storing the minimum width, may be NULL
  /// \param h        Pointer to variable for storing the minimum height, may be NULL
  ///
  /// \sa SDL_GetWindowMaximumSize()
  /// \sa SDL_SetWindowMinimumSize()
  void SDL_GetWindowMinimumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetWindowMinimumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMinimumSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowMinimumSize>>(
          'SDL_GetWindowMinimumSize');
  late final _dart_SDL_GetWindowMinimumSize _SDL_GetWindowMinimumSize =
      _SDL_GetWindowMinimumSize_ptr.asFunction<
          _dart_SDL_GetWindowMinimumSize>();

  /// \brief Set the maximum size of a window's client area.
  ///
  /// \param window    The window to set a new maximum size.
  /// \param max_w     The maximum width of the window, must be >0
  /// \param max_h     The maximum height of the window, must be >0
  ///
  /// \note You can't change the maximum size of a fullscreen window, it
  /// automatically matches the size of the display mode.
  ///
  /// \sa SDL_GetWindowMaximumSize()
  /// \sa SDL_SetWindowMinimumSize()
  void SDL_SetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    int max_w,
    int max_h,
  ) {
    return _SDL_SetWindowMaximumSize(
      window,
      max_w,
      max_h,
    );
  }

  late final _SDL_SetWindowMaximumSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowMaximumSize>>(
          'SDL_SetWindowMaximumSize');
  late final _dart_SDL_SetWindowMaximumSize _SDL_SetWindowMaximumSize =
      _SDL_SetWindowMaximumSize_ptr.asFunction<
          _dart_SDL_SetWindowMaximumSize>();

  /// \brief Get the maximum size of a window's client area.
  ///
  /// \param window   The window to query.
  /// \param w        Pointer to variable for storing the maximum width, may be NULL
  /// \param h        Pointer to variable for storing the maximum height, may be NULL
  ///
  /// \sa SDL_GetWindowMinimumSize()
  /// \sa SDL_SetWindowMaximumSize()
  void SDL_GetWindowMaximumSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetWindowMaximumSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GetWindowMaximumSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowMaximumSize>>(
          'SDL_GetWindowMaximumSize');
  late final _dart_SDL_GetWindowMaximumSize _SDL_GetWindowMaximumSize =
      _SDL_GetWindowMaximumSize_ptr.asFunction<
          _dart_SDL_GetWindowMaximumSize>();

  /// \brief Set the border state of a window.
  ///
  /// This will add or remove the window's SDL_WINDOW_BORDERLESS flag and
  /// add or remove the border from the actual window. This is a no-op if the
  /// window's border already matches the requested state.
  ///
  /// \param window The window of which to change the border state.
  /// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border.
  ///
  /// \note You can't change the border state of a fullscreen window.
  ///
  /// \sa SDL_GetWindowFlags()
  void SDL_SetWindowBordered(
    ffi.Pointer<SDL_Window> window,
    int bordered,
  ) {
    return _SDL_SetWindowBordered(
      window,
      bordered,
    );
  }

  late final _SDL_SetWindowBordered_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowBordered>>(
          'SDL_SetWindowBordered');
  late final _dart_SDL_SetWindowBordered _SDL_SetWindowBordered =
      _SDL_SetWindowBordered_ptr.asFunction<_dart_SDL_SetWindowBordered>();

  /// \brief Set the user-resizable state of a window.
  ///
  /// This will add or remove the window's SDL_WINDOW_RESIZABLE flag and
  /// allow/disallow user resizing of the window. This is a no-op if the
  /// window's resizable state already matches the requested state.
  ///
  /// \param window The window of which to change the resizable state.
  /// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow.
  ///
  /// \note You can't change the resizable state of a fullscreen window.
  ///
  /// \sa SDL_GetWindowFlags()
  void SDL_SetWindowResizable(
    ffi.Pointer<SDL_Window> window,
    int resizable,
  ) {
    return _SDL_SetWindowResizable(
      window,
      resizable,
    );
  }

  late final _SDL_SetWindowResizable_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowResizable>>(
          'SDL_SetWindowResizable');
  late final _dart_SDL_SetWindowResizable _SDL_SetWindowResizable =
      _SDL_SetWindowResizable_ptr.asFunction<_dart_SDL_SetWindowResizable>();

  /// \brief Show a window.
  ///
  /// \sa SDL_HideWindow()
  void SDL_ShowWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowWindow(
      window,
    );
  }

  late final _SDL_ShowWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ShowWindow>>('SDL_ShowWindow');
  late final _dart_SDL_ShowWindow _SDL_ShowWindow =
      _SDL_ShowWindow_ptr.asFunction<_dart_SDL_ShowWindow>();

  /// \brief Hide a window.
  ///
  /// \sa SDL_ShowWindow()
  void SDL_HideWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_HideWindow(
      window,
    );
  }

  late final _SDL_HideWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HideWindow>>('SDL_HideWindow');
  late final _dart_SDL_HideWindow _SDL_HideWindow =
      _SDL_HideWindow_ptr.asFunction<_dart_SDL_HideWindow>();

  /// \brief Raise a window above other windows and set the input focus.
  void SDL_RaiseWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RaiseWindow(
      window,
    );
  }

  late final _SDL_RaiseWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RaiseWindow>>('SDL_RaiseWindow');
  late final _dart_SDL_RaiseWindow _SDL_RaiseWindow =
      _SDL_RaiseWindow_ptr.asFunction<_dart_SDL_RaiseWindow>();

  /// \brief Make a window as large as possible.
  ///
  /// \sa SDL_RestoreWindow()
  void SDL_MaximizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MaximizeWindow(
      window,
    );
  }

  late final _SDL_MaximizeWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MaximizeWindow>>('SDL_MaximizeWindow');
  late final _dart_SDL_MaximizeWindow _SDL_MaximizeWindow =
      _SDL_MaximizeWindow_ptr.asFunction<_dart_SDL_MaximizeWindow>();

  /// \brief Minimize a window to an iconic representation.
  ///
  /// \sa SDL_RestoreWindow()
  void SDL_MinimizeWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_MinimizeWindow(
      window,
    );
  }

  late final _SDL_MinimizeWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MinimizeWindow>>('SDL_MinimizeWindow');
  late final _dart_SDL_MinimizeWindow _SDL_MinimizeWindow =
      _SDL_MinimizeWindow_ptr.asFunction<_dart_SDL_MinimizeWindow>();

  /// \brief Restore the size and position of a minimized or maximized window.
  ///
  /// \sa SDL_MaximizeWindow()
  /// \sa SDL_MinimizeWindow()
  void SDL_RestoreWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_RestoreWindow(
      window,
    );
  }

  late final _SDL_RestoreWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RestoreWindow>>('SDL_RestoreWindow');
  late final _dart_SDL_RestoreWindow _SDL_RestoreWindow =
      _SDL_RestoreWindow_ptr.asFunction<_dart_SDL_RestoreWindow>();

  /// \brief Set a window's fullscreen state.
  ///
  /// \return 0 on success, or -1 if setting the display mode failed.
  ///
  /// \sa SDL_SetWindowDisplayMode()
  /// \sa SDL_GetWindowDisplayMode()
  int SDL_SetWindowFullscreen(
    ffi.Pointer<SDL_Window> window,
    int flags,
  ) {
    return _SDL_SetWindowFullscreen(
      window,
      flags,
    );
  }

  late final _SDL_SetWindowFullscreen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowFullscreen>>(
          'SDL_SetWindowFullscreen');
  late final _dart_SDL_SetWindowFullscreen _SDL_SetWindowFullscreen =
      _SDL_SetWindowFullscreen_ptr.asFunction<_dart_SDL_SetWindowFullscreen>();

  /// \brief Get the SDL surface associated with the window.
  ///
  /// \return The window's framebuffer surface, or NULL on error.
  ///
  /// A new surface will be created with the optimal format for the window,
  /// if necessary. This surface will be freed when the window is destroyed.
  ///
  /// \note You may not combine this with 3D or the rendering API on this window.
  ///
  /// \sa SDL_UpdateWindowSurface()
  /// \sa SDL_UpdateWindowSurfaceRects()
  ffi.Pointer<SDL_Surface> SDL_GetWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowSurface(
      window,
    );
  }

  late final _SDL_GetWindowSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowSurface>>(
          'SDL_GetWindowSurface');
  late final _dart_SDL_GetWindowSurface _SDL_GetWindowSurface =
      _SDL_GetWindowSurface_ptr.asFunction<_dart_SDL_GetWindowSurface>();

  /// \brief Copy the window surface to the screen.
  ///
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_GetWindowSurface()
  /// \sa SDL_UpdateWindowSurfaceRects()
  int SDL_UpdateWindowSurface(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_UpdateWindowSurface(
      window,
    );
  }

  late final _SDL_UpdateWindowSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UpdateWindowSurface>>(
          'SDL_UpdateWindowSurface');
  late final _dart_SDL_UpdateWindowSurface _SDL_UpdateWindowSurface =
      _SDL_UpdateWindowSurface_ptr.asFunction<_dart_SDL_UpdateWindowSurface>();

  /// \brief Copy a number of rectangles on the window surface to the screen.
  ///
  /// \return 0 on success, or -1 on error.
  ///
  /// \sa SDL_GetWindowSurface()
  /// \sa SDL_UpdateWindowSurface()
  int SDL_UpdateWindowSurfaceRects(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Rect> rects,
    int numrects,
  ) {
    return _SDL_UpdateWindowSurfaceRects(
      window,
      rects,
      numrects,
    );
  }

  late final _SDL_UpdateWindowSurfaceRects_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UpdateWindowSurfaceRects>>(
          'SDL_UpdateWindowSurfaceRects');
  late final _dart_SDL_UpdateWindowSurfaceRects _SDL_UpdateWindowSurfaceRects =
      _SDL_UpdateWindowSurfaceRects_ptr.asFunction<
          _dart_SDL_UpdateWindowSurfaceRects>();

  /// \brief Set a window's input grab mode.
  ///
  /// \param window The window for which the input grab mode should be set.
  /// \param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.
  ///
  /// If the caller enables a grab while another window is currently grabbed,
  /// the other window loses its grab in favor of the caller's window.
  ///
  /// \sa SDL_GetWindowGrab()
  void SDL_SetWindowGrab(
    ffi.Pointer<SDL_Window> window,
    int grabbed,
  ) {
    return _SDL_SetWindowGrab(
      window,
      grabbed,
    );
  }

  late final _SDL_SetWindowGrab_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowGrab>>('SDL_SetWindowGrab');
  late final _dart_SDL_SetWindowGrab _SDL_SetWindowGrab =
      _SDL_SetWindowGrab_ptr.asFunction<_dart_SDL_SetWindowGrab>();

  /// \brief Get a window's input grab mode.
  ///
  /// \return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.
  ///
  /// \sa SDL_SetWindowGrab()
  int SDL_GetWindowGrab(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowGrab(
      window,
    );
  }

  late final _SDL_GetWindowGrab_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowGrab>>('SDL_GetWindowGrab');
  late final _dart_SDL_GetWindowGrab _SDL_GetWindowGrab =
      _SDL_GetWindowGrab_ptr.asFunction<_dart_SDL_GetWindowGrab>();

  /// \brief Get the window that currently has an input grab enabled.
  ///
  /// \return This returns the window if input is grabbed, and NULL otherwise.
  ///
  /// \sa SDL_SetWindowGrab()
  ffi.Pointer<SDL_Window> SDL_GetGrabbedWindow() {
    return _SDL_GetGrabbedWindow();
  }

  late final _SDL_GetGrabbedWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetGrabbedWindow>>(
          'SDL_GetGrabbedWindow');
  late final _dart_SDL_GetGrabbedWindow _SDL_GetGrabbedWindow =
      _SDL_GetGrabbedWindow_ptr.asFunction<_dart_SDL_GetGrabbedWindow>();

  /// \brief Set the brightness (gamma correction) for a window.
  ///
  /// \return 0 on success, or -1 if setting the brightness isn't supported.
  ///
  /// \sa SDL_GetWindowBrightness()
  /// \sa SDL_SetWindowGammaRamp()
  int SDL_SetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
    double brightness,
  ) {
    return _SDL_SetWindowBrightness(
      window,
      brightness,
    );
  }

  late final _SDL_SetWindowBrightness_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowBrightness>>(
          'SDL_SetWindowBrightness');
  late final _dart_SDL_SetWindowBrightness _SDL_SetWindowBrightness =
      _SDL_SetWindowBrightness_ptr.asFunction<_dart_SDL_SetWindowBrightness>();

  /// \brief Get the brightness (gamma correction) for a window.
  ///
  /// \return The last brightness value passed to SDL_SetWindowBrightness()
  ///
  /// \sa SDL_SetWindowBrightness()
  double SDL_GetWindowBrightness(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetWindowBrightness(
      window,
    );
  }

  late final _SDL_GetWindowBrightness_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowBrightness>>(
          'SDL_GetWindowBrightness');
  late final _dart_SDL_GetWindowBrightness _SDL_GetWindowBrightness =
      _SDL_GetWindowBrightness_ptr.asFunction<_dart_SDL_GetWindowBrightness>();

  /// \brief Set the opacity for a window
  ///
  /// \param window The window which will be made transparent or opaque
  /// \param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be
  /// clamped internally between 0.0f and 1.0f.
  ///
  /// \return 0 on success, or -1 if setting the opacity isn't supported.
  ///
  /// \sa SDL_GetWindowOpacity()
  int SDL_SetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    double opacity,
  ) {
    return _SDL_SetWindowOpacity(
      window,
      opacity,
    );
  }

  late final _SDL_SetWindowOpacity_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowOpacity>>(
          'SDL_SetWindowOpacity');
  late final _dart_SDL_SetWindowOpacity _SDL_SetWindowOpacity =
      _SDL_SetWindowOpacity_ptr.asFunction<_dart_SDL_SetWindowOpacity>();

  /// \brief Get the opacity of a window.
  ///
  /// If transparency isn't supported on this platform, opacity will be reported
  /// as 1.0f without error.
  ///
  /// \param window The window in question.
  /// \param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)
  ///
  /// \return 0 on success, or -1 on error (invalid window, etc).
  ///
  /// \sa SDL_SetWindowOpacity()
  int SDL_GetWindowOpacity(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Float> out_opacity,
  ) {
    return _SDL_GetWindowOpacity(
      window,
      out_opacity,
    );
  }

  late final _SDL_GetWindowOpacity_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowOpacity>>(
          'SDL_GetWindowOpacity');
  late final _dart_SDL_GetWindowOpacity _SDL_GetWindowOpacity =
      _SDL_GetWindowOpacity_ptr.asFunction<_dart_SDL_GetWindowOpacity>();

  /// \brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)
  ///
  /// \param modal_window The window that should be modal
  /// \param parent_window The parent window
  ///
  /// \return 0 on success, or -1 otherwise.
  int SDL_SetWindowModalFor(
    ffi.Pointer<SDL_Window> modal_window,
    ffi.Pointer<SDL_Window> parent_window,
  ) {
    return _SDL_SetWindowModalFor(
      modal_window,
      parent_window,
    );
  }

  late final _SDL_SetWindowModalFor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowModalFor>>(
          'SDL_SetWindowModalFor');
  late final _dart_SDL_SetWindowModalFor _SDL_SetWindowModalFor =
      _SDL_SetWindowModalFor_ptr.asFunction<_dart_SDL_SetWindowModalFor>();

  /// \brief Explicitly sets input focus to the window.
  ///
  /// You almost certainly want SDL_RaiseWindow() instead of this function. Use
  /// this with caution, as you might give focus to a window that's completely
  /// obscured by other windows.
  ///
  /// \param window The window that should get the input focus
  ///
  /// \return 0 on success, or -1 otherwise.
  /// \sa SDL_RaiseWindow()
  int SDL_SetWindowInputFocus(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_SetWindowInputFocus(
      window,
    );
  }

  late final _SDL_SetWindowInputFocus_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowInputFocus>>(
          'SDL_SetWindowInputFocus');
  late final _dart_SDL_SetWindowInputFocus _SDL_SetWindowInputFocus =
      _SDL_SetWindowInputFocus_ptr.asFunction<_dart_SDL_SetWindowInputFocus>();

  /// \brief Set the gamma ramp for a window.
  ///
  /// \param window The window for which the gamma ramp should be set.
  /// \param red The translation table for the red channel, or NULL.
  /// \param green The translation table for the green channel, or NULL.
  /// \param blue The translation table for the blue channel, or NULL.
  ///
  /// \return 0 on success, or -1 if gamma ramps are unsupported.
  ///
  /// Set the gamma translation table for the red, green, and blue channels
  /// of the video hardware.  Each table is an array of 256 16-bit quantities,
  /// representing a mapping between the input and output for that channel.
  /// The input is the index into the array, and the output is the 16-bit
  /// gamma value at that index, scaled to the output color precision.
  ///
  /// \sa SDL_GetWindowGammaRamp()
  int SDL_SetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Uint16> red,
    ffi.Pointer<ffi.Uint16> green,
    ffi.Pointer<ffi.Uint16> blue,
  ) {
    return _SDL_SetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_SetWindowGammaRamp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowGammaRamp>>(
          'SDL_SetWindowGammaRamp');
  late final _dart_SDL_SetWindowGammaRamp _SDL_SetWindowGammaRamp =
      _SDL_SetWindowGammaRamp_ptr.asFunction<_dart_SDL_SetWindowGammaRamp>();

  /// \brief Get the gamma ramp for a window.
  ///
  /// \param window The window from which the gamma ramp should be queried.
  /// \param red   A pointer to a 256 element array of 16-bit quantities to hold
  /// the translation table for the red channel, or NULL.
  /// \param green A pointer to a 256 element array of 16-bit quantities to hold
  /// the translation table for the green channel, or NULL.
  /// \param blue  A pointer to a 256 element array of 16-bit quantities to hold
  /// the translation table for the blue channel, or NULL.
  ///
  /// \return 0 on success, or -1 if gamma ramps are unsupported.
  ///
  /// \sa SDL_SetWindowGammaRamp()
  int SDL_GetWindowGammaRamp(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Uint16> red,
    ffi.Pointer<ffi.Uint16> green,
    ffi.Pointer<ffi.Uint16> blue,
  ) {
    return _SDL_GetWindowGammaRamp(
      window,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GetWindowGammaRamp_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetWindowGammaRamp>>(
          'SDL_GetWindowGammaRamp');
  late final _dart_SDL_GetWindowGammaRamp _SDL_GetWindowGammaRamp =
      _SDL_GetWindowGammaRamp_ptr.asFunction<_dart_SDL_GetWindowGammaRamp>();

  /// \brief Provide a callback that decides if a window region has special properties.
  ///
  /// Normally windows are dragged and resized by decorations provided by the
  /// system window manager (a title bar, borders, etc), but for some apps, it
  /// makes sense to drag them from somewhere else inside the window itself; for
  /// example, one might have a borderless window that wants to be draggable
  /// from any part, or simulate its own title bar, etc.
  ///
  /// This function lets the app provide a callback that designates pieces of
  /// a given window as special. This callback is run during event processing
  /// if we need to tell the OS to treat a region of the window specially; the
  /// use of this callback is known as "hit testing."
  ///
  /// Mouse input may not be delivered to your application if it is within
  /// a special area; the OS will often apply that input to moving the window or
  /// resizing the window and not deliver it to the application.
  ///
  /// Specifying NULL for a callback disables hit-testing. Hit-testing is
  /// disabled by default.
  ///
  /// Platforms that don't support this functionality will return -1
  /// unconditionally, even if you're attempting to disable hit-testing.
  ///
  /// Your callback may fire at any time, and its firing does not indicate any
  /// specific behavior (for example, on Windows, this certainly might fire
  /// when the OS is deciding whether to drag your window, but it fires for lots
  /// of other reasons, too, some unrelated to anything you probably care about
  /// _and when the mouse isn't actually at the location it is testing_).
  /// Since this can fire at any time, you should try to keep your callback
  /// efficient, devoid of allocations, etc.
  ///
  /// \param window The window to set hit-testing on.
  /// \param callback The callback to call when doing a hit-test.
  /// \param callback_data An app-defined void pointer passed to the callback.
  /// \return 0 on success, -1 on error (including unsupported).
  int SDL_SetWindowHitTest(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.NativeFunction<SDL_HitTest>> callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _SDL_SetWindowHitTest(
      window,
      callback,
      callback_data,
    );
  }

  late final _SDL_SetWindowHitTest_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowHitTest>>(
          'SDL_SetWindowHitTest');
  late final _dart_SDL_SetWindowHitTest _SDL_SetWindowHitTest =
      _SDL_SetWindowHitTest_ptr.asFunction<_dart_SDL_SetWindowHitTest>();

  /// \brief Destroy a window.
  void SDL_DestroyWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_DestroyWindow(
      window,
    );
  }

  late final _SDL_DestroyWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DestroyWindow>>('SDL_DestroyWindow');
  late final _dart_SDL_DestroyWindow _SDL_DestroyWindow =
      _SDL_DestroyWindow_ptr.asFunction<_dart_SDL_DestroyWindow>();

  /// \brief Returns whether the screensaver is currently enabled (default off).
  ///
  /// \sa SDL_EnableScreenSaver()
  /// \sa SDL_DisableScreenSaver()
  int SDL_IsScreenSaverEnabled() {
    return _SDL_IsScreenSaverEnabled();
  }

  late final _SDL_IsScreenSaverEnabled_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IsScreenSaverEnabled>>(
          'SDL_IsScreenSaverEnabled');
  late final _dart_SDL_IsScreenSaverEnabled _SDL_IsScreenSaverEnabled =
      _SDL_IsScreenSaverEnabled_ptr.asFunction<
          _dart_SDL_IsScreenSaverEnabled>();

  /// \brief Allow the screen to be blanked by a screensaver
  ///
  /// \sa SDL_IsScreenSaverEnabled()
  /// \sa SDL_DisableScreenSaver()
  void SDL_EnableScreenSaver() {
    return _SDL_EnableScreenSaver();
  }

  late final _SDL_EnableScreenSaver_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_EnableScreenSaver>>(
          'SDL_EnableScreenSaver');
  late final _dart_SDL_EnableScreenSaver _SDL_EnableScreenSaver =
      _SDL_EnableScreenSaver_ptr.asFunction<_dart_SDL_EnableScreenSaver>();

  /// \brief Prevent the screen from being blanked by a screensaver
  ///
  /// \sa SDL_IsScreenSaverEnabled()
  /// \sa SDL_EnableScreenSaver()
  void SDL_DisableScreenSaver() {
    return _SDL_DisableScreenSaver();
  }

  late final _SDL_DisableScreenSaver_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DisableScreenSaver>>(
          'SDL_DisableScreenSaver');
  late final _dart_SDL_DisableScreenSaver _SDL_DisableScreenSaver =
      _SDL_DisableScreenSaver_ptr.asFunction<_dart_SDL_DisableScreenSaver>();

  /// \brief Dynamically load an OpenGL library.
  ///
  /// \param path The platform dependent OpenGL library name, or NULL to open the
  /// default OpenGL library.
  ///
  /// \return 0 on success, or -1 if the library couldn't be loaded.
  ///
  /// This should be done after initializing the video driver, but before
  /// creating any OpenGL windows.  If no OpenGL library is loaded, the default
  /// library will be loaded upon creation of the first OpenGL window.
  ///
  /// \note If you do this, you need to retrieve all of the GL functions used in
  /// your program from the dynamic library using SDL_GL_GetProcAddress().
  ///
  /// \sa SDL_GL_GetProcAddress()
  /// \sa SDL_GL_UnloadLibrary()
  int SDL_GL_LoadLibrary(
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _SDL_GL_LoadLibrary(
      path,
    );
  }

  late final _SDL_GL_LoadLibrary_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_LoadLibrary>>('SDL_GL_LoadLibrary');
  late final _dart_SDL_GL_LoadLibrary _SDL_GL_LoadLibrary =
      _SDL_GL_LoadLibrary_ptr.asFunction<_dart_SDL_GL_LoadLibrary>();

  /// \brief Get the address of an OpenGL function.
  ffi.Pointer<ffi.Void> SDL_GL_GetProcAddress(
    ffi.Pointer<ffi.Int8> proc,
  ) {
    return _SDL_GL_GetProcAddress(
      proc,
    );
  }

  late final _SDL_GL_GetProcAddress_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_GetProcAddress>>(
          'SDL_GL_GetProcAddress');
  late final _dart_SDL_GL_GetProcAddress _SDL_GL_GetProcAddress =
      _SDL_GL_GetProcAddress_ptr.asFunction<_dart_SDL_GL_GetProcAddress>();

  /// \brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
  ///
  /// \sa SDL_GL_LoadLibrary()
  void SDL_GL_UnloadLibrary() {
    return _SDL_GL_UnloadLibrary();
  }

  late final _SDL_GL_UnloadLibrary_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_UnloadLibrary>>(
          'SDL_GL_UnloadLibrary');
  late final _dart_SDL_GL_UnloadLibrary _SDL_GL_UnloadLibrary =
      _SDL_GL_UnloadLibrary_ptr.asFunction<_dart_SDL_GL_UnloadLibrary>();

  /// \brief Return true if an OpenGL extension is supported for the current
  /// context.
  int SDL_GL_ExtensionSupported(
    ffi.Pointer<ffi.Int8> extension_1,
  ) {
    return _SDL_GL_ExtensionSupported(
      extension_1,
    );
  }

  late final _SDL_GL_ExtensionSupported_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_ExtensionSupported>>(
          'SDL_GL_ExtensionSupported');
  late final _dart_SDL_GL_ExtensionSupported _SDL_GL_ExtensionSupported =
      _SDL_GL_ExtensionSupported_ptr.asFunction<
          _dart_SDL_GL_ExtensionSupported>();

  /// \brief Reset all previously set OpenGL context attributes to their default values
  void SDL_GL_ResetAttributes() {
    return _SDL_GL_ResetAttributes();
  }

  late final _SDL_GL_ResetAttributes_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_ResetAttributes>>(
          'SDL_GL_ResetAttributes');
  late final _dart_SDL_GL_ResetAttributes _SDL_GL_ResetAttributes =
      _SDL_GL_ResetAttributes_ptr.asFunction<_dart_SDL_GL_ResetAttributes>();

  /// \brief Set an OpenGL window attribute before window creation.
  ///
  /// \return 0 on success, or -1 if the attribute could not be set.
  int SDL_GL_SetAttribute(
    int attr,
    int value,
  ) {
    return _SDL_GL_SetAttribute(
      attr,
      value,
    );
  }

  late final _SDL_GL_SetAttribute_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_SetAttribute>>(
          'SDL_GL_SetAttribute');
  late final _dart_SDL_GL_SetAttribute _SDL_GL_SetAttribute =
      _SDL_GL_SetAttribute_ptr.asFunction<_dart_SDL_GL_SetAttribute>();

  /// \brief Get the actual value for an attribute from the current context.
  ///
  /// \return 0 on success, or -1 if the attribute could not be retrieved.
  /// The integer at \c value will be modified in either case.
  int SDL_GL_GetAttribute(
    int attr,
    ffi.Pointer<ffi.Int32> value,
  ) {
    return _SDL_GL_GetAttribute(
      attr,
      value,
    );
  }

  late final _SDL_GL_GetAttribute_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_GetAttribute>>(
          'SDL_GL_GetAttribute');
  late final _dart_SDL_GL_GetAttribute _SDL_GL_GetAttribute =
      _SDL_GL_GetAttribute_ptr.asFunction<_dart_SDL_GL_GetAttribute>();

  /// \brief Create an OpenGL context for use with an OpenGL window, and make it
  /// current.
  ///
  /// \sa SDL_GL_DeleteContext()
  ffi.Pointer<ffi.Void> SDL_GL_CreateContext(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_CreateContext(
      window,
    );
  }

  late final _SDL_GL_CreateContext_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_CreateContext>>(
          'SDL_GL_CreateContext');
  late final _dart_SDL_GL_CreateContext _SDL_GL_CreateContext =
      _SDL_GL_CreateContext_ptr.asFunction<_dart_SDL_GL_CreateContext>();

  /// \brief Set up an OpenGL context for rendering into an OpenGL window.
  ///
  /// \note The context must have been created with a compatible window.
  int SDL_GL_MakeCurrent(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _SDL_GL_MakeCurrent(
      window,
      context,
    );
  }

  late final _SDL_GL_MakeCurrent_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_MakeCurrent>>('SDL_GL_MakeCurrent');
  late final _dart_SDL_GL_MakeCurrent _SDL_GL_MakeCurrent =
      _SDL_GL_MakeCurrent_ptr.asFunction<_dart_SDL_GL_MakeCurrent>();

  /// \brief Get the currently active OpenGL window.
  ffi.Pointer<SDL_Window> SDL_GL_GetCurrentWindow() {
    return _SDL_GL_GetCurrentWindow();
  }

  late final _SDL_GL_GetCurrentWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_GetCurrentWindow>>(
          'SDL_GL_GetCurrentWindow');
  late final _dart_SDL_GL_GetCurrentWindow _SDL_GL_GetCurrentWindow =
      _SDL_GL_GetCurrentWindow_ptr.asFunction<_dart_SDL_GL_GetCurrentWindow>();

  /// \brief Get the currently active OpenGL context.
  ffi.Pointer<ffi.Void> SDL_GL_GetCurrentContext() {
    return _SDL_GL_GetCurrentContext();
  }

  late final _SDL_GL_GetCurrentContext_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_GetCurrentContext>>(
          'SDL_GL_GetCurrentContext');
  late final _dart_SDL_GL_GetCurrentContext _SDL_GL_GetCurrentContext =
      _SDL_GL_GetCurrentContext_ptr.asFunction<
          _dart_SDL_GL_GetCurrentContext>();

  /// \brief Get the size of a window's underlying drawable in pixels (for use
  /// with glViewport).
  ///
  /// \param window   Window from which the drawable size should be queried
  /// \param w        Pointer to variable for storing the width in pixels, may be NULL
  /// \param h        Pointer to variable for storing the height in pixels, may be NULL
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not disabled
  /// by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
  ///
  /// \sa SDL_GetWindowSize()
  /// \sa SDL_CreateWindow()
  void SDL_GL_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GL_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_GL_GetDrawableSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_GetDrawableSize>>(
          'SDL_GL_GetDrawableSize');
  late final _dart_SDL_GL_GetDrawableSize _SDL_GL_GetDrawableSize =
      _SDL_GL_GetDrawableSize_ptr.asFunction<_dart_SDL_GL_GetDrawableSize>();

  /// \brief Set the swap interval for the current OpenGL context.
  ///
  /// \param interval 0 for immediate updates, 1 for updates synchronized with the
  /// vertical retrace. If the system supports it, you may
  /// specify -1 to allow late swaps to happen immediately
  /// instead of waiting for the next retrace.
  ///
  /// \return 0 on success, or -1 if setting the swap interval is not supported.
  ///
  /// \sa SDL_GL_GetSwapInterval()
  int SDL_GL_SetSwapInterval(
    int interval,
  ) {
    return _SDL_GL_SetSwapInterval(
      interval,
    );
  }

  late final _SDL_GL_SetSwapInterval_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_SetSwapInterval>>(
          'SDL_GL_SetSwapInterval');
  late final _dart_SDL_GL_SetSwapInterval _SDL_GL_SetSwapInterval =
      _SDL_GL_SetSwapInterval_ptr.asFunction<_dart_SDL_GL_SetSwapInterval>();

  /// \brief Get the swap interval for the current OpenGL context.
  ///
  /// \return 0 if there is no vertical retrace synchronization, 1 if the buffer
  /// swap is synchronized with the vertical retrace, and -1 if late
  /// swaps happen immediately instead of waiting for the next retrace.
  /// If the system can't determine the swap interval, or there isn't a
  /// valid current context, this will return 0 as a safe default.
  ///
  /// \sa SDL_GL_SetSwapInterval()
  int SDL_GL_GetSwapInterval() {
    return _SDL_GL_GetSwapInterval();
  }

  late final _SDL_GL_GetSwapInterval_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_GetSwapInterval>>(
          'SDL_GL_GetSwapInterval');
  late final _dart_SDL_GL_GetSwapInterval _SDL_GL_GetSwapInterval =
      _SDL_GL_GetSwapInterval_ptr.asFunction<_dart_SDL_GL_GetSwapInterval>();

  /// \brief Swap the OpenGL buffers for a window, if double-buffering is
  /// supported.
  void SDL_GL_SwapWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GL_SwapWindow(
      window,
    );
  }

  late final _SDL_GL_SwapWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_SwapWindow>>('SDL_GL_SwapWindow');
  late final _dart_SDL_GL_SwapWindow _SDL_GL_SwapWindow =
      _SDL_GL_SwapWindow_ptr.asFunction<_dart_SDL_GL_SwapWindow>();

  /// \brief Delete an OpenGL context.
  ///
  /// \sa SDL_GL_CreateContext()
  void SDL_GL_DeleteContext(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _SDL_GL_DeleteContext(
      context,
    );
  }

  late final _SDL_GL_DeleteContext_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_DeleteContext>>(
          'SDL_GL_DeleteContext');
  late final _dart_SDL_GL_DeleteContext _SDL_GL_DeleteContext =
      _SDL_GL_DeleteContext_ptr.asFunction<_dart_SDL_GL_DeleteContext>();

  /// \brief Get the window which currently has keyboard focus.
  ffi.Pointer<SDL_Window> SDL_GetKeyboardFocus() {
    return _SDL_GetKeyboardFocus();
  }

  late final _SDL_GetKeyboardFocus_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetKeyboardFocus>>(
          'SDL_GetKeyboardFocus');
  late final _dart_SDL_GetKeyboardFocus _SDL_GetKeyboardFocus =
      _SDL_GetKeyboardFocus_ptr.asFunction<_dart_SDL_GetKeyboardFocus>();

  /// \brief Get a snapshot of the current state of the keyboard.
  ///
  /// \param numkeys if non-NULL, receives the length of the returned array.
  ///
  /// \return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.
  ///
  /// \b Example:
  /// \code
  /// const Uint8 *state = SDL_GetKeyboardState(NULL);
  /// if ( state[SDL_SCANCODE_RETURN] )   {
  /// printf("<RETURN> is pressed.\n");
  /// }
  /// \endcode
  ffi.Pointer<ffi.Uint8> SDL_GetKeyboardState(
    ffi.Pointer<ffi.Int32> numkeys,
  ) {
    return _SDL_GetKeyboardState(
      numkeys,
    );
  }

  late final _SDL_GetKeyboardState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetKeyboardState>>(
          'SDL_GetKeyboardState');
  late final _dart_SDL_GetKeyboardState _SDL_GetKeyboardState =
      _SDL_GetKeyboardState_ptr.asFunction<_dart_SDL_GetKeyboardState>();

  /// \brief Get the current key modifier state for the keyboard.
  int SDL_GetModState() {
    return _SDL_GetModState();
  }

  late final _SDL_GetModState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetModState>>('SDL_GetModState');
  late final _dart_SDL_GetModState _SDL_GetModState =
      _SDL_GetModState_ptr.asFunction<_dart_SDL_GetModState>();

  /// \brief Set the current key modifier state for the keyboard.
  ///
  /// \note This does not change the keyboard state, only the key modifier flags.
  void SDL_SetModState(
    int modstate,
  ) {
    return _SDL_SetModState(
      modstate,
    );
  }

  late final _SDL_SetModState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetModState>>('SDL_SetModState');
  late final _dart_SDL_SetModState _SDL_SetModState =
      _SDL_SetModState_ptr.asFunction<_dart_SDL_SetModState>();

  /// \brief Get the key code corresponding to the given scancode according
  /// to the current keyboard layout.
  ///
  /// See ::SDL_Keycode for details.
  ///
  /// \sa SDL_GetKeyName()
  int SDL_GetKeyFromScancode(
    int scancode,
  ) {
    return _SDL_GetKeyFromScancode(
      scancode,
    );
  }

  late final _SDL_GetKeyFromScancode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetKeyFromScancode>>(
          'SDL_GetKeyFromScancode');
  late final _dart_SDL_GetKeyFromScancode _SDL_GetKeyFromScancode =
      _SDL_GetKeyFromScancode_ptr.asFunction<_dart_SDL_GetKeyFromScancode>();

  /// \brief Get the scancode corresponding to the given key code according to the
  /// current keyboard layout.
  ///
  /// See ::SDL_Scancode for details.
  ///
  /// \sa SDL_GetScancodeName()
  int SDL_GetScancodeFromKey(
    int key,
  ) {
    return _SDL_GetScancodeFromKey(
      key,
    );
  }

  late final _SDL_GetScancodeFromKey_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetScancodeFromKey>>(
          'SDL_GetScancodeFromKey');
  late final _dart_SDL_GetScancodeFromKey _SDL_GetScancodeFromKey =
      _SDL_GetScancodeFromKey_ptr.asFunction<_dart_SDL_GetScancodeFromKey>();

  /// \brief Get a human-readable name for a scancode.
  ///
  /// \return A pointer to the name for the scancode.
  /// If the scancode doesn't have a name, this function returns
  /// an empty string ("").
  ///
  /// \sa SDL_Scancode
  ffi.Pointer<ffi.Int8> SDL_GetScancodeName(
    int scancode,
  ) {
    return _SDL_GetScancodeName(
      scancode,
    );
  }

  late final _SDL_GetScancodeName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetScancodeName>>(
          'SDL_GetScancodeName');
  late final _dart_SDL_GetScancodeName _SDL_GetScancodeName =
      _SDL_GetScancodeName_ptr.asFunction<_dart_SDL_GetScancodeName>();

  /// \brief Get a scancode from a human-readable name
  ///
  /// \return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized
  ///
  /// \sa SDL_Scancode
  int SDL_GetScancodeFromName(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetScancodeFromName(
      name,
    );
  }

  late final _SDL_GetScancodeFromName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetScancodeFromName>>(
          'SDL_GetScancodeFromName');
  late final _dart_SDL_GetScancodeFromName _SDL_GetScancodeFromName =
      _SDL_GetScancodeFromName_ptr.asFunction<_dart_SDL_GetScancodeFromName>();

  /// \brief Get a human-readable name for a key.
  ///
  /// \return A pointer to a UTF-8 string that stays valid at least until the next
  /// call to this function. If you need it around any longer, you must
  /// copy it.  If the key doesn't have a name, this function returns an
  /// empty string ("").
  ///
  /// \sa SDL_Keycode
  ffi.Pointer<ffi.Int8> SDL_GetKeyName(
    int key,
  ) {
    return _SDL_GetKeyName(
      key,
    );
  }

  late final _SDL_GetKeyName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetKeyName>>('SDL_GetKeyName');
  late final _dart_SDL_GetKeyName _SDL_GetKeyName =
      _SDL_GetKeyName_ptr.asFunction<_dart_SDL_GetKeyName>();

  /// \brief Get a key code from a human-readable name
  ///
  /// \return key code, or SDLK_UNKNOWN if the name wasn't recognized
  ///
  /// \sa SDL_Keycode
  int SDL_GetKeyFromName(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetKeyFromName(
      name,
    );
  }

  late final _SDL_GetKeyFromName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetKeyFromName>>('SDL_GetKeyFromName');
  late final _dart_SDL_GetKeyFromName _SDL_GetKeyFromName =
      _SDL_GetKeyFromName_ptr.asFunction<_dart_SDL_GetKeyFromName>();

  /// \brief Start accepting Unicode text input events.
  /// This function will show the on-screen keyboard if supported.
  ///
  /// \sa SDL_StopTextInput()
  /// \sa SDL_SetTextInputRect()
  /// \sa SDL_HasScreenKeyboardSupport()
  void SDL_StartTextInput() {
    return _SDL_StartTextInput();
  }

  late final _SDL_StartTextInput_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_StartTextInput>>('SDL_StartTextInput');
  late final _dart_SDL_StartTextInput _SDL_StartTextInput =
      _SDL_StartTextInput_ptr.asFunction<_dart_SDL_StartTextInput>();

  /// \brief Return whether or not Unicode text input events are enabled.
  ///
  /// \sa SDL_StartTextInput()
  /// \sa SDL_StopTextInput()
  int SDL_IsTextInputActive() {
    return _SDL_IsTextInputActive();
  }

  late final _SDL_IsTextInputActive_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IsTextInputActive>>(
          'SDL_IsTextInputActive');
  late final _dart_SDL_IsTextInputActive _SDL_IsTextInputActive =
      _SDL_IsTextInputActive_ptr.asFunction<_dart_SDL_IsTextInputActive>();

  /// \brief Stop receiving any text input events.
  /// This function will hide the on-screen keyboard if supported.
  ///
  /// \sa SDL_StartTextInput()
  /// \sa SDL_HasScreenKeyboardSupport()
  void SDL_StopTextInput() {
    return _SDL_StopTextInput();
  }

  late final _SDL_StopTextInput_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_StopTextInput>>('SDL_StopTextInput');
  late final _dart_SDL_StopTextInput _SDL_StopTextInput =
      _SDL_StopTextInput_ptr.asFunction<_dart_SDL_StopTextInput>();

  /// \brief Set the rectangle used to type Unicode text inputs.
  /// This is used as a hint for IME and on-screen keyboard placement.
  ///
  /// \sa SDL_StartTextInput()
  void SDL_SetTextInputRect(
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_SetTextInputRect(
      rect,
    );
  }

  late final _SDL_SetTextInputRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetTextInputRect>>(
          'SDL_SetTextInputRect');
  late final _dart_SDL_SetTextInputRect _SDL_SetTextInputRect =
      _SDL_SetTextInputRect_ptr.asFunction<_dart_SDL_SetTextInputRect>();

  /// \brief Returns whether the platform has some screen keyboard support.
  ///
  /// \return SDL_TRUE if some keyboard support is available else SDL_FALSE.
  ///
  /// \note Not all screen keyboard functions are supported on all platforms.
  ///
  /// \sa SDL_IsScreenKeyboardShown()
  int SDL_HasScreenKeyboardSupport() {
    return _SDL_HasScreenKeyboardSupport();
  }

  late final _SDL_HasScreenKeyboardSupport_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasScreenKeyboardSupport>>(
          'SDL_HasScreenKeyboardSupport');
  late final _dart_SDL_HasScreenKeyboardSupport _SDL_HasScreenKeyboardSupport =
      _SDL_HasScreenKeyboardSupport_ptr.asFunction<
          _dart_SDL_HasScreenKeyboardSupport>();

  /// \brief Returns whether the screen keyboard is shown for given window.
  ///
  /// \param window The window for which screen keyboard should be queried.
  ///
  /// \return SDL_TRUE if screen keyboard is shown else SDL_FALSE.
  ///
  /// \sa SDL_HasScreenKeyboardSupport()
  int SDL_IsScreenKeyboardShown(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsScreenKeyboardShown(
      window,
    );
  }

  late final _SDL_IsScreenKeyboardShown_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IsScreenKeyboardShown>>(
          'SDL_IsScreenKeyboardShown');
  late final _dart_SDL_IsScreenKeyboardShown _SDL_IsScreenKeyboardShown =
      _SDL_IsScreenKeyboardShown_ptr.asFunction<
          _dart_SDL_IsScreenKeyboardShown>();

  /// \brief Get the window which currently has mouse focus.
  ffi.Pointer<SDL_Window> SDL_GetMouseFocus() {
    return _SDL_GetMouseFocus();
  }

  late final _SDL_GetMouseFocus_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetMouseFocus>>('SDL_GetMouseFocus');
  late final _dart_SDL_GetMouseFocus _SDL_GetMouseFocus =
      _SDL_GetMouseFocus_ptr.asFunction<_dart_SDL_GetMouseFocus>();

  /// \brief Retrieve the current state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can
  /// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  /// mouse cursor position relative to the focus window for the currently
  /// selected mouse.  You can pass NULL for either x or y.
  int SDL_GetMouseState(
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetMouseState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetMouseState>>('SDL_GetMouseState');
  late final _dart_SDL_GetMouseState _SDL_GetMouseState =
      _SDL_GetMouseState_ptr.asFunction<_dart_SDL_GetMouseState>();

  /// \brief Get the current state of the mouse, in relation to the desktop
  ///
  /// This works just like SDL_GetMouseState(), but the coordinates will be
  /// reported relative to the top-left of the desktop. This can be useful if
  /// you need to track the mouse outside of a specific window and
  /// SDL_CaptureMouse() doesn't fit your needs. For example, it could be
  /// useful if you need to track the mouse while dragging a window, where
  /// coordinates relative to a window might not be in sync at all times.
  ///
  /// \note SDL_GetMouseState() returns the mouse position as SDL understands
  /// it from the last pump of the event queue. This function, however,
  /// queries the OS for the current mouse position, and as such, might
  /// be a slightly less efficient function. Unless you know what you're
  /// doing and have a good reason to use this function, you probably want
  /// SDL_GetMouseState() instead.
  ///
  /// \param x Returns the current X coord, relative to the desktop. Can be NULL.
  /// \param y Returns the current Y coord, relative to the desktop. Can be NULL.
  /// \return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros.
  ///
  /// \sa SDL_GetMouseState
  int SDL_GetGlobalMouseState(
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetGlobalMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetGlobalMouseState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetGlobalMouseState>>(
          'SDL_GetGlobalMouseState');
  late final _dart_SDL_GetGlobalMouseState _SDL_GetGlobalMouseState =
      _SDL_GetGlobalMouseState_ptr.asFunction<_dart_SDL_GetGlobalMouseState>();

  /// \brief Retrieve the relative state of the mouse.
  ///
  /// The current button state is returned as a button bitmask, which can
  /// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
  /// mouse deltas since the last call to SDL_GetRelativeMouseState().
  int SDL_GetRelativeMouseState(
    ffi.Pointer<ffi.Int32> x,
    ffi.Pointer<ffi.Int32> y,
  ) {
    return _SDL_GetRelativeMouseState(
      x,
      y,
    );
  }

  late final _SDL_GetRelativeMouseState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRelativeMouseState>>(
          'SDL_GetRelativeMouseState');
  late final _dart_SDL_GetRelativeMouseState _SDL_GetRelativeMouseState =
      _SDL_GetRelativeMouseState_ptr.asFunction<
          _dart_SDL_GetRelativeMouseState>();

  /// \brief Moves the mouse to the given position within the window.
  ///
  /// \param window The window to move the mouse into, or NULL for the current mouse focus
  /// \param x The x coordinate within the window
  /// \param y The y coordinate within the window
  ///
  /// \note This function generates a mouse motion event
  void SDL_WarpMouseInWindow(
    ffi.Pointer<SDL_Window> window,
    int x,
    int y,
  ) {
    return _SDL_WarpMouseInWindow(
      window,
      x,
      y,
    );
  }

  late final _SDL_WarpMouseInWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WarpMouseInWindow>>(
          'SDL_WarpMouseInWindow');
  late final _dart_SDL_WarpMouseInWindow _SDL_WarpMouseInWindow =
      _SDL_WarpMouseInWindow_ptr.asFunction<_dart_SDL_WarpMouseInWindow>();

  /// \brief Moves the mouse to the given position in global screen space.
  ///
  /// \param x The x coordinate
  /// \param y The y coordinate
  /// \return 0 on success, -1 on error (usually: unsupported by a platform).
  ///
  /// \note This function generates a mouse motion event
  int SDL_WarpMouseGlobal(
    int x,
    int y,
  ) {
    return _SDL_WarpMouseGlobal(
      x,
      y,
    );
  }

  late final _SDL_WarpMouseGlobal_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WarpMouseGlobal>>(
          'SDL_WarpMouseGlobal');
  late final _dart_SDL_WarpMouseGlobal _SDL_WarpMouseGlobal =
      _SDL_WarpMouseGlobal_ptr.asFunction<_dart_SDL_WarpMouseGlobal>();

  /// \brief Set relative mouse mode.
  ///
  /// \param enabled Whether or not to enable relative mode
  ///
  /// \return 0 on success, or -1 if relative mode is not supported.
  ///
  /// While the mouse is in relative mode, the cursor is hidden, and the
  /// driver will try to report continuous motion in the current window.
  /// Only relative motion events will be delivered, the mouse position
  /// will not change.
  ///
  /// \note This function will flush any pending mouse motion.
  ///
  /// \sa SDL_GetRelativeMouseMode()
  int SDL_SetRelativeMouseMode(
    int enabled,
  ) {
    return _SDL_SetRelativeMouseMode(
      enabled,
    );
  }

  late final _SDL_SetRelativeMouseMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetRelativeMouseMode>>(
          'SDL_SetRelativeMouseMode');
  late final _dart_SDL_SetRelativeMouseMode _SDL_SetRelativeMouseMode =
      _SDL_SetRelativeMouseMode_ptr.asFunction<
          _dart_SDL_SetRelativeMouseMode>();

  /// \brief Capture the mouse, to track input outside an SDL window.
  ///
  /// \param enabled Whether or not to enable capturing
  ///
  /// Capturing enables your app to obtain mouse events globally, instead of
  /// just within your window. Not all video targets support this function.
  /// When capturing is enabled, the current window will get all mouse events,
  /// but unlike relative mode, no change is made to the cursor and it is
  /// not restrained to your window.
  ///
  /// This function may also deny mouse input to other windows--both those in
  /// your application and others on the system--so you should use this
  /// function sparingly, and in small bursts. For example, you might want to
  /// track the mouse while the user is dragging something, until the user
  /// releases a mouse button. It is not recommended that you capture the mouse
  /// for long periods of time, such as the entire time your app is running.
  ///
  /// While captured, mouse events still report coordinates relative to the
  /// current (foreground) window, but those coordinates may be outside the
  /// bounds of the window (including negative values). Capturing is only
  /// allowed for the foreground window. If the window loses focus while
  /// capturing, the capture will be disabled automatically.
  ///
  /// While capturing is enabled, the current window will have the
  /// SDL_WINDOW_MOUSE_CAPTURE flag set.
  ///
  /// \return 0 on success, or -1 if not supported.
  int SDL_CaptureMouse(
    int enabled,
  ) {
    return _SDL_CaptureMouse(
      enabled,
    );
  }

  late final _SDL_CaptureMouse_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CaptureMouse>>('SDL_CaptureMouse');
  late final _dart_SDL_CaptureMouse _SDL_CaptureMouse =
      _SDL_CaptureMouse_ptr.asFunction<_dart_SDL_CaptureMouse>();

  /// \brief Query whether relative mouse mode is enabled.
  ///
  /// \sa SDL_SetRelativeMouseMode()
  int SDL_GetRelativeMouseMode() {
    return _SDL_GetRelativeMouseMode();
  }

  late final _SDL_GetRelativeMouseMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRelativeMouseMode>>(
          'SDL_GetRelativeMouseMode');
  late final _dart_SDL_GetRelativeMouseMode _SDL_GetRelativeMouseMode =
      _SDL_GetRelativeMouseMode_ptr.asFunction<
          _dart_SDL_GetRelativeMouseMode>();

  /// \brief Create a cursor, using the specified bitmap data and
  /// mask (in MSB format).
  ///
  /// The cursor width must be a multiple of 8 bits.
  ///
  /// The cursor is created in black and white according to the following:
  /// <table>
  /// <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>
  /// <tr><td>  0   </td><td>  1   </td><td> White </td></tr>
  /// <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>
  /// <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>
  /// <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black
  /// if not. </td></tr>
  /// </table>
  ///
  /// \sa SDL_FreeCursor()
  ffi.Pointer<SDL_Cursor> SDL_CreateCursor(
    ffi.Pointer<ffi.Uint8> data,
    ffi.Pointer<ffi.Uint8> mask,
    int w,
    int h,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateCursor(
      data,
      mask,
      w,
      h,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateCursor>>('SDL_CreateCursor');
  late final _dart_SDL_CreateCursor _SDL_CreateCursor =
      _SDL_CreateCursor_ptr.asFunction<_dart_SDL_CreateCursor>();

  /// \brief Create a color cursor.
  ///
  /// \sa SDL_FreeCursor()
  ffi.Pointer<SDL_Cursor> SDL_CreateColorCursor(
    ffi.Pointer<SDL_Surface> surface,
    int hot_x,
    int hot_y,
  ) {
    return _SDL_CreateColorCursor(
      surface,
      hot_x,
      hot_y,
    );
  }

  late final _SDL_CreateColorCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateColorCursor>>(
          'SDL_CreateColorCursor');
  late final _dart_SDL_CreateColorCursor _SDL_CreateColorCursor =
      _SDL_CreateColorCursor_ptr.asFunction<_dart_SDL_CreateColorCursor>();

  /// \brief Create a system cursor.
  ///
  /// \sa SDL_FreeCursor()
  ffi.Pointer<SDL_Cursor> SDL_CreateSystemCursor(
    int id,
  ) {
    return _SDL_CreateSystemCursor(
      id,
    );
  }

  late final _SDL_CreateSystemCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateSystemCursor>>(
          'SDL_CreateSystemCursor');
  late final _dart_SDL_CreateSystemCursor _SDL_CreateSystemCursor =
      _SDL_CreateSystemCursor_ptr.asFunction<_dart_SDL_CreateSystemCursor>();

  /// \brief Set the active cursor.
  void SDL_SetCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_SetCursor(
      cursor,
    );
  }

  late final _SDL_SetCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetCursor>>('SDL_SetCursor');
  late final _dart_SDL_SetCursor _SDL_SetCursor =
      _SDL_SetCursor_ptr.asFunction<_dart_SDL_SetCursor>();

  /// \brief Return the active cursor.
  ffi.Pointer<SDL_Cursor> SDL_GetCursor() {
    return _SDL_GetCursor();
  }

  late final _SDL_GetCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetCursor>>('SDL_GetCursor');
  late final _dart_SDL_GetCursor _SDL_GetCursor =
      _SDL_GetCursor_ptr.asFunction<_dart_SDL_GetCursor>();

  /// \brief Return the default cursor.
  ffi.Pointer<SDL_Cursor> SDL_GetDefaultCursor() {
    return _SDL_GetDefaultCursor();
  }

  late final _SDL_GetDefaultCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetDefaultCursor>>(
          'SDL_GetDefaultCursor');
  late final _dart_SDL_GetDefaultCursor _SDL_GetDefaultCursor =
      _SDL_GetDefaultCursor_ptr.asFunction<_dart_SDL_GetDefaultCursor>();

  /// \brief Frees a cursor created with SDL_CreateCursor() or similar functions.
  ///
  /// \sa SDL_CreateCursor()
  /// \sa SDL_CreateColorCursor()
  /// \sa SDL_CreateSystemCursor()
  void SDL_FreeCursor(
    ffi.Pointer<SDL_Cursor> cursor,
  ) {
    return _SDL_FreeCursor(
      cursor,
    );
  }

  late final _SDL_FreeCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FreeCursor>>('SDL_FreeCursor');
  late final _dart_SDL_FreeCursor _SDL_FreeCursor =
      _SDL_FreeCursor_ptr.asFunction<_dart_SDL_FreeCursor>();

  /// \brief Toggle whether or not the cursor is shown.
  ///
  /// \param toggle 1 to show the cursor, 0 to hide it, -1 to query the current
  /// state.
  ///
  /// \return 1 if the cursor is shown, or 0 if the cursor is hidden.
  int SDL_ShowCursor(
    int toggle,
  ) {
    return _SDL_ShowCursor(
      toggle,
    );
  }

  late final _SDL_ShowCursor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ShowCursor>>('SDL_ShowCursor');
  late final _dart_SDL_ShowCursor _SDL_ShowCursor =
      _SDL_ShowCursor_ptr.asFunction<_dart_SDL_ShowCursor>();

  /// Locking for multi-threaded access to the joystick API
  ///
  /// If you are using the joystick API or handling events from multiple threads
  /// you should use these locking functions to protect access to the joysticks.
  ///
  /// In particular, you are guaranteed that the joystick list won't change, so
  /// the API functions that take a joystick index will be valid, and joystick
  /// and game controller events will not be delivered.
  void SDL_LockJoysticks() {
    return _SDL_LockJoysticks();
  }

  late final _SDL_LockJoysticks_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockJoysticks>>('SDL_LockJoysticks');
  late final _dart_SDL_LockJoysticks _SDL_LockJoysticks =
      _SDL_LockJoysticks_ptr.asFunction<_dart_SDL_LockJoysticks>();

  void SDL_UnlockJoysticks() {
    return _SDL_UnlockJoysticks();
  }

  late final _SDL_UnlockJoysticks_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockJoysticks>>(
          'SDL_UnlockJoysticks');
  late final _dart_SDL_UnlockJoysticks _SDL_UnlockJoysticks =
      _SDL_UnlockJoysticks_ptr.asFunction<_dart_SDL_UnlockJoysticks>();

  /// Count the number of joysticks attached to the system right now
  int SDL_NumJoysticks() {
    return _SDL_NumJoysticks();
  }

  late final _SDL_NumJoysticks_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_NumJoysticks>>('SDL_NumJoysticks');
  late final _dart_SDL_NumJoysticks _SDL_NumJoysticks =
      _SDL_NumJoysticks_ptr.asFunction<_dart_SDL_NumJoysticks>();

  /// Get the implementation dependent name of a joystick.
  /// This can be called before any joysticks are opened.
  /// If no name can be found, this function returns NULL.
  ffi.Pointer<ffi.Int8> SDL_JoystickNameForIndex(
    int device_index,
  ) {
    return _SDL_JoystickNameForIndex(
      device_index,
    );
  }

  late final _SDL_JoystickNameForIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickNameForIndex>>(
          'SDL_JoystickNameForIndex');
  late final _dart_SDL_JoystickNameForIndex _SDL_JoystickNameForIndex =
      _SDL_JoystickNameForIndex_ptr.asFunction<
          _dart_SDL_JoystickNameForIndex>();

  /// Get the player index of a joystick, or -1 if it's not available
  /// This can be called before any joysticks are opened.
  int SDL_JoystickGetDevicePlayerIndex(
    int device_index,
  ) {
    return _SDL_JoystickGetDevicePlayerIndex(
      device_index,
    );
  }

  late final _SDL_JoystickGetDevicePlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetDevicePlayerIndex>>(
          'SDL_JoystickGetDevicePlayerIndex');
  late final _dart_SDL_JoystickGetDevicePlayerIndex
      _SDL_JoystickGetDevicePlayerIndex = _SDL_JoystickGetDevicePlayerIndex_ptr
          .asFunction<_dart_SDL_JoystickGetDevicePlayerIndex>();

  /// Get the USB vendor ID of a joystick, if available.
  /// This can be called before any joysticks are opened.
  /// If the vendor ID isn't available this function returns 0.
  int SDL_JoystickGetDeviceVendor(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceVendor(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceVendor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetDeviceVendor>>(
          'SDL_JoystickGetDeviceVendor');
  late final _dart_SDL_JoystickGetDeviceVendor _SDL_JoystickGetDeviceVendor =
      _SDL_JoystickGetDeviceVendor_ptr.asFunction<
          _dart_SDL_JoystickGetDeviceVendor>();

  /// Get the USB product ID of a joystick, if available.
  /// This can be called before any joysticks are opened.
  /// If the product ID isn't available this function returns 0.
  int SDL_JoystickGetDeviceProduct(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProduct(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProduct_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetDeviceProduct>>(
          'SDL_JoystickGetDeviceProduct');
  late final _dart_SDL_JoystickGetDeviceProduct _SDL_JoystickGetDeviceProduct =
      _SDL_JoystickGetDeviceProduct_ptr.asFunction<
          _dart_SDL_JoystickGetDeviceProduct>();

  /// Get the product version of a joystick, if available.
  /// This can be called before any joysticks are opened.
  /// If the product version isn't available this function returns 0.
  int SDL_JoystickGetDeviceProductVersion(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceProductVersion(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceProductVersion_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetDeviceProductVersion>>(
          'SDL_JoystickGetDeviceProductVersion');
  late final _dart_SDL_JoystickGetDeviceProductVersion
      _SDL_JoystickGetDeviceProductVersion =
      _SDL_JoystickGetDeviceProductVersion_ptr.asFunction<
          _dart_SDL_JoystickGetDeviceProductVersion>();

  /// Get the type of a joystick, if available.
  /// This can be called before any joysticks are opened.
  int SDL_JoystickGetDeviceType(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceType(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetDeviceType>>(
          'SDL_JoystickGetDeviceType');
  late final _dart_SDL_JoystickGetDeviceType _SDL_JoystickGetDeviceType =
      _SDL_JoystickGetDeviceType_ptr.asFunction<
          _dart_SDL_JoystickGetDeviceType>();

  /// Get the instance ID of a joystick.
  /// This can be called before any joysticks are opened.
  /// If the index is out of range, this function will return -1.
  int SDL_JoystickGetDeviceInstanceID(
    int device_index,
  ) {
    return _SDL_JoystickGetDeviceInstanceID(
      device_index,
    );
  }

  late final _SDL_JoystickGetDeviceInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetDeviceInstanceID>>(
          'SDL_JoystickGetDeviceInstanceID');
  late final _dart_SDL_JoystickGetDeviceInstanceID
      _SDL_JoystickGetDeviceInstanceID = _SDL_JoystickGetDeviceInstanceID_ptr
          .asFunction<_dart_SDL_JoystickGetDeviceInstanceID>();

  /// Open a joystick for use.
  /// The index passed as an argument refers to the N'th joystick on the system.
  /// This index is not the value which will identify this joystick in future
  /// joystick events.  The joystick's instance id (::SDL_JoystickID) will be used
  /// there instead.
  ///
  /// \return A joystick identifier, or NULL if an error occurred.
  ffi.Pointer<_SDL_Joystick> SDL_JoystickOpen(
    int device_index,
  ) {
    return _SDL_JoystickOpen(
      device_index,
    );
  }

  late final _SDL_JoystickOpen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickOpen>>('SDL_JoystickOpen');
  late final _dart_SDL_JoystickOpen _SDL_JoystickOpen =
      _SDL_JoystickOpen_ptr.asFunction<_dart_SDL_JoystickOpen>();

  /// Return the SDL_Joystick associated with an instance id.
  ffi.Pointer<_SDL_Joystick> SDL_JoystickFromInstanceID(
    int instance_id,
  ) {
    return _SDL_JoystickFromInstanceID(
      instance_id,
    );
  }

  late final _SDL_JoystickFromInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickFromInstanceID>>(
          'SDL_JoystickFromInstanceID');
  late final _dart_SDL_JoystickFromInstanceID _SDL_JoystickFromInstanceID =
      _SDL_JoystickFromInstanceID_ptr.asFunction<
          _dart_SDL_JoystickFromInstanceID>();

  /// Return the SDL_Joystick associated with a player index.
  ffi.Pointer<_SDL_Joystick> SDL_JoystickFromPlayerIndex(
    int player_index,
  ) {
    return _SDL_JoystickFromPlayerIndex(
      player_index,
    );
  }

  late final _SDL_JoystickFromPlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickFromPlayerIndex>>(
          'SDL_JoystickFromPlayerIndex');
  late final _dart_SDL_JoystickFromPlayerIndex _SDL_JoystickFromPlayerIndex =
      _SDL_JoystickFromPlayerIndex_ptr.asFunction<
          _dart_SDL_JoystickFromPlayerIndex>();

  /// Attaches a new virtual joystick.
  /// Returns the joystick's device index, or -1 if an error occurred.
  int SDL_JoystickAttachVirtual(
    int type,
    int naxes,
    int nbuttons,
    int nhats,
  ) {
    return _SDL_JoystickAttachVirtual(
      type,
      naxes,
      nbuttons,
      nhats,
    );
  }

  late final _SDL_JoystickAttachVirtual_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickAttachVirtual>>(
          'SDL_JoystickAttachVirtual');
  late final _dart_SDL_JoystickAttachVirtual _SDL_JoystickAttachVirtual =
      _SDL_JoystickAttachVirtual_ptr.asFunction<
          _dart_SDL_JoystickAttachVirtual>();

  /// Detaches a virtual joystick
  /// Returns 0 on success, or -1 if an error occurred.
  int SDL_JoystickDetachVirtual(
    int device_index,
  ) {
    return _SDL_JoystickDetachVirtual(
      device_index,
    );
  }

  late final _SDL_JoystickDetachVirtual_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickDetachVirtual>>(
          'SDL_JoystickDetachVirtual');
  late final _dart_SDL_JoystickDetachVirtual _SDL_JoystickDetachVirtual =
      _SDL_JoystickDetachVirtual_ptr.asFunction<
          _dart_SDL_JoystickDetachVirtual>();

  /// Indicates whether or not a virtual-joystick is at a given device index.
  int SDL_JoystickIsVirtual(
    int device_index,
  ) {
    return _SDL_JoystickIsVirtual(
      device_index,
    );
  }

  late final _SDL_JoystickIsVirtual_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickIsVirtual>>(
          'SDL_JoystickIsVirtual');
  late final _dart_SDL_JoystickIsVirtual _SDL_JoystickIsVirtual =
      _SDL_JoystickIsVirtual_ptr.asFunction<_dart_SDL_JoystickIsVirtual>();

  /// Set values on an opened, virtual-joystick's controls.
  /// Please note that values set here will not be applied until the next
  /// call to SDL_JoystickUpdate, which can either be called directly,
  /// or can be called indirectly through various other SDL APIS,
  /// including, but not limited to the following: SDL_PollEvent,
  /// SDL_PumpEvents, SDL_WaitEventTimeout, SDL_WaitEvent.
  ///
  /// Returns 0 on success, -1 on error.
  int SDL_JoystickSetVirtualAxis(
    ffi.Pointer<_SDL_Joystick> joystick,
    int axis,
    int value,
  ) {
    return _SDL_JoystickSetVirtualAxis(
      joystick,
      axis,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualAxis_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickSetVirtualAxis>>(
          'SDL_JoystickSetVirtualAxis');
  late final _dart_SDL_JoystickSetVirtualAxis _SDL_JoystickSetVirtualAxis =
      _SDL_JoystickSetVirtualAxis_ptr.asFunction<
          _dart_SDL_JoystickSetVirtualAxis>();

  int SDL_JoystickSetVirtualButton(
    ffi.Pointer<_SDL_Joystick> joystick,
    int button,
    int value,
  ) {
    return _SDL_JoystickSetVirtualButton(
      joystick,
      button,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualButton_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickSetVirtualButton>>(
          'SDL_JoystickSetVirtualButton');
  late final _dart_SDL_JoystickSetVirtualButton _SDL_JoystickSetVirtualButton =
      _SDL_JoystickSetVirtualButton_ptr.asFunction<
          _dart_SDL_JoystickSetVirtualButton>();

  int SDL_JoystickSetVirtualHat(
    ffi.Pointer<_SDL_Joystick> joystick,
    int hat,
    int value,
  ) {
    return _SDL_JoystickSetVirtualHat(
      joystick,
      hat,
      value,
    );
  }

  late final _SDL_JoystickSetVirtualHat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickSetVirtualHat>>(
          'SDL_JoystickSetVirtualHat');
  late final _dart_SDL_JoystickSetVirtualHat _SDL_JoystickSetVirtualHat =
      _SDL_JoystickSetVirtualHat_ptr.asFunction<
          _dart_SDL_JoystickSetVirtualHat>();

  /// Return the name for this currently opened joystick.
  /// If no name can be found, this function returns NULL.
  ffi.Pointer<ffi.Int8> SDL_JoystickName(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickName(
      joystick,
    );
  }

  late final _SDL_JoystickName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickName>>('SDL_JoystickName');
  late final _dart_SDL_JoystickName _SDL_JoystickName =
      _SDL_JoystickName_ptr.asFunction<_dart_SDL_JoystickName>();

  /// Get the player index of an opened joystick, or -1 if it's not available
  ///
  /// For XInput controllers this returns the XInput user index.
  int SDL_JoystickGetPlayerIndex(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetPlayerIndex(
      joystick,
    );
  }

  late final _SDL_JoystickGetPlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetPlayerIndex>>(
          'SDL_JoystickGetPlayerIndex');
  late final _dart_SDL_JoystickGetPlayerIndex _SDL_JoystickGetPlayerIndex =
      _SDL_JoystickGetPlayerIndex_ptr.asFunction<
          _dart_SDL_JoystickGetPlayerIndex>();

  /// Set the player index of an opened joystick
  void SDL_JoystickSetPlayerIndex(
    ffi.Pointer<_SDL_Joystick> joystick,
    int player_index,
  ) {
    return _SDL_JoystickSetPlayerIndex(
      joystick,
      player_index,
    );
  }

  late final _SDL_JoystickSetPlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickSetPlayerIndex>>(
          'SDL_JoystickSetPlayerIndex');
  late final _dart_SDL_JoystickSetPlayerIndex _SDL_JoystickSetPlayerIndex =
      _SDL_JoystickSetPlayerIndex_ptr.asFunction<
          _dart_SDL_JoystickSetPlayerIndex>();

  /// Get the USB vendor ID of an opened joystick, if available.
  /// If the vendor ID isn't available this function returns 0.
  int SDL_JoystickGetVendor(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetVendor(
      joystick,
    );
  }

  late final _SDL_JoystickGetVendor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetVendor>>(
          'SDL_JoystickGetVendor');
  late final _dart_SDL_JoystickGetVendor _SDL_JoystickGetVendor =
      _SDL_JoystickGetVendor_ptr.asFunction<_dart_SDL_JoystickGetVendor>();

  /// Get the USB product ID of an opened joystick, if available.
  /// If the product ID isn't available this function returns 0.
  int SDL_JoystickGetProduct(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProduct(
      joystick,
    );
  }

  late final _SDL_JoystickGetProduct_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetProduct>>(
          'SDL_JoystickGetProduct');
  late final _dart_SDL_JoystickGetProduct _SDL_JoystickGetProduct =
      _SDL_JoystickGetProduct_ptr.asFunction<_dart_SDL_JoystickGetProduct>();

  /// Get the product version of an opened joystick, if available.
  /// If the product version isn't available this function returns 0.
  int SDL_JoystickGetProductVersion(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetProductVersion(
      joystick,
    );
  }

  late final _SDL_JoystickGetProductVersion_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetProductVersion>>(
          'SDL_JoystickGetProductVersion');
  late final _dart_SDL_JoystickGetProductVersion
      _SDL_JoystickGetProductVersion = _SDL_JoystickGetProductVersion_ptr
          .asFunction<_dart_SDL_JoystickGetProductVersion>();

  /// Get the serial number of an opened joystick, if available.
  ///
  /// Returns the serial number of the joystick, or NULL if it is not available.
  ffi.Pointer<ffi.Int8> SDL_JoystickGetSerial(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetSerial(
      joystick,
    );
  }

  late final _SDL_JoystickGetSerial_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetSerial>>(
          'SDL_JoystickGetSerial');
  late final _dart_SDL_JoystickGetSerial _SDL_JoystickGetSerial =
      _SDL_JoystickGetSerial_ptr.asFunction<_dart_SDL_JoystickGetSerial>();

  /// Get the type of an opened joystick.
  int SDL_JoystickGetType(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetType(
      joystick,
    );
  }

  late final _SDL_JoystickGetType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetType>>(
          'SDL_JoystickGetType');
  late final _dart_SDL_JoystickGetType _SDL_JoystickGetType =
      _SDL_JoystickGetType_ptr.asFunction<_dart_SDL_JoystickGetType>();

  /// Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not.
  int SDL_JoystickGetAttached(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickGetAttached(
      joystick,
    );
  }

  late final _SDL_JoystickGetAttached_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetAttached>>(
          'SDL_JoystickGetAttached');
  late final _dart_SDL_JoystickGetAttached _SDL_JoystickGetAttached =
      _SDL_JoystickGetAttached_ptr.asFunction<_dart_SDL_JoystickGetAttached>();

  /// Get the instance ID of an opened joystick or -1 if the joystick is invalid.
  int SDL_JoystickInstanceID(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickInstanceID(
      joystick,
    );
  }

  late final _SDL_JoystickInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickInstanceID>>(
          'SDL_JoystickInstanceID');
  late final _dart_SDL_JoystickInstanceID _SDL_JoystickInstanceID =
      _SDL_JoystickInstanceID_ptr.asFunction<_dart_SDL_JoystickInstanceID>();

  /// Get the number of general axis controls on a joystick.
  int SDL_JoystickNumAxes(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumAxes(
      joystick,
    );
  }

  late final _SDL_JoystickNumAxes_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickNumAxes>>(
          'SDL_JoystickNumAxes');
  late final _dart_SDL_JoystickNumAxes _SDL_JoystickNumAxes =
      _SDL_JoystickNumAxes_ptr.asFunction<_dart_SDL_JoystickNumAxes>();

  /// Get the number of trackballs on a joystick.
  ///
  /// Joystick trackballs have only relative motion events associated
  /// with them and their state cannot be polled.
  int SDL_JoystickNumBalls(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumBalls(
      joystick,
    );
  }

  late final _SDL_JoystickNumBalls_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickNumBalls>>(
          'SDL_JoystickNumBalls');
  late final _dart_SDL_JoystickNumBalls _SDL_JoystickNumBalls =
      _SDL_JoystickNumBalls_ptr.asFunction<_dart_SDL_JoystickNumBalls>();

  /// Get the number of POV hats on a joystick.
  int SDL_JoystickNumHats(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumHats(
      joystick,
    );
  }

  late final _SDL_JoystickNumHats_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickNumHats>>(
          'SDL_JoystickNumHats');
  late final _dart_SDL_JoystickNumHats _SDL_JoystickNumHats =
      _SDL_JoystickNumHats_ptr.asFunction<_dart_SDL_JoystickNumHats>();

  /// Get the number of buttons on a joystick.
  int SDL_JoystickNumButtons(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickNumButtons(
      joystick,
    );
  }

  late final _SDL_JoystickNumButtons_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickNumButtons>>(
          'SDL_JoystickNumButtons');
  late final _dart_SDL_JoystickNumButtons _SDL_JoystickNumButtons =
      _SDL_JoystickNumButtons_ptr.asFunction<_dart_SDL_JoystickNumButtons>();

  /// Update the current state of the open joysticks.
  ///
  /// This is called automatically by the event loop if any joystick
  /// events are enabled.
  void SDL_JoystickUpdate() {
    return _SDL_JoystickUpdate();
  }

  late final _SDL_JoystickUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickUpdate>>('SDL_JoystickUpdate');
  late final _dart_SDL_JoystickUpdate _SDL_JoystickUpdate =
      _SDL_JoystickUpdate_ptr.asFunction<_dart_SDL_JoystickUpdate>();

  /// Enable/disable joystick event polling.
  ///
  /// If joystick events are disabled, you must call SDL_JoystickUpdate()
  /// yourself and check the state of the joystick when you want joystick
  /// information.
  ///
  /// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
  int SDL_JoystickEventState(
    int state,
  ) {
    return _SDL_JoystickEventState(
      state,
    );
  }

  late final _SDL_JoystickEventState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickEventState>>(
          'SDL_JoystickEventState');
  late final _dart_SDL_JoystickEventState _SDL_JoystickEventState =
      _SDL_JoystickEventState_ptr.asFunction<_dart_SDL_JoystickEventState>();

  /// Get the current state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  int SDL_JoystickGetAxis(
    ffi.Pointer<_SDL_Joystick> joystick,
    int axis,
  ) {
    return _SDL_JoystickGetAxis(
      joystick,
      axis,
    );
  }

  late final _SDL_JoystickGetAxis_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetAxis>>(
          'SDL_JoystickGetAxis');
  late final _dart_SDL_JoystickGetAxis _SDL_JoystickGetAxis =
      _SDL_JoystickGetAxis_ptr.asFunction<_dart_SDL_JoystickGetAxis>();

  /// Get the initial state of an axis control on a joystick.
  ///
  /// The state is a value ranging from -32768 to 32767.
  ///
  /// The axis indices start at index 0.
  ///
  /// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
  int SDL_JoystickGetAxisInitialState(
    ffi.Pointer<_SDL_Joystick> joystick,
    int axis,
    ffi.Pointer<ffi.Int16> state,
  ) {
    return _SDL_JoystickGetAxisInitialState(
      joystick,
      axis,
      state,
    );
  }

  late final _SDL_JoystickGetAxisInitialState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetAxisInitialState>>(
          'SDL_JoystickGetAxisInitialState');
  late final _dart_SDL_JoystickGetAxisInitialState
      _SDL_JoystickGetAxisInitialState = _SDL_JoystickGetAxisInitialState_ptr
          .asFunction<_dart_SDL_JoystickGetAxisInitialState>();

  /// Get the current state of a POV hat on a joystick.
  ///
  /// The hat indices start at index 0.
  ///
  /// \return The return value is one of the following positions:
  /// - ::SDL_HAT_CENTERED
  /// - ::SDL_HAT_UP
  /// - ::SDL_HAT_RIGHT
  /// - ::SDL_HAT_DOWN
  /// - ::SDL_HAT_LEFT
  /// - ::SDL_HAT_RIGHTUP
  /// - ::SDL_HAT_RIGHTDOWN
  /// - ::SDL_HAT_LEFTUP
  /// - ::SDL_HAT_LEFTDOWN
  int SDL_JoystickGetHat(
    ffi.Pointer<_SDL_Joystick> joystick,
    int hat,
  ) {
    return _SDL_JoystickGetHat(
      joystick,
      hat,
    );
  }

  late final _SDL_JoystickGetHat_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetHat>>('SDL_JoystickGetHat');
  late final _dart_SDL_JoystickGetHat _SDL_JoystickGetHat =
      _SDL_JoystickGetHat_ptr.asFunction<_dart_SDL_JoystickGetHat>();

  /// Get the ball axis change since the last poll.
  ///
  /// \return 0, or -1 if you passed it invalid parameters.
  ///
  /// The ball indices start at index 0.
  int SDL_JoystickGetBall(
    ffi.Pointer<_SDL_Joystick> joystick,
    int ball,
    ffi.Pointer<ffi.Int32> dx,
    ffi.Pointer<ffi.Int32> dy,
  ) {
    return _SDL_JoystickGetBall(
      joystick,
      ball,
      dx,
      dy,
    );
  }

  late final _SDL_JoystickGetBall_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetBall>>(
          'SDL_JoystickGetBall');
  late final _dart_SDL_JoystickGetBall _SDL_JoystickGetBall =
      _SDL_JoystickGetBall_ptr.asFunction<_dart_SDL_JoystickGetBall>();

  /// Get the current state of a button on a joystick.
  ///
  /// The button indices start at index 0.
  int SDL_JoystickGetButton(
    ffi.Pointer<_SDL_Joystick> joystick,
    int button,
  ) {
    return _SDL_JoystickGetButton(
      joystick,
      button,
    );
  }

  late final _SDL_JoystickGetButton_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickGetButton>>(
          'SDL_JoystickGetButton');
  late final _dart_SDL_JoystickGetButton _SDL_JoystickGetButton =
      _SDL_JoystickGetButton_ptr.asFunction<_dart_SDL_JoystickGetButton>();

  /// Start a rumble effect
  /// Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if rumble isn't supported on this joystick
  int SDL_JoystickRumble(
    ffi.Pointer<_SDL_Joystick> joystick,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumble(
      joystick,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumble_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickRumble>>('SDL_JoystickRumble');
  late final _dart_SDL_JoystickRumble _SDL_JoystickRumble =
      _SDL_JoystickRumble_ptr.asFunction<_dart_SDL_JoystickRumble>();

  /// Start a rumble effect in the joystick's triggers
  /// Each call to this function cancels any previous trigger rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param joystick The joystick to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0 to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if trigger rumble isn't supported on this joystick
  int SDL_JoystickRumbleTriggers(
    ffi.Pointer<_SDL_Joystick> joystick,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_JoystickRumbleTriggers(
      joystick,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_JoystickRumbleTriggers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickRumbleTriggers>>(
          'SDL_JoystickRumbleTriggers');
  late final _dart_SDL_JoystickRumbleTriggers _SDL_JoystickRumbleTriggers =
      _SDL_JoystickRumbleTriggers_ptr.asFunction<
          _dart_SDL_JoystickRumbleTriggers>();

  /// Return whether a joystick has an LED
  ///
  /// \param joystick The joystick to query
  ///
  /// \return SDL_TRUE, or SDL_FALSE if this joystick does not have a modifiable LED
  int SDL_JoystickHasLED(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickHasLED(
      joystick,
    );
  }

  late final _SDL_JoystickHasLED_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickHasLED>>('SDL_JoystickHasLED');
  late final _dart_SDL_JoystickHasLED _SDL_JoystickHasLED =
      _SDL_JoystickHasLED_ptr.asFunction<_dart_SDL_JoystickHasLED>();

  /// Update a joystick's LED color.
  ///
  /// \param joystick The joystick to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  ///
  /// \return 0, or -1 if this joystick does not have a modifiable LED
  int SDL_JoystickSetLED(
    ffi.Pointer<_SDL_Joystick> joystick,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_JoystickSetLED(
      joystick,
      red,
      green,
      blue,
    );
  }

  late final _SDL_JoystickSetLED_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickSetLED>>('SDL_JoystickSetLED');
  late final _dart_SDL_JoystickSetLED _SDL_JoystickSetLED =
      _SDL_JoystickSetLED_ptr.asFunction<_dart_SDL_JoystickSetLED>();

  /// Close a joystick previously opened with SDL_JoystickOpen().
  void SDL_JoystickClose(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickClose(
      joystick,
    );
  }

  late final _SDL_JoystickClose_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickClose>>('SDL_JoystickClose');
  late final _dart_SDL_JoystickClose _SDL_JoystickClose =
      _SDL_JoystickClose_ptr.asFunction<_dart_SDL_JoystickClose>();

  /// Return the battery level of this joystick
  int SDL_JoystickCurrentPowerLevel(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickCurrentPowerLevel(
      joystick,
    );
  }

  late final _SDL_JoystickCurrentPowerLevel_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickCurrentPowerLevel>>(
          'SDL_JoystickCurrentPowerLevel');
  late final _dart_SDL_JoystickCurrentPowerLevel
      _SDL_JoystickCurrentPowerLevel = _SDL_JoystickCurrentPowerLevel_ptr
          .asFunction<_dart_SDL_JoystickCurrentPowerLevel>();

  /// Locking for multi-threaded access to the sensor API
  ///
  /// If you are using the sensor API or handling events from multiple threads
  /// you should use these locking functions to protect access to the sensors.
  ///
  /// In particular, you are guaranteed that the sensor list won't change, so
  /// the API functions that take a sensor index will be valid, and sensor
  /// events will not be delivered.
  void SDL_LockSensors() {
    return _SDL_LockSensors();
  }

  late final _SDL_LockSensors_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockSensors>>('SDL_LockSensors');
  late final _dart_SDL_LockSensors _SDL_LockSensors =
      _SDL_LockSensors_ptr.asFunction<_dart_SDL_LockSensors>();

  void SDL_UnlockSensors() {
    return _SDL_UnlockSensors();
  }

  late final _SDL_UnlockSensors_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockSensors>>('SDL_UnlockSensors');
  late final _dart_SDL_UnlockSensors _SDL_UnlockSensors =
      _SDL_UnlockSensors_ptr.asFunction<_dart_SDL_UnlockSensors>();

  /// \brief Count the number of sensors attached to the system right now
  int SDL_NumSensors() {
    return _SDL_NumSensors();
  }

  late final _SDL_NumSensors_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_NumSensors>>('SDL_NumSensors');
  late final _dart_SDL_NumSensors _SDL_NumSensors =
      _SDL_NumSensors_ptr.asFunction<_dart_SDL_NumSensors>();

  /// \brief Get the implementation dependent name of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor name, or NULL if device_index is out of range.
  ffi.Pointer<ffi.Int8> SDL_SensorGetDeviceName(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceName(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetDeviceName>>(
          'SDL_SensorGetDeviceName');
  late final _dart_SDL_SensorGetDeviceName _SDL_SensorGetDeviceName =
      _SDL_SensorGetDeviceName_ptr.asFunction<_dart_SDL_SensorGetDeviceName>();

  /// \brief Get the type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor type, or SDL_SENSOR_INVALID if device_index is out of range.
  int SDL_SensorGetDeviceType(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceType(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetDeviceType>>(
          'SDL_SensorGetDeviceType');
  late final _dart_SDL_SensorGetDeviceType _SDL_SensorGetDeviceType =
      _SDL_SensorGetDeviceType_ptr.asFunction<_dart_SDL_SensorGetDeviceType>();

  /// \brief Get the platform dependent type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor platform dependent type, or -1 if device_index is out of range.
  int SDL_SensorGetDeviceNonPortableType(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceNonPortableType(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceNonPortableType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetDeviceNonPortableType>>(
          'SDL_SensorGetDeviceNonPortableType');
  late final _dart_SDL_SensorGetDeviceNonPortableType
      _SDL_SensorGetDeviceNonPortableType =
      _SDL_SensorGetDeviceNonPortableType_ptr.asFunction<
          _dart_SDL_SensorGetDeviceNonPortableType>();

  /// \brief Get the instance ID of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor instance ID, or -1 if device_index is out of range.
  int SDL_SensorGetDeviceInstanceID(
    int device_index,
  ) {
    return _SDL_SensorGetDeviceInstanceID(
      device_index,
    );
  }

  late final _SDL_SensorGetDeviceInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetDeviceInstanceID>>(
          'SDL_SensorGetDeviceInstanceID');
  late final _dart_SDL_SensorGetDeviceInstanceID
      _SDL_SensorGetDeviceInstanceID = _SDL_SensorGetDeviceInstanceID_ptr
          .asFunction<_dart_SDL_SensorGetDeviceInstanceID>();

  /// \brief Open a sensor for use.
  ///
  /// The index passed as an argument refers to the N'th sensor on the system.
  ///
  /// \return A sensor identifier, or NULL if an error occurred.
  ffi.Pointer<_SDL_Sensor> SDL_SensorOpen(
    int device_index,
  ) {
    return _SDL_SensorOpen(
      device_index,
    );
  }

  late final _SDL_SensorOpen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorOpen>>('SDL_SensorOpen');
  late final _dart_SDL_SensorOpen _SDL_SensorOpen =
      _SDL_SensorOpen_ptr.asFunction<_dart_SDL_SensorOpen>();

  /// Return the SDL_Sensor associated with an instance id.
  ffi.Pointer<_SDL_Sensor> SDL_SensorFromInstanceID(
    int instance_id,
  ) {
    return _SDL_SensorFromInstanceID(
      instance_id,
    );
  }

  late final _SDL_SensorFromInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorFromInstanceID>>(
          'SDL_SensorFromInstanceID');
  late final _dart_SDL_SensorFromInstanceID _SDL_SensorFromInstanceID =
      _SDL_SensorFromInstanceID_ptr.asFunction<
          _dart_SDL_SensorFromInstanceID>();

  /// \brief Get the implementation dependent name of a sensor.
  ///
  /// \return The sensor name, or NULL if the sensor is NULL.
  ffi.Pointer<ffi.Int8> SDL_SensorGetName(
    ffi.Pointer<_SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetName(
      sensor,
    );
  }

  late final _SDL_SensorGetName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetName>>('SDL_SensorGetName');
  late final _dart_SDL_SensorGetName _SDL_SensorGetName =
      _SDL_SensorGetName_ptr.asFunction<_dart_SDL_SensorGetName>();

  /// \brief Get the type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL.
  int SDL_SensorGetType(
    ffi.Pointer<_SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetType(
      sensor,
    );
  }

  late final _SDL_SensorGetType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetType>>('SDL_SensorGetType');
  late final _dart_SDL_SensorGetType _SDL_SensorGetType =
      _SDL_SensorGetType_ptr.asFunction<_dart_SDL_SensorGetType>();

  /// \brief Get the platform dependent type of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor platform dependent type, or -1 if the sensor is NULL.
  int SDL_SensorGetNonPortableType(
    ffi.Pointer<_SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetNonPortableType(
      sensor,
    );
  }

  late final _SDL_SensorGetNonPortableType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetNonPortableType>>(
          'SDL_SensorGetNonPortableType');
  late final _dart_SDL_SensorGetNonPortableType _SDL_SensorGetNonPortableType =
      _SDL_SensorGetNonPortableType_ptr.asFunction<
          _dart_SDL_SensorGetNonPortableType>();

  /// \brief Get the instance ID of a sensor.
  ///
  /// This can be called before any sensors are opened.
  ///
  /// \return The sensor instance ID, or -1 if the sensor is NULL.
  int SDL_SensorGetInstanceID(
    ffi.Pointer<_SDL_Sensor> sensor,
  ) {
    return _SDL_SensorGetInstanceID(
      sensor,
    );
  }

  late final _SDL_SensorGetInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetInstanceID>>(
          'SDL_SensorGetInstanceID');
  late final _dart_SDL_SensorGetInstanceID _SDL_SensorGetInstanceID =
      _SDL_SensorGetInstanceID_ptr.asFunction<_dart_SDL_SensorGetInstanceID>();

  /// Get the current state of an opened sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  ///
  /// \param sensor The sensor to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  ///
  /// \return 0 or -1 if an error occurred.
  int SDL_SensorGetData(
    ffi.Pointer<_SDL_Sensor> sensor,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_SensorGetData(
      sensor,
      data,
      num_values,
    );
  }

  late final _SDL_SensorGetData_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorGetData>>('SDL_SensorGetData');
  late final _dart_SDL_SensorGetData _SDL_SensorGetData =
      _SDL_SensorGetData_ptr.asFunction<_dart_SDL_SensorGetData>();

  /// Close a sensor previously opened with SDL_SensorOpen()
  void SDL_SensorClose(
    ffi.Pointer<_SDL_Sensor> sensor,
  ) {
    return _SDL_SensorClose(
      sensor,
    );
  }

  late final _SDL_SensorClose_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorClose>>('SDL_SensorClose');
  late final _dart_SDL_SensorClose _SDL_SensorClose =
      _SDL_SensorClose_ptr.asFunction<_dart_SDL_SensorClose>();

  /// Update the current state of the open sensors.
  ///
  /// This is called automatically by the event loop if sensor events are enabled.
  ///
  /// This needs to be called from the thread that initialized the sensor subsystem.
  void SDL_SensorUpdate() {
    return _SDL_SensorUpdate();
  }

  late final _SDL_SensorUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SensorUpdate>>('SDL_SensorUpdate');
  late final _dart_SDL_SensorUpdate _SDL_SensorUpdate =
      _SDL_SensorUpdate_ptr.asFunction<_dart_SDL_SensorUpdate>();

  /// Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()
  /// A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt
  ///
  /// If \c freerw is non-zero, the stream will be closed after being read.
  ///
  /// \return number of mappings added, -1 on error
  int SDL_GameControllerAddMappingsFromRW(
    ffi.Pointer<SDL_RWops> rw,
    int freerw,
  ) {
    return _SDL_GameControllerAddMappingsFromRW(
      rw,
      freerw,
    );
  }

  late final _SDL_GameControllerAddMappingsFromRW_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerAddMappingsFromRW>>(
          'SDL_GameControllerAddMappingsFromRW');
  late final _dart_SDL_GameControllerAddMappingsFromRW
      _SDL_GameControllerAddMappingsFromRW =
      _SDL_GameControllerAddMappingsFromRW_ptr.asFunction<
          _dart_SDL_GameControllerAddMappingsFromRW>();

  /// Add or update an existing mapping configuration
  ///
  /// \return 1 if mapping is added, 0 if updated, -1 on error
  int SDL_GameControllerAddMapping(
    ffi.Pointer<ffi.Int8> mappingString,
  ) {
    return _SDL_GameControllerAddMapping(
      mappingString,
    );
  }

  late final _SDL_GameControllerAddMapping_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerAddMapping>>(
          'SDL_GameControllerAddMapping');
  late final _dart_SDL_GameControllerAddMapping _SDL_GameControllerAddMapping =
      _SDL_GameControllerAddMapping_ptr.asFunction<
          _dart_SDL_GameControllerAddMapping>();

  /// Get the number of mappings installed
  ///
  /// \return the number of mappings
  int SDL_GameControllerNumMappings() {
    return _SDL_GameControllerNumMappings();
  }

  late final _SDL_GameControllerNumMappings_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerNumMappings>>(
          'SDL_GameControllerNumMappings');
  late final _dart_SDL_GameControllerNumMappings
      _SDL_GameControllerNumMappings = _SDL_GameControllerNumMappings_ptr
          .asFunction<_dart_SDL_GameControllerNumMappings>();

  /// Get the mapping at a particular index.
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range.
  ffi.Pointer<ffi.Int8> SDL_GameControllerMappingForIndex(
    int mapping_index,
  ) {
    return _SDL_GameControllerMappingForIndex(
      mapping_index,
    );
  }

  late final _SDL_GameControllerMappingForIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerMappingForIndex>>(
          'SDL_GameControllerMappingForIndex');
  late final _dart_SDL_GameControllerMappingForIndex
      _SDL_GameControllerMappingForIndex =
      _SDL_GameControllerMappingForIndex_ptr.asFunction<
          _dart_SDL_GameControllerMappingForIndex>();

  /// Get a mapping string for an open GameController
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
  ffi.Pointer<ffi.Int8> SDL_GameControllerMapping(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerMapping(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerMapping_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerMapping>>(
          'SDL_GameControllerMapping');
  late final _dart_SDL_GameControllerMapping _SDL_GameControllerMapping =
      _SDL_GameControllerMapping_ptr.asFunction<
          _dart_SDL_GameControllerMapping>();

  /// Is the joystick on this index supported by the game controller interface?
  int SDL_IsGameController(
    int joystick_index,
  ) {
    return _SDL_IsGameController(
      joystick_index,
    );
  }

  late final _SDL_IsGameController_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IsGameController>>(
          'SDL_IsGameController');
  late final _dart_SDL_IsGameController _SDL_IsGameController =
      _SDL_IsGameController_ptr.asFunction<_dart_SDL_IsGameController>();

  /// Get the implementation dependent name of a game controller.
  /// This can be called before any controllers are opened.
  /// If no name can be found, this function returns NULL.
  ffi.Pointer<ffi.Int8> SDL_GameControllerNameForIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerNameForIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerNameForIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerNameForIndex>>(
          'SDL_GameControllerNameForIndex');
  late final _dart_SDL_GameControllerNameForIndex
      _SDL_GameControllerNameForIndex = _SDL_GameControllerNameForIndex_ptr
          .asFunction<_dart_SDL_GameControllerNameForIndex>();

  /// Get the type of a game controller.
  /// This can be called before any controllers are opened.
  int SDL_GameControllerTypeForIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerTypeForIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerTypeForIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerTypeForIndex>>(
          'SDL_GameControllerTypeForIndex');
  late final _dart_SDL_GameControllerTypeForIndex
      _SDL_GameControllerTypeForIndex = _SDL_GameControllerTypeForIndex_ptr
          .asFunction<_dart_SDL_GameControllerTypeForIndex>();

  /// Get the mapping of a game controller.
  /// This can be called before any controllers are opened.
  ///
  /// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
  ffi.Pointer<ffi.Int8> SDL_GameControllerMappingForDeviceIndex(
    int joystick_index,
  ) {
    return _SDL_GameControllerMappingForDeviceIndex(
      joystick_index,
    );
  }

  late final _SDL_GameControllerMappingForDeviceIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerMappingForDeviceIndex>>(
          'SDL_GameControllerMappingForDeviceIndex');
  late final _dart_SDL_GameControllerMappingForDeviceIndex
      _SDL_GameControllerMappingForDeviceIndex =
      _SDL_GameControllerMappingForDeviceIndex_ptr.asFunction<
          _dart_SDL_GameControllerMappingForDeviceIndex>();

  /// Open a game controller for use.
  /// The index passed as an argument refers to the N'th game controller on the system.
  /// This index is not the value which will identify this controller in future
  /// controller events.  The joystick's instance id (::SDL_JoystickID) will be
  /// used there instead.
  ///
  /// \return A controller identifier, or NULL if an error occurred.
  ffi.Pointer<_SDL_GameController> SDL_GameControllerOpen(
    int joystick_index,
  ) {
    return _SDL_GameControllerOpen(
      joystick_index,
    );
  }

  late final _SDL_GameControllerOpen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerOpen>>(
          'SDL_GameControllerOpen');
  late final _dart_SDL_GameControllerOpen _SDL_GameControllerOpen =
      _SDL_GameControllerOpen_ptr.asFunction<_dart_SDL_GameControllerOpen>();

  /// Return the SDL_GameController associated with an instance id.
  ffi.Pointer<_SDL_GameController> SDL_GameControllerFromInstanceID(
    int joyid,
  ) {
    return _SDL_GameControllerFromInstanceID(
      joyid,
    );
  }

  late final _SDL_GameControllerFromInstanceID_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerFromInstanceID>>(
          'SDL_GameControllerFromInstanceID');
  late final _dart_SDL_GameControllerFromInstanceID
      _SDL_GameControllerFromInstanceID = _SDL_GameControllerFromInstanceID_ptr
          .asFunction<_dart_SDL_GameControllerFromInstanceID>();

  /// Return the SDL_GameController associated with a player index.
  ffi.Pointer<_SDL_GameController> SDL_GameControllerFromPlayerIndex(
    int player_index,
  ) {
    return _SDL_GameControllerFromPlayerIndex(
      player_index,
    );
  }

  late final _SDL_GameControllerFromPlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerFromPlayerIndex>>(
          'SDL_GameControllerFromPlayerIndex');
  late final _dart_SDL_GameControllerFromPlayerIndex
      _SDL_GameControllerFromPlayerIndex =
      _SDL_GameControllerFromPlayerIndex_ptr.asFunction<
          _dart_SDL_GameControllerFromPlayerIndex>();

  /// Return the name for this currently opened controller
  ffi.Pointer<ffi.Int8> SDL_GameControllerName(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerName(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerName>>(
          'SDL_GameControllerName');
  late final _dart_SDL_GameControllerName _SDL_GameControllerName =
      _SDL_GameControllerName_ptr.asFunction<_dart_SDL_GameControllerName>();

  /// Return the type of this currently opened controller
  int SDL_GameControllerGetType(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetType(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetType>>(
          'SDL_GameControllerGetType');
  late final _dart_SDL_GameControllerGetType _SDL_GameControllerGetType =
      _SDL_GameControllerGetType_ptr.asFunction<
          _dart_SDL_GameControllerGetType>();

  /// Get the player index of an opened game controller, or -1 if it's not available
  ///
  /// For XInput controllers this returns the XInput user index.
  int SDL_GameControllerGetPlayerIndex(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetPlayerIndex(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetPlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetPlayerIndex>>(
          'SDL_GameControllerGetPlayerIndex');
  late final _dart_SDL_GameControllerGetPlayerIndex
      _SDL_GameControllerGetPlayerIndex = _SDL_GameControllerGetPlayerIndex_ptr
          .asFunction<_dart_SDL_GameControllerGetPlayerIndex>();

  /// Set the player index of an opened game controller
  void SDL_GameControllerSetPlayerIndex(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int player_index,
  ) {
    return _SDL_GameControllerSetPlayerIndex(
      gamecontroller,
      player_index,
    );
  }

  late final _SDL_GameControllerSetPlayerIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerSetPlayerIndex>>(
          'SDL_GameControllerSetPlayerIndex');
  late final _dart_SDL_GameControllerSetPlayerIndex
      _SDL_GameControllerSetPlayerIndex = _SDL_GameControllerSetPlayerIndex_ptr
          .asFunction<_dart_SDL_GameControllerSetPlayerIndex>();

  /// Get the USB vendor ID of an opened controller, if available.
  /// If the vendor ID isn't available this function returns 0.
  int SDL_GameControllerGetVendor(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetVendor(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetVendor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetVendor>>(
          'SDL_GameControllerGetVendor');
  late final _dart_SDL_GameControllerGetVendor _SDL_GameControllerGetVendor =
      _SDL_GameControllerGetVendor_ptr.asFunction<
          _dart_SDL_GameControllerGetVendor>();

  /// Get the USB product ID of an opened controller, if available.
  /// If the product ID isn't available this function returns 0.
  int SDL_GameControllerGetProduct(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetProduct(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProduct_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetProduct>>(
          'SDL_GameControllerGetProduct');
  late final _dart_SDL_GameControllerGetProduct _SDL_GameControllerGetProduct =
      _SDL_GameControllerGetProduct_ptr.asFunction<
          _dart_SDL_GameControllerGetProduct>();

  /// Get the product version of an opened controller, if available.
  /// If the product version isn't available this function returns 0.
  int SDL_GameControllerGetProductVersion(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetProductVersion(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetProductVersion_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetProductVersion>>(
          'SDL_GameControllerGetProductVersion');
  late final _dart_SDL_GameControllerGetProductVersion
      _SDL_GameControllerGetProductVersion =
      _SDL_GameControllerGetProductVersion_ptr.asFunction<
          _dart_SDL_GameControllerGetProductVersion>();

  /// Get the serial number of an opened controller, if available.
  ///
  /// Returns the serial number of the controller, or NULL if it is not available.
  ffi.Pointer<ffi.Int8> SDL_GameControllerGetSerial(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetSerial(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetSerial_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetSerial>>(
          'SDL_GameControllerGetSerial');
  late final _dart_SDL_GameControllerGetSerial _SDL_GameControllerGetSerial =
      _SDL_GameControllerGetSerial_ptr.asFunction<
          _dart_SDL_GameControllerGetSerial>();

  /// Returns SDL_TRUE if the controller has been opened and currently connected,
  /// or SDL_FALSE if it has not.
  int SDL_GameControllerGetAttached(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetAttached(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetAttached_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetAttached>>(
          'SDL_GameControllerGetAttached');
  late final _dart_SDL_GameControllerGetAttached
      _SDL_GameControllerGetAttached = _SDL_GameControllerGetAttached_ptr
          .asFunction<_dart_SDL_GameControllerGetAttached>();

  /// Get the underlying joystick object used by a controller
  ffi.Pointer<_SDL_Joystick> SDL_GameControllerGetJoystick(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetJoystick(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetJoystick_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetJoystick>>(
          'SDL_GameControllerGetJoystick');
  late final _dart_SDL_GameControllerGetJoystick
      _SDL_GameControllerGetJoystick = _SDL_GameControllerGetJoystick_ptr
          .asFunction<_dart_SDL_GameControllerGetJoystick>();

  /// Enable/disable controller event polling.
  ///
  /// If controller events are disabled, you must call SDL_GameControllerUpdate()
  /// yourself and check the state of the controller when you want controller
  /// information.
  ///
  /// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
  int SDL_GameControllerEventState(
    int state,
  ) {
    return _SDL_GameControllerEventState(
      state,
    );
  }

  late final _SDL_GameControllerEventState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerEventState>>(
          'SDL_GameControllerEventState');
  late final _dart_SDL_GameControllerEventState _SDL_GameControllerEventState =
      _SDL_GameControllerEventState_ptr.asFunction<
          _dart_SDL_GameControllerEventState>();

  /// Update the current state of the open game controllers.
  ///
  /// This is called automatically by the event loop if any game controller
  /// events are enabled.
  void SDL_GameControllerUpdate() {
    return _SDL_GameControllerUpdate();
  }

  late final _SDL_GameControllerUpdate_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerUpdate>>(
          'SDL_GameControllerUpdate');
  late final _dart_SDL_GameControllerUpdate _SDL_GameControllerUpdate =
      _SDL_GameControllerUpdate_ptr.asFunction<
          _dart_SDL_GameControllerUpdate>();

  /// turn this string into a axis mapping
  int SDL_GameControllerGetAxisFromString(
    ffi.Pointer<ffi.Int8> pchString,
  ) {
    return _SDL_GameControllerGetAxisFromString(
      pchString,
    );
  }

  late final _SDL_GameControllerGetAxisFromString_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetAxisFromString>>(
          'SDL_GameControllerGetAxisFromString');
  late final _dart_SDL_GameControllerGetAxisFromString
      _SDL_GameControllerGetAxisFromString =
      _SDL_GameControllerGetAxisFromString_ptr.asFunction<
          _dart_SDL_GameControllerGetAxisFromString>();

  /// turn this axis enum into a string mapping
  ffi.Pointer<ffi.Int8> SDL_GameControllerGetStringForAxis(
    int axis,
  ) {
    return _SDL_GameControllerGetStringForAxis(
      axis,
    );
  }

  late final _SDL_GameControllerGetStringForAxis_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetStringForAxis>>(
          'SDL_GameControllerGetStringForAxis');
  late final _dart_SDL_GameControllerGetStringForAxis
      _SDL_GameControllerGetStringForAxis =
      _SDL_GameControllerGetStringForAxis_ptr.asFunction<
          _dart_SDL_GameControllerGetStringForAxis>();

  /// Return whether a game controller has a given axis
  int SDL_GameControllerHasAxis(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerHasAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerHasAxis_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerHasAxis>>(
          'SDL_GameControllerHasAxis');
  late final _dart_SDL_GameControllerHasAxis _SDL_GameControllerHasAxis =
      _SDL_GameControllerHasAxis_ptr.asFunction<
          _dart_SDL_GameControllerHasAxis>();

  /// Get the current state of an axis control on a game controller.
  ///
  /// The state is a value ranging from -32768 to 32767 (except for the triggers,
  /// which range from 0 to 32767).
  ///
  /// The axis indices start at index 0.
  int SDL_GameControllerGetAxis(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int axis,
  ) {
    return _SDL_GameControllerGetAxis(
      gamecontroller,
      axis,
    );
  }

  late final _SDL_GameControllerGetAxis_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetAxis>>(
          'SDL_GameControllerGetAxis');
  late final _dart_SDL_GameControllerGetAxis _SDL_GameControllerGetAxis =
      _SDL_GameControllerGetAxis_ptr.asFunction<
          _dart_SDL_GameControllerGetAxis>();

  /// turn this string into a button mapping
  int SDL_GameControllerGetButtonFromString(
    ffi.Pointer<ffi.Int8> pchString,
  ) {
    return _SDL_GameControllerGetButtonFromString(
      pchString,
    );
  }

  late final _SDL_GameControllerGetButtonFromString_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetButtonFromString>>(
          'SDL_GameControllerGetButtonFromString');
  late final _dart_SDL_GameControllerGetButtonFromString
      _SDL_GameControllerGetButtonFromString =
      _SDL_GameControllerGetButtonFromString_ptr.asFunction<
          _dart_SDL_GameControllerGetButtonFromString>();

  /// turn this button enum into a string mapping
  ffi.Pointer<ffi.Int8> SDL_GameControllerGetStringForButton(
    int button,
  ) {
    return _SDL_GameControllerGetStringForButton(
      button,
    );
  }

  late final _SDL_GameControllerGetStringForButton_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetStringForButton>>(
          'SDL_GameControllerGetStringForButton');
  late final _dart_SDL_GameControllerGetStringForButton
      _SDL_GameControllerGetStringForButton =
      _SDL_GameControllerGetStringForButton_ptr.asFunction<
          _dart_SDL_GameControllerGetStringForButton>();

  /// Return whether a game controller has a given button
  int SDL_GameControllerHasButton(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerHasButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerHasButton_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerHasButton>>(
          'SDL_GameControllerHasButton');
  late final _dart_SDL_GameControllerHasButton _SDL_GameControllerHasButton =
      _SDL_GameControllerHasButton_ptr.asFunction<
          _dart_SDL_GameControllerHasButton>();

  /// Get the current state of a button on a game controller.
  ///
  /// The button indices start at index 0.
  int SDL_GameControllerGetButton(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int button,
  ) {
    return _SDL_GameControllerGetButton(
      gamecontroller,
      button,
    );
  }

  late final _SDL_GameControllerGetButton_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetButton>>(
          'SDL_GameControllerGetButton');
  late final _dart_SDL_GameControllerGetButton _SDL_GameControllerGetButton =
      _SDL_GameControllerGetButton_ptr.asFunction<
          _dart_SDL_GameControllerGetButton>();

  /// Get the number of touchpads on a game controller.
  int SDL_GameControllerGetNumTouchpads(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerGetNumTouchpads(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerGetNumTouchpads_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetNumTouchpads>>(
          'SDL_GameControllerGetNumTouchpads');
  late final _dart_SDL_GameControllerGetNumTouchpads
      _SDL_GameControllerGetNumTouchpads =
      _SDL_GameControllerGetNumTouchpads_ptr.asFunction<
          _dart_SDL_GameControllerGetNumTouchpads>();

  /// Get the number of supported simultaneous fingers on a touchpad on a game controller.
  int SDL_GameControllerGetNumTouchpadFingers(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int touchpad,
  ) {
    return _SDL_GameControllerGetNumTouchpadFingers(
      gamecontroller,
      touchpad,
    );
  }

  late final _SDL_GameControllerGetNumTouchpadFingers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetNumTouchpadFingers>>(
          'SDL_GameControllerGetNumTouchpadFingers');
  late final _dart_SDL_GameControllerGetNumTouchpadFingers
      _SDL_GameControllerGetNumTouchpadFingers =
      _SDL_GameControllerGetNumTouchpadFingers_ptr.asFunction<
          _dart_SDL_GameControllerGetNumTouchpadFingers>();

  /// Get the current state of a finger on a touchpad on a game controller.
  int SDL_GameControllerGetTouchpadFinger(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int touchpad,
    int finger,
    ffi.Pointer<ffi.Uint8> state,
    ffi.Pointer<ffi.Float> x,
    ffi.Pointer<ffi.Float> y,
    ffi.Pointer<ffi.Float> pressure,
  ) {
    return _SDL_GameControllerGetTouchpadFinger(
      gamecontroller,
      touchpad,
      finger,
      state,
      x,
      y,
      pressure,
    );
  }

  late final _SDL_GameControllerGetTouchpadFinger_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetTouchpadFinger>>(
          'SDL_GameControllerGetTouchpadFinger');
  late final _dart_SDL_GameControllerGetTouchpadFinger
      _SDL_GameControllerGetTouchpadFinger =
      _SDL_GameControllerGetTouchpadFinger_ptr.asFunction<
          _dart_SDL_GameControllerGetTouchpadFinger>();

  /// Return whether a game controller has a particular sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  ///
  /// \return SDL_TRUE if the sensor exists, SDL_FALSE otherwise.
  int SDL_GameControllerHasSensor(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerHasSensor(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerHasSensor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerHasSensor>>(
          'SDL_GameControllerHasSensor');
  late final _dart_SDL_GameControllerHasSensor _SDL_GameControllerHasSensor =
      _SDL_GameControllerHasSensor_ptr.asFunction<
          _dart_SDL_GameControllerHasSensor>();

  /// Set whether data reporting for a game controller sensor is enabled
  ///
  /// \param gamecontroller The controller to update
  /// \param type The type of sensor to enable/disable
  /// \param enabled Whether data reporting should be enabled
  ///
  /// \return 0 or -1 if an error occurred.
  int SDL_GameControllerSetSensorEnabled(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int type,
    int enabled,
  ) {
    return _SDL_GameControllerSetSensorEnabled(
      gamecontroller,
      type,
      enabled,
    );
  }

  late final _SDL_GameControllerSetSensorEnabled_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerSetSensorEnabled>>(
          'SDL_GameControllerSetSensorEnabled');
  late final _dart_SDL_GameControllerSetSensorEnabled
      _SDL_GameControllerSetSensorEnabled =
      _SDL_GameControllerSetSensorEnabled_ptr.asFunction<
          _dart_SDL_GameControllerSetSensorEnabled>();

  /// Query whether sensor data reporting is enabled for a game controller
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  ///
  /// \return SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.
  int SDL_GameControllerIsSensorEnabled(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int type,
  ) {
    return _SDL_GameControllerIsSensorEnabled(
      gamecontroller,
      type,
    );
  }

  late final _SDL_GameControllerIsSensorEnabled_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerIsSensorEnabled>>(
          'SDL_GameControllerIsSensorEnabled');
  late final _dart_SDL_GameControllerIsSensorEnabled
      _SDL_GameControllerIsSensorEnabled =
      _SDL_GameControllerIsSensorEnabled_ptr.asFunction<
          _dart_SDL_GameControllerIsSensorEnabled>();

  /// Get the current state of a game controller sensor.
  ///
  /// The number of values and interpretation of the data is sensor dependent.
  /// See SDL_sensor.h for the details for each type of sensor.
  ///
  /// \param gamecontroller The controller to query
  /// \param type The type of sensor to query
  /// \param data A pointer filled with the current sensor state
  /// \param num_values The number of values to write to data
  ///
  /// \return 0 or -1 if an error occurred.
  int SDL_GameControllerGetSensorData(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int type,
    ffi.Pointer<ffi.Float> data,
    int num_values,
  ) {
    return _SDL_GameControllerGetSensorData(
      gamecontroller,
      type,
      data,
      num_values,
    );
  }

  late final _SDL_GameControllerGetSensorData_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerGetSensorData>>(
          'SDL_GameControllerGetSensorData');
  late final _dart_SDL_GameControllerGetSensorData
      _SDL_GameControllerGetSensorData = _SDL_GameControllerGetSensorData_ptr
          .asFunction<_dart_SDL_GameControllerGetSensorData>();

  /// Start a rumble effect
  /// Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF
  /// \param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if rumble isn't supported on this controller
  int SDL_GameControllerRumble(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int low_frequency_rumble,
    int high_frequency_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumble(
      gamecontroller,
      low_frequency_rumble,
      high_frequency_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumble_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerRumble>>(
          'SDL_GameControllerRumble');
  late final _dart_SDL_GameControllerRumble _SDL_GameControllerRumble =
      _SDL_GameControllerRumble_ptr.asFunction<
          _dart_SDL_GameControllerRumble>();

  /// Start a rumble effect in the game controller's triggers
  /// Each call to this function cancels any previous trigger rumble effect, and calling it with 0 intensity stops any rumbling.
  ///
  /// \param gamecontroller The controller to vibrate
  /// \param left_rumble The intensity of the left trigger rumble motor, from 0 to 0xFFFF
  /// \param right_rumble The intensity of the right trigger rumble motor, from 0 to 0xFFFF
  /// \param duration_ms The duration of the rumble effect, in milliseconds
  ///
  /// \return 0, or -1 if rumble isn't supported on this controller
  int SDL_GameControllerRumbleTriggers(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int left_rumble,
    int right_rumble,
    int duration_ms,
  ) {
    return _SDL_GameControllerRumbleTriggers(
      gamecontroller,
      left_rumble,
      right_rumble,
      duration_ms,
    );
  }

  late final _SDL_GameControllerRumbleTriggers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerRumbleTriggers>>(
          'SDL_GameControllerRumbleTriggers');
  late final _dart_SDL_GameControllerRumbleTriggers
      _SDL_GameControllerRumbleTriggers = _SDL_GameControllerRumbleTriggers_ptr
          .asFunction<_dart_SDL_GameControllerRumbleTriggers>();

  /// Return whether a controller has an LED
  ///
  /// \param gamecontroller The controller to query
  ///
  /// \return SDL_TRUE, or SDL_FALSE if this controller does not have a modifiable LED
  int SDL_GameControllerHasLED(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerHasLED(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerHasLED_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerHasLED>>(
          'SDL_GameControllerHasLED');
  late final _dart_SDL_GameControllerHasLED _SDL_GameControllerHasLED =
      _SDL_GameControllerHasLED_ptr.asFunction<
          _dart_SDL_GameControllerHasLED>();

  /// Update a controller's LED color.
  ///
  /// \param gamecontroller The controller to update
  /// \param red The intensity of the red LED
  /// \param green The intensity of the green LED
  /// \param blue The intensity of the blue LED
  ///
  /// \return 0, or -1 if this controller does not have a modifiable LED
  int SDL_GameControllerSetLED(
    ffi.Pointer<_SDL_GameController> gamecontroller,
    int red,
    int green,
    int blue,
  ) {
    return _SDL_GameControllerSetLED(
      gamecontroller,
      red,
      green,
      blue,
    );
  }

  late final _SDL_GameControllerSetLED_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerSetLED>>(
          'SDL_GameControllerSetLED');
  late final _dart_SDL_GameControllerSetLED _SDL_GameControllerSetLED =
      _SDL_GameControllerSetLED_ptr.asFunction<
          _dart_SDL_GameControllerSetLED>();

  /// Close a controller previously opened with SDL_GameControllerOpen().
  void SDL_GameControllerClose(
    ffi.Pointer<_SDL_GameController> gamecontroller,
  ) {
    return _SDL_GameControllerClose(
      gamecontroller,
    );
  }

  late final _SDL_GameControllerClose_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GameControllerClose>>(
          'SDL_GameControllerClose');
  late final _dart_SDL_GameControllerClose _SDL_GameControllerClose =
      _SDL_GameControllerClose_ptr.asFunction<_dart_SDL_GameControllerClose>();

  /// \brief Get the number of registered touch devices.
  int SDL_GetNumTouchDevices() {
    return _SDL_GetNumTouchDevices();
  }

  late final _SDL_GetNumTouchDevices_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumTouchDevices>>(
          'SDL_GetNumTouchDevices');
  late final _dart_SDL_GetNumTouchDevices _SDL_GetNumTouchDevices =
      _SDL_GetNumTouchDevices_ptr.asFunction<_dart_SDL_GetNumTouchDevices>();

  /// \brief Get the touch ID with the given index, or 0 if the index is invalid.
  int SDL_GetTouchDevice(
    int index,
  ) {
    return _SDL_GetTouchDevice(
      index,
    );
  }

  late final _SDL_GetTouchDevice_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTouchDevice>>('SDL_GetTouchDevice');
  late final _dart_SDL_GetTouchDevice _SDL_GetTouchDevice =
      _SDL_GetTouchDevice_ptr.asFunction<_dart_SDL_GetTouchDevice>();

  /// \brief Get the type of the given touch device.
  int SDL_GetTouchDeviceType(
    int touchID,
  ) {
    return _SDL_GetTouchDeviceType(
      touchID,
    );
  }

  late final _SDL_GetTouchDeviceType_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTouchDeviceType>>(
          'SDL_GetTouchDeviceType');
  late final _dart_SDL_GetTouchDeviceType _SDL_GetTouchDeviceType =
      _SDL_GetTouchDeviceType_ptr.asFunction<_dart_SDL_GetTouchDeviceType>();

  /// \brief Get the number of active fingers for a given touch device.
  int SDL_GetNumTouchFingers(
    int touchID,
  ) {
    return _SDL_GetNumTouchFingers(
      touchID,
    );
  }

  late final _SDL_GetNumTouchFingers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumTouchFingers>>(
          'SDL_GetNumTouchFingers');
  late final _dart_SDL_GetNumTouchFingers _SDL_GetNumTouchFingers =
      _SDL_GetNumTouchFingers_ptr.asFunction<_dart_SDL_GetNumTouchFingers>();

  /// \brief Get the finger object of the given touch, with the given index.
  ffi.Pointer<SDL_Finger> SDL_GetTouchFinger(
    int touchID,
    int index,
  ) {
    return _SDL_GetTouchFinger(
      touchID,
      index,
    );
  }

  late final _SDL_GetTouchFinger_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTouchFinger>>('SDL_GetTouchFinger');
  late final _dart_SDL_GetTouchFinger _SDL_GetTouchFinger =
      _SDL_GetTouchFinger_ptr.asFunction<_dart_SDL_GetTouchFinger>();

  /// \brief Begin Recording a gesture on the specified touch, or all touches (-1)
  int SDL_RecordGesture(
    int touchId,
  ) {
    return _SDL_RecordGesture(
      touchId,
    );
  }

  late final _SDL_RecordGesture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RecordGesture>>('SDL_RecordGesture');
  late final _dart_SDL_RecordGesture _SDL_RecordGesture =
      _SDL_RecordGesture_ptr.asFunction<_dart_SDL_RecordGesture>();

  /// \brief Save all currently loaded Dollar Gesture templates
  int SDL_SaveAllDollarTemplates(
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveAllDollarTemplates(
      dst,
    );
  }

  late final _SDL_SaveAllDollarTemplates_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SaveAllDollarTemplates>>(
          'SDL_SaveAllDollarTemplates');
  late final _dart_SDL_SaveAllDollarTemplates _SDL_SaveAllDollarTemplates =
      _SDL_SaveAllDollarTemplates_ptr.asFunction<
          _dart_SDL_SaveAllDollarTemplates>();

  /// \brief Save a currently loaded Dollar Gesture template
  int SDL_SaveDollarTemplate(
    int gestureId,
    ffi.Pointer<SDL_RWops> dst,
  ) {
    return _SDL_SaveDollarTemplate(
      gestureId,
      dst,
    );
  }

  late final _SDL_SaveDollarTemplate_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SaveDollarTemplate>>(
          'SDL_SaveDollarTemplate');
  late final _dart_SDL_SaveDollarTemplate _SDL_SaveDollarTemplate =
      _SDL_SaveDollarTemplate_ptr.asFunction<_dart_SDL_SaveDollarTemplate>();

  /// \brief Load Dollar Gesture templates from a file
  int SDL_LoadDollarTemplates(
    int touchId,
    ffi.Pointer<SDL_RWops> src,
  ) {
    return _SDL_LoadDollarTemplates(
      touchId,
      src,
    );
  }

  late final _SDL_LoadDollarTemplates_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadDollarTemplates>>(
          'SDL_LoadDollarTemplates');
  late final _dart_SDL_LoadDollarTemplates _SDL_LoadDollarTemplates =
      _SDL_LoadDollarTemplates_ptr.asFunction<_dart_SDL_LoadDollarTemplates>();

  /// Pumps the event loop, gathering events from the input devices.
  ///
  /// This function updates the event queue and internal input device state.
  ///
  /// This should only be run in the thread that sets the video mode.
  void SDL_PumpEvents() {
    return _SDL_PumpEvents();
  }

  late final _SDL_PumpEvents_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_PumpEvents>>('SDL_PumpEvents');
  late final _dart_SDL_PumpEvents _SDL_PumpEvents =
      _SDL_PumpEvents_ptr.asFunction<_dart_SDL_PumpEvents>();

  /// Checks to see if certain event types are in the event queue.
  int SDL_HasEvent(
    int type,
  ) {
    return _SDL_HasEvent(
      type,
    );
  }

  late final _SDL_HasEvent_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasEvent>>('SDL_HasEvent');
  late final _dart_SDL_HasEvent _SDL_HasEvent =
      _SDL_HasEvent_ptr.asFunction<_dart_SDL_HasEvent>();

  int SDL_HasEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_HasEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_HasEvents_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HasEvents>>('SDL_HasEvents');
  late final _dart_SDL_HasEvents _SDL_HasEvents =
      _SDL_HasEvents_ptr.asFunction<_dart_SDL_HasEvents>();

  /// This function clears events from the event queue
  /// This function only affects currently queued events. If you want to make
  /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
  /// on the main thread immediately before the flush call.
  void SDL_FlushEvent(
    int type,
  ) {
    return _SDL_FlushEvent(
      type,
    );
  }

  late final _SDL_FlushEvent_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FlushEvent>>('SDL_FlushEvent');
  late final _dart_SDL_FlushEvent _SDL_FlushEvent =
      _SDL_FlushEvent_ptr.asFunction<_dart_SDL_FlushEvent>();

  void SDL_FlushEvents(
    int minType,
    int maxType,
  ) {
    return _SDL_FlushEvents(
      minType,
      maxType,
    );
  }

  late final _SDL_FlushEvents_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_FlushEvents>>('SDL_FlushEvents');
  late final _dart_SDL_FlushEvents _SDL_FlushEvents =
      _SDL_FlushEvents_ptr.asFunction<_dart_SDL_FlushEvents>();

  /// This function allows you to set the state of processing certain events.
  /// - If \c state is set to ::SDL_IGNORE, that event will be automatically
  /// dropped from the event queue and will not be filtered.
  /// - If \c state is set to ::SDL_ENABLE, that event will be processed
  /// normally.
  /// - If \c state is set to ::SDL_QUERY, SDL_EventState() will return the
  /// current processing state of the specified event.
  int SDL_EventState(
    int type,
    int state,
  ) {
    return _SDL_EventState(
      type,
      state,
    );
  }

  late final _SDL_EventState_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_EventState>>('SDL_EventState');
  late final _dart_SDL_EventState _SDL_EventState =
      _SDL_EventState_ptr.asFunction<_dart_SDL_EventState>();

  /// This function allocates a set of user-defined events, and returns
  /// the beginning event number for that set of events.
  ///
  /// If there aren't enough user-defined events left, this function
  /// returns (Uint32)-1
  int SDL_RegisterEvents(
    int numevents,
  ) {
    return _SDL_RegisterEvents(
      numevents,
    );
  }

  late final _SDL_RegisterEvents_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RegisterEvents>>('SDL_RegisterEvents');
  late final _dart_SDL_RegisterEvents _SDL_RegisterEvents =
      _SDL_RegisterEvents_ptr.asFunction<_dart_SDL_RegisterEvents>();

  /// \brief Get the path where the application resides.
  ///
  /// Get the "base path". This is the directory where the application was run
  /// from, which is probably the installation directory, and may or may not
  /// be the process's current working directory.
  ///
  /// This returns an absolute path in UTF-8 encoding, and is guaranteed to
  /// end with a path separator ('\\' on Windows, '/' most other places).
  ///
  /// The pointer returned by this function is owned by you. Please call
  /// SDL_free() on the pointer when you are done with it, or it will be a
  /// memory leak. This is not necessarily a fast call, though, so you should
  /// call this once near startup and save the string if you need it.
  ///
  /// Some platforms can't determine the application's path, and on other
  /// platforms, this might be meaningless. In such cases, this function will
  /// return NULL.
  ///
  /// \return String of base dir in UTF-8 encoding, or NULL on error.
  ///
  /// \sa SDL_GetPrefPath
  ffi.Pointer<ffi.Int8> SDL_GetBasePath() {
    return _SDL_GetBasePath();
  }

  late final _SDL_GetBasePath_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetBasePath>>('SDL_GetBasePath');
  late final _dart_SDL_GetBasePath _SDL_GetBasePath =
      _SDL_GetBasePath_ptr.asFunction<_dart_SDL_GetBasePath>();

  /// \brief Get the user-and-app-specific path where files can be written.
  ///
  /// Get the "pref dir". This is meant to be where users can write personal
  /// files (preferences and save games, etc) that are specific to your
  /// application. This directory is unique per user, per application.
  ///
  /// This function will decide the appropriate location in the native filesystem,
  /// create the directory if necessary, and return a string of the absolute
  /// path to the directory in UTF-8 encoding.
  ///
  /// On Windows, the string might look like:
  /// "C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\"
  ///
  /// On Linux, the string might look like:
  /// "/home/bob/.local/share/My Program Name/"
  ///
  /// On Mac OS X, the string might look like:
  /// "/Users/bob/Library/Application Support/My Program Name/"
  ///
  /// (etc.)
  ///
  /// You specify the name of your organization (if it's not a real organization,
  /// your name or an Internet domain you own might do) and the name of your
  /// application. These should be untranslated proper names.
  ///
  /// Both the org and app strings may become part of a directory name, so
  /// please follow these rules:
  ///
  /// - Try to use the same org string (including case-sensitivity) for
  /// all your applications that use this function.
  /// - Always use a unique app string for each one, and make sure it never
  /// changes for an app once you've decided on it.
  /// - Unicode characters are legal, as long as it's UTF-8 encoded, but...
  /// - ...only use letters, numbers, and spaces. Avoid punctuation like
  /// "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
  ///
  /// This returns an absolute path in UTF-8 encoding, and is guaranteed to
  /// end with a path separator ('\\' on Windows, '/' most other places).
  ///
  /// The pointer returned by this function is owned by you. Please call
  /// SDL_free() on the pointer when you are done with it, or it will be a
  /// memory leak. This is not necessarily a fast call, though, so you should
  /// call this once near startup and save the string if you need it.
  ///
  /// You should assume the path returned by this function is the only safe
  /// place to write files (and that SDL_GetBasePath(), while it might be
  /// writable, or even the parent of the returned path, aren't where you
  /// should be writing things).
  ///
  /// Some platforms can't determine the pref path, and on other
  /// platforms, this might be meaningless. In such cases, this function will
  /// return NULL.
  ///
  /// \param org The name of your organization.
  /// \param app The name of your application.
  /// \return UTF-8 string of user dir in platform-dependent notation. NULL
  /// if there's a problem (creating directory failed, etc).
  ///
  /// \sa SDL_GetBasePath
  ffi.Pointer<ffi.Int8> SDL_GetPrefPath(
    ffi.Pointer<ffi.Int8> org,
    ffi.Pointer<ffi.Int8> app,
  ) {
    return _SDL_GetPrefPath(
      org,
      app,
    );
  }

  late final _SDL_GetPrefPath_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPrefPath>>('SDL_GetPrefPath');
  late final _dart_SDL_GetPrefPath _SDL_GetPrefPath =
      _SDL_GetPrefPath_ptr.asFunction<_dart_SDL_GetPrefPath>();

  /// \brief Count the number of haptic devices attached to the system.
  ///
  /// \return Number of haptic devices detected on the system.
  int SDL_NumHaptics() {
    return _SDL_NumHaptics();
  }

  late final _SDL_NumHaptics_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_NumHaptics>>('SDL_NumHaptics');
  late final _dart_SDL_NumHaptics _SDL_NumHaptics =
      _SDL_NumHaptics_ptr.asFunction<_dart_SDL_NumHaptics>();

  /// \brief Get the implementation dependent name of a haptic device.
  ///
  /// This can be called before any joysticks are opened.
  /// If no name can be found, this function returns NULL.
  ///
  /// \param device_index Index of the device to get its name.
  /// \return Name of the device or NULL on error.
  ///
  /// \sa SDL_NumHaptics
  ffi.Pointer<ffi.Int8> SDL_HapticName(
    int device_index,
  ) {
    return _SDL_HapticName(
      device_index,
    );
  }

  late final _SDL_HapticName_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticName>>('SDL_HapticName');
  late final _dart_SDL_HapticName _SDL_HapticName =
      _SDL_HapticName_ptr.asFunction<_dart_SDL_HapticName>();

  /// \brief Opens a haptic device for use.
  ///
  /// The index passed as an argument refers to the N'th haptic device on this
  /// system.
  ///
  /// When opening a haptic device, its gain will be set to maximum and
  /// autocenter will be disabled.  To modify these values use
  /// SDL_HapticSetGain() and SDL_HapticSetAutocenter().
  ///
  /// \param device_index Index of the device to open.
  /// \return Device identifier or NULL on error.
  ///
  /// \sa SDL_HapticIndex
  /// \sa SDL_HapticOpenFromMouse
  /// \sa SDL_HapticOpenFromJoystick
  /// \sa SDL_HapticClose
  /// \sa SDL_HapticSetGain
  /// \sa SDL_HapticSetAutocenter
  /// \sa SDL_HapticPause
  /// \sa SDL_HapticStopAll
  ffi.Pointer<_SDL_Haptic> SDL_HapticOpen(
    int device_index,
  ) {
    return _SDL_HapticOpen(
      device_index,
    );
  }

  late final _SDL_HapticOpen_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticOpen>>('SDL_HapticOpen');
  late final _dart_SDL_HapticOpen _SDL_HapticOpen =
      _SDL_HapticOpen_ptr.asFunction<_dart_SDL_HapticOpen>();

  /// \brief Checks if the haptic device at index has been opened.
  ///
  /// \param device_index Index to check to see if it has been opened.
  /// \return 1 if it has been opened or 0 if it hasn't.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticIndex
  int SDL_HapticOpened(
    int device_index,
  ) {
    return _SDL_HapticOpened(
      device_index,
    );
  }

  late final _SDL_HapticOpened_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticOpened>>('SDL_HapticOpened');
  late final _dart_SDL_HapticOpened _SDL_HapticOpened =
      _SDL_HapticOpened_ptr.asFunction<_dart_SDL_HapticOpened>();

  /// \brief Gets the index of a haptic device.
  ///
  /// \param haptic Haptic device to get the index of.
  /// \return The index of the haptic device or -1 on error.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticOpened
  int SDL_HapticIndex(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticIndex(
      haptic,
    );
  }

  late final _SDL_HapticIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticIndex>>('SDL_HapticIndex');
  late final _dart_SDL_HapticIndex _SDL_HapticIndex =
      _SDL_HapticIndex_ptr.asFunction<_dart_SDL_HapticIndex>();

  /// \brief Gets whether or not the current mouse has haptic capabilities.
  ///
  /// \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
  ///
  /// \sa SDL_HapticOpenFromMouse
  int SDL_MouseIsHaptic() {
    return _SDL_MouseIsHaptic();
  }

  late final _SDL_MouseIsHaptic_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_MouseIsHaptic>>('SDL_MouseIsHaptic');
  late final _dart_SDL_MouseIsHaptic _SDL_MouseIsHaptic =
      _SDL_MouseIsHaptic_ptr.asFunction<_dart_SDL_MouseIsHaptic>();

  /// \brief Tries to open a haptic device from the current mouse.
  ///
  /// \return The haptic device identifier or NULL on error.
  ///
  /// \sa SDL_MouseIsHaptic
  /// \sa SDL_HapticOpen
  ffi.Pointer<_SDL_Haptic> SDL_HapticOpenFromMouse() {
    return _SDL_HapticOpenFromMouse();
  }

  late final _SDL_HapticOpenFromMouse_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticOpenFromMouse>>(
          'SDL_HapticOpenFromMouse');
  late final _dart_SDL_HapticOpenFromMouse _SDL_HapticOpenFromMouse =
      _SDL_HapticOpenFromMouse_ptr.asFunction<_dart_SDL_HapticOpenFromMouse>();

  /// \brief Checks to see if a joystick has haptic features.
  ///
  /// \param joystick Joystick to test for haptic capabilities.
  /// \return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't
  /// or -1 if an error occurred.
  ///
  /// \sa SDL_HapticOpenFromJoystick
  int SDL_JoystickIsHaptic(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_JoystickIsHaptic(
      joystick,
    );
  }

  late final _SDL_JoystickIsHaptic_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_JoystickIsHaptic>>(
          'SDL_JoystickIsHaptic');
  late final _dart_SDL_JoystickIsHaptic _SDL_JoystickIsHaptic =
      _SDL_JoystickIsHaptic_ptr.asFunction<_dart_SDL_JoystickIsHaptic>();

  /// \brief Opens a haptic device for use from a joystick device.
  ///
  /// You must still close the haptic device separately.  It will not be closed
  /// with the joystick.
  ///
  /// When opening from a joystick you should first close the haptic device before
  /// closing the joystick device.  If not, on some implementations the haptic
  /// device will also get unallocated and you'll be unable to use force feedback
  /// on that device.
  ///
  /// \param joystick Joystick to create a haptic device from.
  /// \return A valid haptic device identifier on success or NULL on error.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticClose
  ffi.Pointer<_SDL_Haptic> SDL_HapticOpenFromJoystick(
    ffi.Pointer<_SDL_Joystick> joystick,
  ) {
    return _SDL_HapticOpenFromJoystick(
      joystick,
    );
  }

  late final _SDL_HapticOpenFromJoystick_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticOpenFromJoystick>>(
          'SDL_HapticOpenFromJoystick');
  late final _dart_SDL_HapticOpenFromJoystick _SDL_HapticOpenFromJoystick =
      _SDL_HapticOpenFromJoystick_ptr.asFunction<
          _dart_SDL_HapticOpenFromJoystick>();

  /// \brief Closes a haptic device previously opened with SDL_HapticOpen().
  ///
  /// \param haptic Haptic device to close.
  void SDL_HapticClose(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticClose(
      haptic,
    );
  }

  late final _SDL_HapticClose_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticClose>>('SDL_HapticClose');
  late final _dart_SDL_HapticClose _SDL_HapticClose =
      _SDL_HapticClose_ptr.asFunction<_dart_SDL_HapticClose>();

  /// \brief Returns the number of effects a haptic device can store.
  ///
  /// On some platforms this isn't fully supported, and therefore is an
  /// approximation.  Always check to see if your created effect was actually
  /// created and do not rely solely on SDL_HapticNumEffects().
  ///
  /// \param haptic The haptic device to query effect max.
  /// \return The number of effects the haptic device can store or
  /// -1 on error.
  ///
  /// \sa SDL_HapticNumEffectsPlaying
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffects(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumEffects(
      haptic,
    );
  }

  late final _SDL_HapticNumEffects_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticNumEffects>>(
          'SDL_HapticNumEffects');
  late final _dart_SDL_HapticNumEffects _SDL_HapticNumEffects =
      _SDL_HapticNumEffects_ptr.asFunction<_dart_SDL_HapticNumEffects>();

  /// \brief Returns the number of effects a haptic device can play at the same
  /// time.
  ///
  /// This is not supported on all platforms, but will always return a value.
  /// Added here for the sake of completeness.
  ///
  /// \param haptic The haptic device to query maximum playing effects.
  /// \return The number of effects the haptic device can play at the same time
  /// or -1 on error.
  ///
  /// \sa SDL_HapticNumEffects
  /// \sa SDL_HapticQuery
  int SDL_HapticNumEffectsPlaying(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumEffectsPlaying(
      haptic,
    );
  }

  late final _SDL_HapticNumEffectsPlaying_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticNumEffectsPlaying>>(
          'SDL_HapticNumEffectsPlaying');
  late final _dart_SDL_HapticNumEffectsPlaying _SDL_HapticNumEffectsPlaying =
      _SDL_HapticNumEffectsPlaying_ptr.asFunction<
          _dart_SDL_HapticNumEffectsPlaying>();

  /// \brief Gets the haptic device's supported features in bitwise manner.
  ///
  /// Example:
  /// \code
  /// if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {
  /// printf("We have constant haptic effect!\n");
  /// }
  /// \endcode
  ///
  /// \param haptic The haptic device to query.
  /// \return Haptic features in bitwise manner (OR'd).
  ///
  /// \sa SDL_HapticNumEffects
  /// \sa SDL_HapticEffectSupported
  int SDL_HapticQuery(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticQuery(
      haptic,
    );
  }

  late final _SDL_HapticQuery_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticQuery>>('SDL_HapticQuery');
  late final _dart_SDL_HapticQuery _SDL_HapticQuery =
      _SDL_HapticQuery_ptr.asFunction<_dart_SDL_HapticQuery>();

  /// \brief Gets the number of haptic axes the device has.
  ///
  /// \sa SDL_HapticDirection
  int SDL_HapticNumAxes(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticNumAxes(
      haptic,
    );
  }

  late final _SDL_HapticNumAxes_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticNumAxes>>('SDL_HapticNumAxes');
  late final _dart_SDL_HapticNumAxes _SDL_HapticNumAxes =
      _SDL_HapticNumAxes_ptr.asFunction<_dart_SDL_HapticNumAxes>();

  /// \brief Runs the haptic effect on its associated haptic device.
  ///
  /// If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over
  /// repeating the envelope (attack and fade) every time.  If you only want the
  /// effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length
  /// parameter.
  ///
  /// \param haptic Haptic device to run the effect on.
  /// \param effect Identifier of the haptic effect to run.
  /// \param iterations Number of iterations to run the effect. Use
  /// ::SDL_HAPTIC_INFINITY for infinity.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticStopEffect
  /// \sa SDL_HapticDestroyEffect
  /// \sa SDL_HapticGetEffectStatus
  int SDL_HapticRunEffect(
    ffi.Pointer<_SDL_Haptic> haptic,
    int effect,
    int iterations,
  ) {
    return _SDL_HapticRunEffect(
      haptic,
      effect,
      iterations,
    );
  }

  late final _SDL_HapticRunEffect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticRunEffect>>(
          'SDL_HapticRunEffect');
  late final _dart_SDL_HapticRunEffect _SDL_HapticRunEffect =
      _SDL_HapticRunEffect_ptr.asFunction<_dart_SDL_HapticRunEffect>();

  /// \brief Stops the haptic effect on its associated haptic device.
  ///
  /// \param haptic Haptic device to stop the effect on.
  /// \param effect Identifier of the effect to stop.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticDestroyEffect
  int SDL_HapticStopEffect(
    ffi.Pointer<_SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticStopEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticStopEffect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticStopEffect>>(
          'SDL_HapticStopEffect');
  late final _dart_SDL_HapticStopEffect _SDL_HapticStopEffect =
      _SDL_HapticStopEffect_ptr.asFunction<_dart_SDL_HapticStopEffect>();

  /// \brief Destroys a haptic effect on the device.
  ///
  /// This will stop the effect if it's running.  Effects are automatically
  /// destroyed when the device is closed.
  ///
  /// \param haptic Device to destroy the effect on.
  /// \param effect Identifier of the effect to destroy.
  ///
  /// \sa SDL_HapticNewEffect
  void SDL_HapticDestroyEffect(
    ffi.Pointer<_SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticDestroyEffect(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticDestroyEffect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticDestroyEffect>>(
          'SDL_HapticDestroyEffect');
  late final _dart_SDL_HapticDestroyEffect _SDL_HapticDestroyEffect =
      _SDL_HapticDestroyEffect_ptr.asFunction<_dart_SDL_HapticDestroyEffect>();

  /// \brief Gets the status of the current effect on the haptic device.
  ///
  /// Device must support the ::SDL_HAPTIC_STATUS feature.
  ///
  /// \param haptic Haptic device to query the effect status on.
  /// \param effect Identifier of the effect to query its status.
  /// \return 0 if it isn't playing, 1 if it is playing or -1 on error.
  ///
  /// \sa SDL_HapticRunEffect
  /// \sa SDL_HapticStopEffect
  int SDL_HapticGetEffectStatus(
    ffi.Pointer<_SDL_Haptic> haptic,
    int effect,
  ) {
    return _SDL_HapticGetEffectStatus(
      haptic,
      effect,
    );
  }

  late final _SDL_HapticGetEffectStatus_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticGetEffectStatus>>(
          'SDL_HapticGetEffectStatus');
  late final _dart_SDL_HapticGetEffectStatus _SDL_HapticGetEffectStatus =
      _SDL_HapticGetEffectStatus_ptr.asFunction<
          _dart_SDL_HapticGetEffectStatus>();

  /// \brief Sets the global gain of the device.
  ///
  /// Device must support the ::SDL_HAPTIC_GAIN feature.
  ///
  /// The user may specify the maximum gain by setting the environment variable
  /// SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
  /// SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the
  /// maximum.
  ///
  /// \param haptic Haptic device to set the gain on.
  /// \param gain Value to set the gain to, should be between 0 and 100.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetGain(
    ffi.Pointer<_SDL_Haptic> haptic,
    int gain,
  ) {
    return _SDL_HapticSetGain(
      haptic,
      gain,
    );
  }

  late final _SDL_HapticSetGain_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticSetGain>>('SDL_HapticSetGain');
  late final _dart_SDL_HapticSetGain _SDL_HapticSetGain =
      _SDL_HapticSetGain_ptr.asFunction<_dart_SDL_HapticSetGain>();

  /// \brief Sets the global autocenter of the device.
  ///
  /// Autocenter should be between 0 and 100.  Setting it to 0 will disable
  /// autocentering.
  ///
  /// Device must support the ::SDL_HAPTIC_AUTOCENTER feature.
  ///
  /// \param haptic Haptic device to set autocentering on.
  /// \param autocenter Value to set autocenter to, 0 disables autocentering.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticQuery
  int SDL_HapticSetAutocenter(
    ffi.Pointer<_SDL_Haptic> haptic,
    int autocenter,
  ) {
    return _SDL_HapticSetAutocenter(
      haptic,
      autocenter,
    );
  }

  late final _SDL_HapticSetAutocenter_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticSetAutocenter>>(
          'SDL_HapticSetAutocenter');
  late final _dart_SDL_HapticSetAutocenter _SDL_HapticSetAutocenter =
      _SDL_HapticSetAutocenter_ptr.asFunction<_dart_SDL_HapticSetAutocenter>();

  /// \brief Pauses a haptic device.
  ///
  /// Device must support the ::SDL_HAPTIC_PAUSE feature.  Call
  /// SDL_HapticUnpause() to resume playback.
  ///
  /// Do not modify the effects nor add new ones while the device is paused.
  /// That can cause all sorts of weird errors.
  ///
  /// \param haptic Haptic device to pause.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticUnpause
  int SDL_HapticPause(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticPause(
      haptic,
    );
  }

  late final _SDL_HapticPause_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticPause>>('SDL_HapticPause');
  late final _dart_SDL_HapticPause _SDL_HapticPause =
      _SDL_HapticPause_ptr.asFunction<_dart_SDL_HapticPause>();

  /// \brief Unpauses a haptic device.
  ///
  /// Call to unpause after SDL_HapticPause().
  ///
  /// \param haptic Haptic device to unpause.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticPause
  int SDL_HapticUnpause(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticUnpause(
      haptic,
    );
  }

  late final _SDL_HapticUnpause_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticUnpause>>('SDL_HapticUnpause');
  late final _dart_SDL_HapticUnpause _SDL_HapticUnpause =
      _SDL_HapticUnpause_ptr.asFunction<_dart_SDL_HapticUnpause>();

  /// \brief Stops all the currently playing effects on a haptic device.
  ///
  /// \param haptic Haptic device to stop.
  /// \return 0 on success or -1 on error.
  int SDL_HapticStopAll(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticStopAll(
      haptic,
    );
  }

  late final _SDL_HapticStopAll_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticStopAll>>('SDL_HapticStopAll');
  late final _dart_SDL_HapticStopAll _SDL_HapticStopAll =
      _SDL_HapticStopAll_ptr.asFunction<_dart_SDL_HapticStopAll>();

  /// \brief Checks to see if rumble is supported on a haptic device.
  ///
  /// \param haptic Haptic device to check to see if it supports rumble.
  /// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
  ///
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumbleSupported(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleSupported(
      haptic,
    );
  }

  late final _SDL_HapticRumbleSupported_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticRumbleSupported>>(
          'SDL_HapticRumbleSupported');
  late final _dart_SDL_HapticRumbleSupported _SDL_HapticRumbleSupported =
      _SDL_HapticRumbleSupported_ptr.asFunction<
          _dart_SDL_HapticRumbleSupported>();

  /// \brief Initializes the haptic device for simple rumble playback.
  ///
  /// \param haptic Haptic device to initialize for simple rumble playback.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticOpen
  /// \sa SDL_HapticRumbleSupported
  /// \sa SDL_HapticRumblePlay
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumbleInit(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleInit(
      haptic,
    );
  }

  late final _SDL_HapticRumbleInit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticRumbleInit>>(
          'SDL_HapticRumbleInit');
  late final _dart_SDL_HapticRumbleInit _SDL_HapticRumbleInit =
      _SDL_HapticRumbleInit_ptr.asFunction<_dart_SDL_HapticRumbleInit>();

  /// \brief Runs simple rumble on a haptic device
  ///
  /// \param haptic Haptic device to play rumble effect on.
  /// \param strength Strength of the rumble to play as a 0-1 float value.
  /// \param length Length of the rumble to play in milliseconds.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticRumbleSupported
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumbleStop
  int SDL_HapticRumblePlay(
    ffi.Pointer<_SDL_Haptic> haptic,
    double strength,
    int length,
  ) {
    return _SDL_HapticRumblePlay(
      haptic,
      strength,
      length,
    );
  }

  late final _SDL_HapticRumblePlay_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticRumblePlay>>(
          'SDL_HapticRumblePlay');
  late final _dart_SDL_HapticRumblePlay _SDL_HapticRumblePlay =
      _SDL_HapticRumblePlay_ptr.asFunction<_dart_SDL_HapticRumblePlay>();

  /// \brief Stops the simple rumble on a haptic device.
  ///
  /// \param haptic Haptic to stop the rumble on.
  /// \return 0 on success or -1 on error.
  ///
  /// \sa SDL_HapticRumbleSupported
  /// \sa SDL_HapticRumbleInit
  /// \sa SDL_HapticRumblePlay
  int SDL_HapticRumbleStop(
    ffi.Pointer<_SDL_Haptic> haptic,
  ) {
    return _SDL_HapticRumbleStop(
      haptic,
    );
  }

  late final _SDL_HapticRumbleStop_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_HapticRumbleStop>>(
          'SDL_HapticRumbleStop');
  late final _dart_SDL_HapticRumbleStop _SDL_HapticRumbleStop =
      _SDL_HapticRumbleStop_ptr.asFunction<_dart_SDL_HapticRumbleStop>();

  /// \brief Set a hint with a specific priority
  ///
  /// The priority controls the behavior when setting a hint that already
  /// has a value.  Hints will replace existing hints of their priority and
  /// lower.  Environment variables are considered to have override priority.
  ///
  /// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
  int SDL_SetHintWithPriority(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
    int priority,
  ) {
    return _SDL_SetHintWithPriority(
      name,
      value,
      priority,
    );
  }

  late final _SDL_SetHintWithPriority_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetHintWithPriority>>(
          'SDL_SetHintWithPriority');
  late final _dart_SDL_SetHintWithPriority _SDL_SetHintWithPriority =
      _SDL_SetHintWithPriority_ptr.asFunction<_dart_SDL_SetHintWithPriority>();

  /// \brief Set a hint with normal priority
  ///
  /// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
  int SDL_SetHint(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _SDL_SetHint(
      name,
      value,
    );
  }

  late final _SDL_SetHint_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetHint>>('SDL_SetHint');
  late final _dart_SDL_SetHint _SDL_SetHint =
      _SDL_SetHint_ptr.asFunction<_dart_SDL_SetHint>();

  /// \brief Get a hint
  ///
  /// \return The string value of a hint variable.
  ffi.Pointer<ffi.Int8> SDL_GetHint(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_GetHint(
      name,
    );
  }

  late final _SDL_GetHint_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetHint>>('SDL_GetHint');
  late final _dart_SDL_GetHint _SDL_GetHint =
      _SDL_GetHint_ptr.asFunction<_dart_SDL_GetHint>();

  /// \brief Get a hint
  ///
  /// \return The boolean value of a hint variable.
  int SDL_GetHintBoolean(
    ffi.Pointer<ffi.Int8> name,
    int default_value,
  ) {
    return _SDL_GetHintBoolean(
      name,
      default_value,
    );
  }

  late final _SDL_GetHintBoolean_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetHintBoolean>>('SDL_GetHintBoolean');
  late final _dart_SDL_GetHintBoolean _SDL_GetHintBoolean =
      _SDL_GetHintBoolean_ptr.asFunction<_dart_SDL_GetHintBoolean>();

  /// \brief Add a function to watch a particular hint
  ///
  /// \param name The hint to watch
  /// \param callback The function to call when the hint value changes
  /// \param userdata A pointer to pass to the callback function
  void SDL_AddHintCallback(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.NativeFunction<SDL_HintCallback>> callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_AddHintCallback(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_AddHintCallback_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AddHintCallback>>(
          'SDL_AddHintCallback');
  late final _dart_SDL_AddHintCallback _SDL_AddHintCallback =
      _SDL_AddHintCallback_ptr.asFunction<_dart_SDL_AddHintCallback>();

  /// \brief Remove a function watching a particular hint
  ///
  /// \param name The hint being watched
  /// \param callback The function being called when the hint value changes
  /// \param userdata A pointer being passed to the callback function
  void SDL_DelHintCallback(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.NativeFunction<SDL_HintCallback>> callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_DelHintCallback(
      name,
      callback,
      userdata,
    );
  }

  late final _SDL_DelHintCallback_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DelHintCallback>>(
          'SDL_DelHintCallback');
  late final _dart_SDL_DelHintCallback _SDL_DelHintCallback =
      _SDL_DelHintCallback_ptr.asFunction<_dart_SDL_DelHintCallback>();

  /// \brief  Clear all hints
  ///
  /// This function is called during SDL_Quit() to free stored hints.
  void SDL_ClearHints() {
    return _SDL_ClearHints();
  }

  late final _SDL_ClearHints_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ClearHints>>('SDL_ClearHints');
  late final _dart_SDL_ClearHints _SDL_ClearHints =
      _SDL_ClearHints_ptr.asFunction<_dart_SDL_ClearHints>();

  /// This function dynamically loads a shared object and returns a pointer
  /// to the object handle (or NULL if there was an error).
  /// The 'sofile' parameter is a system dependent name of the object file.
  ffi.Pointer<ffi.Void> SDL_LoadObject(
    ffi.Pointer<ffi.Int8> sofile,
  ) {
    return _SDL_LoadObject(
      sofile,
    );
  }

  late final _SDL_LoadObject_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadObject>>('SDL_LoadObject');
  late final _dart_SDL_LoadObject _SDL_LoadObject =
      _SDL_LoadObject_ptr.asFunction<_dart_SDL_LoadObject>();

  /// Given an object handle, this function looks up the address of the
  /// named function in the shared object and returns it.  This address
  /// is no longer valid after calling SDL_UnloadObject().
  ffi.Pointer<ffi.Void> SDL_LoadFunction(
    ffi.Pointer<ffi.Void> handle,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _SDL_LoadFunction(
      handle,
      name,
    );
  }

  late final _SDL_LoadFunction_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LoadFunction>>('SDL_LoadFunction');
  late final _dart_SDL_LoadFunction _SDL_LoadFunction =
      _SDL_LoadFunction_ptr.asFunction<_dart_SDL_LoadFunction>();

  /// Unload a shared object from memory.
  void SDL_UnloadObject(
    ffi.Pointer<ffi.Void> handle,
  ) {
    return _SDL_UnloadObject(
      handle,
    );
  }

  late final _SDL_UnloadObject_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnloadObject>>('SDL_UnloadObject');
  late final _dart_SDL_UnloadObject _SDL_UnloadObject =
      _SDL_UnloadObject_ptr.asFunction<_dart_SDL_UnloadObject>();

  /// \brief Set the priority of all log categories
  void SDL_LogSetAllPriority(
    int priority,
  ) {
    return _SDL_LogSetAllPriority(
      priority,
    );
  }

  late final _SDL_LogSetAllPriority_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogSetAllPriority>>(
          'SDL_LogSetAllPriority');
  late final _dart_SDL_LogSetAllPriority _SDL_LogSetAllPriority =
      _SDL_LogSetAllPriority_ptr.asFunction<_dart_SDL_LogSetAllPriority>();

  /// \brief Set the priority of a particular log category
  void SDL_LogSetPriority(
    int category,
    int priority,
  ) {
    return _SDL_LogSetPriority(
      category,
      priority,
    );
  }

  late final _SDL_LogSetPriority_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogSetPriority>>('SDL_LogSetPriority');
  late final _dart_SDL_LogSetPriority _SDL_LogSetPriority =
      _SDL_LogSetPriority_ptr.asFunction<_dart_SDL_LogSetPriority>();

  /// \brief Get the priority of a particular log category
  int SDL_LogGetPriority(
    int category,
  ) {
    return _SDL_LogGetPriority(
      category,
    );
  }

  late final _SDL_LogGetPriority_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogGetPriority>>('SDL_LogGetPriority');
  late final _dart_SDL_LogGetPriority _SDL_LogGetPriority =
      _SDL_LogGetPriority_ptr.asFunction<_dart_SDL_LogGetPriority>();

  /// \brief Reset all priorities to default.
  ///
  /// \note This is called in SDL_Quit().
  void SDL_LogResetPriorities() {
    return _SDL_LogResetPriorities();
  }

  late final _SDL_LogResetPriorities_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogResetPriorities>>(
          'SDL_LogResetPriorities');
  late final _dart_SDL_LogResetPriorities _SDL_LogResetPriorities =
      _SDL_LogResetPriorities_ptr.asFunction<_dart_SDL_LogResetPriorities>();

  /// \brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO
  void SDL_Log(
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_Log(
      fmt,
    );
  }

  late final _SDL_Log_ptr = _lookup<ffi.NativeFunction<_c_SDL_Log>>('SDL_Log');
  late final _dart_SDL_Log _SDL_Log = _SDL_Log_ptr.asFunction<_dart_SDL_Log>();

  /// \brief Log a message with SDL_LOG_PRIORITY_VERBOSE
  void SDL_LogVerbose(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogVerbose(
      category,
      fmt,
    );
  }

  late final _SDL_LogVerbose_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogVerbose>>('SDL_LogVerbose');
  late final _dart_SDL_LogVerbose _SDL_LogVerbose =
      _SDL_LogVerbose_ptr.asFunction<_dart_SDL_LogVerbose>();

  /// \brief Log a message with SDL_LOG_PRIORITY_DEBUG
  void SDL_LogDebug(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogDebug(
      category,
      fmt,
    );
  }

  late final _SDL_LogDebug_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogDebug>>('SDL_LogDebug');
  late final _dart_SDL_LogDebug _SDL_LogDebug =
      _SDL_LogDebug_ptr.asFunction<_dart_SDL_LogDebug>();

  /// \brief Log a message with SDL_LOG_PRIORITY_INFO
  void SDL_LogInfo(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogInfo(
      category,
      fmt,
    );
  }

  late final _SDL_LogInfo_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogInfo>>('SDL_LogInfo');
  late final _dart_SDL_LogInfo _SDL_LogInfo =
      _SDL_LogInfo_ptr.asFunction<_dart_SDL_LogInfo>();

  /// \brief Log a message with SDL_LOG_PRIORITY_WARN
  void SDL_LogWarn(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogWarn(
      category,
      fmt,
    );
  }

  late final _SDL_LogWarn_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogWarn>>('SDL_LogWarn');
  late final _dart_SDL_LogWarn _SDL_LogWarn =
      _SDL_LogWarn_ptr.asFunction<_dart_SDL_LogWarn>();

  /// \brief Log a message with SDL_LOG_PRIORITY_ERROR
  void SDL_LogError(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogError(
      category,
      fmt,
    );
  }

  late final _SDL_LogError_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogError>>('SDL_LogError');
  late final _dart_SDL_LogError _SDL_LogError =
      _SDL_LogError_ptr.asFunction<_dart_SDL_LogError>();

  /// \brief Log a message with SDL_LOG_PRIORITY_CRITICAL
  void SDL_LogCritical(
    int category,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogCritical(
      category,
      fmt,
    );
  }

  late final _SDL_LogCritical_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogCritical>>('SDL_LogCritical');
  late final _dart_SDL_LogCritical _SDL_LogCritical =
      _SDL_LogCritical_ptr.asFunction<_dart_SDL_LogCritical>();

  /// \brief Log a message with the specified category and priority.
  void SDL_LogMessage(
    int category,
    int priority,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    return _SDL_LogMessage(
      category,
      priority,
      fmt,
    );
  }

  late final _SDL_LogMessage_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogMessage>>('SDL_LogMessage');
  late final _dart_SDL_LogMessage _SDL_LogMessage =
      _SDL_LogMessage_ptr.asFunction<_dart_SDL_LogMessage>();

  /// \brief Log a message with the specified category and priority.
  void SDL_LogMessageV(
    int category,
    int priority,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<ffi.Int8> ap,
  ) {
    return _SDL_LogMessageV(
      category,
      priority,
      fmt,
      ap,
    );
  }

  late final _SDL_LogMessageV_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogMessageV>>('SDL_LogMessageV');
  late final _dart_SDL_LogMessageV _SDL_LogMessageV =
      _SDL_LogMessageV_ptr.asFunction<_dart_SDL_LogMessageV>();

  /// \brief Get the current log output function.
  void SDL_LogGetOutputFunction(
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_LogOutputFunction>>>
        callback,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
  ) {
    return _SDL_LogGetOutputFunction(
      callback,
      userdata,
    );
  }

  late final _SDL_LogGetOutputFunction_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogGetOutputFunction>>(
          'SDL_LogGetOutputFunction');
  late final _dart_SDL_LogGetOutputFunction _SDL_LogGetOutputFunction =
      _SDL_LogGetOutputFunction_ptr.asFunction<
          _dart_SDL_LogGetOutputFunction>();

  /// \brief This function allows you to replace the default log output
  /// function with one of your own.
  void SDL_LogSetOutputFunction(
    ffi.Pointer<ffi.NativeFunction<SDL_LogOutputFunction>> callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_LogSetOutputFunction(
      callback,
      userdata,
    );
  }

  late final _SDL_LogSetOutputFunction_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LogSetOutputFunction>>(
          'SDL_LogSetOutputFunction');
  late final _dart_SDL_LogSetOutputFunction _SDL_LogSetOutputFunction =
      _SDL_LogSetOutputFunction_ptr.asFunction<
          _dart_SDL_LogSetOutputFunction>();

  /// \brief Create a modal message box.
  ///
  /// \param messageboxdata The SDL_MessageBoxData structure with title, text, etc.
  /// \param buttonid The pointer to which user id of hit button should be copied.
  ///
  /// \return -1 on error, otherwise 0 and buttonid contains user id of button
  /// hit or -1 if dialog was closed.
  ///
  /// \note This function should be called on the thread that created the parent
  /// window, or on the main thread if the messagebox has no parent.  It will
  /// block execution of that thread until the user clicks a button or
  /// closes the messagebox.
  int SDL_ShowMessageBox(
    ffi.Pointer<SDL_MessageBoxData> messageboxdata,
    ffi.Pointer<ffi.Int32> buttonid,
  ) {
    return _SDL_ShowMessageBox(
      messageboxdata,
      buttonid,
    );
  }

  late final _SDL_ShowMessageBox_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ShowMessageBox>>('SDL_ShowMessageBox');
  late final _dart_SDL_ShowMessageBox _SDL_ShowMessageBox =
      _SDL_ShowMessageBox_ptr.asFunction<_dart_SDL_ShowMessageBox>();

  /// \brief Create a simple modal message box
  ///
  /// \param flags    ::SDL_MessageBoxFlags
  /// \param title    UTF-8 title text
  /// \param message  UTF-8 message text
  /// \param window   The parent window, or NULL for no parent
  ///
  /// \return 0 on success, -1 on error
  ///
  /// \sa SDL_ShowMessageBox
  int SDL_ShowSimpleMessageBox(
    int flags,
    ffi.Pointer<ffi.Int8> title,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_ShowSimpleMessageBox(
      flags,
      title,
      message,
      window,
    );
  }

  late final _SDL_ShowSimpleMessageBox_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_ShowSimpleMessageBox>>(
          'SDL_ShowSimpleMessageBox');
  late final _dart_SDL_ShowSimpleMessageBox _SDL_ShowSimpleMessageBox =
      _SDL_ShowSimpleMessageBox_ptr.asFunction<
          _dart_SDL_ShowSimpleMessageBox>();

  /// \brief Create a CAMetalLayer-backed NSView/UIView and attach it to the
  /// specified window.
  ///
  /// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on its
  /// own. It is up to user code to do that.
  ///
  /// The returned handle can be casted directly to a NSView or UIView.
  /// To access the backing CAMetalLayer, call SDL_Metal_GetLayer().
  ///
  /// \note \a window must be created with the SDL_WINDOW_METAL flag.
  ///
  /// \sa SDL_Metal_DestroyView
  /// \sa SDL_Metal_GetLayer
  ffi.Pointer<ffi.Void> SDL_Metal_CreateView(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_Metal_CreateView(
      window,
    );
  }

  late final _SDL_Metal_CreateView_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Metal_CreateView>>(
          'SDL_Metal_CreateView');
  late final _dart_SDL_Metal_CreateView _SDL_Metal_CreateView =
      _SDL_Metal_CreateView_ptr.asFunction<_dart_SDL_Metal_CreateView>();

  /// \brief Destroy an existing SDL_MetalView object.
  ///
  /// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was
  /// called after SDL_CreateWindow.
  ///
  /// \sa SDL_Metal_CreateView
  void SDL_Metal_DestroyView(
    ffi.Pointer<ffi.Void> view,
  ) {
    return _SDL_Metal_DestroyView(
      view,
    );
  }

  late final _SDL_Metal_DestroyView_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Metal_DestroyView>>(
          'SDL_Metal_DestroyView');
  late final _dart_SDL_Metal_DestroyView _SDL_Metal_DestroyView =
      _SDL_Metal_DestroyView_ptr.asFunction<_dart_SDL_Metal_DestroyView>();

  /// \brief Get a pointer to the backing CAMetalLayer for the given view.
  ///
  /// \sa SDL_MetalCreateView
  ffi.Pointer<ffi.Void> SDL_Metal_GetLayer(
    ffi.Pointer<ffi.Void> view,
  ) {
    return _SDL_Metal_GetLayer(
      view,
    );
  }

  late final _SDL_Metal_GetLayer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Metal_GetLayer>>('SDL_Metal_GetLayer');
  late final _dart_SDL_Metal_GetLayer _SDL_Metal_GetLayer =
      _SDL_Metal_GetLayer_ptr.asFunction<_dart_SDL_Metal_GetLayer>();

  /// \brief Get the size of a window's underlying drawable in pixels (for use
  /// with setting viewport, scissor & etc).
  ///
  /// \param window   SDL_Window from which the drawable size should be queried
  /// \param w        Pointer to variable for storing the width in pixels,
  /// may be NULL
  /// \param h        Pointer to variable for storing the height in pixels,
  /// may be NULL
  ///
  /// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
  /// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
  /// platform with high-DPI support (Apple calls this "Retina"), and not disabled
  /// by the \c SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
  ///
  /// \note On macOS high-DPI support must be enabled for an application by
  /// setting NSHighResolutionCapable to true in its Info.plist.
  ///
  /// \sa SDL_GetWindowSize()
  /// \sa SDL_CreateWindow()
  void SDL_Metal_GetDrawableSize(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_Metal_GetDrawableSize(
      window,
      w,
      h,
    );
  }

  late final _SDL_Metal_GetDrawableSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Metal_GetDrawableSize>>(
          'SDL_Metal_GetDrawableSize');
  late final _dart_SDL_Metal_GetDrawableSize _SDL_Metal_GetDrawableSize =
      _SDL_Metal_GetDrawableSize_ptr.asFunction<
          _dart_SDL_Metal_GetDrawableSize>();

  /// \brief Get the current power supply details.
  ///
  /// \param secs Seconds of battery life left. You can pass a NULL here if
  /// you don't care. Will return -1 if we can't determine a
  /// value, or we're not running on a battery.
  ///
  /// \param pct Percentage of battery life left, between 0 and 100. You can
  /// pass a NULL here if you don't care. Will return -1 if we
  /// can't determine a value, or we're not running on a battery.
  ///
  /// \return The state of the battery (if any).
  int SDL_GetPowerInfo(
    ffi.Pointer<ffi.Int32> secs,
    ffi.Pointer<ffi.Int32> pct,
  ) {
    return _SDL_GetPowerInfo(
      secs,
      pct,
    );
  }

  late final _SDL_GetPowerInfo_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPowerInfo>>('SDL_GetPowerInfo');
  late final _dart_SDL_GetPowerInfo _SDL_GetPowerInfo =
      _SDL_GetPowerInfo_ptr.asFunction<_dart_SDL_GetPowerInfo>();

  /// \brief Get the number of 2D rendering drivers available for the current
  /// display.
  ///
  /// A render driver is a set of code that handles rendering and texture
  /// management on a particular display.  Normally there is only one, but
  /// some drivers may have several available with different capabilities.
  ///
  /// \sa SDL_GetRenderDriverInfo()
  /// \sa SDL_CreateRenderer()
  int SDL_GetNumRenderDrivers() {
    return _SDL_GetNumRenderDrivers();
  }

  late final _SDL_GetNumRenderDrivers_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetNumRenderDrivers>>(
          'SDL_GetNumRenderDrivers');
  late final _dart_SDL_GetNumRenderDrivers _SDL_GetNumRenderDrivers =
      _SDL_GetNumRenderDrivers_ptr.asFunction<_dart_SDL_GetNumRenderDrivers>();

  /// \brief Get information about a specific 2D rendering driver for the current
  /// display.
  ///
  /// \param index The index of the driver to query information about.
  /// \param info  A pointer to an SDL_RendererInfo struct to be filled with
  /// information on the rendering driver.
  ///
  /// \return 0 on success, -1 if the index was out of range.
  ///
  /// \sa SDL_CreateRenderer()
  int SDL_GetRenderDriverInfo(
    int index,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRenderDriverInfo(
      index,
      info,
    );
  }

  late final _SDL_GetRenderDriverInfo_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRenderDriverInfo>>(
          'SDL_GetRenderDriverInfo');
  late final _dart_SDL_GetRenderDriverInfo _SDL_GetRenderDriverInfo =
      _SDL_GetRenderDriverInfo_ptr.asFunction<_dart_SDL_GetRenderDriverInfo>();

  /// \brief Create a window and default renderer
  ///
  /// \param width    The width of the window
  /// \param height   The height of the window
  /// \param window_flags The flags used to create the window
  /// \param window   A pointer filled with the window, or NULL on error
  /// \param renderer A pointer filled with the renderer, or NULL on error
  ///
  /// \return 0 on success, or -1 on error
  int SDL_CreateWindowAndRenderer(
    int width,
    int height,
    int window_flags,
    ffi.Pointer<ffi.Pointer<SDL_Window>> window,
    ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
  ) {
    return _SDL_CreateWindowAndRenderer(
      width,
      height,
      window_flags,
      window,
      renderer,
    );
  }

  late final _SDL_CreateWindowAndRenderer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateWindowAndRenderer>>(
          'SDL_CreateWindowAndRenderer');
  late final _dart_SDL_CreateWindowAndRenderer _SDL_CreateWindowAndRenderer =
      _SDL_CreateWindowAndRenderer_ptr.asFunction<
          _dart_SDL_CreateWindowAndRenderer>();

  /// \brief Create a 2D rendering context for a window.
  ///
  /// \param window The window where rendering is displayed.
  /// \param index    The index of the rendering driver to initialize, or -1 to
  /// initialize the first one supporting the requested flags.
  /// \param flags    ::SDL_RendererFlags.
  ///
  /// \return A valid rendering context or NULL if there was an error.
  ///
  /// \sa SDL_CreateSoftwareRenderer()
  /// \sa SDL_GetRendererInfo()
  /// \sa SDL_DestroyRenderer()
  ffi.Pointer<SDL_Renderer> SDL_CreateRenderer(
    ffi.Pointer<SDL_Window> window,
    int index,
    int flags,
  ) {
    return _SDL_CreateRenderer(
      window,
      index,
      flags,
    );
  }

  late final _SDL_CreateRenderer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateRenderer>>('SDL_CreateRenderer');
  late final _dart_SDL_CreateRenderer _SDL_CreateRenderer =
      _SDL_CreateRenderer_ptr.asFunction<_dart_SDL_CreateRenderer>();

  /// \brief Create a 2D software rendering context for a surface.
  ///
  /// \param surface The surface where rendering is done.
  ///
  /// \return A valid rendering context or NULL if there was an error.
  ///
  /// \sa SDL_CreateRenderer()
  /// \sa SDL_DestroyRenderer()
  ffi.Pointer<SDL_Renderer> SDL_CreateSoftwareRenderer(
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateSoftwareRenderer(
      surface,
    );
  }

  late final _SDL_CreateSoftwareRenderer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateSoftwareRenderer>>(
          'SDL_CreateSoftwareRenderer');
  late final _dart_SDL_CreateSoftwareRenderer _SDL_CreateSoftwareRenderer =
      _SDL_CreateSoftwareRenderer_ptr.asFunction<
          _dart_SDL_CreateSoftwareRenderer>();

  /// \brief Get the renderer associated with a window.
  ffi.Pointer<SDL_Renderer> SDL_GetRenderer(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_GetRenderer(
      window,
    );
  }

  late final _SDL_GetRenderer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRenderer>>('SDL_GetRenderer');
  late final _dart_SDL_GetRenderer _SDL_GetRenderer =
      _SDL_GetRenderer_ptr.asFunction<_dart_SDL_GetRenderer>();

  /// \brief Get information about a rendering context.
  int SDL_GetRendererInfo(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_RendererInfo> info,
  ) {
    return _SDL_GetRendererInfo(
      renderer,
      info,
    );
  }

  late final _SDL_GetRendererInfo_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRendererInfo>>(
          'SDL_GetRendererInfo');
  late final _dart_SDL_GetRendererInfo _SDL_GetRendererInfo =
      _SDL_GetRendererInfo_ptr.asFunction<_dart_SDL_GetRendererInfo>();

  /// \brief Get the output size in pixels of a rendering context.
  int SDL_GetRendererOutputSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_GetRendererOutputSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_GetRendererOutputSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRendererOutputSize>>(
          'SDL_GetRendererOutputSize');
  late final _dart_SDL_GetRendererOutputSize _SDL_GetRendererOutputSize =
      _SDL_GetRendererOutputSize_ptr.asFunction<
          _dart_SDL_GetRendererOutputSize>();

  /// \brief Create a texture for a rendering context.
  ///
  /// \param renderer The renderer.
  /// \param format The format of the texture.
  /// \param access One of the enumerated values in ::SDL_TextureAccess.
  /// \param w      The width of the texture in pixels.
  /// \param h      The height of the texture in pixels.
  ///
  /// \return The created texture is returned, or NULL if no rendering context was
  /// active,  the format was unsupported, or the width or height were out
  /// of range.
  ///
  /// \note The contents of the texture are not defined at creation.
  ///
  /// \sa SDL_QueryTexture()
  /// \sa SDL_UpdateTexture()
  /// \sa SDL_DestroyTexture()
  ffi.Pointer<SDL_Texture> SDL_CreateTexture(
    ffi.Pointer<SDL_Renderer> renderer,
    int format,
    int access,
    int w,
    int h,
  ) {
    return _SDL_CreateTexture(
      renderer,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_CreateTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateTexture>>('SDL_CreateTexture');
  late final _dart_SDL_CreateTexture _SDL_CreateTexture =
      _SDL_CreateTexture_ptr.asFunction<_dart_SDL_CreateTexture>();

  /// \brief Create a texture from an existing surface.
  ///
  /// \param renderer The renderer.
  /// \param surface The surface containing pixel data used to fill the texture.
  ///
  /// \return The created texture is returned, or NULL on error.
  ///
  /// \note The surface is not modified or freed by this function.
  ///
  /// \sa SDL_QueryTexture()
  /// \sa SDL_DestroyTexture()
  ffi.Pointer<SDL_Texture> SDL_CreateTextureFromSurface(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Surface> surface,
  ) {
    return _SDL_CreateTextureFromSurface(
      renderer,
      surface,
    );
  }

  late final _SDL_CreateTextureFromSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateTextureFromSurface>>(
          'SDL_CreateTextureFromSurface');
  late final _dart_SDL_CreateTextureFromSurface _SDL_CreateTextureFromSurface =
      _SDL_CreateTextureFromSurface_ptr.asFunction<
          _dart_SDL_CreateTextureFromSurface>();

  /// \brief Query the attributes of a texture
  ///
  /// \param texture A texture to be queried.
  /// \param format  A pointer filled in with the raw format of the texture.  The
  /// actual format may differ, but pixel transfers will use this
  /// format.
  /// \param access  A pointer filled in with the actual access to the texture.
  /// \param w       A pointer filled in with the width of the texture in pixels.
  /// \param h       A pointer filled in with the height of the texture in pixels.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  int SDL_QueryTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Uint32> format,
    ffi.Pointer<ffi.Int32> access,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_QueryTexture(
      texture,
      format,
      access,
      w,
      h,
    );
  }

  late final _SDL_QueryTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_QueryTexture>>('SDL_QueryTexture');
  late final _dart_SDL_QueryTexture _SDL_QueryTexture =
      _SDL_QueryTexture_ptr.asFunction<_dart_SDL_QueryTexture>();

  /// \brief Set an additional color value used in render copy operations.
  ///
  /// \param texture The texture to update.
  /// \param r       The red color value multiplied into copy operations.
  /// \param g       The green color value multiplied into copy operations.
  /// \param b       The blue color value multiplied into copy operations.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or color modulation
  /// is not supported.
  ///
  /// \sa SDL_GetTextureColorMod()
  int SDL_SetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    int r,
    int g,
    int b,
  ) {
    return _SDL_SetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_SetTextureColorMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetTextureColorMod>>(
          'SDL_SetTextureColorMod');
  late final _dart_SDL_SetTextureColorMod _SDL_SetTextureColorMod =
      _SDL_SetTextureColorMod_ptr.asFunction<_dart_SDL_SetTextureColorMod>();

  /// \brief Get the additional color value used in render copy operations.
  ///
  /// \param texture The texture to query.
  /// \param r         A pointer filled in with the current red color value.
  /// \param g         A pointer filled in with the current green color value.
  /// \param b         A pointer filled in with the current blue color value.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureColorMod()
  int SDL_GetTextureColorMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Uint8> r,
    ffi.Pointer<ffi.Uint8> g,
    ffi.Pointer<ffi.Uint8> b,
  ) {
    return _SDL_GetTextureColorMod(
      texture,
      r,
      g,
      b,
    );
  }

  late final _SDL_GetTextureColorMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTextureColorMod>>(
          'SDL_GetTextureColorMod');
  late final _dart_SDL_GetTextureColorMod _SDL_GetTextureColorMod =
      _SDL_GetTextureColorMod_ptr.asFunction<_dart_SDL_GetTextureColorMod>();

  /// \brief Set an additional alpha value used in render copy operations.
  ///
  /// \param texture The texture to update.
  /// \param alpha     The alpha value multiplied into copy operations.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or alpha modulation
  /// is not supported.
  ///
  /// \sa SDL_GetTextureAlphaMod()
  int SDL_SetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    int alpha,
  ) {
    return _SDL_SetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_SetTextureAlphaMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetTextureAlphaMod>>(
          'SDL_SetTextureAlphaMod');
  late final _dart_SDL_SetTextureAlphaMod _SDL_SetTextureAlphaMod =
      _SDL_SetTextureAlphaMod_ptr.asFunction<_dart_SDL_SetTextureAlphaMod>();

  /// \brief Get the additional alpha value used in render copy operations.
  ///
  /// \param texture The texture to query.
  /// \param alpha     A pointer filled in with the current alpha value.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureAlphaMod()
  int SDL_GetTextureAlphaMod(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Uint8> alpha,
  ) {
    return _SDL_GetTextureAlphaMod(
      texture,
      alpha,
    );
  }

  late final _SDL_GetTextureAlphaMod_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTextureAlphaMod>>(
          'SDL_GetTextureAlphaMod');
  late final _dart_SDL_GetTextureAlphaMod _SDL_GetTextureAlphaMod =
      _SDL_GetTextureAlphaMod_ptr.asFunction<_dart_SDL_GetTextureAlphaMod>();

  /// \brief Set the blend mode used for texture copy operations.
  ///
  /// \param texture The texture to update.
  /// \param blendMode ::SDL_BlendMode to use for texture blending.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or the blend mode is
  /// not supported.
  ///
  /// \note If the blend mode is not supported, the closest supported mode is
  /// chosen.
  ///
  /// \sa SDL_GetTextureBlendMode()
  int SDL_SetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    int blendMode,
  ) {
    return _SDL_SetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_SetTextureBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetTextureBlendMode>>(
          'SDL_SetTextureBlendMode');
  late final _dart_SDL_SetTextureBlendMode _SDL_SetTextureBlendMode =
      _SDL_SetTextureBlendMode_ptr.asFunction<_dart_SDL_SetTextureBlendMode>();

  /// \brief Get the blend mode used for texture copy operations.
  ///
  /// \param texture   The texture to query.
  /// \param blendMode A pointer filled in with the current blend mode.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureBlendMode()
  int SDL_GetTextureBlendMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetTextureBlendMode(
      texture,
      blendMode,
    );
  }

  late final _SDL_GetTextureBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTextureBlendMode>>(
          'SDL_GetTextureBlendMode');
  late final _dart_SDL_GetTextureBlendMode _SDL_GetTextureBlendMode =
      _SDL_GetTextureBlendMode_ptr.asFunction<_dart_SDL_GetTextureBlendMode>();

  /// \brief Set the scale mode used for texture scale operations.
  ///
  /// \param texture The texture to update.
  /// \param scaleMode ::SDL_ScaleMode to use for texture scaling.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \note If the scale mode is not supported, the closest supported mode is
  /// chosen.
  ///
  /// \sa SDL_GetTextureScaleMode()
  int SDL_SetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    int scaleMode,
  ) {
    return _SDL_SetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_SetTextureScaleMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetTextureScaleMode>>(
          'SDL_SetTextureScaleMode');
  late final _dart_SDL_SetTextureScaleMode _SDL_SetTextureScaleMode =
      _SDL_SetTextureScaleMode_ptr.asFunction<_dart_SDL_SetTextureScaleMode>();

  /// \brief Get the scale mode used for texture scale operations.
  ///
  /// \param texture   The texture to query.
  /// \param scaleMode A pointer filled in with the current scale mode.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \sa SDL_SetTextureScaleMode()
  int SDL_GetTextureScaleMode(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Int32> scaleMode,
  ) {
    return _SDL_GetTextureScaleMode(
      texture,
      scaleMode,
    );
  }

  late final _SDL_GetTextureScaleMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTextureScaleMode>>(
          'SDL_GetTextureScaleMode');
  late final _dart_SDL_GetTextureScaleMode _SDL_GetTextureScaleMode =
      _SDL_GetTextureScaleMode_ptr.asFunction<_dart_SDL_GetTextureScaleMode>();

  /// \brief Update the given texture rectangle with new pixel data.
  ///
  /// \param texture   The texture to update
  /// \param rect      A pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param pixels    The raw pixel data in the format of the texture.
  /// \param pitch     The number of bytes in a row of pixel data, including padding between lines.
  ///
  /// The pixel data must be in the format of the texture. The pixel format can be
  /// queried with SDL_QueryTexture.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \note This is a fairly slow function.
  int SDL_UpdateTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_UpdateTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_UpdateTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UpdateTexture>>('SDL_UpdateTexture');
  late final _dart_SDL_UpdateTexture _SDL_UpdateTexture =
      _SDL_UpdateTexture_ptr.asFunction<_dart_SDL_UpdateTexture>();

  /// \brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data.
  ///
  /// \param texture   The texture to update
  /// \param rect      A pointer to the rectangle of pixels to update, or NULL to
  /// update the entire texture.
  /// \param Yplane    The raw pixel data for the Y plane.
  /// \param Ypitch    The number of bytes between rows of pixel data for the Y plane.
  /// \param Uplane    The raw pixel data for the U plane.
  /// \param Upitch    The number of bytes between rows of pixel data for the U plane.
  /// \param Vplane    The raw pixel data for the V plane.
  /// \param Vpitch    The number of bytes between rows of pixel data for the V plane.
  ///
  /// \return 0 on success, or -1 if the texture is not valid.
  ///
  /// \note You can use SDL_UpdateTexture() as long as your pixel data is
  /// a contiguous block of Y and U/V planes in the proper order, but
  /// this function is available if your pixel data is not contiguous.
  int SDL_UpdateYUVTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Uint8> Yplane,
    int Ypitch,
    ffi.Pointer<ffi.Uint8> Uplane,
    int Upitch,
    ffi.Pointer<ffi.Uint8> Vplane,
    int Vpitch,
  ) {
    return _SDL_UpdateYUVTexture(
      texture,
      rect,
      Yplane,
      Ypitch,
      Uplane,
      Upitch,
      Vplane,
      Vpitch,
    );
  }

  late final _SDL_UpdateYUVTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UpdateYUVTexture>>(
          'SDL_UpdateYUVTexture');
  late final _dart_SDL_UpdateYUVTexture _SDL_UpdateYUVTexture =
      _SDL_UpdateYUVTexture_ptr.asFunction<_dart_SDL_UpdateYUVTexture>();

  /// \brief Lock a portion of the texture for write-only pixel access.
  ///
  /// \param texture   The texture to lock for access, which was created with
  /// ::SDL_TEXTUREACCESS_STREAMING.
  /// \param rect      A pointer to the rectangle to lock for access. If the rect
  /// is NULL, the entire texture will be locked.
  /// \param pixels    This is filled in with a pointer to the locked pixels,
  /// appropriately offset by the locked area.
  /// \param pitch     This is filled in with the pitch of the locked pixels.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
  ///
  /// \sa SDL_UnlockTexture()
  int SDL_LockTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
    ffi.Pointer<ffi.Int32> pitch,
  ) {
    return _SDL_LockTexture(
      texture,
      rect,
      pixels,
      pitch,
    );
  }

  late final _SDL_LockTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockTexture>>('SDL_LockTexture');
  late final _dart_SDL_LockTexture _SDL_LockTexture =
      _SDL_LockTexture_ptr.asFunction<_dart_SDL_LockTexture>();

  /// \brief Lock a portion of the texture for write-only pixel access.
  /// Expose it as a SDL surface.
  ///
  /// \param texture   The texture to lock for access, which was created with
  /// ::SDL_TEXTUREACCESS_STREAMING.
  /// \param rect      A pointer to the rectangle to lock for access. If the rect
  /// is NULL, the entire texture will be locked.
  /// \param surface   This is filled in with a SDL surface representing the locked area
  /// Surface is freed internally after calling SDL_UnlockTexture or SDL_DestroyTexture.
  ///
  /// \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
  ///
  /// \sa SDL_UnlockTexture()
  int SDL_LockTextureToSurface(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> rect,
    ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
  ) {
    return _SDL_LockTextureToSurface(
      texture,
      rect,
      surface,
    );
  }

  late final _SDL_LockTextureToSurface_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_LockTextureToSurface>>(
          'SDL_LockTextureToSurface');
  late final _dart_SDL_LockTextureToSurface _SDL_LockTextureToSurface =
      _SDL_LockTextureToSurface_ptr.asFunction<
          _dart_SDL_LockTextureToSurface>();

  /// \brief Unlock a texture, uploading the changes to video memory, if needed.
  /// If SDL_LockTextureToSurface() was called for locking, the SDL surface is freed.
  ///
  /// \sa SDL_LockTexture()
  /// \sa SDL_LockTextureToSurface()
  void SDL_UnlockTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_UnlockTexture(
      texture,
    );
  }

  late final _SDL_UnlockTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_UnlockTexture>>('SDL_UnlockTexture');
  late final _dart_SDL_UnlockTexture _SDL_UnlockTexture =
      _SDL_UnlockTexture_ptr.asFunction<_dart_SDL_UnlockTexture>();

  /// \brief Determines whether a window supports the use of render targets
  ///
  /// \param renderer The renderer that will be checked
  ///
  /// \return SDL_TRUE if supported, SDL_FALSE if not.
  int SDL_RenderTargetSupported(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderTargetSupported(
      renderer,
    );
  }

  late final _SDL_RenderTargetSupported_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderTargetSupported>>(
          'SDL_RenderTargetSupported');
  late final _dart_SDL_RenderTargetSupported _SDL_RenderTargetSupported =
      _SDL_RenderTargetSupported_ptr.asFunction<
          _dart_SDL_RenderTargetSupported>();

  /// \brief Set a texture as the current rendering target.
  ///
  /// \param renderer The renderer.
  /// \param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \sa SDL_GetRenderTarget()
  int SDL_SetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_SetRenderTarget(
      renderer,
      texture,
    );
  }

  late final _SDL_SetRenderTarget_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetRenderTarget>>(
          'SDL_SetRenderTarget');
  late final _dart_SDL_SetRenderTarget _SDL_SetRenderTarget =
      _SDL_SetRenderTarget_ptr.asFunction<_dart_SDL_SetRenderTarget>();

  /// \brief Get the current render target or NULL for the default render target.
  ///
  /// \return The current render target
  ///
  /// \sa SDL_SetRenderTarget()
  ffi.Pointer<SDL_Texture> SDL_GetRenderTarget(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_GetRenderTarget(
      renderer,
    );
  }

  late final _SDL_GetRenderTarget_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRenderTarget>>(
          'SDL_GetRenderTarget');
  late final _dart_SDL_GetRenderTarget _SDL_GetRenderTarget =
      _SDL_GetRenderTarget_ptr.asFunction<_dart_SDL_GetRenderTarget>();

  /// \brief Set device independent resolution for rendering
  ///
  /// \param renderer The renderer for which resolution should be set.
  /// \param w      The width of the logical resolution
  /// \param h      The height of the logical resolution
  ///
  /// This function uses the viewport and scaling functionality to allow a fixed logical
  /// resolution for rendering, regardless of the actual output resolution.  If the actual
  /// output resolution doesn't have the same aspect ratio the output rendering will be
  /// centered within the output display.
  ///
  /// If the output display is a window, mouse events in the window will be filtered
  /// and scaled so they seem to arrive within the logical resolution.
  ///
  /// \note If this function results in scaling or subpixel drawing by the
  /// rendering backend, it will be handled using the appropriate
  /// quality hints.
  ///
  /// \sa SDL_RenderGetLogicalSize()
  /// \sa SDL_RenderSetScale()
  /// \sa SDL_RenderSetViewport()
  int SDL_RenderSetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    int w,
    int h,
  ) {
    return _SDL_RenderSetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderSetLogicalSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderSetLogicalSize>>(
          'SDL_RenderSetLogicalSize');
  late final _dart_SDL_RenderSetLogicalSize _SDL_RenderSetLogicalSize =
      _SDL_RenderSetLogicalSize_ptr.asFunction<
          _dart_SDL_RenderSetLogicalSize>();

  /// \brief Get device independent resolution for rendering
  ///
  /// \param renderer The renderer from which resolution should be queried.
  /// \param w      A pointer filled with the width of the logical resolution
  /// \param h      A pointer filled with the height of the logical resolution
  ///
  /// \sa SDL_RenderSetLogicalSize()
  void SDL_RenderGetLogicalSize(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> w,
    ffi.Pointer<ffi.Int32> h,
  ) {
    return _SDL_RenderGetLogicalSize(
      renderer,
      w,
      h,
    );
  }

  late final _SDL_RenderGetLogicalSize_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetLogicalSize>>(
          'SDL_RenderGetLogicalSize');
  late final _dart_SDL_RenderGetLogicalSize _SDL_RenderGetLogicalSize =
      _SDL_RenderGetLogicalSize_ptr.asFunction<
          _dart_SDL_RenderGetLogicalSize>();

  /// \brief Set whether to force integer scales for resolution-independent rendering
  ///
  /// \param renderer The renderer for which integer scaling should be set.
  /// \param enable   Enable or disable integer scaling
  ///
  /// This function restricts the logical viewport to integer values - that is, when
  /// a resolution is between two multiples of a logical size, the viewport size is
  /// rounded down to the lower multiple.
  ///
  /// \sa SDL_RenderSetLogicalSize()
  int SDL_RenderSetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
    int enable,
  ) {
    return _SDL_RenderSetIntegerScale(
      renderer,
      enable,
    );
  }

  late final _SDL_RenderSetIntegerScale_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderSetIntegerScale>>(
          'SDL_RenderSetIntegerScale');
  late final _dart_SDL_RenderSetIntegerScale _SDL_RenderSetIntegerScale =
      _SDL_RenderSetIntegerScale_ptr.asFunction<
          _dart_SDL_RenderSetIntegerScale>();

  /// \brief Get whether integer scales are forced for resolution-independent rendering
  ///
  /// \param renderer The renderer from which integer scaling should be queried.
  ///
  /// \sa SDL_RenderSetIntegerScale()
  int SDL_RenderGetIntegerScale(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetIntegerScale(
      renderer,
    );
  }

  late final _SDL_RenderGetIntegerScale_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetIntegerScale>>(
          'SDL_RenderGetIntegerScale');
  late final _dart_SDL_RenderGetIntegerScale _SDL_RenderGetIntegerScale =
      _SDL_RenderGetIntegerScale_ptr.asFunction<
          _dart_SDL_RenderGetIntegerScale>();

  /// \brief Set the drawing area for rendering on the current target.
  ///
  /// \param renderer The renderer for which the drawing area should be set.
  /// \param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target.
  ///
  /// The x,y of the viewport rect represents the origin for rendering.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \note If the window associated with the renderer is resized, the viewport is automatically reset.
  ///
  /// \sa SDL_RenderGetViewport()
  /// \sa SDL_RenderSetLogicalSize()
  int SDL_RenderSetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetViewport_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderSetViewport>>(
          'SDL_RenderSetViewport');
  late final _dart_SDL_RenderSetViewport _SDL_RenderSetViewport =
      _SDL_RenderSetViewport_ptr.asFunction<_dart_SDL_RenderSetViewport>();

  /// \brief Get the drawing area for the current target.
  ///
  /// \sa SDL_RenderSetViewport()
  void SDL_RenderGetViewport(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetViewport(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetViewport_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetViewport>>(
          'SDL_RenderGetViewport');
  late final _dart_SDL_RenderGetViewport _SDL_RenderGetViewport =
      _SDL_RenderGetViewport_ptr.asFunction<_dart_SDL_RenderGetViewport>();

  /// \brief Set the clip rectangle for the current target.
  ///
  /// \param renderer The renderer for which clip rectangle should be set.
  /// \param rect   A pointer to the rectangle to set as the clip rectangle,
  /// relative to the viewport, or NULL to disable clipping.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \sa SDL_RenderGetClipRect()
  int SDL_RenderSetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderSetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderSetClipRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderSetClipRect>>(
          'SDL_RenderSetClipRect');
  late final _dart_SDL_RenderSetClipRect _SDL_RenderSetClipRect =
      _SDL_RenderSetClipRect_ptr.asFunction<_dart_SDL_RenderSetClipRect>();

  /// \brief Get the clip rectangle for the current target.
  ///
  /// \param renderer The renderer from which clip rectangle should be queried.
  /// \param rect   A pointer filled in with the current clip rectangle, or
  /// an empty rectangle if clipping is disabled.
  ///
  /// \sa SDL_RenderSetClipRect()
  void SDL_RenderGetClipRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderGetClipRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderGetClipRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetClipRect>>(
          'SDL_RenderGetClipRect');
  late final _dart_SDL_RenderGetClipRect _SDL_RenderGetClipRect =
      _SDL_RenderGetClipRect_ptr.asFunction<_dart_SDL_RenderGetClipRect>();

  /// \brief Get whether clipping is enabled on the given renderer.
  ///
  /// \param renderer The renderer from which clip state should be queried.
  ///
  /// \sa SDL_RenderGetClipRect()
  int SDL_RenderIsClipEnabled(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderIsClipEnabled(
      renderer,
    );
  }

  late final _SDL_RenderIsClipEnabled_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderIsClipEnabled>>(
          'SDL_RenderIsClipEnabled');
  late final _dart_SDL_RenderIsClipEnabled _SDL_RenderIsClipEnabled =
      _SDL_RenderIsClipEnabled_ptr.asFunction<_dart_SDL_RenderIsClipEnabled>();

  /// \brief Set the drawing scale for rendering on the current target.
  ///
  /// \param renderer The renderer for which the drawing scale should be set.
  /// \param scaleX The horizontal scaling factor
  /// \param scaleY The vertical scaling factor
  ///
  /// The drawing coordinates are scaled by the x/y scaling factors
  /// before they are used by the renderer.  This allows resolution
  /// independent drawing with a single coordinate system.
  ///
  /// \note If this results in scaling or subpixel drawing by the
  /// rendering backend, it will be handled using the appropriate
  /// quality hints.  For best results use integer scaling factors.
  ///
  /// \sa SDL_RenderGetScale()
  /// \sa SDL_RenderSetLogicalSize()
  int SDL_RenderSetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    double scaleX,
    double scaleY,
  ) {
    return _SDL_RenderSetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderSetScale_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderSetScale>>('SDL_RenderSetScale');
  late final _dart_SDL_RenderSetScale _SDL_RenderSetScale =
      _SDL_RenderSetScale_ptr.asFunction<_dart_SDL_RenderSetScale>();

  /// \brief Get the drawing scale for the current target.
  ///
  /// \param renderer The renderer from which drawing scale should be queried.
  /// \param scaleX A pointer filled in with the horizontal scaling factor
  /// \param scaleY A pointer filled in with the vertical scaling factor
  ///
  /// \sa SDL_RenderSetScale()
  void SDL_RenderGetScale(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Float> scaleX,
    ffi.Pointer<ffi.Float> scaleY,
  ) {
    return _SDL_RenderGetScale(
      renderer,
      scaleX,
      scaleY,
    );
  }

  late final _SDL_RenderGetScale_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetScale>>('SDL_RenderGetScale');
  late final _dart_SDL_RenderGetScale _SDL_RenderGetScale =
      _SDL_RenderGetScale_ptr.asFunction<_dart_SDL_RenderGetScale>();

  /// \brief Set the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer The renderer for which drawing color should be set.
  /// \param r The red value used to draw on the rendering target.
  /// \param g The green value used to draw on the rendering target.
  /// \param b The blue value used to draw on the rendering target.
  /// \param a The alpha value used to draw on the rendering target, usually
  /// ::SDL_ALPHA_OPAQUE (255).
  ///
  /// \return 0 on success, or -1 on error
  int SDL_SetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    int r,
    int g,
    int b,
    int a,
  ) {
    return _SDL_SetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_SetRenderDrawColor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetRenderDrawColor>>(
          'SDL_SetRenderDrawColor');
  late final _dart_SDL_SetRenderDrawColor _SDL_SetRenderDrawColor =
      _SDL_SetRenderDrawColor_ptr.asFunction<_dart_SDL_SetRenderDrawColor>();

  /// \brief Get the color used for drawing operations (Rect, Line and Clear).
  ///
  /// \param renderer The renderer from which drawing color should be queried.
  /// \param r A pointer to the red value used to draw on the rendering target.
  /// \param g A pointer to the green value used to draw on the rendering target.
  /// \param b A pointer to the blue value used to draw on the rendering target.
  /// \param a A pointer to the alpha value used to draw on the rendering target,
  /// usually ::SDL_ALPHA_OPAQUE (255).
  ///
  /// \return 0 on success, or -1 on error
  int SDL_GetRenderDrawColor(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Uint8> r,
    ffi.Pointer<ffi.Uint8> g,
    ffi.Pointer<ffi.Uint8> b,
    ffi.Pointer<ffi.Uint8> a,
  ) {
    return _SDL_GetRenderDrawColor(
      renderer,
      r,
      g,
      b,
      a,
    );
  }

  late final _SDL_GetRenderDrawColor_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRenderDrawColor>>(
          'SDL_GetRenderDrawColor');
  late final _dart_SDL_GetRenderDrawColor _SDL_GetRenderDrawColor =
      _SDL_GetRenderDrawColor_ptr.asFunction<_dart_SDL_GetRenderDrawColor>();

  /// \brief Set the blend mode used for drawing operations (Fill and Line).
  ///
  /// \param renderer The renderer for which blend mode should be set.
  /// \param blendMode ::SDL_BlendMode to use for blending.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \note If the blend mode is not supported, the closest supported mode is
  /// chosen.
  ///
  /// \sa SDL_GetRenderDrawBlendMode()
  int SDL_SetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    int blendMode,
  ) {
    return _SDL_SetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_SetRenderDrawBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetRenderDrawBlendMode>>(
          'SDL_SetRenderDrawBlendMode');
  late final _dart_SDL_SetRenderDrawBlendMode _SDL_SetRenderDrawBlendMode =
      _SDL_SetRenderDrawBlendMode_ptr.asFunction<
          _dart_SDL_SetRenderDrawBlendMode>();

  /// \brief Get the blend mode used for drawing operations.
  ///
  /// \param renderer The renderer from which blend mode should be queried.
  /// \param blendMode A pointer filled in with the current blend mode.
  ///
  /// \return 0 on success, or -1 on error
  ///
  /// \sa SDL_SetRenderDrawBlendMode()
  int SDL_GetRenderDrawBlendMode(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<ffi.Int32> blendMode,
  ) {
    return _SDL_GetRenderDrawBlendMode(
      renderer,
      blendMode,
    );
  }

  late final _SDL_GetRenderDrawBlendMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRenderDrawBlendMode>>(
          'SDL_GetRenderDrawBlendMode');
  late final _dart_SDL_GetRenderDrawBlendMode _SDL_GetRenderDrawBlendMode =
      _SDL_GetRenderDrawBlendMode_ptr.asFunction<
          _dart_SDL_GetRenderDrawBlendMode>();

  /// \brief Clear the current rendering target with the drawing color
  ///
  /// This function clears the entire rendering target, ignoring the viewport and
  /// the clip rectangle.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderClear(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderClear(
      renderer,
    );
  }

  late final _SDL_RenderClear_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderClear>>('SDL_RenderClear');
  late final _dart_SDL_RenderClear _SDL_RenderClear =
      _SDL_RenderClear_ptr.asFunction<_dart_SDL_RenderClear>();

  /// \brief Draw a point on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPoint(
    ffi.Pointer<SDL_Renderer> renderer,
    int x,
    int y,
  ) {
    return _SDL_RenderDrawPoint(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPoint_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawPoint>>(
          'SDL_RenderDrawPoint');
  late final _dart_SDL_RenderDrawPoint _SDL_RenderDrawPoint =
      _SDL_RenderDrawPoint_ptr.asFunction<_dart_SDL_RenderDrawPoint>();

  /// \brief Draw multiple points on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPoints(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawPoints(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPoints_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawPoints>>(
          'SDL_RenderDrawPoints');
  late final _dart_SDL_RenderDrawPoints _SDL_RenderDrawPoints =
      _SDL_RenderDrawPoints_ptr.asFunction<_dart_SDL_RenderDrawPoints>();

  /// \brief Draw a line on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLine(
    ffi.Pointer<SDL_Renderer> renderer,
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _SDL_RenderDrawLine(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLine_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawLine>>('SDL_RenderDrawLine');
  late final _dart_SDL_RenderDrawLine _SDL_RenderDrawLine =
      _SDL_RenderDrawLine_ptr.asFunction<_dart_SDL_RenderDrawLine>();

  /// \brief Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLines(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Point> points,
    int count,
  ) {
    return _SDL_RenderDrawLines(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLines_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawLines>>(
          'SDL_RenderDrawLines');
  late final _dart_SDL_RenderDrawLines _SDL_RenderDrawLines =
      _SDL_RenderDrawLines_ptr.asFunction<_dart_SDL_RenderDrawLines>();

  /// \brief Draw a rectangle on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderDrawRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawRect>>('SDL_RenderDrawRect');
  late final _dart_SDL_RenderDrawRect _SDL_RenderDrawRect =
      _SDL_RenderDrawRect_ptr.asFunction<_dart_SDL_RenderDrawRect>();

  /// \brief Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRects_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawRects>>(
          'SDL_RenderDrawRects');
  late final _dart_SDL_RenderDrawRects _SDL_RenderDrawRects =
      _SDL_RenderDrawRects_ptr.asFunction<_dart_SDL_RenderDrawRects>();

  /// \brief Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRect(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
  ) {
    return _SDL_RenderFillRect(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRect_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderFillRect>>('SDL_RenderFillRect');
  late final _dart_SDL_RenderFillRect _SDL_RenderFillRect =
      _SDL_RenderFillRect_ptr.asFunction<_dart_SDL_RenderFillRect>();

  /// \brief Fill some number of rectangles on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRects(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rects,
    int count,
  ) {
    return _SDL_RenderFillRects(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRects_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderFillRects>>(
          'SDL_RenderFillRects');
  late final _dart_SDL_RenderFillRects _SDL_RenderFillRects =
      _SDL_RenderFillRects_ptr.asFunction<_dart_SDL_RenderFillRects>();

  /// \brief Copy a portion of the texture to the current rendering target.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopy(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
  ) {
    return _SDL_RenderCopy(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopy_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderCopy>>('SDL_RenderCopy');
  late final _dart_SDL_RenderCopy _SDL_RenderCopy =
      _SDL_RenderCopy_ptr.asFunction<_dart_SDL_RenderCopy>();

  /// \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction
  /// \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).
  /// \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopyEx(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_Rect> dstrect,
    double angle,
    ffi.Pointer<SDL_Point> center,
    int flip,
  ) {
    return _SDL_RenderCopyEx(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyEx_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderCopyEx>>('SDL_RenderCopyEx');
  late final _dart_SDL_RenderCopyEx _SDL_RenderCopyEx =
      _SDL_RenderCopyEx_ptr.asFunction<_dart_SDL_RenderCopyEx>();

  /// \brief Draw a point on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a point.
  /// \param x The x coordinate of the point.
  /// \param y The y coordinate of the point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPointF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x,
    double y,
  ) {
    return _SDL_RenderDrawPointF(
      renderer,
      x,
      y,
    );
  }

  late final _SDL_RenderDrawPointF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawPointF>>(
          'SDL_RenderDrawPointF');
  late final _dart_SDL_RenderDrawPointF _SDL_RenderDrawPointF =
      _SDL_RenderDrawPointF_ptr.asFunction<_dart_SDL_RenderDrawPointF>();

  /// \brief Draw multiple points on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple points.
  /// \param points The points to draw
  /// \param count The number of points to draw
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawPointsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawPointsF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawPointsF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawPointsF>>(
          'SDL_RenderDrawPointsF');
  late final _dart_SDL_RenderDrawPointsF _SDL_RenderDrawPointsF =
      _SDL_RenderDrawPointsF_ptr.asFunction<_dart_SDL_RenderDrawPointsF>();

  /// \brief Draw a line on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a line.
  /// \param x1 The x coordinate of the start point.
  /// \param y1 The y coordinate of the start point.
  /// \param x2 The x coordinate of the end point.
  /// \param y2 The y coordinate of the end point.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLineF(
    ffi.Pointer<SDL_Renderer> renderer,
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _SDL_RenderDrawLineF(
      renderer,
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _SDL_RenderDrawLineF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawLineF>>(
          'SDL_RenderDrawLineF');
  late final _dart_SDL_RenderDrawLineF _SDL_RenderDrawLineF =
      _SDL_RenderDrawLineF_ptr.asFunction<_dart_SDL_RenderDrawLineF>();

  /// \brief Draw a series of connected lines on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple lines.
  /// \param points The points along the lines
  /// \param count The number of points, drawing count-1 lines
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawLinesF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FPoint> points,
    int count,
  ) {
    return _SDL_RenderDrawLinesF(
      renderer,
      points,
      count,
    );
  }

  late final _SDL_RenderDrawLinesF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawLinesF>>(
          'SDL_RenderDrawLinesF');
  late final _dart_SDL_RenderDrawLinesF _SDL_RenderDrawLinesF =
      _SDL_RenderDrawLinesF_ptr.asFunction<_dart_SDL_RenderDrawLinesF>();

  /// \brief Draw a rectangle on the current rendering target.
  ///
  /// \param renderer The renderer which should draw a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderDrawRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderDrawRectF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawRectF>>(
          'SDL_RenderDrawRectF');
  late final _dart_SDL_RenderDrawRectF _SDL_RenderDrawRectF =
      _SDL_RenderDrawRectF_ptr.asFunction<_dart_SDL_RenderDrawRectF>();

  /// \brief Draw some number of rectangles on the current rendering target.
  ///
  /// \param renderer The renderer which should draw multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderDrawRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderDrawRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderDrawRectsF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderDrawRectsF>>(
          'SDL_RenderDrawRectsF');
  late final _dart_SDL_RenderDrawRectsF _SDL_RenderDrawRectsF =
      _SDL_RenderDrawRectsF_ptr.asFunction<_dart_SDL_RenderDrawRectsF>();

  /// \brief Fill a rectangle on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill a rectangle.
  /// \param rect A pointer to the destination rectangle, or NULL for the entire
  /// rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRectF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rect,
  ) {
    return _SDL_RenderFillRectF(
      renderer,
      rect,
    );
  }

  late final _SDL_RenderFillRectF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderFillRectF>>(
          'SDL_RenderFillRectF');
  late final _dart_SDL_RenderFillRectF _SDL_RenderFillRectF =
      _SDL_RenderFillRectF_ptr.asFunction<_dart_SDL_RenderFillRectF>();

  /// \brief Fill some number of rectangles on the current rendering target with the drawing color.
  ///
  /// \param renderer The renderer which should fill multiple rectangles.
  /// \param rects A pointer to an array of destination rectangles.
  /// \param count The number of rectangles.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderFillRectsF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_FRect> rects,
    int count,
  ) {
    return _SDL_RenderFillRectsF(
      renderer,
      rects,
      count,
    );
  }

  late final _SDL_RenderFillRectsF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderFillRectsF>>(
          'SDL_RenderFillRectsF');
  late final _dart_SDL_RenderFillRectsF _SDL_RenderFillRectsF =
      _SDL_RenderFillRectsF_ptr.asFunction<_dart_SDL_RenderFillRectsF>();

  /// \brief Copy a portion of the texture to the current rendering target.
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopyF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
  ) {
    return _SDL_RenderCopyF(
      renderer,
      texture,
      srcrect,
      dstrect,
    );
  }

  late final _SDL_RenderCopyF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderCopyF>>('SDL_RenderCopyF');
  late final _dart_SDL_RenderCopyF _SDL_RenderCopyF =
      _SDL_RenderCopyF_ptr.asFunction<_dart_SDL_RenderCopyF>();

  /// \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
  ///
  /// \param renderer The renderer which should copy parts of a texture.
  /// \param texture The source texture.
  /// \param srcrect   A pointer to the source rectangle, or NULL for the entire
  /// texture.
  /// \param dstrect   A pointer to the destination rectangle, or NULL for the
  /// entire rendering target.
  /// \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction
  /// \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).
  /// \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
  ///
  /// \return 0 on success, or -1 on error
  int SDL_RenderCopyExF(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<SDL_Rect> srcrect,
    ffi.Pointer<SDL_FRect> dstrect,
    double angle,
    ffi.Pointer<SDL_FPoint> center,
    int flip,
  ) {
    return _SDL_RenderCopyExF(
      renderer,
      texture,
      srcrect,
      dstrect,
      angle,
      center,
      flip,
    );
  }

  late final _SDL_RenderCopyExF_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderCopyExF>>('SDL_RenderCopyExF');
  late final _dart_SDL_RenderCopyExF _SDL_RenderCopyExF =
      _SDL_RenderCopyExF_ptr.asFunction<_dart_SDL_RenderCopyExF>();

  /// \brief Read pixels from the current rendering target.
  ///
  /// \param renderer The renderer from which pixels should be read.
  /// \param rect   A pointer to the rectangle to read, or NULL for the entire
  /// render target.
  /// \param format The desired format of the pixel data, or 0 to use the format
  /// of the rendering target
  /// \param pixels A pointer to be filled in with the pixel data
  /// \param pitch  The pitch of the pixels parameter.
  ///
  /// \return 0 on success, or -1 if pixel reading is not supported.
  ///
  /// \warning This is a very slow operation, and should not be used frequently.
  int SDL_RenderReadPixels(
    ffi.Pointer<SDL_Renderer> renderer,
    ffi.Pointer<SDL_Rect> rect,
    int format,
    ffi.Pointer<ffi.Void> pixels,
    int pitch,
  ) {
    return _SDL_RenderReadPixels(
      renderer,
      rect,
      format,
      pixels,
      pitch,
    );
  }

  late final _SDL_RenderReadPixels_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderReadPixels>>(
          'SDL_RenderReadPixels');
  late final _dart_SDL_RenderReadPixels _SDL_RenderReadPixels =
      _SDL_RenderReadPixels_ptr.asFunction<_dart_SDL_RenderReadPixels>();

  /// \brief Update the screen with rendering performed.
  void SDL_RenderPresent(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderPresent(
      renderer,
    );
  }

  late final _SDL_RenderPresent_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderPresent>>('SDL_RenderPresent');
  late final _dart_SDL_RenderPresent _SDL_RenderPresent =
      _SDL_RenderPresent_ptr.asFunction<_dart_SDL_RenderPresent>();

  /// \brief Destroy the specified texture.
  ///
  /// \sa SDL_CreateTexture()
  /// \sa SDL_CreateTextureFromSurface()
  void SDL_DestroyTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_DestroyTexture(
      texture,
    );
  }

  late final _SDL_DestroyTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DestroyTexture>>('SDL_DestroyTexture');
  late final _dart_SDL_DestroyTexture _SDL_DestroyTexture =
      _SDL_DestroyTexture_ptr.asFunction<_dart_SDL_DestroyTexture>();

  /// \brief Destroy the rendering context for a window and free associated
  /// textures.
  ///
  /// \sa SDL_CreateRenderer()
  void SDL_DestroyRenderer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_DestroyRenderer(
      renderer,
    );
  }

  late final _SDL_DestroyRenderer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DestroyRenderer>>(
          'SDL_DestroyRenderer');
  late final _dart_SDL_DestroyRenderer _SDL_DestroyRenderer =
      _SDL_DestroyRenderer_ptr.asFunction<_dart_SDL_DestroyRenderer>();

  /// \brief Force the rendering context to flush any pending commands to the
  /// underlying rendering API.
  ///
  /// You do not need to (and in fact, shouldn't) call this function unless
  /// you are planning to call into OpenGL/Direct3D/Metal/whatever directly
  /// in addition to using an SDL_Renderer.
  ///
  /// This is for a very-specific case: if you are using SDL's render API,
  /// you asked for a specific renderer backend (OpenGL, Direct3D, etc),
  /// you set SDL_HINT_RENDER_BATCHING to "1", and you plan to make
  /// OpenGL/D3D/whatever calls in addition to SDL render API calls. If all of
  /// this applies, you should call SDL_RenderFlush() between calls to SDL's
  /// render API and the low-level API you're using in cooperation.
  ///
  /// In all other cases, you can ignore this function. This is only here to
  /// get maximum performance out of a specific situation. In all other cases,
  /// SDL will do the right thing, perhaps at a performance loss.
  ///
  /// This function is first available in SDL 2.0.10, and is not needed in
  /// 2.0.9 and earlier, as earlier versions did not queue rendering commands
  /// at all, instead flushing them to the OS immediately.
  int SDL_RenderFlush(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderFlush(
      renderer,
    );
  }

  late final _SDL_RenderFlush_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderFlush>>('SDL_RenderFlush');
  late final _dart_SDL_RenderFlush _SDL_RenderFlush =
      _SDL_RenderFlush_ptr.asFunction<_dart_SDL_RenderFlush>();

  /// \brief Bind the texture to the current OpenGL/ES/ES2 context for use with
  /// OpenGL instructions.
  ///
  /// \param texture  The SDL texture to bind
  /// \param texw     A pointer to a float that will be filled with the texture width
  /// \param texh     A pointer to a float that will be filled with the texture height
  ///
  /// \return 0 on success, or -1 if the operation is not supported
  int SDL_GL_BindTexture(
    ffi.Pointer<SDL_Texture> texture,
    ffi.Pointer<ffi.Float> texw,
    ffi.Pointer<ffi.Float> texh,
  ) {
    return _SDL_GL_BindTexture(
      texture,
      texw,
      texh,
    );
  }

  late final _SDL_GL_BindTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_BindTexture>>('SDL_GL_BindTexture');
  late final _dart_SDL_GL_BindTexture _SDL_GL_BindTexture =
      _SDL_GL_BindTexture_ptr.asFunction<_dart_SDL_GL_BindTexture>();

  /// \brief Unbind a texture from the current OpenGL/ES/ES2 context.
  ///
  /// \param texture  The SDL texture to unbind
  ///
  /// \return 0 on success, or -1 if the operation is not supported
  int SDL_GL_UnbindTexture(
    ffi.Pointer<SDL_Texture> texture,
  ) {
    return _SDL_GL_UnbindTexture(
      texture,
    );
  }

  late final _SDL_GL_UnbindTexture_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GL_UnbindTexture>>(
          'SDL_GL_UnbindTexture');
  late final _dart_SDL_GL_UnbindTexture _SDL_GL_UnbindTexture =
      _SDL_GL_UnbindTexture_ptr.asFunction<_dart_SDL_GL_UnbindTexture>();

  /// \brief Get the CAMetalLayer associated with the given Metal renderer
  ///
  /// \param renderer The renderer to query
  ///
  /// \return CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer
  ///
  /// \sa SDL_RenderGetMetalCommandEncoder()
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalLayer(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalLayer(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalLayer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetMetalLayer>>(
          'SDL_RenderGetMetalLayer');
  late final _dart_SDL_RenderGetMetalLayer _SDL_RenderGetMetalLayer =
      _SDL_RenderGetMetalLayer_ptr.asFunction<_dart_SDL_RenderGetMetalLayer>();

  /// \brief Get the Metal command encoder for the current frame
  ///
  /// \param renderer The renderer to query
  ///
  /// \return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer
  ///
  /// \sa SDL_RenderGetMetalLayer()
  ffi.Pointer<ffi.Void> SDL_RenderGetMetalCommandEncoder(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetMetalCommandEncoder(
      renderer,
    );
  }

  late final _SDL_RenderGetMetalCommandEncoder_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetMetalCommandEncoder>>(
          'SDL_RenderGetMetalCommandEncoder');
  late final _dart_SDL_RenderGetMetalCommandEncoder
      _SDL_RenderGetMetalCommandEncoder = _SDL_RenderGetMetalCommandEncoder_ptr
          .asFunction<_dart_SDL_RenderGetMetalCommandEncoder>();

  /// \brief Create a window that can be shaped with the specified position, dimensions, and flags.
  ///
  /// \param title The title of the window, in UTF-8 encoding.
  /// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
  /// ::SDL_WINDOWPOS_UNDEFINED.
  /// \param w     The width of the window.
  /// \param h     The height of the window.
  /// \param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:
  /// ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,
  /// ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,
  /// ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,
  /// ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset.
  ///
  /// \return The window created, or NULL if window creation failed.
  ///
  /// \sa SDL_DestroyWindow()
  ffi.Pointer<SDL_Window> SDL_CreateShapedWindow(
    ffi.Pointer<ffi.Int8> title,
    int x,
    int y,
    int w,
    int h,
    int flags,
  ) {
    return _SDL_CreateShapedWindow(
      title,
      x,
      y,
      w,
      h,
      flags,
    );
  }

  late final _SDL_CreateShapedWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_CreateShapedWindow>>(
          'SDL_CreateShapedWindow');
  late final _dart_SDL_CreateShapedWindow _SDL_CreateShapedWindow =
      _SDL_CreateShapedWindow_ptr.asFunction<_dart_SDL_CreateShapedWindow>();

  /// \brief Return whether the given window is a shaped window.
  ///
  /// \param window The window to query for being shaped.
  ///
  /// \return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL.
  ///
  /// \sa SDL_CreateShapedWindow
  int SDL_IsShapedWindow(
    ffi.Pointer<SDL_Window> window,
  ) {
    return _SDL_IsShapedWindow(
      window,
    );
  }

  late final _SDL_IsShapedWindow_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IsShapedWindow>>('SDL_IsShapedWindow');
  late final _dart_SDL_IsShapedWindow _SDL_IsShapedWindow =
      _SDL_IsShapedWindow_ptr.asFunction<_dart_SDL_IsShapedWindow>();

  /// \brief Set the shape and parameters of a shaped window.
  ///
  /// \param window The shaped window whose parameters should be set.
  /// \param shape A surface encoding the desired shape for the window.
  /// \param shape_mode The parameters to set for the shaped window.
  ///
  /// \return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW
  /// if the SDL_Window given does not reference a valid shaped window.
  ///
  /// \sa SDL_WindowShapeMode
  /// \sa SDL_GetShapedWindowMode.
  int SDL_SetWindowShape(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_Surface> shape,
    ffi.Pointer<SDL_WindowShapeMode> shape_mode,
  ) {
    return _SDL_SetWindowShape(
      window,
      shape,
      shape_mode,
    );
  }

  late final _SDL_SetWindowShape_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowShape>>('SDL_SetWindowShape');
  late final _dart_SDL_SetWindowShape _SDL_SetWindowShape =
      _SDL_SetWindowShape_ptr.asFunction<_dart_SDL_SetWindowShape>();

  /// \brief Get the shape parameters of a shaped window.
  ///
  /// \param window The shaped window whose parameters should be retrieved.
  /// \param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape.
  ///
  /// \return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode
  /// data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if
  /// the SDL_Window given is a shapeable window currently lacking a shape.
  ///
  /// \sa SDL_WindowShapeMode
  /// \sa SDL_SetWindowShape
  int SDL_GetShapedWindowMode(
    ffi.Pointer<SDL_Window> window,
    ffi.Pointer<SDL_WindowShapeMode> shape_mode,
  ) {
    return _SDL_GetShapedWindowMode(
      window,
      shape_mode,
    );
  }

  late final _SDL_GetShapedWindowMode_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetShapedWindowMode>>(
          'SDL_GetShapedWindowMode');
  late final _dart_SDL_GetShapedWindowMode _SDL_GetShapedWindowMode =
      _SDL_GetShapedWindowMode_ptr.asFunction<_dart_SDL_GetShapedWindowMode>();

  void SDL_SetWindowsMessageHook(
    ffi.Pointer<ffi.NativeFunction<SDL_WindowsMessageHook>> callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _SDL_SetWindowsMessageHook(
      callback,
      userdata,
    );
  }

  late final _SDL_SetWindowsMessageHook_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_SetWindowsMessageHook>>(
          'SDL_SetWindowsMessageHook');
  late final _dart_SDL_SetWindowsMessageHook _SDL_SetWindowsMessageHook =
      _SDL_SetWindowsMessageHook_ptr.asFunction<
          _dart_SDL_SetWindowsMessageHook>();

  /// \brief Returns the D3D9 adapter index that matches the specified display index.
  ///
  /// This adapter index can be passed to IDirect3D9::CreateDevice and controls
  /// on which monitor a full screen application will appear.
  int SDL_Direct3D9GetAdapterIndex(
    int displayIndex,
  ) {
    return _SDL_Direct3D9GetAdapterIndex(
      displayIndex,
    );
  }

  late final _SDL_Direct3D9GetAdapterIndex_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Direct3D9GetAdapterIndex>>(
          'SDL_Direct3D9GetAdapterIndex');
  late final _dart_SDL_Direct3D9GetAdapterIndex _SDL_Direct3D9GetAdapterIndex =
      _SDL_Direct3D9GetAdapterIndex_ptr.asFunction<
          _dart_SDL_Direct3D9GetAdapterIndex>();

  /// \brief Returns the D3D device associated with a renderer, or NULL if it's not a D3D renderer.
  ///
  /// Once you are done using the device, you should release it to avoid a resource leak.
  ffi.Pointer<IDirect3DDevice9> SDL_RenderGetD3D9Device(
    ffi.Pointer<SDL_Renderer> renderer,
  ) {
    return _SDL_RenderGetD3D9Device(
      renderer,
    );
  }

  late final _SDL_RenderGetD3D9Device_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RenderGetD3D9Device>>(
          'SDL_RenderGetD3D9Device');
  late final _dart_SDL_RenderGetD3D9Device _SDL_RenderGetD3D9Device =
      _SDL_RenderGetD3D9Device_ptr.asFunction<_dart_SDL_RenderGetD3D9Device>();

  /// \brief Returns the DXGI Adapter and Output indices for the specified display index.
  ///
  /// These can be passed to EnumAdapters and EnumOutputs respectively to get the objects
  /// required to create a DX10 or DX11 device and swap chain.
  int SDL_DXGIGetOutputInfo(
    int displayIndex,
    ffi.Pointer<ffi.Int32> adapterIndex,
    ffi.Pointer<ffi.Int32> outputIndex,
  ) {
    return _SDL_DXGIGetOutputInfo(
      displayIndex,
      adapterIndex,
      outputIndex,
    );
  }

  late final _SDL_DXGIGetOutputInfo_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_DXGIGetOutputInfo>>(
          'SDL_DXGIGetOutputInfo');
  late final _dart_SDL_DXGIGetOutputInfo _SDL_DXGIGetOutputInfo =
      _SDL_DXGIGetOutputInfo_ptr.asFunction<_dart_SDL_DXGIGetOutputInfo>();

  /// \brief Return true if the current device is a tablet.
  int SDL_IsTablet() {
    return _SDL_IsTablet();
  }

  late final _SDL_IsTablet_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_IsTablet>>('SDL_IsTablet');
  late final _dart_SDL_IsTablet _SDL_IsTablet =
      _SDL_IsTablet_ptr.asFunction<_dart_SDL_IsTablet>();

  void SDL_OnApplicationWillTerminate() {
    return _SDL_OnApplicationWillTerminate();
  }

  late final _SDL_OnApplicationWillTerminate_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OnApplicationWillTerminate>>(
          'SDL_OnApplicationWillTerminate');
  late final _dart_SDL_OnApplicationWillTerminate
      _SDL_OnApplicationWillTerminate = _SDL_OnApplicationWillTerminate_ptr
          .asFunction<_dart_SDL_OnApplicationWillTerminate>();

  void SDL_OnApplicationDidReceiveMemoryWarning() {
    return _SDL_OnApplicationDidReceiveMemoryWarning();
  }

  late final _SDL_OnApplicationDidReceiveMemoryWarning_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OnApplicationDidReceiveMemoryWarning>>(
          'SDL_OnApplicationDidReceiveMemoryWarning');
  late final _dart_SDL_OnApplicationDidReceiveMemoryWarning
      _SDL_OnApplicationDidReceiveMemoryWarning =
      _SDL_OnApplicationDidReceiveMemoryWarning_ptr.asFunction<
          _dart_SDL_OnApplicationDidReceiveMemoryWarning>();

  void SDL_OnApplicationWillResignActive() {
    return _SDL_OnApplicationWillResignActive();
  }

  late final _SDL_OnApplicationWillResignActive_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OnApplicationWillResignActive>>(
          'SDL_OnApplicationWillResignActive');
  late final _dart_SDL_OnApplicationWillResignActive
      _SDL_OnApplicationWillResignActive =
      _SDL_OnApplicationWillResignActive_ptr.asFunction<
          _dart_SDL_OnApplicationWillResignActive>();

  void SDL_OnApplicationDidEnterBackground() {
    return _SDL_OnApplicationDidEnterBackground();
  }

  late final _SDL_OnApplicationDidEnterBackground_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OnApplicationDidEnterBackground>>(
          'SDL_OnApplicationDidEnterBackground');
  late final _dart_SDL_OnApplicationDidEnterBackground
      _SDL_OnApplicationDidEnterBackground =
      _SDL_OnApplicationDidEnterBackground_ptr.asFunction<
          _dart_SDL_OnApplicationDidEnterBackground>();

  void SDL_OnApplicationWillEnterForeground() {
    return _SDL_OnApplicationWillEnterForeground();
  }

  late final _SDL_OnApplicationWillEnterForeground_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OnApplicationWillEnterForeground>>(
          'SDL_OnApplicationWillEnterForeground');
  late final _dart_SDL_OnApplicationWillEnterForeground
      _SDL_OnApplicationWillEnterForeground =
      _SDL_OnApplicationWillEnterForeground_ptr.asFunction<
          _dart_SDL_OnApplicationWillEnterForeground>();

  void SDL_OnApplicationDidBecomeActive() {
    return _SDL_OnApplicationDidBecomeActive();
  }

  late final _SDL_OnApplicationDidBecomeActive_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OnApplicationDidBecomeActive>>(
          'SDL_OnApplicationDidBecomeActive');
  late final _dart_SDL_OnApplicationDidBecomeActive
      _SDL_OnApplicationDidBecomeActive = _SDL_OnApplicationDidBecomeActive_ptr
          .asFunction<_dart_SDL_OnApplicationDidBecomeActive>();

  /// \brief Get the number of milliseconds since the SDL library initialization.
  ///
  /// \note This value wraps if the program runs for more than ~49 days.
  int SDL_GetTicks() {
    return _SDL_GetTicks();
  }

  late final _SDL_GetTicks_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetTicks>>('SDL_GetTicks');
  late final _dart_SDL_GetTicks _SDL_GetTicks =
      _SDL_GetTicks_ptr.asFunction<_dart_SDL_GetTicks>();

  /// \brief Get the current value of the high resolution counter
  int SDL_GetPerformanceCounter() {
    return _SDL_GetPerformanceCounter();
  }

  late final _SDL_GetPerformanceCounter_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPerformanceCounter>>(
          'SDL_GetPerformanceCounter');
  late final _dart_SDL_GetPerformanceCounter _SDL_GetPerformanceCounter =
      _SDL_GetPerformanceCounter_ptr.asFunction<
          _dart_SDL_GetPerformanceCounter>();

  /// \brief Get the count per second of the high resolution counter
  int SDL_GetPerformanceFrequency() {
    return _SDL_GetPerformanceFrequency();
  }

  late final _SDL_GetPerformanceFrequency_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPerformanceFrequency>>(
          'SDL_GetPerformanceFrequency');
  late final _dart_SDL_GetPerformanceFrequency _SDL_GetPerformanceFrequency =
      _SDL_GetPerformanceFrequency_ptr.asFunction<
          _dart_SDL_GetPerformanceFrequency>();

  /// \brief Wait a specified number of milliseconds before returning.
  void SDL_Delay(
    int ms,
  ) {
    return _SDL_Delay(
      ms,
    );
  }

  late final _SDL_Delay_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Delay>>('SDL_Delay');
  late final _dart_SDL_Delay _SDL_Delay =
      _SDL_Delay_ptr.asFunction<_dart_SDL_Delay>();

  /// \brief Add a new timer to the pool of timers already running.
  ///
  /// \return A timer ID, or 0 when an error occurs.
  int SDL_AddTimer(
    int interval,
    ffi.Pointer<ffi.NativeFunction<SDL_TimerCallback>> callback,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _SDL_AddTimer(
      interval,
      callback,
      param,
    );
  }

  late final _SDL_AddTimer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_AddTimer>>('SDL_AddTimer');
  late final _dart_SDL_AddTimer _SDL_AddTimer =
      _SDL_AddTimer_ptr.asFunction<_dart_SDL_AddTimer>();

  /// \brief Remove a timer knowing its ID.
  ///
  /// \return A boolean value indicating success or failure.
  ///
  /// \warning It is not safe to remove a timer multiple times.
  int SDL_RemoveTimer(
    int id,
  ) {
    return _SDL_RemoveTimer(
      id,
    );
  }

  late final _SDL_RemoveTimer_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_RemoveTimer>>('SDL_RemoveTimer');
  late final _dart_SDL_RemoveTimer _SDL_RemoveTimer =
      _SDL_RemoveTimer_ptr.asFunction<_dart_SDL_RemoveTimer>();

  /// \brief Get the version of SDL that is linked against your program.
  ///
  /// If you are linking to SDL dynamically, then it is possible that the
  /// current version will be different than the version you compiled against.
  /// This function returns the current version, while SDL_VERSION() is a
  /// macro that tells you what version you compiled with.
  ///
  /// \code
  /// SDL_version compiled;
  /// SDL_version linked;
  ///
  /// SDL_VERSION(&compiled);
  /// SDL_GetVersion(&linked);
  /// printf("We compiled against SDL version %d.%d.%d ...\n",
  /// compiled.major, compiled.minor, compiled.patch);
  /// printf("But we linked against SDL version %d.%d.%d.\n",
  /// linked.major, linked.minor, linked.patch);
  /// \endcode
  ///
  /// This function may be called safely at any time, even before SDL_Init().
  ///
  /// \sa SDL_VERSION
  void SDL_GetVersion(
    ffi.Pointer<SDL_version> ver,
  ) {
    return _SDL_GetVersion(
      ver,
    );
  }

  late final _SDL_GetVersion_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetVersion>>('SDL_GetVersion');
  late final _dart_SDL_GetVersion _SDL_GetVersion =
      _SDL_GetVersion_ptr.asFunction<_dart_SDL_GetVersion>();

  /// \brief Get the code revision of SDL that is linked against your program.
  ///
  /// Returns an arbitrary string (a hash value) uniquely identifying the
  /// exact revision of the SDL library in use, and is only useful in comparing
  /// against other revisions. It is NOT an incrementing number.
  ffi.Pointer<ffi.Int8> SDL_GetRevision() {
    return _SDL_GetRevision();
  }

  late final _SDL_GetRevision_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRevision>>('SDL_GetRevision');
  late final _dart_SDL_GetRevision _SDL_GetRevision =
      _SDL_GetRevision_ptr.asFunction<_dart_SDL_GetRevision>();

  /// \brief Get the revision number of SDL that is linked against your program.
  ///
  /// Returns a number uniquely identifying the exact revision of the SDL
  /// library in use. It is an incrementing number based on commits to
  /// hg.libsdl.org.
  int SDL_GetRevisionNumber() {
    return _SDL_GetRevisionNumber();
  }

  late final _SDL_GetRevisionNumber_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetRevisionNumber>>(
          'SDL_GetRevisionNumber');
  late final _dart_SDL_GetRevisionNumber _SDL_GetRevisionNumber =
      _SDL_GetRevisionNumber_ptr.asFunction<_dart_SDL_GetRevisionNumber>();

  /// \brief Report the user's preferred locale.
  ///
  /// This returns an array of SDL_Locale structs, the final item zeroed out.
  /// When the caller is done with this array, it should call SDL_free() on
  /// the returned value; all the memory involved is allocated in a single
  /// block, so a single SDL_free() will suffice.
  ///
  /// Returned language strings are in the format xx, where 'xx' is an ISO-639
  /// language specifier (such as "en" for English, "de" for German, etc).
  /// Country strings are in the format YY, where "YY" is an ISO-3166 country
  /// code (such as "US" for the United States, "CA" for Canada, etc). Country
  /// might be NULL if there's no specific guidance on them (so you might get
  /// { "en", "US" } for American English, but { "en", NULL } means "English
  /// language, generically"). Language strings are never NULL, except to
  /// terminate the array.
  ///
  /// Please note that not all of these strings are 2 characters; some are
  /// three or more.
  ///
  /// The returned list of locales are in the order of the user's preference.
  /// For example, a German citizen that is fluent in US English and knows
  /// enough Japanese to navigate around Tokyo might have a list like:
  /// { "de", "en_US", "jp", NULL }. Someone from England might prefer British
  /// English (where "color" is spelled "colour", etc), but will settle for
  /// anything like it: { "en_GB", "en", NULL }.
  ///
  /// This function returns NULL on error, including when the platform does not
  /// supply this information at all.
  ///
  /// This might be a "slow" call that has to query the operating system. It's
  /// best to ask for this once and save the results. However, this list can
  /// change, usually because the user has changed a system preference outside
  /// of your program; SDL will send an SDL_LOCALECHANGED event in this case,
  /// if possible, and you can call this function again to get an updated copy
  /// of preferred locales.
  ///
  /// \return array of locales, terminated with a locale with a NULL language
  /// field. Will return NULL on error.
  ffi.Pointer<SDL_Locale> SDL_GetPreferredLocales() {
    return _SDL_GetPreferredLocales();
  }

  late final _SDL_GetPreferredLocales_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_GetPreferredLocales>>(
          'SDL_GetPreferredLocales');
  late final _dart_SDL_GetPreferredLocales _SDL_GetPreferredLocales =
      _SDL_GetPreferredLocales_ptr.asFunction<_dart_SDL_GetPreferredLocales>();

  /// \brief Open an URL / URI in the browser or other
  ///
  /// Open a URL in a separate, system-provided application. How this works will
  /// vary wildly depending on the platform. This will likely launch what
  /// makes sense to handle a specific URL's protocol (a web browser for http://,
  /// etc), but it might also be able to launch file managers for directories
  /// and other things.
  ///
  /// What happens when you open a URL varies wildly as well: your game window
  /// may lose focus (and may or may not lose focus if your game was fullscreen
  /// or grabbing input at the time). On mobile devices, your app will likely
  /// move to the background or your process might be paused. Any given platform
  /// may or may not handle a given URL.
  ///
  /// If this is unimplemented (or simply unavailable) for a platform, this will
  /// fail with an error. A successful result does not mean the URL loaded, just
  /// that we launched something to handle it (or at least believe we did).
  ///
  /// All this to say: this function can be useful, but you should definitely
  /// test it on every platform you target.
  ///
  /// \param url A valid URL to open.
  /// \return 0 on success, or -1 on error.
  int SDL_OpenURL(
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _SDL_OpenURL(
      url,
    );
  }

  late final _SDL_OpenURL_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_OpenURL>>('SDL_OpenURL');
  late final _dart_SDL_OpenURL _SDL_OpenURL =
      _SDL_OpenURL_ptr.asFunction<_dart_SDL_OpenURL>();

  /// This function initializes  the subsystems specified by \c flags
  int SDL_Init(
    int flags,
  ) {
    return _SDL_Init(
      flags,
    );
  }

  late final _SDL_Init_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Init>>('SDL_Init');
  late final _dart_SDL_Init _SDL_Init =
      _SDL_Init_ptr.asFunction<_dart_SDL_Init>();

  /// This function initializes specific SDL subsystems
  ///
  /// Subsystem initialization is ref-counted, you must call
  /// SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly
  /// shutdown a subsystem manually (or call SDL_Quit() to force shutdown).
  /// If a subsystem is already loaded then this call will
  /// increase the ref-count and return.
  int SDL_InitSubSystem(
    int flags,
  ) {
    return _SDL_InitSubSystem(
      flags,
    );
  }

  late final _SDL_InitSubSystem_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_InitSubSystem>>('SDL_InitSubSystem');
  late final _dart_SDL_InitSubSystem _SDL_InitSubSystem =
      _SDL_InitSubSystem_ptr.asFunction<_dart_SDL_InitSubSystem>();

  /// This function cleans up specific SDL subsystems
  void SDL_QuitSubSystem(
    int flags,
  ) {
    return _SDL_QuitSubSystem(
      flags,
    );
  }

  late final _SDL_QuitSubSystem_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_QuitSubSystem>>('SDL_QuitSubSystem');
  late final _dart_SDL_QuitSubSystem _SDL_QuitSubSystem =
      _SDL_QuitSubSystem_ptr.asFunction<_dart_SDL_QuitSubSystem>();

  /// This function returns a mask of the specified subsystems which have
  /// previously been initialized.
  ///
  /// If \c flags is 0, it returns a mask of all initialized subsystems.
  int SDL_WasInit(
    int flags,
  ) {
    return _SDL_WasInit(
      flags,
    );
  }

  late final _SDL_WasInit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_WasInit>>('SDL_WasInit');
  late final _dart_SDL_WasInit _SDL_WasInit =
      _SDL_WasInit_ptr.asFunction<_dart_SDL_WasInit>();

  /// This function cleans up all initialized subsystems. You should
  /// call it upon all exit conditions.
  void SDL_Quit() {
    return _SDL_Quit();
  }

  late final _SDL_Quit_ptr =
      _lookup<ffi.NativeFunction<_c_SDL_Quit>>('SDL_Quit');
  late final _dart_SDL_Quit _SDL_Quit =
      _SDL_Quit_ptr.asFunction<_dart_SDL_Quit>();
}

class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> _locale_pctype;

  @ffi.Int32()
  external int _locale_mb_cur_max;

  @ffi.Uint32()
  external int _locale_lc_codepage;
}

class __crt_locale_data extends ffi.Opaque {}

class __crt_multibyte_data extends ffi.Opaque {}

class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

class _Mbstatet extends ffi.Struct {
  @ffi.Uint64()
  external int _Wchar;

  @ffi.Uint16()
  external int _Byte;

  @ffi.Uint16()
  external int _State;
}

abstract class SDL_bool {
  static const int SDL_FALSE = 0;
  static const int SDL_TRUE = 1;
}

abstract class SDL_DUMMY_ENUM {
  static const int DUMMY_ENUM_VALUE = 0;
}

class _SDL_iconv_t extends ffi.Opaque {}

abstract class SDL_AssertState {
  /// < Retry the assert immediately.
  static const int SDL_ASSERTION_RETRY = 0;

  /// < Make the debugger trigger a breakpoint.
  static const int SDL_ASSERTION_BREAK = 1;

  /// < Terminate the program.
  static const int SDL_ASSERTION_ABORT = 2;

  /// < Ignore the assert.
  static const int SDL_ASSERTION_IGNORE = 3;

  /// < Ignore the assert from now on.
  static const int SDL_ASSERTION_ALWAYS_IGNORE = 4;
}

class SDL_AssertData extends ffi.Struct {
  @ffi.Int32()
  external int always_ignore;

  @ffi.Uint32()
  external int trigger_count;

  external ffi.Pointer<ffi.Int8> condition;

  external ffi.Pointer<ffi.Int8> filename;

  @ffi.Int32()
  external int linenum;

  external ffi.Pointer<ffi.Int8> function;

  external ffi.Pointer<SDL_AssertData> next;
}

/// \brief A type representing an atomic integer value.  It is a struct
/// so people don't accidentally use numeric operations on it.
class SDL_atomic_t extends ffi.Struct {
  @ffi.Int32()
  external int value;
}

abstract class SDL_errorcode {
  static const int SDL_ENOMEM = 0;
  static const int SDL_EFREAD = 1;
  static const int SDL_EFWRITE = 2;
  static const int SDL_EFSEEK = 3;
  static const int SDL_UNSUPPORTED = 4;
  static const int SDL_LASTERROR = 5;
}

class SDL_mutex extends ffi.Opaque {}

class SDL_semaphore extends ffi.Opaque {}

class SDL_cond extends ffi.Opaque {}

class SDL_Thread extends ffi.Opaque {}

/// The SDL thread priority.
///
/// SDL will make system changes as necessary in order to apply the thread priority.
/// Code which attempts to control thread state related to priority should be aware
/// that calling SDL_SetThreadPriority may alter such state.
/// SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.
///
/// \note On many systems you require special privileges to set high or time critical priority.
abstract class SDL_ThreadPriority {
  static const int SDL_THREAD_PRIORITY_LOW = 0;
  static const int SDL_THREAD_PRIORITY_NORMAL = 1;
  static const int SDL_THREAD_PRIORITY_HIGH = 2;
  static const int SDL_THREAD_PRIORITY_TIME_CRITICAL = 3;
}

class _exception extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external ffi.Pointer<ffi.Int8> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

class _complex extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

abstract class _crt_argv_mode {
  static const int _crt_argv_no_arguments = 0;
  static const int _crt_argv_unexpanded_arguments = 1;
  static const int _crt_argv_expanded_arguments = 2;
}

abstract class _crt_exit_return_mode {
  static const int _crt_exit_terminate_process = 0;
  static const int _crt_exit_return_to_caller = 1;
}

abstract class _crt_exit_cleanup_mode {
  static const int _crt_exit_full_cleanup = 0;
  static const int _crt_exit_quick_cleanup = 1;
  static const int _crt_exit_no_cleanup = 2;
}

class _EXCEPTION_POINTERS extends ffi.Opaque {}

abstract class _crt_app_type {
  static const int _crt_unknown_app = 0;
  static const int _crt_console_app = 1;
  static const int _crt_gui_app = 2;
}

class _onexit_table_t extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _first;

  external ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _last;

  external ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _end;
}

/// This is the read/write operation structure -- very basic.
class SDL_RWops extends ffi.Opaque {}

/// The calculated values in this structure are calculated by SDL_OpenAudio().
///
/// For multi-channel audio, the default SDL channel mapping is:
/// 2:  FL FR                       (stereo)
/// 3:  FL FR LFE                   (2.1 surround)
/// 4:  FL FR BL BR                 (quad)
/// 5:  FL FR FC BL BR              (quad + center)
/// 6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)
/// 7:  FL FR FC LFE BC SL SR       (6.1 surround)
/// 8:  FL FR FC LFE BL BR SL SR    (7.1 surround)
class SDL_AudioSpec extends ffi.Struct {
  /// < DSP frequency -- samples per second
  @ffi.Int32()
  external int freq;

  /// < Audio data format
  @ffi.Uint16()
  external int format;

  /// < Number of channels: 1 mono, 2 stereo
  @ffi.Uint8()
  external int channels;

  /// < Audio buffer silence value (calculated)
  @ffi.Uint8()
  external int silence;

  /// < Audio buffer size in sample FRAMES (total samples divided by channel count)
  @ffi.Uint16()
  external int samples;

  /// < Necessary for some compile environments
  @ffi.Uint16()
  external int padding;

  /// < Audio buffer size in bytes (calculated)
  @ffi.Uint32()
  external int size;

  /// < Callback that feeds the audio device (NULL to use SDL_QueueAudio()).
  external ffi.Pointer<ffi.NativeFunction<SDL_AudioCallback>> callback;

  /// < Userdata passed to callback (ignored for NULL callbacks).
  external ffi.Pointer<ffi.Void> userdata;
}

class SDL_AudioCVT extends ffi.Opaque {}

abstract class SDL_AudioStatus {
  static const int SDL_AUDIO_STOPPED = 0;
  static const int SDL_AUDIO_PLAYING = 1;
  static const int SDL_AUDIO_PAUSED = 2;
}

class _SDL_AudioStream extends ffi.Opaque {}

/// Pixel type.
abstract class SDL_PixelType {
  static const int SDL_PIXELTYPE_UNKNOWN = 0;
  static const int SDL_PIXELTYPE_INDEX1 = 1;
  static const int SDL_PIXELTYPE_INDEX4 = 2;
  static const int SDL_PIXELTYPE_INDEX8 = 3;
  static const int SDL_PIXELTYPE_PACKED8 = 4;
  static const int SDL_PIXELTYPE_PACKED16 = 5;
  static const int SDL_PIXELTYPE_PACKED32 = 6;
  static const int SDL_PIXELTYPE_ARRAYU8 = 7;
  static const int SDL_PIXELTYPE_ARRAYU16 = 8;
  static const int SDL_PIXELTYPE_ARRAYU32 = 9;
  static const int SDL_PIXELTYPE_ARRAYF16 = 10;
  static const int SDL_PIXELTYPE_ARRAYF32 = 11;
}

/// Bitmap pixel order, high bit -> low bit.
abstract class SDL_BitmapOrder {
  static const int SDL_BITMAPORDER_NONE = 0;
  static const int SDL_BITMAPORDER_4321 = 1;
  static const int SDL_BITMAPORDER_1234 = 2;
}

/// Packed component order, high bit -> low bit.
abstract class SDL_PackedOrder {
  static const int SDL_PACKEDORDER_NONE = 0;
  static const int SDL_PACKEDORDER_XRGB = 1;
  static const int SDL_PACKEDORDER_RGBX = 2;
  static const int SDL_PACKEDORDER_ARGB = 3;
  static const int SDL_PACKEDORDER_RGBA = 4;
  static const int SDL_PACKEDORDER_XBGR = 5;
  static const int SDL_PACKEDORDER_BGRX = 6;
  static const int SDL_PACKEDORDER_ABGR = 7;
  static const int SDL_PACKEDORDER_BGRA = 8;
}

/// Array component order, low byte -> high byte.
abstract class SDL_ArrayOrder {
  static const int SDL_ARRAYORDER_NONE = 0;
  static const int SDL_ARRAYORDER_RGB = 1;
  static const int SDL_ARRAYORDER_RGBA = 2;
  static const int SDL_ARRAYORDER_ARGB = 3;
  static const int SDL_ARRAYORDER_BGR = 4;
  static const int SDL_ARRAYORDER_BGRA = 5;
  static const int SDL_ARRAYORDER_ABGR = 6;
}

/// Packed component layout.
abstract class SDL_PackedLayout {
  static const int SDL_PACKEDLAYOUT_NONE = 0;
  static const int SDL_PACKEDLAYOUT_332 = 1;
  static const int SDL_PACKEDLAYOUT_4444 = 2;
  static const int SDL_PACKEDLAYOUT_1555 = 3;
  static const int SDL_PACKEDLAYOUT_5551 = 4;
  static const int SDL_PACKEDLAYOUT_565 = 5;
  static const int SDL_PACKEDLAYOUT_8888 = 6;
  static const int SDL_PACKEDLAYOUT_2101010 = 7;
  static const int SDL_PACKEDLAYOUT_1010102 = 8;
}

abstract class SDL_PixelFormatEnum {
  static const int SDL_PIXELFORMAT_UNKNOWN = 0;
  static const int SDL_PIXELFORMAT_INDEX1LSB = 286261504;
  static const int SDL_PIXELFORMAT_INDEX1MSB = 287310080;
  static const int SDL_PIXELFORMAT_INDEX4LSB = 303039488;
  static const int SDL_PIXELFORMAT_INDEX4MSB = 304088064;
  static const int SDL_PIXELFORMAT_INDEX8 = 318769153;
  static const int SDL_PIXELFORMAT_RGB332 = 336660481;
  static const int SDL_PIXELFORMAT_XRGB4444 = 353504258;
  static const int SDL_PIXELFORMAT_RGB444 = 353504258;
  static const int SDL_PIXELFORMAT_XBGR4444 = 357698562;
  static const int SDL_PIXELFORMAT_BGR444 = 357698562;
  static const int SDL_PIXELFORMAT_XRGB1555 = 353570562;
  static const int SDL_PIXELFORMAT_RGB555 = 353570562;
  static const int SDL_PIXELFORMAT_XBGR1555 = 357764866;
  static const int SDL_PIXELFORMAT_BGR555 = 357764866;
  static const int SDL_PIXELFORMAT_ARGB4444 = 355602434;
  static const int SDL_PIXELFORMAT_RGBA4444 = 356651010;
  static const int SDL_PIXELFORMAT_ABGR4444 = 359796738;
  static const int SDL_PIXELFORMAT_BGRA4444 = 360845314;
  static const int SDL_PIXELFORMAT_ARGB1555 = 355667970;
  static const int SDL_PIXELFORMAT_RGBA5551 = 356782082;
  static const int SDL_PIXELFORMAT_ABGR1555 = 359862274;
  static const int SDL_PIXELFORMAT_BGRA5551 = 360976386;
  static const int SDL_PIXELFORMAT_RGB565 = 353701890;
  static const int SDL_PIXELFORMAT_BGR565 = 357896194;
  static const int SDL_PIXELFORMAT_RGB24 = 386930691;
  static const int SDL_PIXELFORMAT_BGR24 = 390076419;
  static const int SDL_PIXELFORMAT_XRGB8888 = 370546692;
  static const int SDL_PIXELFORMAT_RGB888 = 370546692;
  static const int SDL_PIXELFORMAT_RGBX8888 = 371595268;
  static const int SDL_PIXELFORMAT_XBGR8888 = 374740996;
  static const int SDL_PIXELFORMAT_BGR888 = 374740996;
  static const int SDL_PIXELFORMAT_BGRX8888 = 375789572;
  static const int SDL_PIXELFORMAT_ARGB8888 = 372645892;
  static const int SDL_PIXELFORMAT_RGBA8888 = 373694468;
  static const int SDL_PIXELFORMAT_ABGR8888 = 376840196;
  static const int SDL_PIXELFORMAT_BGRA8888 = 377888772;
  static const int SDL_PIXELFORMAT_ARGB2101010 = 372711428;
  static const int SDL_PIXELFORMAT_RGBA32 = 376840196;
  static const int SDL_PIXELFORMAT_ARGB32 = 377888772;
  static const int SDL_PIXELFORMAT_BGRA32 = 372645892;
  static const int SDL_PIXELFORMAT_ABGR32 = 373694468;

  /// < Planar mode: Y + V + U  (3 planes)
  static const int SDL_PIXELFORMAT_YV12 = 842094169;

  /// < Planar mode: Y + U + V  (3 planes)
  static const int SDL_PIXELFORMAT_IYUV = 1448433993;

  /// < Packed mode: Y0+U0+Y1+V0 (1 plane)
  static const int SDL_PIXELFORMAT_YUY2 = 844715353;

  /// < Packed mode: U0+Y0+V0+Y1 (1 plane)
  static const int SDL_PIXELFORMAT_UYVY = 1498831189;

  /// < Packed mode: Y0+V0+Y1+U0 (1 plane)
  static const int SDL_PIXELFORMAT_YVYU = 1431918169;

  /// < Planar mode: Y + U/V interleaved  (2 planes)
  static const int SDL_PIXELFORMAT_NV12 = 842094158;

  /// < Planar mode: Y + V/U interleaved  (2 planes)
  static const int SDL_PIXELFORMAT_NV21 = 825382478;

  /// < Android video texture format
  static const int SDL_PIXELFORMAT_EXTERNAL_OES = 542328143;
}

class SDL_Color extends ffi.Struct {
  @ffi.Uint8()
  external int r;

  @ffi.Uint8()
  external int g;

  @ffi.Uint8()
  external int b;

  @ffi.Uint8()
  external int a;
}

class SDL_Palette extends ffi.Struct {
  @ffi.Int32()
  external int ncolors;

  external ffi.Pointer<SDL_Color> colors;

  @ffi.Uint32()
  external int version;

  @ffi.Int32()
  external int refcount;
}

/// \note Everything in the pixel format structure is read-only.
class SDL_PixelFormat extends ffi.Opaque {}

/// \brief  The structure that defines a point (integer)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
class SDL_Point extends ffi.Struct {
  @ffi.Int32()
  external int x;

  @ffi.Int32()
  external int y;
}

/// \brief  The structure that defines a point (floating point)
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
class SDL_FPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

/// \brief A rectangle, with the origin at the upper left (integer).
///
/// \sa SDL_RectEmpty
/// \sa SDL_RectEquals
/// \sa SDL_HasIntersection
/// \sa SDL_IntersectRect
/// \sa SDL_UnionRect
/// \sa SDL_EnclosePoints
class SDL_Rect extends ffi.Struct {
  @ffi.Int32()
  external int x;

  @ffi.Int32()
  external int y;

  @ffi.Int32()
  external int w;

  @ffi.Int32()
  external int h;
}

/// \brief A rectangle, with the origin at the upper left (floating point).
class SDL_FRect extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double w;

  @ffi.Float()
  external double h;
}

/// \brief The blend mode used in SDL_RenderCopy() and drawing operations.
abstract class SDL_BlendMode {
  /// < no blending
  /// dstRGBA = srcRGBA
  static const int SDL_BLENDMODE_NONE = 0;

  /// < alpha blending
  /// dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
  /// dstA = srcA + (dstA * (1-srcA))
  static const int SDL_BLENDMODE_BLEND = 1;

  /// < additive blending
  /// dstRGB = (srcRGB * srcA) + dstRGB
  /// dstA = dstA
  static const int SDL_BLENDMODE_ADD = 2;

  /// < color modulate
  /// dstRGB = srcRGB * dstRGB
  /// dstA = dstA
  static const int SDL_BLENDMODE_MOD = 4;

  /// < color multiply
  /// dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
  /// dstA = (srcA * dstA) + (dstA * (1-srcA))
  static const int SDL_BLENDMODE_MUL = 8;
  static const int SDL_BLENDMODE_INVALID = 2147483647;
}

/// \brief The blend operation used when combining source and destination pixel components
abstract class SDL_BlendOperation {
  /// < dst + src: supported by all renderers
  static const int SDL_BLENDOPERATION_ADD = 1;

  /// < dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES
  static const int SDL_BLENDOPERATION_SUBTRACT = 2;

  /// < src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES
  static const int SDL_BLENDOPERATION_REV_SUBTRACT = 3;

  /// < min(dst, src) : supported by D3D11
  static const int SDL_BLENDOPERATION_MINIMUM = 4;

  /// < max(dst, src) : supported by D3D11
  static const int SDL_BLENDOPERATION_MAXIMUM = 5;
}

/// \brief The normalized factor used to multiply pixel components
abstract class SDL_BlendFactor {
  /// < 0, 0, 0, 0
  static const int SDL_BLENDFACTOR_ZERO = 1;

  /// < 1, 1, 1, 1
  static const int SDL_BLENDFACTOR_ONE = 2;

  /// < srcR, srcG, srcB, srcA
  static const int SDL_BLENDFACTOR_SRC_COLOR = 3;

  /// < 1-srcR, 1-srcG, 1-srcB, 1-srcA
  static const int SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4;

  /// < srcA, srcA, srcA, srcA
  static const int SDL_BLENDFACTOR_SRC_ALPHA = 5;

  /// < 1-srcA, 1-srcA, 1-srcA, 1-srcA
  static const int SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6;

  /// < dstR, dstG, dstB, dstA
  static const int SDL_BLENDFACTOR_DST_COLOR = 7;

  /// < 1-dstR, 1-dstG, 1-dstB, 1-dstA
  static const int SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8;

  /// < dstA, dstA, dstA, dstA
  static const int SDL_BLENDFACTOR_DST_ALPHA = 9;

  /// < 1-dstA, 1-dstA, 1-dstA, 1-dstA
  static const int SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10;
}

class SDL_BlitMap extends ffi.Opaque {}

/// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
/// which, if not NULL, contains the raw pixel data for the surface.
class SDL_Surface extends ffi.Struct {
  /// < Read-only
  @ffi.Uint32()
  external int flags;

  /// < Read-only
  external ffi.Pointer<SDL_PixelFormat> format;

  /// < Read-only
  @ffi.Int32()
  external int w;

  @ffi.Int32()
  external int h;

  /// < Read-only
  @ffi.Int32()
  external int pitch;

  /// < Read-write
  external ffi.Pointer<ffi.Void> pixels;

  /// < Read-write
  external ffi.Pointer<ffi.Void> userdata;

  /// < Read-only
  @ffi.Int32()
  external int locked;

  /// < Private
  external ffi.Pointer<ffi.Void> list_blitmap;

  /// < Read-only
  external SDL_Rect clip_rect;

  /// < Private
  external ffi.Pointer<SDL_BlitMap> map;

  /// < Read-mostly
  @ffi.Int32()
  external int refcount;
}

/// \brief The formula used for converting between YUV and RGB
abstract class SDL_YUV_CONVERSION_MODE {
  /// < Full range JPEG
  static const int SDL_YUV_CONVERSION_JPEG = 0;

  /// < BT.601 (the default)
  static const int SDL_YUV_CONVERSION_BT601 = 1;

  /// < BT.709
  static const int SDL_YUV_CONVERSION_BT709 = 2;

  /// < BT.601 for SD content, BT.709 for HD content
  static const int SDL_YUV_CONVERSION_AUTOMATIC = 3;
}

/// \brief  The structure that defines a display mode
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
/// \sa SDL_GetDesktopDisplayMode()
/// \sa SDL_GetCurrentDisplayMode()
/// \sa SDL_GetClosestDisplayMode()
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode()
class SDL_DisplayMode extends ffi.Struct {
  /// < pixel format
  @ffi.Uint32()
  external int format;

  /// < width, in screen coordinates
  @ffi.Int32()
  external int w;

  /// < height, in screen coordinates
  @ffi.Int32()
  external int h;

  /// < refresh rate (or zero for unspecified)
  @ffi.Int32()
  external int refresh_rate;

  /// < driver-specific data, initialize to 0
  external ffi.Pointer<ffi.Void> driverdata;
}

class SDL_Window extends ffi.Opaque {}

/// \brief The flags on a window
///
/// \sa SDL_GetWindowFlags()
abstract class SDL_WindowFlags {
  /// < fullscreen window
  static const int SDL_WINDOW_FULLSCREEN = 1;

  /// < window usable with OpenGL context
  static const int SDL_WINDOW_OPENGL = 2;

  /// < window is visible
  static const int SDL_WINDOW_SHOWN = 4;

  /// < window is not visible
  static const int SDL_WINDOW_HIDDEN = 8;

  /// < no window decoration
  static const int SDL_WINDOW_BORDERLESS = 16;

  /// < window can be resized
  static const int SDL_WINDOW_RESIZABLE = 32;

  /// < window is minimized
  static const int SDL_WINDOW_MINIMIZED = 64;

  /// < window is maximized
  static const int SDL_WINDOW_MAXIMIZED = 128;

  /// < window has grabbed input focus
  static const int SDL_WINDOW_INPUT_GRABBED = 256;

  /// < window has input focus
  static const int SDL_WINDOW_INPUT_FOCUS = 512;

  /// < window has mouse focus
  static const int SDL_WINDOW_MOUSE_FOCUS = 1024;
  static const int SDL_WINDOW_FULLSCREEN_DESKTOP = 4097;

  /// < window not created by SDL
  static const int SDL_WINDOW_FOREIGN = 2048;

  /// < window should be created in high-DPI mode if supported.
  /// On macOS NSHighResolutionCapable must be set true in the
  /// application's Info.plist for this to have any effect.
  static const int SDL_WINDOW_ALLOW_HIGHDPI = 8192;

  /// < window has mouse captured (unrelated to INPUT_GRABBED)
  static const int SDL_WINDOW_MOUSE_CAPTURE = 16384;

  /// < window should always be above others
  static const int SDL_WINDOW_ALWAYS_ON_TOP = 32768;

  /// < window should not be added to the taskbar
  static const int SDL_WINDOW_SKIP_TASKBAR = 65536;

  /// < window should be treated as a utility window
  static const int SDL_WINDOW_UTILITY = 131072;

  /// < window should be treated as a tooltip
  static const int SDL_WINDOW_TOOLTIP = 262144;

  /// < window should be treated as a popup menu
  static const int SDL_WINDOW_POPUP_MENU = 524288;

  /// < window usable for Vulkan surface
  static const int SDL_WINDOW_VULKAN = 268435456;

  /// < window usable for Metal view
  static const int SDL_WINDOW_METAL = 536870912;
}

/// \brief Event subtype for window events
abstract class SDL_WindowEventID {
  /// < Never used
  static const int SDL_WINDOWEVENT_NONE = 0;

  /// < Window has been shown
  static const int SDL_WINDOWEVENT_SHOWN = 1;

  /// < Window has been hidden
  static const int SDL_WINDOWEVENT_HIDDEN = 2;

  /// < Window has been exposed and should be
  /// redrawn
  static const int SDL_WINDOWEVENT_EXPOSED = 3;

  /// < Window has been moved to data1, data2
  static const int SDL_WINDOWEVENT_MOVED = 4;

  /// < Window has been resized to data1xdata2
  static const int SDL_WINDOWEVENT_RESIZED = 5;

  /// < The window size has changed, either as
  /// a result of an API call or through the
  /// system or user changing the window size.
  static const int SDL_WINDOWEVENT_SIZE_CHANGED = 6;

  /// < Window has been minimized
  static const int SDL_WINDOWEVENT_MINIMIZED = 7;

  /// < Window has been maximized
  static const int SDL_WINDOWEVENT_MAXIMIZED = 8;

  /// < Window has been restored to normal size
  /// and position
  static const int SDL_WINDOWEVENT_RESTORED = 9;

  /// < Window has gained mouse focus
  static const int SDL_WINDOWEVENT_ENTER = 10;

  /// < Window has lost mouse focus
  static const int SDL_WINDOWEVENT_LEAVE = 11;

  /// < Window has gained keyboard focus
  static const int SDL_WINDOWEVENT_FOCUS_GAINED = 12;

  /// < Window has lost keyboard focus
  static const int SDL_WINDOWEVENT_FOCUS_LOST = 13;

  /// < The window manager requests that the window be closed
  static const int SDL_WINDOWEVENT_CLOSE = 14;

  /// < Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)
  static const int SDL_WINDOWEVENT_TAKE_FOCUS = 15;

  /// < Window had a hit test that wasn't SDL_HITTEST_NORMAL.
  static const int SDL_WINDOWEVENT_HIT_TEST = 16;
}

/// \brief Event subtype for display events
abstract class SDL_DisplayEventID {
  /// < Never used
  static const int SDL_DISPLAYEVENT_NONE = 0;

  /// < Display orientation has changed to data1
  static const int SDL_DISPLAYEVENT_ORIENTATION = 1;

  /// < Display has been added to the system
  static const int SDL_DISPLAYEVENT_CONNECTED = 2;

  /// < Display has been removed from the system
  static const int SDL_DISPLAYEVENT_DISCONNECTED = 3;
}

abstract class SDL_DisplayOrientation {
  /// < The display orientation can't be determined
  static const int SDL_ORIENTATION_UNKNOWN = 0;

  /// < The display is in landscape mode, with the right side up, relative to portrait mode
  static const int SDL_ORIENTATION_LANDSCAPE = 1;

  /// < The display is in landscape mode, with the left side up, relative to portrait mode
  static const int SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2;

  /// < The display is in portrait mode
  static const int SDL_ORIENTATION_PORTRAIT = 3;

  /// < The display is in portrait mode, upside down
  static const int SDL_ORIENTATION_PORTRAIT_FLIPPED = 4;
}

/// \brief OpenGL configuration attributes
abstract class SDL_GLattr {
  static const int SDL_GL_RED_SIZE = 0;
  static const int SDL_GL_GREEN_SIZE = 1;
  static const int SDL_GL_BLUE_SIZE = 2;
  static const int SDL_GL_ALPHA_SIZE = 3;
  static const int SDL_GL_BUFFER_SIZE = 4;
  static const int SDL_GL_DOUBLEBUFFER = 5;
  static const int SDL_GL_DEPTH_SIZE = 6;
  static const int SDL_GL_STENCIL_SIZE = 7;
  static const int SDL_GL_ACCUM_RED_SIZE = 8;
  static const int SDL_GL_ACCUM_GREEN_SIZE = 9;
  static const int SDL_GL_ACCUM_BLUE_SIZE = 10;
  static const int SDL_GL_ACCUM_ALPHA_SIZE = 11;
  static const int SDL_GL_STEREO = 12;
  static const int SDL_GL_MULTISAMPLEBUFFERS = 13;
  static const int SDL_GL_MULTISAMPLESAMPLES = 14;
  static const int SDL_GL_ACCELERATED_VISUAL = 15;
  static const int SDL_GL_RETAINED_BACKING = 16;
  static const int SDL_GL_CONTEXT_MAJOR_VERSION = 17;
  static const int SDL_GL_CONTEXT_MINOR_VERSION = 18;
  static const int SDL_GL_CONTEXT_EGL = 19;
  static const int SDL_GL_CONTEXT_FLAGS = 20;
  static const int SDL_GL_CONTEXT_PROFILE_MASK = 21;
  static const int SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22;
  static const int SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23;
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24;
  static const int SDL_GL_CONTEXT_RESET_NOTIFICATION = 25;
  static const int SDL_GL_CONTEXT_NO_ERROR = 26;
}

abstract class SDL_GLprofile {
  static const int SDL_GL_CONTEXT_PROFILE_CORE = 1;
  static const int SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2;

  /// < GLX_CONTEXT_ES2_PROFILE_BIT_EXT
  static const int SDL_GL_CONTEXT_PROFILE_ES = 4;
}

abstract class SDL_GLcontextFlag {
  static const int SDL_GL_CONTEXT_DEBUG_FLAG = 1;
  static const int SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2;
  static const int SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4;
  static const int SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8;
}

abstract class SDL_GLcontextReleaseFlag {
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0;
  static const int SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1;
}

abstract class SDL_GLContextResetNotification {
  static const int SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0;
  static const int SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1;
}

/// \brief Possible return values from the SDL_HitTest callback.
///
/// \sa SDL_HitTest
abstract class SDL_HitTestResult {
  /// < Region is normal. No special properties.
  static const int SDL_HITTEST_NORMAL = 0;

  /// < Region can drag entire window.
  static const int SDL_HITTEST_DRAGGABLE = 1;
  static const int SDL_HITTEST_RESIZE_TOPLEFT = 2;
  static const int SDL_HITTEST_RESIZE_TOP = 3;
  static const int SDL_HITTEST_RESIZE_TOPRIGHT = 4;
  static const int SDL_HITTEST_RESIZE_RIGHT = 5;
  static const int SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6;
  static const int SDL_HITTEST_RESIZE_BOTTOM = 7;
  static const int SDL_HITTEST_RESIZE_BOTTOMLEFT = 8;
  static const int SDL_HITTEST_RESIZE_LEFT = 9;
}

/// \brief The SDL keyboard scancode representation.
///
/// Values of this type are used to represent keyboard keys, among other places
/// in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
/// SDL_Event structure.
///
/// The values in this enumeration are based on the USB usage page standard:
/// https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
abstract class SDL_Scancode {
  static const int SDL_SCANCODE_UNKNOWN = 0;
  static const int SDL_SCANCODE_A = 4;
  static const int SDL_SCANCODE_B = 5;
  static const int SDL_SCANCODE_C = 6;
  static const int SDL_SCANCODE_D = 7;
  static const int SDL_SCANCODE_E = 8;
  static const int SDL_SCANCODE_F = 9;
  static const int SDL_SCANCODE_G = 10;
  static const int SDL_SCANCODE_H = 11;
  static const int SDL_SCANCODE_I = 12;
  static const int SDL_SCANCODE_J = 13;
  static const int SDL_SCANCODE_K = 14;
  static const int SDL_SCANCODE_L = 15;
  static const int SDL_SCANCODE_M = 16;
  static const int SDL_SCANCODE_N = 17;
  static const int SDL_SCANCODE_O = 18;
  static const int SDL_SCANCODE_P = 19;
  static const int SDL_SCANCODE_Q = 20;
  static const int SDL_SCANCODE_R = 21;
  static const int SDL_SCANCODE_S = 22;
  static const int SDL_SCANCODE_T = 23;
  static const int SDL_SCANCODE_U = 24;
  static const int SDL_SCANCODE_V = 25;
  static const int SDL_SCANCODE_W = 26;
  static const int SDL_SCANCODE_X = 27;
  static const int SDL_SCANCODE_Y = 28;
  static const int SDL_SCANCODE_Z = 29;
  static const int SDL_SCANCODE_1 = 30;
  static const int SDL_SCANCODE_2 = 31;
  static const int SDL_SCANCODE_3 = 32;
  static const int SDL_SCANCODE_4 = 33;
  static const int SDL_SCANCODE_5 = 34;
  static const int SDL_SCANCODE_6 = 35;
  static const int SDL_SCANCODE_7 = 36;
  static const int SDL_SCANCODE_8 = 37;
  static const int SDL_SCANCODE_9 = 38;
  static const int SDL_SCANCODE_0 = 39;
  static const int SDL_SCANCODE_RETURN = 40;
  static const int SDL_SCANCODE_ESCAPE = 41;
  static const int SDL_SCANCODE_BACKSPACE = 42;
  static const int SDL_SCANCODE_TAB = 43;
  static const int SDL_SCANCODE_SPACE = 44;
  static const int SDL_SCANCODE_MINUS = 45;
  static const int SDL_SCANCODE_EQUALS = 46;
  static const int SDL_SCANCODE_LEFTBRACKET = 47;
  static const int SDL_SCANCODE_RIGHTBRACKET = 48;

  /// < Located at the lower left of the return
  /// key on ISO keyboards and at the right end
  /// of the QWERTY row on ANSI keyboards.
  /// Produces REVERSE SOLIDUS (backslash) and
  /// VERTICAL LINE in a US layout, REVERSE
  /// SOLIDUS and VERTICAL LINE in a UK Mac
  /// layout, NUMBER SIGN and TILDE in a UK
  /// Windows layout, DOLLAR SIGN and POUND SIGN
  /// in a Swiss German layout, NUMBER SIGN and
  /// APOSTROPHE in a German layout, GRAVE
  /// ACCENT and POUND SIGN in a French Mac
  /// layout, and ASTERISK and MICRO SIGN in a
  /// French Windows layout.
  static const int SDL_SCANCODE_BACKSLASH = 49;

  /// < ISO USB keyboards actually use this code
  /// instead of 49 for the same key, but all
  /// OSes I've seen treat the two codes
  /// identically. So, as an implementor, unless
  /// your keyboard generates both of those
  /// codes and your OS treats them differently,
  /// you should generate SDL_SCANCODE_BACKSLASH
  /// instead of this code. As a user, you
  /// should not rely on this code because SDL
  /// will never generate it with most (all?)
  /// keyboards.
  static const int SDL_SCANCODE_NONUSHASH = 50;
  static const int SDL_SCANCODE_SEMICOLON = 51;
  static const int SDL_SCANCODE_APOSTROPHE = 52;

  /// < Located in the top left corner (on both ANSI
  /// and ISO keyboards). Produces GRAVE ACCENT and
  /// TILDE in a US Windows layout and in US and UK
  /// Mac layouts on ANSI keyboards, GRAVE ACCENT
  /// and NOT SIGN in a UK Windows layout, SECTION
  /// SIGN and PLUS-MINUS SIGN in US and UK Mac
  /// layouts on ISO keyboards, SECTION SIGN and
  /// DEGREE SIGN in a Swiss German layout (Mac:
  /// only on ISO keyboards), CIRCUMFLEX ACCENT and
  /// DEGREE SIGN in a German layout (Mac: only on
  /// ISO keyboards), SUPERSCRIPT TWO and TILDE in a
  /// French Windows layout, COMMERCIAL AT and
  /// NUMBER SIGN in a French Mac layout on ISO
  /// keyboards, and LESS-THAN SIGN and GREATER-THAN
  /// SIGN in a Swiss German, German, or French Mac
  /// layout on ANSI keyboards.
  static const int SDL_SCANCODE_GRAVE = 53;
  static const int SDL_SCANCODE_COMMA = 54;
  static const int SDL_SCANCODE_PERIOD = 55;
  static const int SDL_SCANCODE_SLASH = 56;
  static const int SDL_SCANCODE_CAPSLOCK = 57;
  static const int SDL_SCANCODE_F1 = 58;
  static const int SDL_SCANCODE_F2 = 59;
  static const int SDL_SCANCODE_F3 = 60;
  static const int SDL_SCANCODE_F4 = 61;
  static const int SDL_SCANCODE_F5 = 62;
  static const int SDL_SCANCODE_F6 = 63;
  static const int SDL_SCANCODE_F7 = 64;
  static const int SDL_SCANCODE_F8 = 65;
  static const int SDL_SCANCODE_F9 = 66;
  static const int SDL_SCANCODE_F10 = 67;
  static const int SDL_SCANCODE_F11 = 68;
  static const int SDL_SCANCODE_F12 = 69;
  static const int SDL_SCANCODE_PRINTSCREEN = 70;
  static const int SDL_SCANCODE_SCROLLLOCK = 71;
  static const int SDL_SCANCODE_PAUSE = 72;

  /// < insert on PC, help on some Mac keyboards (but
  /// does send code 73, not 117)
  static const int SDL_SCANCODE_INSERT = 73;
  static const int SDL_SCANCODE_HOME = 74;
  static const int SDL_SCANCODE_PAGEUP = 75;
  static const int SDL_SCANCODE_DELETE = 76;
  static const int SDL_SCANCODE_END = 77;
  static const int SDL_SCANCODE_PAGEDOWN = 78;
  static const int SDL_SCANCODE_RIGHT = 79;
  static const int SDL_SCANCODE_LEFT = 80;
  static const int SDL_SCANCODE_DOWN = 81;
  static const int SDL_SCANCODE_UP = 82;

  /// < num lock on PC, clear on Mac keyboards
  static const int SDL_SCANCODE_NUMLOCKCLEAR = 83;
  static const int SDL_SCANCODE_KP_DIVIDE = 84;
  static const int SDL_SCANCODE_KP_MULTIPLY = 85;
  static const int SDL_SCANCODE_KP_MINUS = 86;
  static const int SDL_SCANCODE_KP_PLUS = 87;
  static const int SDL_SCANCODE_KP_ENTER = 88;
  static const int SDL_SCANCODE_KP_1 = 89;
  static const int SDL_SCANCODE_KP_2 = 90;
  static const int SDL_SCANCODE_KP_3 = 91;
  static const int SDL_SCANCODE_KP_4 = 92;
  static const int SDL_SCANCODE_KP_5 = 93;
  static const int SDL_SCANCODE_KP_6 = 94;
  static const int SDL_SCANCODE_KP_7 = 95;
  static const int SDL_SCANCODE_KP_8 = 96;
  static const int SDL_SCANCODE_KP_9 = 97;
  static const int SDL_SCANCODE_KP_0 = 98;
  static const int SDL_SCANCODE_KP_PERIOD = 99;

  /// < This is the additional key that ISO
  /// keyboards have over ANSI ones,
  /// located between left shift and Y.
  /// Produces GRAVE ACCENT and TILDE in a
  /// US or UK Mac layout, REVERSE SOLIDUS
  /// (backslash) and VERTICAL LINE in a
  /// US or UK Windows layout, and
  /// LESS-THAN SIGN and GREATER-THAN SIGN
  /// in a Swiss German, German, or French
  /// layout.
  static const int SDL_SCANCODE_NONUSBACKSLASH = 100;

  /// < windows contextual menu, compose
  static const int SDL_SCANCODE_APPLICATION = 101;

  /// < The USB document says this is a status flag,
  /// not a physical key - but some Mac keyboards
  /// do have a power key.
  static const int SDL_SCANCODE_POWER = 102;
  static const int SDL_SCANCODE_KP_EQUALS = 103;
  static const int SDL_SCANCODE_F13 = 104;
  static const int SDL_SCANCODE_F14 = 105;
  static const int SDL_SCANCODE_F15 = 106;
  static const int SDL_SCANCODE_F16 = 107;
  static const int SDL_SCANCODE_F17 = 108;
  static const int SDL_SCANCODE_F18 = 109;
  static const int SDL_SCANCODE_F19 = 110;
  static const int SDL_SCANCODE_F20 = 111;
  static const int SDL_SCANCODE_F21 = 112;
  static const int SDL_SCANCODE_F22 = 113;
  static const int SDL_SCANCODE_F23 = 114;
  static const int SDL_SCANCODE_F24 = 115;
  static const int SDL_SCANCODE_EXECUTE = 116;
  static const int SDL_SCANCODE_HELP = 117;
  static const int SDL_SCANCODE_MENU = 118;
  static const int SDL_SCANCODE_SELECT = 119;
  static const int SDL_SCANCODE_STOP = 120;

  /// < redo
  static const int SDL_SCANCODE_AGAIN = 121;
  static const int SDL_SCANCODE_UNDO = 122;
  static const int SDL_SCANCODE_CUT = 123;
  static const int SDL_SCANCODE_COPY = 124;
  static const int SDL_SCANCODE_PASTE = 125;
  static const int SDL_SCANCODE_FIND = 126;
  static const int SDL_SCANCODE_MUTE = 127;
  static const int SDL_SCANCODE_VOLUMEUP = 128;
  static const int SDL_SCANCODE_VOLUMEDOWN = 129;
  static const int SDL_SCANCODE_KP_COMMA = 133;
  static const int SDL_SCANCODE_KP_EQUALSAS400 = 134;

  /// < used on Asian keyboards, see
  /// footnotes in USB doc
  static const int SDL_SCANCODE_INTERNATIONAL1 = 135;
  static const int SDL_SCANCODE_INTERNATIONAL2 = 136;

  /// < Yen
  static const int SDL_SCANCODE_INTERNATIONAL3 = 137;
  static const int SDL_SCANCODE_INTERNATIONAL4 = 138;
  static const int SDL_SCANCODE_INTERNATIONAL5 = 139;
  static const int SDL_SCANCODE_INTERNATIONAL6 = 140;
  static const int SDL_SCANCODE_INTERNATIONAL7 = 141;
  static const int SDL_SCANCODE_INTERNATIONAL8 = 142;
  static const int SDL_SCANCODE_INTERNATIONAL9 = 143;

  /// < Hangul/English toggle
  static const int SDL_SCANCODE_LANG1 = 144;

  /// < Hanja conversion
  static const int SDL_SCANCODE_LANG2 = 145;

  /// < Katakana
  static const int SDL_SCANCODE_LANG3 = 146;

  /// < Hiragana
  static const int SDL_SCANCODE_LANG4 = 147;

  /// < Zenkaku/Hankaku
  static const int SDL_SCANCODE_LANG5 = 148;

  /// < reserved
  static const int SDL_SCANCODE_LANG6 = 149;

  /// < reserved
  static const int SDL_SCANCODE_LANG7 = 150;

  /// < reserved
  static const int SDL_SCANCODE_LANG8 = 151;

  /// < reserved
  static const int SDL_SCANCODE_LANG9 = 152;

  /// < Erase-Eaze
  static const int SDL_SCANCODE_ALTERASE = 153;
  static const int SDL_SCANCODE_SYSREQ = 154;
  static const int SDL_SCANCODE_CANCEL = 155;
  static const int SDL_SCANCODE_CLEAR = 156;
  static const int SDL_SCANCODE_PRIOR = 157;
  static const int SDL_SCANCODE_RETURN2 = 158;
  static const int SDL_SCANCODE_SEPARATOR = 159;
  static const int SDL_SCANCODE_OUT = 160;
  static const int SDL_SCANCODE_OPER = 161;
  static const int SDL_SCANCODE_CLEARAGAIN = 162;
  static const int SDL_SCANCODE_CRSEL = 163;
  static const int SDL_SCANCODE_EXSEL = 164;
  static const int SDL_SCANCODE_KP_00 = 176;
  static const int SDL_SCANCODE_KP_000 = 177;
  static const int SDL_SCANCODE_THOUSANDSSEPARATOR = 178;
  static const int SDL_SCANCODE_DECIMALSEPARATOR = 179;
  static const int SDL_SCANCODE_CURRENCYUNIT = 180;
  static const int SDL_SCANCODE_CURRENCYSUBUNIT = 181;
  static const int SDL_SCANCODE_KP_LEFTPAREN = 182;
  static const int SDL_SCANCODE_KP_RIGHTPAREN = 183;
  static const int SDL_SCANCODE_KP_LEFTBRACE = 184;
  static const int SDL_SCANCODE_KP_RIGHTBRACE = 185;
  static const int SDL_SCANCODE_KP_TAB = 186;
  static const int SDL_SCANCODE_KP_BACKSPACE = 187;
  static const int SDL_SCANCODE_KP_A = 188;
  static const int SDL_SCANCODE_KP_B = 189;
  static const int SDL_SCANCODE_KP_C = 190;
  static const int SDL_SCANCODE_KP_D = 191;
  static const int SDL_SCANCODE_KP_E = 192;
  static const int SDL_SCANCODE_KP_F = 193;
  static const int SDL_SCANCODE_KP_XOR = 194;
  static const int SDL_SCANCODE_KP_POWER = 195;
  static const int SDL_SCANCODE_KP_PERCENT = 196;
  static const int SDL_SCANCODE_KP_LESS = 197;
  static const int SDL_SCANCODE_KP_GREATER = 198;
  static const int SDL_SCANCODE_KP_AMPERSAND = 199;
  static const int SDL_SCANCODE_KP_DBLAMPERSAND = 200;
  static const int SDL_SCANCODE_KP_VERTICALBAR = 201;
  static const int SDL_SCANCODE_KP_DBLVERTICALBAR = 202;
  static const int SDL_SCANCODE_KP_COLON = 203;
  static const int SDL_SCANCODE_KP_HASH = 204;
  static const int SDL_SCANCODE_KP_SPACE = 205;
  static const int SDL_SCANCODE_KP_AT = 206;
  static const int SDL_SCANCODE_KP_EXCLAM = 207;
  static const int SDL_SCANCODE_KP_MEMSTORE = 208;
  static const int SDL_SCANCODE_KP_MEMRECALL = 209;
  static const int SDL_SCANCODE_KP_MEMCLEAR = 210;
  static const int SDL_SCANCODE_KP_MEMADD = 211;
  static const int SDL_SCANCODE_KP_MEMSUBTRACT = 212;
  static const int SDL_SCANCODE_KP_MEMMULTIPLY = 213;
  static const int SDL_SCANCODE_KP_MEMDIVIDE = 214;
  static const int SDL_SCANCODE_KP_PLUSMINUS = 215;
  static const int SDL_SCANCODE_KP_CLEAR = 216;
  static const int SDL_SCANCODE_KP_CLEARENTRY = 217;
  static const int SDL_SCANCODE_KP_BINARY = 218;
  static const int SDL_SCANCODE_KP_OCTAL = 219;
  static const int SDL_SCANCODE_KP_DECIMAL = 220;
  static const int SDL_SCANCODE_KP_HEXADECIMAL = 221;
  static const int SDL_SCANCODE_LCTRL = 224;
  static const int SDL_SCANCODE_LSHIFT = 225;

  /// < alt, option
  static const int SDL_SCANCODE_LALT = 226;

  /// < windows, command (apple), meta
  static const int SDL_SCANCODE_LGUI = 227;
  static const int SDL_SCANCODE_RCTRL = 228;
  static const int SDL_SCANCODE_RSHIFT = 229;

  /// < alt gr, option
  static const int SDL_SCANCODE_RALT = 230;

  /// < windows, command (apple), meta
  static const int SDL_SCANCODE_RGUI = 231;

  /// < I'm not sure if this is really not covered
  /// by any of the above, but since there's a
  /// special KMOD_MODE for it I'm adding it here
  static const int SDL_SCANCODE_MODE = 257;
  static const int SDL_SCANCODE_AUDIONEXT = 258;
  static const int SDL_SCANCODE_AUDIOPREV = 259;
  static const int SDL_SCANCODE_AUDIOSTOP = 260;
  static const int SDL_SCANCODE_AUDIOPLAY = 261;
  static const int SDL_SCANCODE_AUDIOMUTE = 262;
  static const int SDL_SCANCODE_MEDIASELECT = 263;
  static const int SDL_SCANCODE_WWW = 264;
  static const int SDL_SCANCODE_MAIL = 265;
  static const int SDL_SCANCODE_CALCULATOR = 266;
  static const int SDL_SCANCODE_COMPUTER = 267;
  static const int SDL_SCANCODE_AC_SEARCH = 268;
  static const int SDL_SCANCODE_AC_HOME = 269;
  static const int SDL_SCANCODE_AC_BACK = 270;
  static const int SDL_SCANCODE_AC_FORWARD = 271;
  static const int SDL_SCANCODE_AC_STOP = 272;
  static const int SDL_SCANCODE_AC_REFRESH = 273;
  static const int SDL_SCANCODE_AC_BOOKMARKS = 274;
  static const int SDL_SCANCODE_BRIGHTNESSDOWN = 275;
  static const int SDL_SCANCODE_BRIGHTNESSUP = 276;

  /// < display mirroring/dual display
  /// switch, video mode switch
  static const int SDL_SCANCODE_DISPLAYSWITCH = 277;
  static const int SDL_SCANCODE_KBDILLUMTOGGLE = 278;
  static const int SDL_SCANCODE_KBDILLUMDOWN = 279;
  static const int SDL_SCANCODE_KBDILLUMUP = 280;
  static const int SDL_SCANCODE_EJECT = 281;
  static const int SDL_SCANCODE_SLEEP = 282;
  static const int SDL_SCANCODE_APP1 = 283;
  static const int SDL_SCANCODE_APP2 = 284;
  static const int SDL_SCANCODE_AUDIOREWIND = 285;
  static const int SDL_SCANCODE_AUDIOFASTFORWARD = 286;

  /// < not a key, just marks the number of scancodes
  /// for array bounds
  static const int SDL_NUM_SCANCODES = 512;
}

abstract class SDL_KeyCode {
  static const int SDLK_UNKNOWN = 0;
  static const int SDLK_RETURN = 13;
  static const int SDLK_ESCAPE = 27;
  static const int SDLK_BACKSPACE = 8;
  static const int SDLK_TAB = 9;
  static const int SDLK_SPACE = 32;
  static const int SDLK_EXCLAIM = 33;
  static const int SDLK_QUOTEDBL = 34;
  static const int SDLK_HASH = 35;
  static const int SDLK_PERCENT = 37;
  static const int SDLK_DOLLAR = 36;
  static const int SDLK_AMPERSAND = 38;
  static const int SDLK_QUOTE = 39;
  static const int SDLK_LEFTPAREN = 40;
  static const int SDLK_RIGHTPAREN = 41;
  static const int SDLK_ASTERISK = 42;
  static const int SDLK_PLUS = 43;
  static const int SDLK_COMMA = 44;
  static const int SDLK_MINUS = 45;
  static const int SDLK_PERIOD = 46;
  static const int SDLK_SLASH = 47;
  static const int SDLK_0 = 48;
  static const int SDLK_1 = 49;
  static const int SDLK_2 = 50;
  static const int SDLK_3 = 51;
  static const int SDLK_4 = 52;
  static const int SDLK_5 = 53;
  static const int SDLK_6 = 54;
  static const int SDLK_7 = 55;
  static const int SDLK_8 = 56;
  static const int SDLK_9 = 57;
  static const int SDLK_COLON = 58;
  static const int SDLK_SEMICOLON = 59;
  static const int SDLK_LESS = 60;
  static const int SDLK_EQUALS = 61;
  static const int SDLK_GREATER = 62;
  static const int SDLK_QUESTION = 63;
  static const int SDLK_AT = 64;
  static const int SDLK_LEFTBRACKET = 91;
  static const int SDLK_BACKSLASH = 92;
  static const int SDLK_RIGHTBRACKET = 93;
  static const int SDLK_CARET = 94;
  static const int SDLK_UNDERSCORE = 95;
  static const int SDLK_BACKQUOTE = 96;
  static const int SDLK_a = 97;
  static const int SDLK_b = 98;
  static const int SDLK_c = 99;
  static const int SDLK_d = 100;
  static const int SDLK_e = 101;
  static const int SDLK_f = 102;
  static const int SDLK_g = 103;
  static const int SDLK_h = 104;
  static const int SDLK_i = 105;
  static const int SDLK_j = 106;
  static const int SDLK_k = 107;
  static const int SDLK_l = 108;
  static const int SDLK_m = 109;
  static const int SDLK_n = 110;
  static const int SDLK_o = 111;
  static const int SDLK_p = 112;
  static const int SDLK_q = 113;
  static const int SDLK_r = 114;
  static const int SDLK_s = 115;
  static const int SDLK_t = 116;
  static const int SDLK_u = 117;
  static const int SDLK_v = 118;
  static const int SDLK_w = 119;
  static const int SDLK_x = 120;
  static const int SDLK_y = 121;
  static const int SDLK_z = 122;
  static const int SDLK_CAPSLOCK = 1073741881;
  static const int SDLK_F1 = 1073741882;
  static const int SDLK_F2 = 1073741883;
  static const int SDLK_F3 = 1073741884;
  static const int SDLK_F4 = 1073741885;
  static const int SDLK_F5 = 1073741886;
  static const int SDLK_F6 = 1073741887;
  static const int SDLK_F7 = 1073741888;
  static const int SDLK_F8 = 1073741889;
  static const int SDLK_F9 = 1073741890;
  static const int SDLK_F10 = 1073741891;
  static const int SDLK_F11 = 1073741892;
  static const int SDLK_F12 = 1073741893;
  static const int SDLK_PRINTSCREEN = 1073741894;
  static const int SDLK_SCROLLLOCK = 1073741895;
  static const int SDLK_PAUSE = 1073741896;
  static const int SDLK_INSERT = 1073741897;
  static const int SDLK_HOME = 1073741898;
  static const int SDLK_PAGEUP = 1073741899;
  static const int SDLK_DELETE = 127;
  static const int SDLK_END = 1073741901;
  static const int SDLK_PAGEDOWN = 1073741902;
  static const int SDLK_RIGHT = 1073741903;
  static const int SDLK_LEFT = 1073741904;
  static const int SDLK_DOWN = 1073741905;
  static const int SDLK_UP = 1073741906;
  static const int SDLK_NUMLOCKCLEAR = 1073741907;
  static const int SDLK_KP_DIVIDE = 1073741908;
  static const int SDLK_KP_MULTIPLY = 1073741909;
  static const int SDLK_KP_MINUS = 1073741910;
  static const int SDLK_KP_PLUS = 1073741911;
  static const int SDLK_KP_ENTER = 1073741912;
  static const int SDLK_KP_1 = 1073741913;
  static const int SDLK_KP_2 = 1073741914;
  static const int SDLK_KP_3 = 1073741915;
  static const int SDLK_KP_4 = 1073741916;
  static const int SDLK_KP_5 = 1073741917;
  static const int SDLK_KP_6 = 1073741918;
  static const int SDLK_KP_7 = 1073741919;
  static const int SDLK_KP_8 = 1073741920;
  static const int SDLK_KP_9 = 1073741921;
  static const int SDLK_KP_0 = 1073741922;
  static const int SDLK_KP_PERIOD = 1073741923;
  static const int SDLK_APPLICATION = 1073741925;
  static const int SDLK_POWER = 1073741926;
  static const int SDLK_KP_EQUALS = 1073741927;
  static const int SDLK_F13 = 1073741928;
  static const int SDLK_F14 = 1073741929;
  static const int SDLK_F15 = 1073741930;
  static const int SDLK_F16 = 1073741931;
  static const int SDLK_F17 = 1073741932;
  static const int SDLK_F18 = 1073741933;
  static const int SDLK_F19 = 1073741934;
  static const int SDLK_F20 = 1073741935;
  static const int SDLK_F21 = 1073741936;
  static const int SDLK_F22 = 1073741937;
  static const int SDLK_F23 = 1073741938;
  static const int SDLK_F24 = 1073741939;
  static const int SDLK_EXECUTE = 1073741940;
  static const int SDLK_HELP = 1073741941;
  static const int SDLK_MENU = 1073741942;
  static const int SDLK_SELECT = 1073741943;
  static const int SDLK_STOP = 1073741944;
  static const int SDLK_AGAIN = 1073741945;
  static const int SDLK_UNDO = 1073741946;
  static const int SDLK_CUT = 1073741947;
  static const int SDLK_COPY = 1073741948;
  static const int SDLK_PASTE = 1073741949;
  static const int SDLK_FIND = 1073741950;
  static const int SDLK_MUTE = 1073741951;
  static const int SDLK_VOLUMEUP = 1073741952;
  static const int SDLK_VOLUMEDOWN = 1073741953;
  static const int SDLK_KP_COMMA = 1073741957;
  static const int SDLK_KP_EQUALSAS400 = 1073741958;
  static const int SDLK_ALTERASE = 1073741977;
  static const int SDLK_SYSREQ = 1073741978;
  static const int SDLK_CANCEL = 1073741979;
  static const int SDLK_CLEAR = 1073741980;
  static const int SDLK_PRIOR = 1073741981;
  static const int SDLK_RETURN2 = 1073741982;
  static const int SDLK_SEPARATOR = 1073741983;
  static const int SDLK_OUT = 1073741984;
  static const int SDLK_OPER = 1073741985;
  static const int SDLK_CLEARAGAIN = 1073741986;
  static const int SDLK_CRSEL = 1073741987;
  static const int SDLK_EXSEL = 1073741988;
  static const int SDLK_KP_00 = 1073742000;
  static const int SDLK_KP_000 = 1073742001;
  static const int SDLK_THOUSANDSSEPARATOR = 1073742002;
  static const int SDLK_DECIMALSEPARATOR = 1073742003;
  static const int SDLK_CURRENCYUNIT = 1073742004;
  static const int SDLK_CURRENCYSUBUNIT = 1073742005;
  static const int SDLK_KP_LEFTPAREN = 1073742006;
  static const int SDLK_KP_RIGHTPAREN = 1073742007;
  static const int SDLK_KP_LEFTBRACE = 1073742008;
  static const int SDLK_KP_RIGHTBRACE = 1073742009;
  static const int SDLK_KP_TAB = 1073742010;
  static const int SDLK_KP_BACKSPACE = 1073742011;
  static const int SDLK_KP_A = 1073742012;
  static const int SDLK_KP_B = 1073742013;
  static const int SDLK_KP_C = 1073742014;
  static const int SDLK_KP_D = 1073742015;
  static const int SDLK_KP_E = 1073742016;
  static const int SDLK_KP_F = 1073742017;
  static const int SDLK_KP_XOR = 1073742018;
  static const int SDLK_KP_POWER = 1073742019;
  static const int SDLK_KP_PERCENT = 1073742020;
  static const int SDLK_KP_LESS = 1073742021;
  static const int SDLK_KP_GREATER = 1073742022;
  static const int SDLK_KP_AMPERSAND = 1073742023;
  static const int SDLK_KP_DBLAMPERSAND = 1073742024;
  static const int SDLK_KP_VERTICALBAR = 1073742025;
  static const int SDLK_KP_DBLVERTICALBAR = 1073742026;
  static const int SDLK_KP_COLON = 1073742027;
  static const int SDLK_KP_HASH = 1073742028;
  static const int SDLK_KP_SPACE = 1073742029;
  static const int SDLK_KP_AT = 1073742030;
  static const int SDLK_KP_EXCLAM = 1073742031;
  static const int SDLK_KP_MEMSTORE = 1073742032;
  static const int SDLK_KP_MEMRECALL = 1073742033;
  static const int SDLK_KP_MEMCLEAR = 1073742034;
  static const int SDLK_KP_MEMADD = 1073742035;
  static const int SDLK_KP_MEMSUBTRACT = 1073742036;
  static const int SDLK_KP_MEMMULTIPLY = 1073742037;
  static const int SDLK_KP_MEMDIVIDE = 1073742038;
  static const int SDLK_KP_PLUSMINUS = 1073742039;
  static const int SDLK_KP_CLEAR = 1073742040;
  static const int SDLK_KP_CLEARENTRY = 1073742041;
  static const int SDLK_KP_BINARY = 1073742042;
  static const int SDLK_KP_OCTAL = 1073742043;
  static const int SDLK_KP_DECIMAL = 1073742044;
  static const int SDLK_KP_HEXADECIMAL = 1073742045;
  static const int SDLK_LCTRL = 1073742048;
  static const int SDLK_LSHIFT = 1073742049;
  static const int SDLK_LALT = 1073742050;
  static const int SDLK_LGUI = 1073742051;
  static const int SDLK_RCTRL = 1073742052;
  static const int SDLK_RSHIFT = 1073742053;
  static const int SDLK_RALT = 1073742054;
  static const int SDLK_RGUI = 1073742055;
  static const int SDLK_MODE = 1073742081;
  static const int SDLK_AUDIONEXT = 1073742082;
  static const int SDLK_AUDIOPREV = 1073742083;
  static const int SDLK_AUDIOSTOP = 1073742084;
  static const int SDLK_AUDIOPLAY = 1073742085;
  static const int SDLK_AUDIOMUTE = 1073742086;
  static const int SDLK_MEDIASELECT = 1073742087;
  static const int SDLK_WWW = 1073742088;
  static const int SDLK_MAIL = 1073742089;
  static const int SDLK_CALCULATOR = 1073742090;
  static const int SDLK_COMPUTER = 1073742091;
  static const int SDLK_AC_SEARCH = 1073742092;
  static const int SDLK_AC_HOME = 1073742093;
  static const int SDLK_AC_BACK = 1073742094;
  static const int SDLK_AC_FORWARD = 1073742095;
  static const int SDLK_AC_STOP = 1073742096;
  static const int SDLK_AC_REFRESH = 1073742097;
  static const int SDLK_AC_BOOKMARKS = 1073742098;
  static const int SDLK_BRIGHTNESSDOWN = 1073742099;
  static const int SDLK_BRIGHTNESSUP = 1073742100;
  static const int SDLK_DISPLAYSWITCH = 1073742101;
  static const int SDLK_KBDILLUMTOGGLE = 1073742102;
  static const int SDLK_KBDILLUMDOWN = 1073742103;
  static const int SDLK_KBDILLUMUP = 1073742104;
  static const int SDLK_EJECT = 1073742105;
  static const int SDLK_SLEEP = 1073742106;
  static const int SDLK_APP1 = 1073742107;
  static const int SDLK_APP2 = 1073742108;
  static const int SDLK_AUDIOREWIND = 1073742109;
  static const int SDLK_AUDIOFASTFORWARD = 1073742110;
}

/// \brief Enumeration of valid key mods (possibly OR'd together).
abstract class SDL_Keymod {
  static const int KMOD_NONE = 0;
  static const int KMOD_LSHIFT = 1;
  static const int KMOD_RSHIFT = 2;
  static const int KMOD_LCTRL = 64;
  static const int KMOD_RCTRL = 128;
  static const int KMOD_LALT = 256;
  static const int KMOD_RALT = 512;
  static const int KMOD_LGUI = 1024;
  static const int KMOD_RGUI = 2048;
  static const int KMOD_NUM = 4096;
  static const int KMOD_CAPS = 8192;
  static const int KMOD_MODE = 16384;
  static const int KMOD_RESERVED = 32768;
  static const int KMOD_CTRL = 192;
  static const int KMOD_SHIFT = 3;
  static const int KMOD_ALT = 768;
  static const int KMOD_GUI = 3072;
}

/// \brief The SDL keysym structure, used in key events.
///
/// \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
class SDL_Keysym extends ffi.Struct {
  /// < SDL physical key code - see ::SDL_Scancode for details
  @ffi.Int32()
  external int scancode;

  /// < SDL virtual key code - see ::SDL_Keycode for details
  @ffi.Int32()
  external int sym;

  /// < current key modifiers
  @ffi.Uint16()
  external int mod;

  @ffi.Uint32()
  external int unused;
}

class SDL_Cursor extends ffi.Opaque {}

/// \brief Cursor types for SDL_CreateSystemCursor().
abstract class SDL_SystemCursor {
  /// < Arrow
  static const int SDL_SYSTEM_CURSOR_ARROW = 0;

  /// < I-beam
  static const int SDL_SYSTEM_CURSOR_IBEAM = 1;

  /// < Wait
  static const int SDL_SYSTEM_CURSOR_WAIT = 2;

  /// < Crosshair
  static const int SDL_SYSTEM_CURSOR_CROSSHAIR = 3;

  /// < Small wait cursor (or Wait if not available)
  static const int SDL_SYSTEM_CURSOR_WAITARROW = 4;

  /// < Double arrow pointing northwest and southeast
  static const int SDL_SYSTEM_CURSOR_SIZENWSE = 5;

  /// < Double arrow pointing northeast and southwest
  static const int SDL_SYSTEM_CURSOR_SIZENESW = 6;

  /// < Double arrow pointing west and east
  static const int SDL_SYSTEM_CURSOR_SIZEWE = 7;

  /// < Double arrow pointing north and south
  static const int SDL_SYSTEM_CURSOR_SIZENS = 8;

  /// < Four pointed arrow pointing north, south, east, and west
  static const int SDL_SYSTEM_CURSOR_SIZEALL = 9;

  /// < Slashed circle or crossbones
  static const int SDL_SYSTEM_CURSOR_NO = 10;

  /// < Hand
  static const int SDL_SYSTEM_CURSOR_HAND = 11;
  static const int SDL_NUM_SYSTEM_CURSORS = 12;
}

/// \brief Scroll direction types for the Scroll event
abstract class SDL_MouseWheelDirection {
  /// < The scroll direction is normal
  static const int SDL_MOUSEWHEEL_NORMAL = 0;

  /// < The scroll direction is flipped / natural
  static const int SDL_MOUSEWHEEL_FLIPPED = 1;
}

/// The joystick structure used to identify an SDL joystick
class _SDL_Joystick extends ffi.Opaque {}

class SDL_JoystickGUID extends ffi.Opaque {}

abstract class SDL_JoystickType {
  static const int SDL_JOYSTICK_TYPE_UNKNOWN = 0;
  static const int SDL_JOYSTICK_TYPE_GAMECONTROLLER = 1;
  static const int SDL_JOYSTICK_TYPE_WHEEL = 2;
  static const int SDL_JOYSTICK_TYPE_ARCADE_STICK = 3;
  static const int SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4;
  static const int SDL_JOYSTICK_TYPE_DANCE_PAD = 5;
  static const int SDL_JOYSTICK_TYPE_GUITAR = 6;
  static const int SDL_JOYSTICK_TYPE_DRUM_KIT = 7;
  static const int SDL_JOYSTICK_TYPE_ARCADE_PAD = 8;
  static const int SDL_JOYSTICK_TYPE_THROTTLE = 9;
}

abstract class SDL_JoystickPowerLevel {
  static const int SDL_JOYSTICK_POWER_UNKNOWN = -1;
  static const int SDL_JOYSTICK_POWER_EMPTY = 0;
  static const int SDL_JOYSTICK_POWER_LOW = 1;
  static const int SDL_JOYSTICK_POWER_MEDIUM = 2;
  static const int SDL_JOYSTICK_POWER_FULL = 3;
  static const int SDL_JOYSTICK_POWER_WIRED = 4;
  static const int SDL_JOYSTICK_POWER_MAX = 5;
}

/// \brief SDL_sensor.h
///
/// In order to use these functions, SDL_Init() must have been called
/// with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system
/// for sensors, and load appropriate drivers.
class _SDL_Sensor extends ffi.Opaque {}

abstract class SDL_SensorType {
  /// < Returned for an invalid sensor
  static const int SDL_SENSOR_INVALID = -1;

  /// < Unknown sensor type
  static const int SDL_SENSOR_UNKNOWN = 0;

  /// < Accelerometer
  static const int SDL_SENSOR_ACCEL = 1;

  /// < Gyroscope
  static const int SDL_SENSOR_GYRO = 2;
}

/// The gamecontroller structure used to identify an SDL game controller
class _SDL_GameController extends ffi.Opaque {}

abstract class SDL_GameControllerType {
  static const int SDL_CONTROLLER_TYPE_UNKNOWN = 0;
  static const int SDL_CONTROLLER_TYPE_XBOX360 = 1;
  static const int SDL_CONTROLLER_TYPE_XBOXONE = 2;
  static const int SDL_CONTROLLER_TYPE_PS3 = 3;
  static const int SDL_CONTROLLER_TYPE_PS4 = 4;
  static const int SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO = 5;
  static const int SDL_CONTROLLER_TYPE_VIRTUAL = 6;
  static const int SDL_CONTROLLER_TYPE_PS5 = 7;
}

abstract class SDL_GameControllerBindType {
  static const int SDL_CONTROLLER_BINDTYPE_NONE = 0;
  static const int SDL_CONTROLLER_BINDTYPE_BUTTON = 1;
  static const int SDL_CONTROLLER_BINDTYPE_AXIS = 2;
  static const int SDL_CONTROLLER_BINDTYPE_HAT = 3;
}

/// Get the SDL joystick layer binding for this controller button/axis mapping
class SDL_GameControllerButtonBind extends ffi.Opaque {}

/// The list of axes available from a controller
///
/// Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,
/// and are centered within ~8000 of zero, though advanced UI will allow users to set
/// or autodetect the dead zone, which varies between controllers.
///
/// Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX.
abstract class SDL_GameControllerAxis {
  static const int SDL_CONTROLLER_AXIS_INVALID = -1;
  static const int SDL_CONTROLLER_AXIS_LEFTX = 0;
  static const int SDL_CONTROLLER_AXIS_LEFTY = 1;
  static const int SDL_CONTROLLER_AXIS_RIGHTX = 2;
  static const int SDL_CONTROLLER_AXIS_RIGHTY = 3;
  static const int SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4;
  static const int SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5;
  static const int SDL_CONTROLLER_AXIS_MAX = 6;
}

/// The list of buttons available from a controller
abstract class SDL_GameControllerButton {
  static const int SDL_CONTROLLER_BUTTON_INVALID = -1;
  static const int SDL_CONTROLLER_BUTTON_A = 0;
  static const int SDL_CONTROLLER_BUTTON_B = 1;
  static const int SDL_CONTROLLER_BUTTON_X = 2;
  static const int SDL_CONTROLLER_BUTTON_Y = 3;
  static const int SDL_CONTROLLER_BUTTON_BACK = 4;
  static const int SDL_CONTROLLER_BUTTON_GUIDE = 5;
  static const int SDL_CONTROLLER_BUTTON_START = 6;
  static const int SDL_CONTROLLER_BUTTON_LEFTSTICK = 7;
  static const int SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8;
  static const int SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9;
  static const int SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10;
  static const int SDL_CONTROLLER_BUTTON_DPAD_UP = 11;
  static const int SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12;
  static const int SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13;
  static const int SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14;
  static const int SDL_CONTROLLER_BUTTON_MISC1 = 15;
  static const int SDL_CONTROLLER_BUTTON_PADDLE1 = 16;
  static const int SDL_CONTROLLER_BUTTON_PADDLE2 = 17;
  static const int SDL_CONTROLLER_BUTTON_PADDLE3 = 18;
  static const int SDL_CONTROLLER_BUTTON_PADDLE4 = 19;
  static const int SDL_CONTROLLER_BUTTON_TOUCHPAD = 20;
  static const int SDL_CONTROLLER_BUTTON_MAX = 21;
}

abstract class SDL_TouchDeviceType {
  static const int SDL_TOUCH_DEVICE_INVALID = -1;
  static const int SDL_TOUCH_DEVICE_DIRECT = 0;
  static const int SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1;
  static const int SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2;
}

class SDL_Finger extends ffi.Struct {
  @ffi.Int64()
  external int id;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double pressure;
}

/// \brief The types of events that can be delivered.
abstract class SDL_EventType {
  /// < Unused (do not remove)
  static const int SDL_FIRSTEVENT = 0;

  /// < User-requested quit
  static const int SDL_QUIT = 256;

  /// < The application is being terminated by the OS
  /// Called on iOS in applicationWillTerminate()
  /// Called on Android in onDestroy()
  static const int SDL_APP_TERMINATING = 257;

  /// < The application is low on memory, free memory if possible.
  /// Called on iOS in applicationDidReceiveMemoryWarning()
  /// Called on Android in onLowMemory()
  static const int SDL_APP_LOWMEMORY = 258;

  /// < The application is about to enter the background
  /// Called on iOS in applicationWillResignActive()
  /// Called on Android in onPause()
  static const int SDL_APP_WILLENTERBACKGROUND = 259;

  /// < The application did enter the background and may not get CPU for some time
  /// Called on iOS in applicationDidEnterBackground()
  /// Called on Android in onPause()
  static const int SDL_APP_DIDENTERBACKGROUND = 260;

  /// < The application is about to enter the foreground
  /// Called on iOS in applicationWillEnterForeground()
  /// Called on Android in onResume()
  static const int SDL_APP_WILLENTERFOREGROUND = 261;

  /// < The application is now interactive
  /// Called on iOS in applicationDidBecomeActive()
  /// Called on Android in onResume()
  static const int SDL_APP_DIDENTERFOREGROUND = 262;

  /// < The user's locale preferences have changed.
  static const int SDL_LOCALECHANGED = 263;

  /// < Display state change
  static const int SDL_DISPLAYEVENT = 336;

  /// < Window state change
  static const int SDL_WINDOWEVENT = 512;

  /// < System specific event
  static const int SDL_SYSWMEVENT = 513;

  /// < Key pressed
  static const int SDL_KEYDOWN = 768;

  /// < Key released
  static const int SDL_KEYUP = 769;

  /// < Keyboard text editing (composition)
  static const int SDL_TEXTEDITING = 770;

  /// < Keyboard text input
  static const int SDL_TEXTINPUT = 771;

  /// < Keymap changed due to a system event such as an
  /// input language or keyboard layout change.
  static const int SDL_KEYMAPCHANGED = 772;

  /// < Mouse moved
  static const int SDL_MOUSEMOTION = 1024;

  /// < Mouse button pressed
  static const int SDL_MOUSEBUTTONDOWN = 1025;

  /// < Mouse button released
  static const int SDL_MOUSEBUTTONUP = 1026;

  /// < Mouse wheel motion
  static const int SDL_MOUSEWHEEL = 1027;

  /// < Joystick axis motion
  static const int SDL_JOYAXISMOTION = 1536;

  /// < Joystick trackball motion
  static const int SDL_JOYBALLMOTION = 1537;

  /// < Joystick hat position change
  static const int SDL_JOYHATMOTION = 1538;

  /// < Joystick button pressed
  static const int SDL_JOYBUTTONDOWN = 1539;

  /// < Joystick button released
  static const int SDL_JOYBUTTONUP = 1540;

  /// < A new joystick has been inserted into the system
  static const int SDL_JOYDEVICEADDED = 1541;

  /// < An opened joystick has been removed
  static const int SDL_JOYDEVICEREMOVED = 1542;

  /// < Game controller axis motion
  static const int SDL_CONTROLLERAXISMOTION = 1616;

  /// < Game controller button pressed
  static const int SDL_CONTROLLERBUTTONDOWN = 1617;

  /// < Game controller button released
  static const int SDL_CONTROLLERBUTTONUP = 1618;

  /// < A new Game controller has been inserted into the system
  static const int SDL_CONTROLLERDEVICEADDED = 1619;

  /// < An opened Game controller has been removed
  static const int SDL_CONTROLLERDEVICEREMOVED = 1620;

  /// < The controller mapping was updated
  static const int SDL_CONTROLLERDEVICEREMAPPED = 1621;

  /// < Game controller touchpad was touched
  static const int SDL_CONTROLLERTOUCHPADDOWN = 1622;

  /// < Game controller touchpad finger was moved
  static const int SDL_CONTROLLERTOUCHPADMOTION = 1623;

  /// < Game controller touchpad finger was lifted
  static const int SDL_CONTROLLERTOUCHPADUP = 1624;

  /// < Game controller sensor was updated
  static const int SDL_CONTROLLERSENSORUPDATE = 1625;
  static const int SDL_FINGERDOWN = 1792;
  static const int SDL_FINGERUP = 1793;
  static const int SDL_FINGERMOTION = 1794;
  static const int SDL_DOLLARGESTURE = 2048;
  static const int SDL_DOLLARRECORD = 2049;
  static const int SDL_MULTIGESTURE = 2050;

  /// < The clipboard changed
  static const int SDL_CLIPBOARDUPDATE = 2304;

  /// < The system requests a file open
  static const int SDL_DROPFILE = 4096;

  /// < text/plain drag-and-drop event
  static const int SDL_DROPTEXT = 4097;

  /// < A new set of drops is beginning (NULL filename)
  static const int SDL_DROPBEGIN = 4098;

  /// < Current set of drops is now complete (NULL filename)
  static const int SDL_DROPCOMPLETE = 4099;

  /// < A new audio device is available
  static const int SDL_AUDIODEVICEADDED = 4352;

  /// < An audio device has been removed.
  static const int SDL_AUDIODEVICEREMOVED = 4353;

  /// < A sensor was updated
  static const int SDL_SENSORUPDATE = 4608;

  /// < The render targets have been reset and their contents need to be updated
  static const int SDL_RENDER_TARGETS_RESET = 8192;

  /// < The device has been reset and all textures need to be recreated
  static const int SDL_RENDER_DEVICE_RESET = 8193;

  /// Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
  /// and should be allocated with SDL_RegisterEvents()
  static const int SDL_USEREVENT = 32768;

  /// This last event is only for bounding internal arrays
  static const int SDL_LASTEVENT = 65535;
}

/// \brief Fields shared by every event
class SDL_CommonEvent extends ffi.Struct {
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;
}

/// \brief Display state change event data (event.display.*)
class SDL_DisplayEvent extends ffi.Struct {
  /// < ::SDL_DISPLAYEVENT
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The associated display index
  @ffi.Uint32()
  external int display;

  /// < ::SDL_DisplayEventID
  @ffi.Uint8()
  external int event;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;

  /// < event dependent data
  @ffi.Int32()
  external int data1;
}

/// \brief Window state change event data (event.window.*)
class SDL_WindowEvent extends ffi.Struct {
  /// < ::SDL_WINDOWEVENT
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The associated window
  @ffi.Uint32()
  external int windowID;

  /// < ::SDL_WindowEventID
  @ffi.Uint8()
  external int event;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;

  /// < event dependent data
  @ffi.Int32()
  external int data1;

  /// < event dependent data
  @ffi.Int32()
  external int data2;
}

/// \brief Keyboard button event structure (event.key.*)
class SDL_KeyboardEvent extends ffi.Struct {
  /// < ::SDL_KEYDOWN or ::SDL_KEYUP
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The window with keyboard focus, if any
  @ffi.Uint32()
  external int windowID;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @ffi.Uint8()
  external int state;

  /// < Non-zero if this is a key repeat
  @ffi.Uint8()
  external int repeat;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;

  /// < The key that was pressed or released
  external SDL_Keysym keysym;
}

/// \brief Keyboard text editing event structure (event.edit.*)
class SDL_TextEditingEvent extends ffi.Opaque {}

/// \brief Keyboard text input event structure (event.text.*)
class SDL_TextInputEvent extends ffi.Opaque {}

/// \brief Mouse motion event structure (event.motion.*)
class SDL_MouseMotionEvent extends ffi.Struct {
  /// < ::SDL_MOUSEMOTION
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @ffi.Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @ffi.Uint32()
  external int which;

  /// < The current button state
  @ffi.Uint32()
  external int state;

  /// < X coordinate, relative to window
  @ffi.Int32()
  external int x;

  /// < Y coordinate, relative to window
  @ffi.Int32()
  external int y;

  /// < The relative motion in the X direction
  @ffi.Int32()
  external int xrel;

  /// < The relative motion in the Y direction
  @ffi.Int32()
  external int yrel;
}

/// \brief Mouse button event structure (event.button.*)
class SDL_MouseButtonEvent extends ffi.Struct {
  /// < ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @ffi.Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @ffi.Uint32()
  external int which;

  /// < The mouse button index
  @ffi.Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @ffi.Uint8()
  external int state;

  /// < 1 for single-click, 2 for double-click, etc.
  @ffi.Uint8()
  external int clicks;

  @ffi.Uint8()
  external int padding1;

  /// < X coordinate, relative to window
  @ffi.Int32()
  external int x;

  /// < Y coordinate, relative to window
  @ffi.Int32()
  external int y;
}

/// \brief Mouse wheel event structure (event.wheel.*)
class SDL_MouseWheelEvent extends ffi.Struct {
  /// < ::SDL_MOUSEWHEEL
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The window with mouse focus, if any
  @ffi.Uint32()
  external int windowID;

  /// < The mouse instance id, or SDL_TOUCH_MOUSEID
  @ffi.Uint32()
  external int which;

  /// < The amount scrolled horizontally, positive to the right and negative to the left
  @ffi.Int32()
  external int x;

  /// < The amount scrolled vertically, positive away from the user and negative toward the user
  @ffi.Int32()
  external int y;

  /// < Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back
  @ffi.Uint32()
  external int direction;
}

/// \brief Joystick axis motion event structure (event.jaxis.*)
class SDL_JoyAxisEvent extends ffi.Struct {
  /// < ::SDL_JOYAXISMOTION
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The joystick axis index
  @ffi.Uint8()
  external int axis;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @ffi.Int16()
  external int value;

  @ffi.Uint16()
  external int padding4;
}

/// \brief Joystick trackball motion event structure (event.jball.*)
class SDL_JoyBallEvent extends ffi.Struct {
  /// < ::SDL_JOYBALLMOTION
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The joystick trackball index
  @ffi.Uint8()
  external int ball;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;

  /// < The relative motion in the X direction
  @ffi.Int16()
  external int xrel;

  /// < The relative motion in the Y direction
  @ffi.Int16()
  external int yrel;
}

/// \brief Joystick hat position change event structure (event.jhat.*)
class SDL_JoyHatEvent extends ffi.Struct {
  /// < ::SDL_JOYHATMOTION
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The joystick hat index
  @ffi.Uint8()
  external int hat;

  /// < The hat position value.
  /// \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
  /// \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
  /// \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
  ///
  /// Note that zero means the POV is centered.
  @ffi.Uint8()
  external int value;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;
}

/// \brief Joystick button event structure (event.jbutton.*)
class SDL_JoyButtonEvent extends ffi.Struct {
  /// < ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The joystick button index
  @ffi.Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @ffi.Uint8()
  external int state;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;
}

/// \brief Joystick device event structure (event.jdevice.*)
class SDL_JoyDeviceEvent extends ffi.Struct {
  /// < ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED event
  @ffi.Int32()
  external int which;
}

/// \brief Game controller axis motion event structure (event.caxis.*)
class SDL_ControllerAxisEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERAXISMOTION
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The controller axis (SDL_GameControllerAxis)
  @ffi.Uint8()
  external int axis;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;

  /// < The axis value (range: -32768 to 32767)
  @ffi.Int16()
  external int value;

  @ffi.Uint16()
  external int padding4;
}

/// \brief Game controller button event structure (event.cbutton.*)
class SDL_ControllerButtonEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The controller button (SDL_GameControllerButton)
  @ffi.Uint8()
  external int button;

  /// < ::SDL_PRESSED or ::SDL_RELEASED
  @ffi.Uint8()
  external int state;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;
}

/// \brief Controller device event structure (event.cdevice.*)
class SDL_ControllerDeviceEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event
  @ffi.Int32()
  external int which;
}

/// \brief Game controller touchpad event structure (event.ctouchpad.*)
class SDL_ControllerTouchpadEvent extends ffi.Struct {
  /// < ::SDL_CONTROLLERTOUCHPADDOWN or ::SDL_CONTROLLERTOUCHPADMOTION or ::SDL_CONTROLLERTOUCHPADUP
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The joystick instance id
  @ffi.Int32()
  external int which;

  /// < The index of the touchpad
  @ffi.Int32()
  external int touchpad;

  /// < The index of the finger on the touchpad
  @ffi.Int32()
  external int finger;

  /// < Normalized in the range 0...1 with 0 being on the left
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1 with 0 being at the top
  @ffi.Float()
  external double y;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;
}

/// \brief Game controller sensor event structure (event.csensor.*)
class SDL_ControllerSensorEvent extends ffi.Opaque {}

/// \brief Audio device event structure (event.adevice.*)
class SDL_AudioDeviceEvent extends ffi.Struct {
  /// < ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event
  @ffi.Uint32()
  external int which;

  /// < zero if an output device, non-zero if a capture device.
  @ffi.Uint8()
  external int iscapture;

  @ffi.Uint8()
  external int padding1;

  @ffi.Uint8()
  external int padding2;

  @ffi.Uint8()
  external int padding3;
}

/// \brief Touch finger event structure (event.tfinger.*)
class SDL_TouchFingerEvent extends ffi.Struct {
  /// < ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The touch device id
  @ffi.Int64()
  external int touchId;

  @ffi.Int64()
  external int fingerId;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double x;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double y;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dx;

  /// < Normalized in the range -1...1
  @ffi.Float()
  external double dy;

  /// < Normalized in the range 0...1
  @ffi.Float()
  external double pressure;

  /// < The window underneath the finger, if any
  @ffi.Uint32()
  external int windowID;
}

/// \brief Multiple Finger Gesture Event (event.mgesture.*)
class SDL_MultiGestureEvent extends ffi.Struct {
  /// < ::SDL_MULTIGESTURE
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The touch device id
  @ffi.Int64()
  external int touchId;

  @ffi.Float()
  external double dTheta;

  @ffi.Float()
  external double dDist;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Uint16()
  external int numFingers;

  @ffi.Uint16()
  external int padding;
}

/// \brief Dollar Gesture Event (event.dgesture.*)
class SDL_DollarGestureEvent extends ffi.Struct {
  /// < ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The touch device id
  @ffi.Int64()
  external int touchId;

  @ffi.Int64()
  external int gestureId;

  @ffi.Uint32()
  external int numFingers;

  @ffi.Float()
  external double error;

  /// < Normalized center of gesture
  @ffi.Float()
  external double x;

  /// < Normalized center of gesture
  @ffi.Float()
  external double y;
}

/// \brief An event used to request a file open by the system (event.drop.*)
/// This event is enabled by default, you can disable it with SDL_EventState().
/// \note If this event is enabled, you must free the filename in the event.
class SDL_DropEvent extends ffi.Struct {
  /// < ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The file name, which should be freed with SDL_free(), is NULL on begin/complete
  external ffi.Pointer<ffi.Int8> file;

  /// < The window that was dropped on, if any
  @ffi.Uint32()
  external int windowID;
}

/// \brief Sensor event structure (event.sensor.*)
class SDL_SensorEvent extends ffi.Opaque {}

/// \brief The "quit requested" event
class SDL_QuitEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;
}

/// \brief OS Specific event
class SDL_OSEvent extends ffi.Struct {
  /// < ::SDL_QUIT
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;
}

/// \brief A user-defined event type (event.user.*)
class SDL_UserEvent extends ffi.Struct {
  /// < ::SDL_USEREVENT through ::SDL_LASTEVENT-1
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < The associated window if any
  @ffi.Uint32()
  external int windowID;

  /// < User defined event code
  @ffi.Int32()
  external int code;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data1;

  /// < User defined data pointer
  external ffi.Pointer<ffi.Void> data2;
}

class SDL_SysWMmsg extends ffi.Opaque {}

/// \brief A video driver dependent system event (event.syswm.*)
/// This event is disabled by default, you can enable it with SDL_EventState()
///
/// \note If you want to use this event, you should include SDL_syswm.h.
class SDL_SysWMEvent extends ffi.Struct {
  /// < ::SDL_SYSWMEVENT
  @ffi.Uint32()
  external int type;

  /// < In milliseconds, populated using SDL_GetTicks()
  @ffi.Uint32()
  external int timestamp;

  /// < driver dependent data, defined in SDL_syswm.h
  external ffi.Pointer<SDL_SysWMmsg> msg;
}

abstract class SDL_eventaction {
  static const int SDL_ADDEVENT = 0;
  static const int SDL_PEEKEVENT = 1;
  static const int SDL_GETEVENT = 2;
}

/// \typedef SDL_Haptic
///
/// \brief The haptic structure used to identify an SDL haptic.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticOpenFromJoystick
/// \sa SDL_HapticClose
class _SDL_Haptic extends ffi.Opaque {}

/// \brief Structure that represents a haptic direction.
///
/// This is the direction where the force comes from,
/// instead of the direction in which the force is exerted.
///
/// Directions can be specified by:
/// - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
/// - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
/// - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
///
/// Cardinal directions of the haptic device are relative to the positioning
/// of the device.  North is considered to be away from the user.
///
/// The following diagram represents the cardinal directions:
/// \verbatim
/// .--.
/// |__| .-------.
/// |=.| |.-----.|
/// |--| ||     ||
/// |  | |'-----'|
/// |__|~')_____('
/// [ COMPUTER ]
///
///
/// North (0,-1)
/// ^
/// |
/// |
/// (-1,0)  West <----[ HAPTIC ]----> East (1,0)
/// |
/// |
/// v
/// South (0,1)
///
///
/// [ USER ]
/// \|||/
/// (o o)
/// ---ooO-(_)-Ooo---
/// \endverbatim
///
/// If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
/// degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
/// the first \c dir parameter.  The cardinal directions would be:
/// - North: 0 (0 degrees)
/// - East: 9000 (90 degrees)
/// - South: 18000 (180 degrees)
/// - West: 27000 (270 degrees)
///
/// If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
/// (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
/// the first three \c dir parameters.  The cardinal directions would be:
/// - North:  0,-1, 0
/// - East:   1, 0, 0
/// - South:  0, 1, 0
/// - West:  -1, 0, 0
///
/// The Z axis represents the height of the effect if supported, otherwise
/// it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
/// can use any multiple you want, only the direction matters.
///
/// If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
/// The first two \c dir parameters are used.  The \c dir parameters are as
/// follows (all values are in hundredths of degrees):
/// - Degrees from (1, 0) rotated towards (0, 1).
/// - Degrees towards (0, 0, 1) (device needs at least 3 axes).
///
///
/// Example of force coming from the south with all encodings (force coming
/// from the south means the user will have to pull the stick to counteract):
/// \code
/// SDL_HapticDirection direction;
///
/// // Cartesian directions
/// direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
/// direction.dir[0] = 0; // X position
/// direction.dir[1] = 1; // Y position
/// // Assuming the device has 2 axes, we don't need to specify third parameter.
///
/// // Polar directions
/// direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
/// direction.dir[0] = 18000; // Polar only uses first parameter
///
/// // Spherical coordinates
/// direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
/// direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
/// \endcode
///
/// \sa SDL_HAPTIC_POLAR
/// \sa SDL_HAPTIC_CARTESIAN
/// \sa SDL_HAPTIC_SPHERICAL
/// \sa SDL_HAPTIC_STEERING_AXIS
/// \sa SDL_HapticEffect
/// \sa SDL_HapticNumAxes
class SDL_HapticDirection extends ffi.Opaque {}

/// \brief A structure containing a template for a Constant effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.
///
/// A constant effect applies a constant force in the specified direction
/// to the joystick.
///
/// \sa SDL_HAPTIC_CONSTANT
/// \sa SDL_HapticEffect
class SDL_HapticConstant extends ffi.Opaque {}

/// \brief A structure containing a template for a Periodic effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SINE
/// - ::SDL_HAPTIC_LEFTRIGHT
/// - ::SDL_HAPTIC_TRIANGLE
/// - ::SDL_HAPTIC_SAWTOOTHUP
/// - ::SDL_HAPTIC_SAWTOOTHDOWN
///
/// A periodic effect consists in a wave-shaped effect that repeats itself
/// over time.  The type determines the shape of the wave and the parameters
/// determine the dimensions of the wave.
///
/// Phase is given by hundredth of a degree meaning that giving the phase a value
/// of 9000 will displace it 25% of its period.  Here are sample values:
/// -     0: No phase displacement.
/// -  9000: Displaced 25% of its period.
/// - 18000: Displaced 50% of its period.
/// - 27000: Displaced 75% of its period.
/// - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
///
/// Examples:
/// \verbatim
/// SDL_HAPTIC_SINE
/// __      __      __      __
/// /  \    /  \    /  \    /
/// /    \__/    \__/    \__/
///
/// SDL_HAPTIC_SQUARE
/// __    __    __    __    __
/// |  |  |  |  |  |  |  |  |  |
/// |  |__|  |__|  |__|  |__|  |
///
/// SDL_HAPTIC_TRIANGLE
/// /\    /\    /\    /\    /\
/// /  \  /  \  /  \  /  \  /
/// /    \/    \/    \/    \/
///
/// SDL_HAPTIC_SAWTOOTHUP
/// /|  /|  /|  /|  /|  /|  /|
/// / | / | / | / | / | / | / |
/// /  |/  |/  |/  |/  |/  |/  |
///
/// SDL_HAPTIC_SAWTOOTHDOWN
/// \  |\  |\  |\  |\  |\  |\  |
/// \ | \ | \ | \ | \ | \ | \ |
/// \|  \|  \|  \|  \|  \|  \|
/// \endverbatim
///
/// \sa SDL_HAPTIC_SINE
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HAPTIC_TRIANGLE
/// \sa SDL_HAPTIC_SAWTOOTHUP
/// \sa SDL_HAPTIC_SAWTOOTHDOWN
/// \sa SDL_HapticEffect
class SDL_HapticPeriodic extends ffi.Opaque {}

/// \brief A structure containing a template for a Condition effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SPRING: Effect based on axes position.
/// - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
/// - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
/// - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
///
/// Direction is handled by condition internals instead of a direction member.
/// The condition effect specific members have three parameters.  The first
/// refers to the X axis, the second refers to the Y axis and the third
/// refers to the Z axis.  The right terms refer to the positive side of the
/// axis and the left terms refer to the negative side of the axis.  Please
/// refer to the ::SDL_HapticDirection diagram for which side is positive and
/// which is negative.
///
/// \sa SDL_HapticDirection
/// \sa SDL_HAPTIC_SPRING
/// \sa SDL_HAPTIC_DAMPER
/// \sa SDL_HAPTIC_INERTIA
/// \sa SDL_HAPTIC_FRICTION
/// \sa SDL_HapticEffect
class SDL_HapticCondition extends ffi.Opaque {}

/// \brief A structure containing a template for a Ramp effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
///
/// The ramp effect starts at start strength and ends at end strength.
/// It augments in linear fashion.  If you use attack and fade with a ramp
/// the effects get added to the ramp effect making the effect become
/// quadratic instead of linear.
///
/// \sa SDL_HAPTIC_RAMP
/// \sa SDL_HapticEffect
class SDL_HapticRamp extends ffi.Opaque {}

/// \brief A structure containing a template for a Left/Right effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
///
/// The Left/Right effect is used to explicitly control the large and small
/// motors, commonly found in modern game controllers. The small (right) motor
/// is high frequency, and the large (left) motor is low frequency.
///
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HapticEffect
class SDL_HapticLeftRight extends ffi.Struct {
  /// < ::SDL_HAPTIC_LEFTRIGHT
  @ffi.Uint16()
  external int type;

  /// < Duration of the effect in milliseconds.
  @ffi.Uint32()
  external int length;

  /// < Control of the large controller motor.
  @ffi.Uint16()
  external int large_magnitude;

  /// < Control of the small controller motor.
  @ffi.Uint16()
  external int small_magnitude;
}

/// \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.
///
/// A custom force feedback effect is much like a periodic effect, where the
/// application can define its exact shape.  You will have to allocate the
/// data yourself.  Data should consist of channels * samples Uint16 samples.
///
/// If channels is one, the effect is rotated using the defined direction.
/// Otherwise it uses the samples in data for the different axes.
///
/// \sa SDL_HAPTIC_CUSTOM
/// \sa SDL_HapticEffect
class SDL_HapticCustom extends ffi.Opaque {}

/// \brief  An enumeration of hint priorities
abstract class SDL_HintPriority {
  static const int SDL_HINT_DEFAULT = 0;
  static const int SDL_HINT_NORMAL = 1;
  static const int SDL_HINT_OVERRIDE = 2;
}

/// \brief The predefined log categories
///
/// By default the application category is enabled at the INFO level,
/// the assert category is enabled at the WARN level, test is enabled
/// at the VERBOSE level and all other categories are enabled at the
/// CRITICAL level.
abstract class SDL_LogCategory {
  static const int SDL_LOG_CATEGORY_APPLICATION = 0;
  static const int SDL_LOG_CATEGORY_ERROR = 1;
  static const int SDL_LOG_CATEGORY_ASSERT = 2;
  static const int SDL_LOG_CATEGORY_SYSTEM = 3;
  static const int SDL_LOG_CATEGORY_AUDIO = 4;
  static const int SDL_LOG_CATEGORY_VIDEO = 5;
  static const int SDL_LOG_CATEGORY_RENDER = 6;
  static const int SDL_LOG_CATEGORY_INPUT = 7;
  static const int SDL_LOG_CATEGORY_TEST = 8;
  static const int SDL_LOG_CATEGORY_RESERVED1 = 9;
  static const int SDL_LOG_CATEGORY_RESERVED2 = 10;
  static const int SDL_LOG_CATEGORY_RESERVED3 = 11;
  static const int SDL_LOG_CATEGORY_RESERVED4 = 12;
  static const int SDL_LOG_CATEGORY_RESERVED5 = 13;
  static const int SDL_LOG_CATEGORY_RESERVED6 = 14;
  static const int SDL_LOG_CATEGORY_RESERVED7 = 15;
  static const int SDL_LOG_CATEGORY_RESERVED8 = 16;
  static const int SDL_LOG_CATEGORY_RESERVED9 = 17;
  static const int SDL_LOG_CATEGORY_RESERVED10 = 18;
  static const int SDL_LOG_CATEGORY_CUSTOM = 19;
}

/// \brief The predefined log priorities
abstract class SDL_LogPriority {
  static const int SDL_LOG_PRIORITY_VERBOSE = 1;
  static const int SDL_LOG_PRIORITY_DEBUG = 2;
  static const int SDL_LOG_PRIORITY_INFO = 3;
  static const int SDL_LOG_PRIORITY_WARN = 4;
  static const int SDL_LOG_PRIORITY_ERROR = 5;
  static const int SDL_LOG_PRIORITY_CRITICAL = 6;
  static const int SDL_NUM_LOG_PRIORITIES = 7;
}

/// \brief SDL_MessageBox flags. If supported will display warning icon, etc.
abstract class SDL_MessageBoxFlags {
  /// < error dialog
  static const int SDL_MESSAGEBOX_ERROR = 16;

  /// < warning dialog
  static const int SDL_MESSAGEBOX_WARNING = 32;

  /// < informational dialog
  static const int SDL_MESSAGEBOX_INFORMATION = 64;

  /// < buttons placed left to right
  static const int SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = 128;

  /// < buttons placed right to left
  static const int SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = 256;
}

/// \brief Flags for SDL_MessageBoxButtonData.
abstract class SDL_MessageBoxButtonFlags {
  /// < Marks the default button when return is hit
  static const int SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1;

  /// < Marks the default button when escape is hit
  static const int SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2;
}

/// \brief Individual button data.
class SDL_MessageBoxButtonData extends ffi.Struct {
  /// < ::SDL_MessageBoxButtonFlags
  @ffi.Uint32()
  external int flags;

  /// < User defined button id (value returned via SDL_ShowMessageBox)
  @ffi.Int32()
  external int buttonid;

  /// < The UTF-8 button text
  external ffi.Pointer<ffi.Int8> text;
}

/// \brief RGB value used in a message box color scheme
class SDL_MessageBoxColor extends ffi.Struct {
  @ffi.Uint8()
  external int r;

  @ffi.Uint8()
  external int g;

  @ffi.Uint8()
  external int b;
}

abstract class SDL_MessageBoxColorType {
  static const int SDL_MESSAGEBOX_COLOR_BACKGROUND = 0;
  static const int SDL_MESSAGEBOX_COLOR_TEXT = 1;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3;
  static const int SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4;
  static const int SDL_MESSAGEBOX_COLOR_MAX = 5;
}

/// \brief A set of colors to use for message box dialogs
class SDL_MessageBoxColorScheme extends ffi.Opaque {}

/// \brief MessageBox structure containing title, text, window, etc.
class SDL_MessageBoxData extends ffi.Struct {
  /// < ::SDL_MessageBoxFlags
  @ffi.Uint32()
  external int flags;

  /// < Parent window, can be NULL
  external ffi.Pointer<SDL_Window> window;

  /// < UTF-8 title
  external ffi.Pointer<ffi.Int8> title;

  /// < UTF-8 message text
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int numbuttons;

  external ffi.Pointer<SDL_MessageBoxButtonData> buttons;

  /// < ::SDL_MessageBoxColorScheme, can be NULL to use system settings
  external ffi.Pointer<SDL_MessageBoxColorScheme> colorScheme;
}

/// \brief The basic state for the system's power supply.
abstract class SDL_PowerState {
  /// < cannot determine power status
  static const int SDL_POWERSTATE_UNKNOWN = 0;

  /// < Not plugged in, running on the battery
  static const int SDL_POWERSTATE_ON_BATTERY = 1;

  /// < Plugged in, no battery available
  static const int SDL_POWERSTATE_NO_BATTERY = 2;

  /// < Plugged in, charging battery
  static const int SDL_POWERSTATE_CHARGING = 3;

  /// < Plugged in, battery charged
  static const int SDL_POWERSTATE_CHARGED = 4;
}

/// \brief Flags used when creating a rendering context
abstract class SDL_RendererFlags {
  /// < The renderer is a software fallback
  static const int SDL_RENDERER_SOFTWARE = 1;

  /// < The renderer uses hardware
  /// acceleration
  static const int SDL_RENDERER_ACCELERATED = 2;

  /// < Present is synchronized
  /// with the refresh rate
  static const int SDL_RENDERER_PRESENTVSYNC = 4;

  /// < The renderer supports
  /// rendering to texture
  static const int SDL_RENDERER_TARGETTEXTURE = 8;
}

/// \brief Information on the capabilities of a render driver or context.
class SDL_RendererInfo extends ffi.Opaque {}

/// \brief The scaling mode for a texture.
abstract class SDL_ScaleMode {
  /// < nearest pixel sampling
  static const int SDL_ScaleModeNearest = 0;

  /// < linear filtering
  static const int SDL_ScaleModeLinear = 1;

  /// < anisotropic filtering
  static const int SDL_ScaleModeBest = 2;
}

/// \brief The access pattern allowed for a texture.
abstract class SDL_TextureAccess {
  /// < Changes rarely, not lockable
  static const int SDL_TEXTUREACCESS_STATIC = 0;

  /// < Changes frequently, lockable
  static const int SDL_TEXTUREACCESS_STREAMING = 1;

  /// < Texture can be used as a render target
  static const int SDL_TEXTUREACCESS_TARGET = 2;
}

/// \brief The texture channel modulation used in SDL_RenderCopy().
abstract class SDL_TextureModulate {
  /// < No modulation
  static const int SDL_TEXTUREMODULATE_NONE = 0;

  /// < srcC = srcC * color
  static const int SDL_TEXTUREMODULATE_COLOR = 1;

  /// < srcA = srcA * alpha
  static const int SDL_TEXTUREMODULATE_ALPHA = 2;
}

/// \brief Flip constants for SDL_RenderCopyEx
abstract class SDL_RendererFlip {
  /// < Do not flip
  static const int SDL_FLIP_NONE = 0;

  /// < flip horizontally
  static const int SDL_FLIP_HORIZONTAL = 1;

  /// < flip vertically
  static const int SDL_FLIP_VERTICAL = 2;
}

/// \brief A structure representing rendering state
class SDL_Renderer extends ffi.Opaque {}

/// \brief An efficient driver-specific representation of pixel data
class SDL_Texture extends ffi.Opaque {}

/// \brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union.
abstract class WindowShapeMode {
  /// \brief The default mode, a binarized alpha cutoff of 1.
  static const int ShapeModeDefault = 0;

  /// \brief A binarized alpha cutoff with a given integer value.
  static const int ShapeModeBinarizeAlpha = 1;

  /// \brief A binarized alpha cutoff with a given integer value, but with the opposite comparison.
  static const int ShapeModeReverseBinarizeAlpha = 2;

  /// \brief A color key is applied.
  static const int ShapeModeColorKey = 3;
}

/// \brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents.
class SDL_WindowShapeMode extends ffi.Opaque {}

class IDirect3DDevice9 extends ffi.Opaque {}

/// \brief Information the version of SDL in use.
///
/// Represents the library's version as three levels: major revision
/// (increments with massive changes, additions, and enhancements),
/// minor revision (increments with backwards-compatible changes to the
/// major revision), and patchlevel (increments with fixes to the minor
/// revision).
///
/// \sa SDL_VERSION
/// \sa SDL_GetVersion
class SDL_version extends ffi.Struct {
  /// < major version
  @ffi.Uint8()
  external int major;

  /// < minor version
  @ffi.Uint8()
  external int minor;

  /// < update version
  @ffi.Uint8()
  external int patch;
}

class SDL_Locale extends ffi.Struct {
  /// < A language name, like "en" for English.
  external ffi.Pointer<ffi.Int8> language;

  /// < A country, like "US" for America. Can be NULL.
  external ffi.Pointer<ffi.Int8> country;
}

const int HAVE_WINAPIFAMILY_H = 1;

const int WINAPI_PARTITION_SERVER = 0;

const int WINAPI_PARTITION_PKG_WINTRUST = 0;

const int WINAPI_PARTITION_PKG_WEBSERVICES = 0;

const int WINAPI_PARTITION_PKG_EVENTLOGSERVICE = 0;

const int WINAPI_PARTITION_PKG_VHD = 0;

const int WINAPI_PARTITION_PKG_PERFCOUNTER = 0;

const int WINAPI_PARTITION_PKG_SECURESTARTUP = 0;

const int WINAPI_PARTITION_PKG_REMOTEFS = 0;

const int WINAPI_PARTITION_PKG_BOOTABLESKU = 0;

const int WINAPI_PARTITION_PKG_CMDTOOLS = 0;

const int WINAPI_PARTITION_PKG_DISM = 0;

const int WINAPI_PARTITION_PKG_CORESETUP = 0;

const int WINAPI_PARTITION_PKG_APPRUNTIME = 0;

const int WINAPI_PARTITION_PKG_ESENT = 0;

const int WINAPI_PARTITION_PKG_WINMGMT = 0;

const int WINAPI_PARTITION_PKG_WNV = 0;

const int WINAPI_PARTITION_PKG_CLUSTER = 0;

const int WINAPI_PARTITION_PKG_VSS = 0;

const int WINAPI_PARTITION_PKG_TRAFFIC = 0;

const int WINAPI_PARTITION_PKG_ISCSI = 0;

const int WINAPI_PARTITION_PKG_STORAGE = 0;

const int WINAPI_PARTITION_PKG_MPSSVC = 0;

const int WINAPI_PARTITION_PKG_APPXDEPLOYMENT = 0;

const int WINAPI_PARTITION_PKG_WER = 0;

const int WINAPI_FAMILY_PC_APP = 2;

const int WINAPI_FAMILY_PHONE_APP = 3;

const int WINAPI_FAMILY_SYSTEM = 4;

const int WINAPI_FAMILY_SERVER = 5;

const int WINAPI_FAMILY_GAMES = 6;

const int WINAPI_FAMILY_DESKTOP_APP = 100;

const int WINAPI_FAMILY_APP = 2;

const int WINAPI_FAMILY = 100;

const int WINAPI_PARTITION_DESKTOP = 1;

const int WINAPI_PARTITION_APP = 1;

const int WINAPI_PARTITION_PC_APP = 1;

const int WINAPI_PARTITION_PHONE_APP = 0;

const int WINAPI_PARTITION_GAMES = 1;

const int WINAPI_PARTITION_SYSTEM = 0;

const int WINAPI_PARTITION_PHONE = 0;

const int WINAPI_FAMILY_WINRT = 0;

const int __WINDOWS__ = 1;

const int __WIN32__ = 1;

const int NULL = 0;

const int SIZEOF_VOIDP = 8;

const int HAVE_DDRAW_H = 1;

const int HAVE_DINPUT_H = 1;

const int HAVE_DSOUND_H = 1;

const int HAVE_DXGI_H = 1;

const int HAVE_XINPUT_H = 1;

const int HAVE_MMDEVICEAPI_H = 1;

const int HAVE_AUDIOCLIENT_H = 1;

const int HAVE_STDARG_H = 1;

const int HAVE_STDDEF_H = 1;

const int _WIN32_WINNT_NT4 = 1024;

const int _WIN32_WINNT_WIN2K = 1280;

const int _WIN32_WINNT_WINXP = 1281;

const int _WIN32_WINNT_WS03 = 1282;

const int _WIN32_WINNT_WIN6 = 1536;

const int _WIN32_WINNT_VISTA = 1536;

const int _WIN32_WINNT_WS08 = 1536;

const int _WIN32_WINNT_LONGHORN = 1536;

const int _WIN32_WINNT_WIN7 = 1537;

const int _WIN32_WINNT_WIN8 = 1538;

const int _WIN32_WINNT_WINBLUE = 1539;

const int _WIN32_WINNT_WINTHRESHOLD = 2560;

const int _WIN32_WINNT_WIN10 = 2560;

const int _WIN32_IE_IE20 = 512;

const int _WIN32_IE_IE30 = 768;

const int _WIN32_IE_IE302 = 770;

const int _WIN32_IE_IE40 = 1024;

const int _WIN32_IE_IE401 = 1025;

const int _WIN32_IE_IE50 = 1280;

const int _WIN32_IE_IE501 = 1281;

const int _WIN32_IE_IE55 = 1360;

const int _WIN32_IE_IE60 = 1536;

const int _WIN32_IE_IE60SP1 = 1537;

const int _WIN32_IE_IE60SP2 = 1539;

const int _WIN32_IE_IE70 = 1792;

const int _WIN32_IE_IE80 = 2048;

const int _WIN32_IE_IE90 = 2304;

const int _WIN32_IE_IE100 = 2560;

const int _WIN32_IE_IE110 = 2560;

const int _WIN32_IE_NT4 = 512;

const int _WIN32_IE_NT4SP1 = 512;

const int _WIN32_IE_NT4SP2 = 512;

const int _WIN32_IE_NT4SP3 = 770;

const int _WIN32_IE_NT4SP4 = 1025;

const int _WIN32_IE_NT4SP5 = 1025;

const int _WIN32_IE_NT4SP6 = 1280;

const int _WIN32_IE_WIN98 = 1025;

const int _WIN32_IE_WIN98SE = 1280;

const int _WIN32_IE_WINME = 1360;

const int _WIN32_IE_WIN2K = 1281;

const int _WIN32_IE_WIN2KSP1 = 1281;

const int _WIN32_IE_WIN2KSP2 = 1281;

const int _WIN32_IE_WIN2KSP3 = 1281;

const int _WIN32_IE_WIN2KSP4 = 1281;

const int _WIN32_IE_XP = 1536;

const int _WIN32_IE_XPSP1 = 1537;

const int _WIN32_IE_XPSP2 = 1539;

const int _WIN32_IE_WS03 = 1538;

const int _WIN32_IE_WS03SP1 = 1539;

const int _WIN32_IE_WIN6 = 1792;

const int _WIN32_IE_LONGHORN = 1792;

const int _WIN32_IE_WIN7 = 2048;

const int _WIN32_IE_WIN8 = 2560;

const int _WIN32_IE_WINBLUE = 2560;

const int _WIN32_IE_WINTHRESHOLD = 2560;

const int _WIN32_IE_WIN10 = 2560;

const int NTDDI_WIN2K = 83886080;

const int NTDDI_WIN2KSP1 = 83886336;

const int NTDDI_WIN2KSP2 = 83886592;

const int NTDDI_WIN2KSP3 = 83886848;

const int NTDDI_WIN2KSP4 = 83887104;

const int NTDDI_WINXP = 83951616;

const int NTDDI_WINXPSP1 = 83951872;

const int NTDDI_WINXPSP2 = 83952128;

const int NTDDI_WINXPSP3 = 83952384;

const int NTDDI_WINXPSP4 = 83952640;

const int NTDDI_WS03 = 84017152;

const int NTDDI_WS03SP1 = 84017408;

const int NTDDI_WS03SP2 = 84017664;

const int NTDDI_WS03SP3 = 84017920;

const int NTDDI_WS03SP4 = 84018176;

const int NTDDI_WIN6 = 100663296;

const int NTDDI_WIN6SP1 = 100663552;

const int NTDDI_WIN6SP2 = 100663808;

const int NTDDI_WIN6SP3 = 100664064;

const int NTDDI_WIN6SP4 = 100664320;

const int NTDDI_VISTA = 100663296;

const int NTDDI_VISTASP1 = 100663552;

const int NTDDI_VISTASP2 = 100663808;

const int NTDDI_VISTASP3 = 100664064;

const int NTDDI_VISTASP4 = 100664320;

const int NTDDI_LONGHORN = 100663296;

const int NTDDI_WS08 = 100663552;

const int NTDDI_WS08SP2 = 100663808;

const int NTDDI_WS08SP3 = 100664064;

const int NTDDI_WS08SP4 = 100664320;

const int NTDDI_WIN7 = 100728832;

const int NTDDI_WIN8 = 100794368;

const int NTDDI_WINBLUE = 100859904;

const int NTDDI_WINTHRESHOLD = 167772160;

const int NTDDI_WIN10 = 167772160;

const int NTDDI_WIN10_TH2 = 167772161;

const int NTDDI_WIN10_RS1 = 167772162;

const int NTDDI_WIN10_RS2 = 167772163;

const int NTDDI_WIN10_RS3 = 167772164;

const int NTDDI_WIN10_RS4 = 167772165;

const int NTDDI_WIN10_RS5 = 167772166;

const int NTDDI_WIN10_19H1 = 167772167;

const int WDK_NTDDI_VERSION = 167772167;

const int OSVERSION_MASK = 4294901760;

const int SPVERSION_MASK = 65280;

const int SUBVERSION_MASK = 255;

const int _WIN32_WINNT = 2560;

const int NTDDI_VERSION = 167772167;

const int WINVER = 2560;

const int _WIN32_IE = 2560;

const int SDL_AUDIO_DRIVER_WASAPI = 1;

const int SDL_AUDIO_DRIVER_DSOUND = 1;

const int SDL_AUDIO_DRIVER_WINMM = 1;

const int SDL_AUDIO_DRIVER_DISK = 1;

const int SDL_AUDIO_DRIVER_DUMMY = 1;

const int SDL_JOYSTICK_DINPUT = 1;

const int SDL_JOYSTICK_HIDAPI = 1;

const int SDL_JOYSTICK_RAWINPUT = 1;

const int SDL_JOYSTICK_VIRTUAL = 1;

const int SDL_JOYSTICK_WGI = 1;

const int SDL_JOYSTICK_XINPUT = 1;

const int SDL_HAPTIC_DINPUT = 1;

const int SDL_HAPTIC_XINPUT = 1;

const int SDL_SENSOR_WINDOWS = 1;

const int SDL_LOADSO_WINDOWS = 1;

const int SDL_THREAD_WINDOWS = 1;

const int SDL_TIMER_WINDOWS = 1;

const int SDL_VIDEO_DRIVER_DUMMY = 1;

const int SDL_VIDEO_DRIVER_WINDOWS = 1;

const int SDL_VIDEO_RENDER_D3D = 1;

const int SDL_VIDEO_RENDER_D3D11 = 1;

const int SDL_VIDEO_OPENGL = 1;

const int SDL_VIDEO_OPENGL_WGL = 1;

const int SDL_VIDEO_RENDER_OGL = 1;

const int SDL_VIDEO_RENDER_OGL_ES2 = 1;

const int SDL_VIDEO_OPENGL_ES2 = 1;

const int SDL_VIDEO_OPENGL_EGL = 1;

const int SDL_VIDEO_VULKAN = 1;

const int SDL_POWER_WINDOWS = 1;

const int SDL_FILESYSTEM_WINDOWS = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_NODISCARD = 1;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int SDL_MAX_SINT8 = 127;

const int SDL_MIN_SINT8 = -128;

const int SDL_MAX_UINT8 = 255;

const int SDL_MIN_UINT8 = 0;

const int SDL_MAX_SINT16 = 32767;

const int SDL_MIN_SINT16 = -32768;

const int SDL_MAX_UINT16 = 65535;

const int SDL_MIN_UINT16 = 0;

const int SDL_MAX_SINT32 = 2147483647;

const int SDL_MIN_SINT32 = -2147483648;

const int SDL_MAX_UINT32 = 4294967295;

const int SDL_MIN_UINT32 = 0;

const int SDL_MAX_SINT64 = 9223372036854775807;

const int SDL_MIN_SINT64 = -9223372036854775808;

const int SDL_MAX_UINT64 = -1;

const int SDL_MIN_UINT64 = 0;

const String SDL_PRIs64 = 'I64d';

const String SDL_PRIu64 = 'I64u';

const String SDL_PRIx64 = 'I64x';

const String SDL_PRIX64 = 'I64X';

const double M_PI = 3.141592653589793;

const int SDL_ICONV_ERROR = -1;

const int SDL_ICONV_E2BIG = -2;

const int SDL_ICONV_EILSEQ = -3;

const int SDL_ICONV_EINVAL = -4;

const int SDL_ASSERT_LEVEL = 1;

const String SDL_FILE = 'temp_for_macros.hpp';

const int SDL_LINE = 596;

const int SDL_NULL_WHILE_LOOP_CONDITION = 0;

const int SDL_LIL_ENDIAN = 1234;

const int SDL_BIG_ENDIAN = 4321;

const int SDL_BYTEORDER = 1234;

const int SDL_MUTEX_TIMEDOUT = 1;

const int SDL_MUTEX_MAXWAIT = 4294967295;

const int _DOMAIN = 1;

const int _SING = 2;

const int _OVERFLOW = 3;

const int _UNDERFLOW = 4;

const int _TLOSS = 5;

const int _PLOSS = 6;

const double _HUGE_ENUF = 1e+300;

const double INFINITY = double.infinity;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double NAN = double.nan;

const int _DENORM = -2;

const int _FINITE = -1;

const int _INFCODE = 1;

const int _NANCODE = 2;

const int FP_INFINITE = 1;

const int FP_NAN = 2;

const int FP_NORMAL = -1;

const int FP_SUBNORMAL = -2;

const int FP_ZERO = 0;

const int _C2 = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = 2147483647;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const int math_errhandling = 3;

const int _FE_DIVBYZERO = 4;

const int _FE_INEXACT = 32;

const int _FE_INVALID = 1;

const int _FE_OVERFLOW = 8;

const int _FE_UNDERFLOW = 16;

const int _D0_C = 3;

const int _D1_C = 2;

const int _D2_C = 1;

const int _D3_C = 0;

const int _DBIAS = 1022;

const int _DOFF = 4;

const int _F0_C = 1;

const int _F1_C = 0;

const int _FBIAS = 126;

const int _FOFF = 7;

const int _FRND = 1;

const int _L0_C = 3;

const int _L1_C = 2;

const int _L2_C = 1;

const int _L3_C = 0;

const int _LBIAS = 1022;

const int _LOFF = 4;

const int _DFRAC = 15;

const int _DMASK = 32752;

const int _DMAX = 2047;

const int _DSIGN = 32768;

const int _FFRAC = 127;

const int _FMASK = 32640;

const int _FMAX = 255;

const int _FSIGN = 32768;

const int _LFRAC = 65535;

const int _LMASK = 32767;

const int _LMAX = 32767;

const int _LSIGN = 32768;

const int _DHUGE_EXP = 1842;

const int _FHUGE_EXP = 229;

const int _LHUGE_EXP = 29490;

const int _FP_LT = 1;

const int _FP_EQ = 2;

const int _FP_GT = 4;

const int DOMAIN = 1;

const int SING = 2;

const int OVERFLOW = 3;

const int UNDERFLOW = 4;

const int TLOSS = 5;

const int PLOSS = 6;

const int _P_WAIT = 0;

const int _P_NOWAIT = 1;

const int _OLD_P_OVERLAY = 2;

const int _P_NOWAITO = 3;

const int _P_DETACH = 4;

const int _P_OVERLAY = 2;

const int _WAIT_CHILD = 0;

const int _WAIT_GRANDCHILD = 1;

const int P_WAIT = 0;

const int P_NOWAIT = 1;

const int P_OVERLAY = 2;

const int OLD_P_OVERLAY = 2;

const int P_NOWAITO = 3;

const int P_DETACH = 4;

const int WAIT_CHILD = 0;

const int WAIT_GRANDCHILD = 1;

const int SDL_RWOPS_UNKNOWN = 0;

const int SDL_RWOPS_WINFILE = 1;

const int SDL_RWOPS_STDFILE = 2;

const int SDL_RWOPS_JNIFILE = 3;

const int SDL_RWOPS_MEMORY = 4;

const int SDL_RWOPS_MEMORY_RO = 5;

const int RW_SEEK_SET = 0;

const int RW_SEEK_CUR = 1;

const int RW_SEEK_END = 2;

const int SDL_AUDIO_MASK_BITSIZE = 255;

const int SDL_AUDIO_MASK_DATATYPE = 256;

const int SDL_AUDIO_MASK_ENDIAN = 4096;

const int SDL_AUDIO_MASK_SIGNED = 32768;

const int AUDIO_U8 = 8;

const int AUDIO_S8 = 32776;

const int AUDIO_U16LSB = 16;

const int AUDIO_S16LSB = 32784;

const int AUDIO_U16MSB = 4112;

const int AUDIO_S16MSB = 36880;

const int AUDIO_U16 = 16;

const int AUDIO_S16 = 32784;

const int AUDIO_S32LSB = 32800;

const int AUDIO_S32MSB = 36896;

const int AUDIO_S32 = 32800;

const int AUDIO_F32LSB = 33056;

const int AUDIO_F32MSB = 37152;

const int AUDIO_F32 = 33056;

const int AUDIO_U16SYS = 16;

const int AUDIO_S16SYS = 32784;

const int AUDIO_S32SYS = 32800;

const int AUDIO_F32SYS = 33056;

const int SDL_AUDIO_ALLOW_FREQUENCY_CHANGE = 1;

const int SDL_AUDIO_ALLOW_FORMAT_CHANGE = 2;

const int SDL_AUDIO_ALLOW_CHANNELS_CHANGE = 4;

const int SDL_AUDIO_ALLOW_SAMPLES_CHANGE = 8;

const int SDL_AUDIO_ALLOW_ANY_CHANGE = 15;

const int SDL_AUDIOCVT_MAX_FILTERS = 9;

const int SDL_MIX_MAXVOLUME = 128;

const int SDL_CACHELINE_SIZE = 128;

const int SDL_ALPHA_OPAQUE = 255;

const int SDL_ALPHA_TRANSPARENT = 0;

const int SDL_SWSURFACE = 0;

const int SDL_PREALLOC = 1;

const int SDL_RLEACCEL = 2;

const int SDL_DONTFREE = 4;

const int SDL_SIMD_ALIGNED = 8;

const int SDL_WINDOWPOS_UNDEFINED_MASK = 536805376;

const int SDL_WINDOWPOS_UNDEFINED = 536805376;

const int SDL_WINDOWPOS_CENTERED_MASK = 805240832;

const int SDL_WINDOWPOS_CENTERED = 805240832;

const int SDLK_SCANCODE_MASK = 1073741824;

const int SDL_BUTTON_LEFT = 1;

const int SDL_BUTTON_MIDDLE = 2;

const int SDL_BUTTON_RIGHT = 3;

const int SDL_BUTTON_X1 = 4;

const int SDL_BUTTON_X2 = 5;

const int SDL_BUTTON_LMASK = 1;

const int SDL_BUTTON_MMASK = 2;

const int SDL_BUTTON_RMASK = 4;

const int SDL_BUTTON_X1MASK = 8;

const int SDL_BUTTON_X2MASK = 16;

const double SDL_IPHONE_MAX_GFORCE = 5.0;

const int SDL_JOYSTICK_AXIS_MAX = 32767;

const int SDL_JOYSTICK_AXIS_MIN = -32768;

const int SDL_HAT_CENTERED = 0;

const int SDL_HAT_UP = 1;

const int SDL_HAT_RIGHT = 2;

const int SDL_HAT_DOWN = 4;

const int SDL_HAT_LEFT = 8;

const int SDL_HAT_RIGHTUP = 3;

const int SDL_HAT_RIGHTDOWN = 6;

const int SDL_HAT_LEFTUP = 9;

const int SDL_HAT_LEFTDOWN = 12;

const double SDL_STANDARD_GRAVITY = 9.806650161743164;

const int SDL_TOUCH_MOUSEID = 4294967295;

const int SDL_MOUSE_TOUCHID = -1;

const int SDL_RELEASED = 0;

const int SDL_PRESSED = 1;

const int SDL_TEXTEDITINGEVENT_TEXT_SIZE = 32;

const int SDL_TEXTINPUTEVENT_TEXT_SIZE = 32;

const int SDL_QUERY = -1;

const int SDL_IGNORE = 0;

const int SDL_DISABLE = 0;

const int SDL_ENABLE = 1;

const int SDL_HAPTIC_CONSTANT = 1;

const int SDL_HAPTIC_SINE = 2;

const int SDL_HAPTIC_LEFTRIGHT = 4;

const int SDL_HAPTIC_TRIANGLE = 8;

const int SDL_HAPTIC_SAWTOOTHUP = 16;

const int SDL_HAPTIC_SAWTOOTHDOWN = 32;

const int SDL_HAPTIC_RAMP = 64;

const int SDL_HAPTIC_SPRING = 128;

const int SDL_HAPTIC_DAMPER = 256;

const int SDL_HAPTIC_INERTIA = 512;

const int SDL_HAPTIC_FRICTION = 1024;

const int SDL_HAPTIC_CUSTOM = 2048;

const int SDL_HAPTIC_GAIN = 4096;

const int SDL_HAPTIC_AUTOCENTER = 8192;

const int SDL_HAPTIC_STATUS = 16384;

const int SDL_HAPTIC_PAUSE = 32768;

const int SDL_HAPTIC_POLAR = 0;

const int SDL_HAPTIC_CARTESIAN = 1;

const int SDL_HAPTIC_SPHERICAL = 2;

const int SDL_HAPTIC_STEERING_AXIS = 3;

const int SDL_HAPTIC_INFINITY = 4294967295;

const String SDL_HINT_FRAMEBUFFER_ACCELERATION = 'SDL_FRAMEBUFFER_ACCELERATION';

const String SDL_HINT_RENDER_DRIVER = 'SDL_RENDER_DRIVER';

const String SDL_HINT_RENDER_OPENGL_SHADERS = 'SDL_RENDER_OPENGL_SHADERS';

const String SDL_HINT_RENDER_DIRECT3D_THREADSAFE =
    'SDL_RENDER_DIRECT3D_THREADSAFE';

const String SDL_HINT_RENDER_DIRECT3D11_DEBUG = 'SDL_RENDER_DIRECT3D11_DEBUG';

const String SDL_HINT_RENDER_LOGICAL_SIZE_MODE = 'SDL_RENDER_LOGICAL_SIZE_MODE';

const String SDL_HINT_RENDER_SCALE_QUALITY = 'SDL_RENDER_SCALE_QUALITY';

const String SDL_HINT_RENDER_VSYNC = 'SDL_RENDER_VSYNC';

const String SDL_HINT_VIDEO_ALLOW_SCREENSAVER = 'SDL_VIDEO_ALLOW_SCREENSAVER';

const String SDL_HINT_VIDEO_EXTERNAL_CONTEXT = 'SDL_VIDEO_EXTERNAL_CONTEXT';

const String SDL_HINT_VIDEO_X11_XVIDMODE = 'SDL_VIDEO_X11_XVIDMODE';

const String SDL_HINT_VIDEO_X11_XINERAMA = 'SDL_VIDEO_X11_XINERAMA';

const String SDL_HINT_VIDEO_X11_XRANDR = 'SDL_VIDEO_X11_XRANDR';

const String SDL_HINT_VIDEO_X11_WINDOW_VISUALID =
    'SDL_VIDEO_X11_WINDOW_VISUALID';

const String SDL_HINT_VIDEO_X11_NET_WM_PING = 'SDL_VIDEO_X11_NET_WM_PING';

const String SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR =
    'SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR';

const String SDL_HINT_VIDEO_X11_FORCE_EGL = 'SDL_VIDEO_X11_FORCE_EGL';

const String SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN =
    'SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN';

const String SDL_HINT_WINDOWS_INTRESOURCE_ICON = 'SDL_WINDOWS_INTRESOURCE_ICON';

const String SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL =
    'SDL_WINDOWS_INTRESOURCE_ICON_SMALL';

const String SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP =
    'SDL_WINDOWS_ENABLE_MESSAGELOOP';

const String SDL_HINT_GRAB_KEYBOARD = 'SDL_GRAB_KEYBOARD';

const String SDL_HINT_MOUSE_DOUBLE_CLICK_TIME = 'SDL_MOUSE_DOUBLE_CLICK_TIME';

const String SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS =
    'SDL_MOUSE_DOUBLE_CLICK_RADIUS';

const String SDL_HINT_MOUSE_NORMAL_SPEED_SCALE = 'SDL_MOUSE_NORMAL_SPEED_SCALE';

const String SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE =
    'SDL_MOUSE_RELATIVE_SPEED_SCALE';

const String SDL_HINT_MOUSE_RELATIVE_SCALING = 'SDL_MOUSE_RELATIVE_SCALING';

const String SDL_HINT_MOUSE_RELATIVE_MODE_WARP = 'SDL_MOUSE_RELATIVE_MODE_WARP';

const String SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH = 'SDL_MOUSE_FOCUS_CLICKTHROUGH';

const String SDL_HINT_TOUCH_MOUSE_EVENTS = 'SDL_TOUCH_MOUSE_EVENTS';

const String SDL_HINT_MOUSE_TOUCH_EVENTS = 'SDL_MOUSE_TOUCH_EVENTS';

const String SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS =
    'SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS';

const String SDL_HINT_IDLE_TIMER_DISABLED = 'SDL_IOS_IDLE_TIMER_DISABLED';

const String SDL_HINT_ORIENTATIONS = 'SDL_IOS_ORIENTATIONS';

const String SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS =
    'SDL_APPLE_TV_CONTROLLER_UI_EVENTS';

const String SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION =
    'SDL_APPLE_TV_REMOTE_ALLOW_ROTATION';

const String SDL_HINT_IOS_HIDE_HOME_INDICATOR = 'SDL_IOS_HIDE_HOME_INDICATOR';

const String SDL_HINT_ACCELEROMETER_AS_JOYSTICK =
    'SDL_ACCELEROMETER_AS_JOYSTICK';

const String SDL_HINT_TV_REMOTE_AS_JOYSTICK = 'SDL_TV_REMOTE_AS_JOYSTICK';

const String SDL_HINT_XINPUT_ENABLED = 'SDL_XINPUT_ENABLED';

const String SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING =
    'SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING';

const String SDL_HINT_GAMECONTROLLERTYPE = 'SDL_GAMECONTROLLERTYPE';

const String SDL_HINT_GAMECONTROLLERCONFIG = 'SDL_GAMECONTROLLERCONFIG';

const String SDL_HINT_GAMECONTROLLERCONFIG_FILE =
    'SDL_GAMECONTROLLERCONFIG_FILE';

const String SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES =
    'SDL_GAMECONTROLLER_IGNORE_DEVICES';

const String SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT =
    'SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT';

const String SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS =
    'SDL_GAMECONTROLLER_USE_BUTTON_LABELS';

const String SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS =
    'SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS';

const String SDL_HINT_JOYSTICK_HIDAPI = 'SDL_JOYSTICK_HIDAPI';

const String SDL_HINT_JOYSTICK_HIDAPI_PS4 = 'SDL_JOYSTICK_HIDAPI_PS4';

const String SDL_HINT_JOYSTICK_HIDAPI_PS5 = 'SDL_JOYSTICK_HIDAPI_PS5';

const String SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE =
    'SDL_JOYSTICK_HIDAPI_PS4_RUMBLE';

const String SDL_HINT_JOYSTICK_HIDAPI_STEAM = 'SDL_JOYSTICK_HIDAPI_STEAM';

const String SDL_HINT_JOYSTICK_HIDAPI_SWITCH = 'SDL_JOYSTICK_HIDAPI_SWITCH';

const String SDL_HINT_JOYSTICK_HIDAPI_XBOX = 'SDL_JOYSTICK_HIDAPI_XBOX';

const String SDL_HINT_JOYSTICK_HIDAPI_CORRELATE_XINPUT =
    'SDL_JOYSTICK_HIDAPI_CORRELATE_XINPUT';

const String SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE = 'SDL_JOYSTICK_HIDAPI_GAMECUBE';

const String SDL_HINT_ENABLE_STEAM_CONTROLLERS = 'SDL_ENABLE_STEAM_CONTROLLERS';

const String SDL_HINT_JOYSTICK_RAWINPUT = 'SDL_JOYSTICK_RAWINPUT';

const String SDL_HINT_JOYSTICK_THREAD = 'SDL_JOYSTICK_THREAD';

const String SDL_HINT_LINUX_JOYSTICK_DEADZONES = 'SDL_LINUX_JOYSTICK_DEADZONES';

const String SDL_HINT_ALLOW_TOPMOST = 'SDL_ALLOW_TOPMOST';

const String SDL_HINT_TIMER_RESOLUTION = 'SDL_TIMER_RESOLUTION';

const String SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION =
    'SDL_QTWAYLAND_CONTENT_ORIENTATION';

const String SDL_HINT_QTWAYLAND_WINDOW_FLAGS = 'SDL_QTWAYLAND_WINDOW_FLAGS';

const String SDL_HINT_THREAD_STACK_SIZE = 'SDL_THREAD_STACK_SIZE';

const String SDL_HINT_THREAD_PRIORITY_POLICY = 'SDL_THREAD_PRIORITY_POLICY';

const String SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL =
    'SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL';

const String SDL_HINT_VIDEO_HIGHDPI_DISABLED = 'SDL_VIDEO_HIGHDPI_DISABLED';

const String SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK =
    'SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK';

const String SDL_HINT_VIDEO_WIN_D3DCOMPILER = 'SDL_VIDEO_WIN_D3DCOMPILER';

const String SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT =
    'SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT';

const String SDL_HINT_WINRT_PRIVACY_POLICY_URL = 'SDL_WINRT_PRIVACY_POLICY_URL';

const String SDL_HINT_WINRT_PRIVACY_POLICY_LABEL =
    'SDL_WINRT_PRIVACY_POLICY_LABEL';

const String SDL_HINT_WINRT_HANDLE_BACK_BUTTON = 'SDL_WINRT_HANDLE_BACK_BUTTON';

const String SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES =
    'SDL_VIDEO_MAC_FULLSCREEN_SPACES';

const String SDL_HINT_MAC_BACKGROUND_APP = 'SDL_MAC_BACKGROUND_APP';

const String SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION =
    'SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION';

const String SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION =
    'SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION';

const String SDL_HINT_IME_INTERNAL_EDITING = 'SDL_IME_INTERNAL_EDITING';

const String SDL_HINT_ANDROID_TRAP_BACK_BUTTON = 'SDL_ANDROID_TRAP_BACK_BUTTON';

const String SDL_HINT_ANDROID_BLOCK_ON_PAUSE = 'SDL_ANDROID_BLOCK_ON_PAUSE';

const String SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO =
    'SDL_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO';

const String SDL_HINT_RETURN_KEY_HIDES_IME = 'SDL_RETURN_KEY_HIDES_IME';

const String SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT =
    'SDL_EMSCRIPTEN_KEYBOARD_ELEMENT';

const String SDL_HINT_EMSCRIPTEN_ASYNCIFY = 'SDL_EMSCRIPTEN_ASYNCIFY';

const String SDL_HINT_NO_SIGNAL_HANDLERS = 'SDL_NO_SIGNAL_HANDLERS';

const String SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4 =
    'SDL_WINDOWS_NO_CLOSE_ON_ALT_F4';

const String SDL_HINT_BMP_SAVE_LEGACY_FORMAT = 'SDL_BMP_SAVE_LEGACY_FORMAT';

const String SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING =
    'SDL_WINDOWS_DISABLE_THREAD_NAMING';

const String SDL_HINT_RPI_VIDEO_LAYER = 'SDL_RPI_VIDEO_LAYER';

const String SDL_HINT_VIDEO_DOUBLE_BUFFER = 'SDL_VIDEO_DOUBLE_BUFFER';

const String SDL_HINT_OPENGL_ES_DRIVER = 'SDL_OPENGL_ES_DRIVER';

const String SDL_HINT_AUDIO_RESAMPLING_MODE = 'SDL_AUDIO_RESAMPLING_MODE';

const String SDL_HINT_AUDIO_CATEGORY = 'SDL_AUDIO_CATEGORY';

const String SDL_HINT_RENDER_BATCHING = 'SDL_RENDER_BATCHING';

const String SDL_HINT_AUTO_UPDATE_JOYSTICKS = 'SDL_AUTO_UPDATE_JOYSTICKS';

const String SDL_HINT_AUTO_UPDATE_SENSORS = 'SDL_AUTO_UPDATE_SENSORS';

const String SDL_HINT_EVENT_LOGGING = 'SDL_EVENT_LOGGING';

const String SDL_HINT_WAVE_RIFF_CHUNK_SIZE = 'SDL_WAVE_RIFF_CHUNK_SIZE';

const String SDL_HINT_WAVE_TRUNCATION = 'SDL_WAVE_TRUNCATION';

const String SDL_HINT_WAVE_FACT_CHUNK = 'SDL_WAVE_FACT_CHUNK';

const String SDL_HINT_DISPLAY_USABLE_BOUNDS = 'SDL_DISPLAY_USABLE_BOUNDS';

const String SDL_HINT_AUDIO_DEVICE_APP_NAME = 'SDL_AUDIO_DEVICE_APP_NAME';

const String SDL_HINT_AUDIO_DEVICE_STREAM_NAME = 'SDL_AUDIO_DEVICE_STREAM_NAME';

const String SDL_HINT_PREFERRED_LOCALES = 'SDL_PREFERRED_LOCALES';

const int SDL_MAX_LOG_MESSAGE = 4096;

const int SDL_NONSHAPEABLE_WINDOW = -1;

const int SDL_INVALID_SHAPE_ARGUMENT = -2;

const int SDL_WINDOW_LACKS_SHAPE = -3;

const int SDL_MAJOR_VERSION = 2;

const int SDL_MINOR_VERSION = 0;

const int SDL_PATCHLEVEL = 14;

const int SDL_COMPILEDVERSION = 2014;

const int SDL_INIT_TIMER = 1;

const int SDL_INIT_AUDIO = 16;

const int SDL_INIT_VIDEO = 32;

const int SDL_INIT_JOYSTICK = 512;

const int SDL_INIT_HAPTIC = 4096;

const int SDL_INIT_GAMECONTROLLER = 8192;

const int SDL_INIT_EVENTS = 16384;

const int SDL_INIT_SENSOR = 32768;

const int SDL_INIT_NOPARACHUTE = 1048576;

const int SDL_INIT_EVERYTHING = 62001;

typedef _c_SDL_GetPlatform = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetPlatform = ffi.Pointer<ffi.Int8> Function();

typedef _c___va_start = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> arg0,
);

typedef _dart___va_start = void Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> arg0,
);

typedef _c___security_init_cookie = ffi.Void Function();

typedef _dart___security_init_cookie = void Function();

typedef _c___security_check_cookie = ffi.Void Function(
  ffi.Uint64 _StackCookie,
);

typedef _dart___security_check_cookie = void Function(
  int _StackCookie,
);

typedef _c___report_gsfailure = ffi.Void Function(
  ffi.Uint64 _StackCookie,
);

typedef _dart___report_gsfailure = void Function(
  int _StackCookie,
);

typedef _c__invalid_parameter_noinfo = ffi.Void Function();

typedef _dart__invalid_parameter_noinfo = void Function();

typedef _c__invalid_parameter_noinfo_noreturn = ffi.Void Function();

typedef _dart__invalid_parameter_noinfo_noreturn = void Function();

typedef _c__invoke_watson = ffi.Void Function(
  ffi.Pointer<ffi.Uint16> _Expression,
  ffi.Pointer<ffi.Uint16> _FunctionName,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Uint32 _LineNo,
  ffi.Uint64 _Reserved,
);

typedef _dart__invoke_watson = void Function(
  ffi.Pointer<ffi.Uint16> _Expression,
  ffi.Pointer<ffi.Uint16> _FunctionName,
  ffi.Pointer<ffi.Uint16> _FileName,
  int _LineNo,
  int _Reserved,
);

typedef _c__errno = ffi.Pointer<ffi.Int32> Function();

typedef _dart__errno = ffi.Pointer<ffi.Int32> Function();

typedef _c__set_errno = ffi.Int32 Function(
  ffi.Int32 _Value,
);

typedef _dart__set_errno = int Function(
  int _Value,
);

typedef _c__get_errno = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> _Value,
);

typedef _dart__get_errno = int Function(
  ffi.Pointer<ffi.Int32> _Value,
);

typedef _c___threadid = ffi.Uint64 Function();

typedef _dart___threadid = int Function();

typedef _c___threadhandle = ffi.Uint64 Function();

typedef _dart___threadhandle = int Function();

typedef _c_SDL_malloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 size,
);

typedef _dart_SDL_malloc = ffi.Pointer<ffi.Void> Function(
  int size,
);

typedef _c_SDL_calloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_SDL_calloc = ffi.Pointer<ffi.Void> Function(
  int nmemb,
  int size,
);

typedef _c_SDL_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> mem,
  ffi.Uint64 size,
);

typedef _dart_SDL_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> mem,
  int size,
);

typedef _c_SDL_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> mem,
);

typedef _dart_SDL_free = void Function(
  ffi.Pointer<ffi.Void> mem,
);

typedef SDL_malloc_func = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64,
);

typedef SDL_calloc_func = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64,
  ffi.Uint64,
);

typedef SDL_realloc_func = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Uint64,
);

typedef SDL_free_func = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_GetMemoryFunctions = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_malloc_func>>> malloc_func,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_calloc_func>>> calloc_func,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_realloc_func>>> realloc_func,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_free_func>>> free_func,
);

typedef _dart_SDL_GetMemoryFunctions = void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_malloc_func>>> malloc_func,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_calloc_func>>> calloc_func,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_realloc_func>>> realloc_func,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_free_func>>> free_func,
);

typedef _c_SDL_SetMemoryFunctions = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<SDL_malloc_func>> malloc_func,
  ffi.Pointer<ffi.NativeFunction<SDL_calloc_func>> calloc_func,
  ffi.Pointer<ffi.NativeFunction<SDL_realloc_func>> realloc_func,
  ffi.Pointer<ffi.NativeFunction<SDL_free_func>> free_func,
);

typedef _dart_SDL_SetMemoryFunctions = int Function(
  ffi.Pointer<ffi.NativeFunction<SDL_malloc_func>> malloc_func,
  ffi.Pointer<ffi.NativeFunction<SDL_calloc_func>> calloc_func,
  ffi.Pointer<ffi.NativeFunction<SDL_realloc_func>> realloc_func,
  ffi.Pointer<ffi.NativeFunction<SDL_free_func>> free_func,
);

typedef _c_SDL_GetNumAllocations = ffi.Int32 Function();

typedef _dart_SDL_GetNumAllocations = int Function();

typedef _c_SDL_getenv = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_SDL_getenv = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_SDL_setenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  ffi.Int32 overwrite,
);

typedef _dart_SDL_setenv = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  int overwrite,
);

typedef _typedefC_1 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_qsort = ffi.Void Function(
  ffi.Pointer<ffi.Void> base,
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> compare,
);

typedef _dart_SDL_qsort = void Function(
  ffi.Pointer<ffi.Void> base,
  int nmemb,
  int size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> compare,
);

typedef _c_SDL_abs = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_abs = int Function(
  int x,
);

typedef _c_SDL_isdigit = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_isdigit = int Function(
  int x,
);

typedef _c_SDL_isspace = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_isspace = int Function(
  int x,
);

typedef _c_SDL_isupper = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_isupper = int Function(
  int x,
);

typedef _c_SDL_islower = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_islower = int Function(
  int x,
);

typedef _c_SDL_toupper = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_toupper = int Function(
  int x,
);

typedef _c_SDL_tolower = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_SDL_tolower = int Function(
  int x,
);

typedef _c_SDL_crc32 = ffi.Uint32 Function(
  ffi.Uint32 crc,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint64 len,
);

typedef _dart_SDL_crc32 = int Function(
  int crc,
  ffi.Pointer<ffi.Void> data,
  int len,
);

typedef _c_SDL_memset = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Int32 c,
  ffi.Uint64 len,
);

typedef _dart_SDL_memset = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> dst,
  int c,
  int len,
);

typedef _c_SDL_memcpy = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 len,
);

typedef _dart_SDL_memcpy = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Pointer<ffi.Void> src,
  int len,
);

typedef _c_SDL_memmove = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 len,
);

typedef _dart_SDL_memmove = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Pointer<ffi.Void> src,
  int len,
);

typedef _c_SDL_memcmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> s1,
  ffi.Pointer<ffi.Void> s2,
  ffi.Uint64 len,
);

typedef _dart_SDL_memcmp = int Function(
  ffi.Pointer<ffi.Void> s1,
  ffi.Pointer<ffi.Void> s2,
  int len,
);

typedef _c_SDL_wcslen = ffi.Uint64 Function(
  ffi.Pointer<ffi.Uint16> wstr,
);

typedef _dart_SDL_wcslen = int Function(
  ffi.Pointer<ffi.Uint16> wstr,
);

typedef _c_SDL_wcslcpy = ffi.Uint64 Function(
  ffi.Pointer<ffi.Uint16> dst,
  ffi.Pointer<ffi.Uint16> src,
  ffi.Uint64 maxlen,
);

typedef _dart_SDL_wcslcpy = int Function(
  ffi.Pointer<ffi.Uint16> dst,
  ffi.Pointer<ffi.Uint16> src,
  int maxlen,
);

typedef _c_SDL_wcslcat = ffi.Uint64 Function(
  ffi.Pointer<ffi.Uint16> dst,
  ffi.Pointer<ffi.Uint16> src,
  ffi.Uint64 maxlen,
);

typedef _dart_SDL_wcslcat = int Function(
  ffi.Pointer<ffi.Uint16> dst,
  ffi.Pointer<ffi.Uint16> src,
  int maxlen,
);

typedef _c_SDL_wcsdup = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> wstr,
);

typedef _dart_SDL_wcsdup = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> wstr,
);

typedef _c_SDL_wcsstr = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> haystack,
  ffi.Pointer<ffi.Uint16> needle,
);

typedef _dart_SDL_wcsstr = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> haystack,
  ffi.Pointer<ffi.Uint16> needle,
);

typedef _c_SDL_wcscmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
);

typedef _dart_SDL_wcscmp = int Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
);

typedef _c_SDL_wcsncmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
  ffi.Uint64 maxlen,
);

typedef _dart_SDL_wcsncmp = int Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
  int maxlen,
);

typedef _c_SDL_wcscasecmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
);

typedef _dart_SDL_wcscasecmp = int Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
);

typedef _c_SDL_wcsncasecmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
  ffi.Uint64 len,
);

typedef _dart_SDL_wcsncasecmp = int Function(
  ffi.Pointer<ffi.Uint16> str1,
  ffi.Pointer<ffi.Uint16> str2,
  int len,
);

typedef _c_SDL_strlen = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_strlen = int Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_strlcpy = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 maxlen,
);

typedef _dart_SDL_strlcpy = int Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  int maxlen,
);

typedef _c_SDL_utf8strlcpy = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 dst_bytes,
);

typedef _dart_SDL_utf8strlcpy = int Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  int dst_bytes,
);

typedef _c_SDL_strlcat = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 maxlen,
);

typedef _dart_SDL_strlcat = int Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  int maxlen,
);

typedef _c_SDL_strdup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_strdup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_strrev = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_strrev = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_strupr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_strupr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_strlwr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_strlwr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_strchr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 c,
);

typedef _dart_SDL_strchr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
  int c,
);

typedef _c_SDL_strrchr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 c,
);

typedef _dart_SDL_strrchr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
  int c,
);

typedef _c_SDL_strstr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> haystack,
  ffi.Pointer<ffi.Int8> needle,
);

typedef _dart_SDL_strstr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> haystack,
  ffi.Pointer<ffi.Int8> needle,
);

typedef _c_SDL_strtokr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s1,
  ffi.Pointer<ffi.Int8> s2,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
);

typedef _dart_SDL_strtokr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s1,
  ffi.Pointer<ffi.Int8> s2,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
);

typedef _c_SDL_utf8strlen = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_utf8strlen = int Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_itoa = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 value,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 radix,
);

typedef _dart_SDL_itoa = ffi.Pointer<ffi.Int8> Function(
  int value,
  ffi.Pointer<ffi.Int8> str,
  int radix,
);

typedef _c_SDL_uitoa = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint32 value,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 radix,
);

typedef _dart_SDL_uitoa = ffi.Pointer<ffi.Int8> Function(
  int value,
  ffi.Pointer<ffi.Int8> str,
  int radix,
);

typedef _c_SDL_ltoa = ffi.Pointer<ffi.Int8> Function(
  ffi.Int64 value,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 radix,
);

typedef _dart_SDL_ltoa = ffi.Pointer<ffi.Int8> Function(
  int value,
  ffi.Pointer<ffi.Int8> str,
  int radix,
);

typedef _c_SDL_ultoa = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint64 value,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 radix,
);

typedef _dart_SDL_ultoa = ffi.Pointer<ffi.Int8> Function(
  int value,
  ffi.Pointer<ffi.Int8> str,
  int radix,
);

typedef _c_SDL_lltoa = ffi.Pointer<ffi.Int8> Function(
  ffi.Int64 value,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 radix,
);

typedef _dart_SDL_lltoa = ffi.Pointer<ffi.Int8> Function(
  int value,
  ffi.Pointer<ffi.Int8> str,
  int radix,
);

typedef _c_SDL_ulltoa = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint64 value,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 radix,
);

typedef _dart_SDL_ulltoa = ffi.Pointer<ffi.Int8> Function(
  int value,
  ffi.Pointer<ffi.Int8> str,
  int radix,
);

typedef _c_SDL_atoi = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_atoi = int Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_atof = ffi.Double Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_SDL_atof = double Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_SDL_strtol = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  ffi.Int32 base,
);

typedef _dart_SDL_strtol = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  int base,
);

typedef _c_SDL_strtoul = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  ffi.Int32 base,
);

typedef _dart_SDL_strtoul = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  int base,
);

typedef _c_SDL_strtoll = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  ffi.Int32 base,
);

typedef _dart_SDL_strtoll = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  int base,
);

typedef _c_SDL_strtoull = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  ffi.Int32 base,
);

typedef _dart_SDL_strtoull = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
  int base,
);

typedef _c_SDL_strtod = ffi.Double Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
);

typedef _dart_SDL_strtod = double Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endp,
);

typedef _c_SDL_strcmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
);

typedef _dart_SDL_strcmp = int Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
);

typedef _c_SDL_strncmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
  ffi.Uint64 maxlen,
);

typedef _dart_SDL_strncmp = int Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
  int maxlen,
);

typedef _c_SDL_strcasecmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
);

typedef _dart_SDL_strcasecmp = int Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
);

typedef _c_SDL_strncasecmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
  ffi.Uint64 len,
);

typedef _dart_SDL_strncasecmp = int Function(
  ffi.Pointer<ffi.Int8> str1,
  ffi.Pointer<ffi.Int8> str2,
  int len,
);

typedef _c_SDL_sscanf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_sscanf = int Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_vsscanf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<ffi.Int8> ap,
);

typedef _dart_SDL_vsscanf = int Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<ffi.Int8> ap,
);

typedef _c_SDL_snprintf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Uint64 maxlen,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_snprintf = int Function(
  ffi.Pointer<ffi.Int8> text,
  int maxlen,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_vsnprintf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Uint64 maxlen,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<ffi.Int8> ap,
);

typedef _dart_SDL_vsnprintf = int Function(
  ffi.Pointer<ffi.Int8> text,
  int maxlen,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<ffi.Int8> ap,
);

typedef _c_SDL_acos = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_acos = double Function(
  double x,
);

typedef _c_SDL_acosf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_acosf = double Function(
  double x,
);

typedef _c_SDL_asin = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_asin = double Function(
  double x,
);

typedef _c_SDL_asinf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_asinf = double Function(
  double x,
);

typedef _c_SDL_atan = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_atan = double Function(
  double x,
);

typedef _c_SDL_atanf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_atanf = double Function(
  double x,
);

typedef _c_SDL_atan2 = ffi.Double Function(
  ffi.Double x,
  ffi.Double y,
);

typedef _dart_SDL_atan2 = double Function(
  double x,
  double y,
);

typedef _c_SDL_atan2f = ffi.Float Function(
  ffi.Float x,
  ffi.Float y,
);

typedef _dart_SDL_atan2f = double Function(
  double x,
  double y,
);

typedef _c_SDL_ceil = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_ceil = double Function(
  double x,
);

typedef _c_SDL_ceilf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_ceilf = double Function(
  double x,
);

typedef _c_SDL_copysign = ffi.Double Function(
  ffi.Double x,
  ffi.Double y,
);

typedef _dart_SDL_copysign = double Function(
  double x,
  double y,
);

typedef _c_SDL_copysignf = ffi.Float Function(
  ffi.Float x,
  ffi.Float y,
);

typedef _dart_SDL_copysignf = double Function(
  double x,
  double y,
);

typedef _c_SDL_cos = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_cos = double Function(
  double x,
);

typedef _c_SDL_cosf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_cosf = double Function(
  double x,
);

typedef _c_SDL_exp = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_exp = double Function(
  double x,
);

typedef _c_SDL_expf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_expf = double Function(
  double x,
);

typedef _c_SDL_fabs = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_fabs = double Function(
  double x,
);

typedef _c_SDL_fabsf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_fabsf = double Function(
  double x,
);

typedef _c_SDL_floor = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_floor = double Function(
  double x,
);

typedef _c_SDL_floorf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_floorf = double Function(
  double x,
);

typedef _c_SDL_trunc = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_trunc = double Function(
  double x,
);

typedef _c_SDL_truncf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_truncf = double Function(
  double x,
);

typedef _c_SDL_fmod = ffi.Double Function(
  ffi.Double x,
  ffi.Double y,
);

typedef _dart_SDL_fmod = double Function(
  double x,
  double y,
);

typedef _c_SDL_fmodf = ffi.Float Function(
  ffi.Float x,
  ffi.Float y,
);

typedef _dart_SDL_fmodf = double Function(
  double x,
  double y,
);

typedef _c_SDL_log = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_log = double Function(
  double x,
);

typedef _c_SDL_logf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_logf = double Function(
  double x,
);

typedef _c_SDL_log10 = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_log10 = double Function(
  double x,
);

typedef _c_SDL_log10f = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_log10f = double Function(
  double x,
);

typedef _c_SDL_pow = ffi.Double Function(
  ffi.Double x,
  ffi.Double y,
);

typedef _dart_SDL_pow = double Function(
  double x,
  double y,
);

typedef _c_SDL_powf = ffi.Float Function(
  ffi.Float x,
  ffi.Float y,
);

typedef _dart_SDL_powf = double Function(
  double x,
  double y,
);

typedef _c_SDL_scalbn = ffi.Double Function(
  ffi.Double x,
  ffi.Int32 n,
);

typedef _dart_SDL_scalbn = double Function(
  double x,
  int n,
);

typedef _c_SDL_scalbnf = ffi.Float Function(
  ffi.Float x,
  ffi.Int32 n,
);

typedef _dart_SDL_scalbnf = double Function(
  double x,
  int n,
);

typedef _c_SDL_sin = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_sin = double Function(
  double x,
);

typedef _c_SDL_sinf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_sinf = double Function(
  double x,
);

typedef _c_SDL_sqrt = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_sqrt = double Function(
  double x,
);

typedef _c_SDL_sqrtf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_sqrtf = double Function(
  double x,
);

typedef _c_SDL_tan = ffi.Double Function(
  ffi.Double x,
);

typedef _dart_SDL_tan = double Function(
  double x,
);

typedef _c_SDL_tanf = ffi.Float Function(
  ffi.Float x,
);

typedef _dart_SDL_tanf = double Function(
  double x,
);

typedef _c_SDL_iconv_open = ffi.Pointer<_SDL_iconv_t> Function(
  ffi.Pointer<ffi.Int8> tocode,
  ffi.Pointer<ffi.Int8> fromcode,
);

typedef _dart_SDL_iconv_open = ffi.Pointer<_SDL_iconv_t> Function(
  ffi.Pointer<ffi.Int8> tocode,
  ffi.Pointer<ffi.Int8> fromcode,
);

typedef _c_SDL_iconv_close = ffi.Int32 Function(
  ffi.Pointer<_SDL_iconv_t> cd,
);

typedef _dart_SDL_iconv_close = int Function(
  ffi.Pointer<_SDL_iconv_t> cd,
);

typedef _c_SDL_iconv = ffi.Uint64 Function(
  ffi.Pointer<_SDL_iconv_t> cd,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> inbuf,
  ffi.Pointer<ffi.Uint64> inbytesleft,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> outbuf,
  ffi.Pointer<ffi.Uint64> outbytesleft,
);

typedef _dart_SDL_iconv = int Function(
  ffi.Pointer<_SDL_iconv_t> cd,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> inbuf,
  ffi.Pointer<ffi.Uint64> inbytesleft,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> outbuf,
  ffi.Pointer<ffi.Uint64> outbytesleft,
);

typedef _c_SDL_iconv_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> tocode,
  ffi.Pointer<ffi.Int8> fromcode,
  ffi.Pointer<ffi.Int8> inbuf,
  ffi.Uint64 inbytesleft,
);

typedef _dart_SDL_iconv_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> tocode,
  ffi.Pointer<ffi.Int8> fromcode,
  ffi.Pointer<ffi.Int8> inbuf,
  int inbytesleft,
);

typedef _c_SDL_main = ffi.Int32 Function(
  ffi.Int32 argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
);

typedef _dart_SDL_main = int Function(
  int argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
);

typedef _c_SDL_SetMainReady = ffi.Void Function();

typedef _dart_SDL_SetMainReady = void Function();

typedef _c_SDL_RegisterApp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Uint32 style,
  ffi.Pointer<ffi.Void> hInst,
);

typedef _dart_SDL_RegisterApp = int Function(
  ffi.Pointer<ffi.Int8> name,
  int style,
  ffi.Pointer<ffi.Void> hInst,
);

typedef _c_SDL_UnregisterApp = ffi.Void Function();

typedef _dart_SDL_UnregisterApp = void Function();

typedef _c___debugbreak = ffi.Void Function();

typedef _dart___debugbreak = void Function();

typedef _c_SDL_ReportAssertion = ffi.Int32 Function(
  ffi.Pointer<SDL_AssertData> arg0,
  ffi.Pointer<ffi.Int8> arg1,
  ffi.Pointer<ffi.Int8> arg2,
  ffi.Int32 arg3,
);

typedef _dart_SDL_ReportAssertion = int Function(
  ffi.Pointer<SDL_AssertData> arg0,
  ffi.Pointer<ffi.Int8> arg1,
  ffi.Pointer<ffi.Int8> arg2,
  int arg3,
);

typedef SDL_AssertionHandler = ffi.Int32 Function(
  ffi.Pointer<SDL_AssertData>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_SetAssertionHandler = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> handler,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_SDL_SetAssertionHandler = void Function(
  ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> handler,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_SDL_GetDefaultAssertionHandler
    = ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> Function();

typedef _dart_SDL_GetDefaultAssertionHandler
    = ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> Function();

typedef _c_SDL_GetAssertionHandler
    = ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> puserdata,
);

typedef _dart_SDL_GetAssertionHandler
    = ffi.Pointer<ffi.NativeFunction<SDL_AssertionHandler>> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> puserdata,
);

typedef _c_SDL_GetAssertionReport = ffi.Pointer<SDL_AssertData> Function();

typedef _dart_SDL_GetAssertionReport = ffi.Pointer<SDL_AssertData> Function();

typedef _c_SDL_ResetAssertionReport = ffi.Void Function();

typedef _dart_SDL_ResetAssertionReport = void Function();

typedef _c_SDL_AtomicTryLock = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> lock,
);

typedef _dart_SDL_AtomicTryLock = int Function(
  ffi.Pointer<ffi.Int32> lock,
);

typedef _c_SDL_AtomicLock = ffi.Void Function(
  ffi.Pointer<ffi.Int32> lock,
);

typedef _dart_SDL_AtomicLock = void Function(
  ffi.Pointer<ffi.Int32> lock,
);

typedef _c_SDL_AtomicUnlock = ffi.Void Function(
  ffi.Pointer<ffi.Int32> lock,
);

typedef _dart_SDL_AtomicUnlock = void Function(
  ffi.Pointer<ffi.Int32> lock,
);

typedef _c_SDL_MemoryBarrierReleaseFunction = ffi.Void Function();

typedef _dart_SDL_MemoryBarrierReleaseFunction = void Function();

typedef _c_SDL_MemoryBarrierAcquireFunction = ffi.Void Function();

typedef _dart_SDL_MemoryBarrierAcquireFunction = void Function();

typedef _c_SDL_AtomicCAS = ffi.Int32 Function(
  ffi.Pointer<SDL_atomic_t> a,
  ffi.Int32 oldval,
  ffi.Int32 newval,
);

typedef _dart_SDL_AtomicCAS = int Function(
  ffi.Pointer<SDL_atomic_t> a,
  int oldval,
  int newval,
);

typedef _c_SDL_AtomicSet = ffi.Int32 Function(
  ffi.Pointer<SDL_atomic_t> a,
  ffi.Int32 v,
);

typedef _dart_SDL_AtomicSet = int Function(
  ffi.Pointer<SDL_atomic_t> a,
  int v,
);

typedef _c_SDL_AtomicGet = ffi.Int32 Function(
  ffi.Pointer<SDL_atomic_t> a,
);

typedef _dart_SDL_AtomicGet = int Function(
  ffi.Pointer<SDL_atomic_t> a,
);

typedef _c_SDL_AtomicAdd = ffi.Int32 Function(
  ffi.Pointer<SDL_atomic_t> a,
  ffi.Int32 v,
);

typedef _dart_SDL_AtomicAdd = int Function(
  ffi.Pointer<SDL_atomic_t> a,
  int v,
);

typedef _c_SDL_AtomicCASPtr = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ffi.Pointer<ffi.Void> oldval,
  ffi.Pointer<ffi.Void> newval,
);

typedef _dart_SDL_AtomicCASPtr = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ffi.Pointer<ffi.Void> oldval,
  ffi.Pointer<ffi.Void> newval,
);

typedef _c_SDL_AtomicSetPtr = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ffi.Pointer<ffi.Void> v,
);

typedef _dart_SDL_AtomicSetPtr = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> a,
  ffi.Pointer<ffi.Void> v,
);

typedef _c_SDL_AtomicGetPtr = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> a,
);

typedef _dart_SDL_AtomicGetPtr = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> a,
);

typedef _c_SDL_SetError = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_SetError = int Function(
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_GetError = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetError = ffi.Pointer<ffi.Int8> Function();

typedef _c_SDL_GetErrorMsg = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> errstr,
  ffi.Int32 maxlen,
);

typedef _dart_SDL_GetErrorMsg = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> errstr,
  int maxlen,
);

typedef _c_SDL_ClearError = ffi.Void Function();

typedef _dart_SDL_ClearError = void Function();

typedef _c_SDL_Error = ffi.Int32 Function(
  ffi.Int32 code,
);

typedef _dart_SDL_Error = int Function(
  int code,
);

typedef _c_SDL_CreateMutex = ffi.Pointer<SDL_mutex> Function();

typedef _dart_SDL_CreateMutex = ffi.Pointer<SDL_mutex> Function();

typedef _c_SDL_LockMutex = ffi.Int32 Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _dart_SDL_LockMutex = int Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _c_SDL_TryLockMutex = ffi.Int32 Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _dart_SDL_TryLockMutex = int Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _c_SDL_UnlockMutex = ffi.Int32 Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _dart_SDL_UnlockMutex = int Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _c_SDL_DestroyMutex = ffi.Void Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _dart_SDL_DestroyMutex = void Function(
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _c_SDL_CreateSemaphore = ffi.Pointer<SDL_semaphore> Function(
  ffi.Uint32 initial_value,
);

typedef _dart_SDL_CreateSemaphore = ffi.Pointer<SDL_semaphore> Function(
  int initial_value,
);

typedef _c_SDL_DestroySemaphore = ffi.Void Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _dart_SDL_DestroySemaphore = void Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _c_SDL_SemWait = ffi.Int32 Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _dart_SDL_SemWait = int Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _c_SDL_SemTryWait = ffi.Int32 Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _dart_SDL_SemTryWait = int Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _c_SDL_SemWaitTimeout = ffi.Int32 Function(
  ffi.Pointer<SDL_semaphore> sem,
  ffi.Uint32 ms,
);

typedef _dart_SDL_SemWaitTimeout = int Function(
  ffi.Pointer<SDL_semaphore> sem,
  int ms,
);

typedef _c_SDL_SemPost = ffi.Int32 Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _dart_SDL_SemPost = int Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _c_SDL_SemValue = ffi.Uint32 Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _dart_SDL_SemValue = int Function(
  ffi.Pointer<SDL_semaphore> sem,
);

typedef _c_SDL_CreateCond = ffi.Pointer<SDL_cond> Function();

typedef _dart_SDL_CreateCond = ffi.Pointer<SDL_cond> Function();

typedef _c_SDL_DestroyCond = ffi.Void Function(
  ffi.Pointer<SDL_cond> cond,
);

typedef _dart_SDL_DestroyCond = void Function(
  ffi.Pointer<SDL_cond> cond,
);

typedef _c_SDL_CondSignal = ffi.Int32 Function(
  ffi.Pointer<SDL_cond> cond,
);

typedef _dart_SDL_CondSignal = int Function(
  ffi.Pointer<SDL_cond> cond,
);

typedef _c_SDL_CondBroadcast = ffi.Int32 Function(
  ffi.Pointer<SDL_cond> cond,
);

typedef _dart_SDL_CondBroadcast = int Function(
  ffi.Pointer<SDL_cond> cond,
);

typedef _c_SDL_CondWait = ffi.Int32 Function(
  ffi.Pointer<SDL_cond> cond,
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _dart_SDL_CondWait = int Function(
  ffi.Pointer<SDL_cond> cond,
  ffi.Pointer<SDL_mutex> mutex,
);

typedef _c_SDL_CondWaitTimeout = ffi.Int32 Function(
  ffi.Pointer<SDL_cond> cond,
  ffi.Pointer<SDL_mutex> mutex,
  ffi.Uint32 ms,
);

typedef _dart_SDL_CondWaitTimeout = int Function(
  ffi.Pointer<SDL_cond> cond,
  ffi.Pointer<SDL_mutex> mutex,
  int ms,
);

typedef _c__fperrraise = ffi.Void Function(
  ffi.Int32 _Except,
);

typedef _dart__fperrraise = void Function(
  int _Except,
);

typedef _c__dclass = ffi.Int16 Function(
  ffi.Double _X,
);

typedef _dart__dclass = int Function(
  double _X,
);

typedef _c__fdclass = ffi.Int16 Function(
  ffi.Float _X,
);

typedef _dart__fdclass = int Function(
  double _X,
);

typedef _c__dsign = ffi.Int32 Function(
  ffi.Double _X,
);

typedef _dart__dsign = int Function(
  double _X,
);

typedef _c__fdsign = ffi.Int32 Function(
  ffi.Float _X,
);

typedef _dart__fdsign = int Function(
  double _X,
);

typedef _c__dpcomp = ffi.Int32 Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart__dpcomp = int Function(
  double _X,
  double _Y,
);

typedef _c__fdpcomp = ffi.Int32 Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart__fdpcomp = int Function(
  double _X,
  double _Y,
);

typedef _c__dtest = ffi.Int16 Function(
  ffi.Pointer<ffi.Double> _Px,
);

typedef _dart__dtest = int Function(
  ffi.Pointer<ffi.Double> _Px,
);

typedef _c__fdtest = ffi.Int16 Function(
  ffi.Pointer<ffi.Float> _Px,
);

typedef _dart__fdtest = int Function(
  ffi.Pointer<ffi.Float> _Px,
);

typedef _c__d_int = ffi.Int16 Function(
  ffi.Pointer<ffi.Double> _Px,
  ffi.Int16 _Xexp,
);

typedef _dart__d_int = int Function(
  ffi.Pointer<ffi.Double> _Px,
  int _Xexp,
);

typedef _c__fd_int = ffi.Int16 Function(
  ffi.Pointer<ffi.Float> _Px,
  ffi.Int16 _Xexp,
);

typedef _dart__fd_int = int Function(
  ffi.Pointer<ffi.Float> _Px,
  int _Xexp,
);

typedef _c__dscale = ffi.Int16 Function(
  ffi.Pointer<ffi.Double> _Px,
  ffi.Int64 _Lexp,
);

typedef _dart__dscale = int Function(
  ffi.Pointer<ffi.Double> _Px,
  int _Lexp,
);

typedef _c__fdscale = ffi.Int16 Function(
  ffi.Pointer<ffi.Float> _Px,
  ffi.Int64 _Lexp,
);

typedef _dart__fdscale = int Function(
  ffi.Pointer<ffi.Float> _Px,
  int _Lexp,
);

typedef _c__dunscale = ffi.Int16 Function(
  ffi.Pointer<ffi.Int16> _Pex,
  ffi.Pointer<ffi.Double> _Px,
);

typedef _dart__dunscale = int Function(
  ffi.Pointer<ffi.Int16> _Pex,
  ffi.Pointer<ffi.Double> _Px,
);

typedef _c__fdunscale = ffi.Int16 Function(
  ffi.Pointer<ffi.Int16> _Pex,
  ffi.Pointer<ffi.Float> _Px,
);

typedef _dart__fdunscale = int Function(
  ffi.Pointer<ffi.Int16> _Pex,
  ffi.Pointer<ffi.Float> _Px,
);

typedef _c__dexp = ffi.Int16 Function(
  ffi.Pointer<ffi.Double> _Px,
  ffi.Double _Y,
  ffi.Int64 _Eoff,
);

typedef _dart__dexp = int Function(
  ffi.Pointer<ffi.Double> _Px,
  double _Y,
  int _Eoff,
);

typedef _c__fdexp = ffi.Int16 Function(
  ffi.Pointer<ffi.Float> _Px,
  ffi.Float _Y,
  ffi.Int64 _Eoff,
);

typedef _dart__fdexp = int Function(
  ffi.Pointer<ffi.Float> _Px,
  double _Y,
  int _Eoff,
);

typedef _c__dnorm = ffi.Int16 Function(
  ffi.Pointer<ffi.Uint16> _Ps,
);

typedef _dart__dnorm = int Function(
  ffi.Pointer<ffi.Uint16> _Ps,
);

typedef _c__fdnorm = ffi.Int16 Function(
  ffi.Pointer<ffi.Uint16> _Ps,
);

typedef _dart__fdnorm = int Function(
  ffi.Pointer<ffi.Uint16> _Ps,
);

typedef _c__dpoly = ffi.Double Function(
  ffi.Double _X,
  ffi.Pointer<ffi.Double> _Tab,
  ffi.Int32 _N,
);

typedef _dart__dpoly = double Function(
  double _X,
  ffi.Pointer<ffi.Double> _Tab,
  int _N,
);

typedef _c__fdpoly = ffi.Float Function(
  ffi.Float _X,
  ffi.Pointer<ffi.Float> _Tab,
  ffi.Int32 _N,
);

typedef _dart__fdpoly = double Function(
  double _X,
  ffi.Pointer<ffi.Float> _Tab,
  int _N,
);

typedef _c__dlog = ffi.Double Function(
  ffi.Double _X,
  ffi.Int32 _Baseflag,
);

typedef _dart__dlog = double Function(
  double _X,
  int _Baseflag,
);

typedef _c__fdlog = ffi.Float Function(
  ffi.Float _X,
  ffi.Int32 _Baseflag,
);

typedef _dart__fdlog = double Function(
  double _X,
  int _Baseflag,
);

typedef _c__dsin = ffi.Double Function(
  ffi.Double _X,
  ffi.Uint32 _Qoff,
);

typedef _dart__dsin = double Function(
  double _X,
  int _Qoff,
);

typedef _c__fdsin = ffi.Float Function(
  ffi.Float _X,
  ffi.Uint32 _Qoff,
);

typedef _dart__fdsin = double Function(
  double _X,
  int _Qoff,
);

typedef _c_abs = ffi.Int32 Function(
  ffi.Int32 _X,
);

typedef _dart_abs = int Function(
  int _X,
);

typedef _c_labs = ffi.Int64 Function(
  ffi.Int64 _X,
);

typedef _dart_labs = int Function(
  int _X,
);

typedef _c_llabs = ffi.Int64 Function(
  ffi.Int64 _X,
);

typedef _dart_llabs = int Function(
  int _X,
);

typedef _c_acos = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_acos = double Function(
  double _X,
);

typedef _c_asin = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_asin = double Function(
  double _X,
);

typedef _c_atan = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_atan = double Function(
  double _X,
);

typedef _c_atan2 = ffi.Double Function(
  ffi.Double _Y,
  ffi.Double _X,
);

typedef _dart_atan2 = double Function(
  double _Y,
  double _X,
);

typedef _c_cos = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_cos = double Function(
  double _X,
);

typedef _c_cosh = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_cosh = double Function(
  double _X,
);

typedef _c_exp = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_exp = double Function(
  double _X,
);

typedef _c_fabs = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_fabs = double Function(
  double _X,
);

typedef _c_fmod = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_fmod = double Function(
  double _X,
  double _Y,
);

typedef _c_log = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_log = double Function(
  double _X,
);

typedef _c_log10 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_log10 = double Function(
  double _X,
);

typedef _c_pow = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_pow = double Function(
  double _X,
  double _Y,
);

typedef _c_sin = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_sin = double Function(
  double _X,
);

typedef _c_sinh = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_sinh = double Function(
  double _X,
);

typedef _c_sqrt = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_sqrt = double Function(
  double _X,
);

typedef _c_tan = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_tan = double Function(
  double _X,
);

typedef _c_tanh = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_tanh = double Function(
  double _X,
);

typedef _c_acosh = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_acosh = double Function(
  double _X,
);

typedef _c_asinh = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_asinh = double Function(
  double _X,
);

typedef _c_atanh = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_atanh = double Function(
  double _X,
);

typedef _c_atof = ffi.Double Function(
  ffi.Pointer<ffi.Int8> _String,
);

typedef _dart_atof = double Function(
  ffi.Pointer<ffi.Int8> _String,
);

typedef _c__atof_l = ffi.Double Function(
  ffi.Pointer<ffi.Int8> _String,
  ffi.Pointer<__crt_locale_pointers> _Locale,
);

typedef _dart__atof_l = double Function(
  ffi.Pointer<ffi.Int8> _String,
  ffi.Pointer<__crt_locale_pointers> _Locale,
);

typedef _c__cabs = ffi.Double Function(
  _complex _Complex_value,
);

typedef _dart__cabs = double Function(
  _complex _Complex_value,
);

typedef _c_cbrt = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_cbrt = double Function(
  double _X,
);

typedef _c_ceil = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_ceil = double Function(
  double _X,
);

typedef _c__chgsign = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart__chgsign = double Function(
  double _X,
);

typedef _c_copysign = ffi.Double Function(
  ffi.Double _Number,
  ffi.Double _Sign,
);

typedef _dart_copysign = double Function(
  double _Number,
  double _Sign,
);

typedef _c__copysign = ffi.Double Function(
  ffi.Double _Number,
  ffi.Double _Sign,
);

typedef _dart__copysign = double Function(
  double _Number,
  double _Sign,
);

typedef _c_erf = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_erf = double Function(
  double _X,
);

typedef _c_erfc = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_erfc = double Function(
  double _X,
);

typedef _c_exp2 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_exp2 = double Function(
  double _X,
);

typedef _c_expm1 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_expm1 = double Function(
  double _X,
);

typedef _c_fdim = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_fdim = double Function(
  double _X,
  double _Y,
);

typedef _c_floor = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_floor = double Function(
  double _X,
);

typedef _c_fma = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
  ffi.Double _Z,
);

typedef _dart_fma = double Function(
  double _X,
  double _Y,
  double _Z,
);

typedef _c_fmax = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_fmax = double Function(
  double _X,
  double _Y,
);

typedef _c_fmin = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_fmin = double Function(
  double _X,
  double _Y,
);

typedef _c_frexp = ffi.Double Function(
  ffi.Double _X,
  ffi.Pointer<ffi.Int32> _Y,
);

typedef _dart_frexp = double Function(
  double _X,
  ffi.Pointer<ffi.Int32> _Y,
);

typedef _c_hypot = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_hypot = double Function(
  double _X,
  double _Y,
);

typedef _c__hypot = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart__hypot = double Function(
  double _X,
  double _Y,
);

typedef _c_ilogb = ffi.Int32 Function(
  ffi.Double _X,
);

typedef _dart_ilogb = int Function(
  double _X,
);

typedef _c_ldexp = ffi.Double Function(
  ffi.Double _X,
  ffi.Int32 _Y,
);

typedef _dart_ldexp = double Function(
  double _X,
  int _Y,
);

typedef _c_lgamma = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_lgamma = double Function(
  double _X,
);

typedef _c_llrint = ffi.Int64 Function(
  ffi.Double _X,
);

typedef _dart_llrint = int Function(
  double _X,
);

typedef _c_llround = ffi.Int64 Function(
  ffi.Double _X,
);

typedef _dart_llround = int Function(
  double _X,
);

typedef _c_log1p = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_log1p = double Function(
  double _X,
);

typedef _c_log2 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_log2 = double Function(
  double _X,
);

typedef _c_logb = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_logb = double Function(
  double _X,
);

typedef _c_lrint = ffi.Int64 Function(
  ffi.Double _X,
);

typedef _dart_lrint = int Function(
  double _X,
);

typedef _c_lround = ffi.Int64 Function(
  ffi.Double _X,
);

typedef _dart_lround = int Function(
  double _X,
);

typedef _c__matherr = ffi.Int32 Function(
  ffi.Pointer<_exception> _Except,
);

typedef _dart__matherr = int Function(
  ffi.Pointer<_exception> _Except,
);

typedef _c_modf = ffi.Double Function(
  ffi.Double _X,
  ffi.Pointer<ffi.Double> _Y,
);

typedef _dart_modf = double Function(
  double _X,
  ffi.Pointer<ffi.Double> _Y,
);

typedef _c_nan = ffi.Double Function(
  ffi.Pointer<ffi.Int8> _X,
);

typedef _dart_nan = double Function(
  ffi.Pointer<ffi.Int8> _X,
);

typedef _c_nearbyint = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_nearbyint = double Function(
  double _X,
);

typedef _c_nextafter = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_nextafter = double Function(
  double _X,
  double _Y,
);

typedef _c_remainder = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
);

typedef _dart_remainder = double Function(
  double _X,
  double _Y,
);

typedef _c_remquo = ffi.Double Function(
  ffi.Double _X,
  ffi.Double _Y,
  ffi.Pointer<ffi.Int32> _Z,
);

typedef _dart_remquo = double Function(
  double _X,
  double _Y,
  ffi.Pointer<ffi.Int32> _Z,
);

typedef _c_rint = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_rint = double Function(
  double _X,
);

typedef _c_round = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_round = double Function(
  double _X,
);

typedef _c_scalbln = ffi.Double Function(
  ffi.Double _X,
  ffi.Int64 _Y,
);

typedef _dart_scalbln = double Function(
  double _X,
  int _Y,
);

typedef _c_scalbn = ffi.Double Function(
  ffi.Double _X,
  ffi.Int32 _Y,
);

typedef _dart_scalbn = double Function(
  double _X,
  int _Y,
);

typedef _c_tgamma = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_tgamma = double Function(
  double _X,
);

typedef _c_trunc = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_trunc = double Function(
  double _X,
);

typedef _c__j0 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart__j0 = double Function(
  double _X,
);

typedef _c__j1 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart__j1 = double Function(
  double _X,
);

typedef _c__jn = ffi.Double Function(
  ffi.Int32 _X,
  ffi.Double _Y,
);

typedef _dart__jn = double Function(
  int _X,
  double _Y,
);

typedef _c__y0 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart__y0 = double Function(
  double _X,
);

typedef _c__y1 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart__y1 = double Function(
  double _X,
);

typedef _c__yn = ffi.Double Function(
  ffi.Int32 _X,
  ffi.Double _Y,
);

typedef _dart__yn = double Function(
  int _X,
  double _Y,
);

typedef _c_acoshf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_acoshf = double Function(
  double _X,
);

typedef _c_asinhf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_asinhf = double Function(
  double _X,
);

typedef _c_atanhf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_atanhf = double Function(
  double _X,
);

typedef _c_cbrtf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_cbrtf = double Function(
  double _X,
);

typedef _c__chgsignf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart__chgsignf = double Function(
  double _X,
);

typedef _c_copysignf = ffi.Float Function(
  ffi.Float _Number,
  ffi.Float _Sign,
);

typedef _dart_copysignf = double Function(
  double _Number,
  double _Sign,
);

typedef _c__copysignf = ffi.Float Function(
  ffi.Float _Number,
  ffi.Float _Sign,
);

typedef _dart__copysignf = double Function(
  double _Number,
  double _Sign,
);

typedef _c_erff = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_erff = double Function(
  double _X,
);

typedef _c_erfcf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_erfcf = double Function(
  double _X,
);

typedef _c_expm1f = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_expm1f = double Function(
  double _X,
);

typedef _c_exp2f = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_exp2f = double Function(
  double _X,
);

typedef _c_fdimf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_fdimf = double Function(
  double _X,
  double _Y,
);

typedef _c_fmaf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
  ffi.Float _Z,
);

typedef _dart_fmaf = double Function(
  double _X,
  double _Y,
  double _Z,
);

typedef _c_fmaxf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_fmaxf = double Function(
  double _X,
  double _Y,
);

typedef _c_fminf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_fminf = double Function(
  double _X,
  double _Y,
);

typedef _c__hypotf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart__hypotf = double Function(
  double _X,
  double _Y,
);

typedef _c_ilogbf = ffi.Int32 Function(
  ffi.Float _X,
);

typedef _dart_ilogbf = int Function(
  double _X,
);

typedef _c_lgammaf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_lgammaf = double Function(
  double _X,
);

typedef _c_llrintf = ffi.Int64 Function(
  ffi.Float _X,
);

typedef _dart_llrintf = int Function(
  double _X,
);

typedef _c_llroundf = ffi.Int64 Function(
  ffi.Float _X,
);

typedef _dart_llroundf = int Function(
  double _X,
);

typedef _c_log1pf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_log1pf = double Function(
  double _X,
);

typedef _c_log2f = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_log2f = double Function(
  double _X,
);

typedef _c_logbf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_logbf = double Function(
  double _X,
);

typedef _c_lrintf = ffi.Int64 Function(
  ffi.Float _X,
);

typedef _dart_lrintf = int Function(
  double _X,
);

typedef _c_lroundf = ffi.Int64 Function(
  ffi.Float _X,
);

typedef _dart_lroundf = int Function(
  double _X,
);

typedef _c_nanf = ffi.Float Function(
  ffi.Pointer<ffi.Int8> _X,
);

typedef _dart_nanf = double Function(
  ffi.Pointer<ffi.Int8> _X,
);

typedef _c_nearbyintf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_nearbyintf = double Function(
  double _X,
);

typedef _c_nextafterf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_nextafterf = double Function(
  double _X,
  double _Y,
);

typedef _c_remainderf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_remainderf = double Function(
  double _X,
  double _Y,
);

typedef _c_remquof = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
  ffi.Pointer<ffi.Int32> _Z,
);

typedef _dart_remquof = double Function(
  double _X,
  double _Y,
  ffi.Pointer<ffi.Int32> _Z,
);

typedef _c_rintf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_rintf = double Function(
  double _X,
);

typedef _c_roundf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_roundf = double Function(
  double _X,
);

typedef _c_scalblnf = ffi.Float Function(
  ffi.Float _X,
  ffi.Int64 _Y,
);

typedef _dart_scalblnf = double Function(
  double _X,
  int _Y,
);

typedef _c_scalbnf = ffi.Float Function(
  ffi.Float _X,
  ffi.Int32 _Y,
);

typedef _dart_scalbnf = double Function(
  double _X,
  int _Y,
);

typedef _c_tgammaf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_tgammaf = double Function(
  double _X,
);

typedef _c_truncf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_truncf = double Function(
  double _X,
);

typedef _c__logbf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart__logbf = double Function(
  double _X,
);

typedef _c__nextafterf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart__nextafterf = double Function(
  double _X,
  double _Y,
);

typedef _c__finitef = ffi.Int32 Function(
  ffi.Float _X,
);

typedef _dart__finitef = int Function(
  double _X,
);

typedef _c__isnanf = ffi.Int32 Function(
  ffi.Float _X,
);

typedef _dart__isnanf = int Function(
  double _X,
);

typedef _c__fpclassf = ffi.Int32 Function(
  ffi.Float _X,
);

typedef _dart__fpclassf = int Function(
  double _X,
);

typedef _c__set_FMA3_enable = ffi.Int32 Function(
  ffi.Int32 _Flag,
);

typedef _dart__set_FMA3_enable = int Function(
  int _Flag,
);

typedef _c__get_FMA3_enable = ffi.Int32 Function();

typedef _dart__get_FMA3_enable = int Function();

typedef _c_acosf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_acosf = double Function(
  double _X,
);

typedef _c_asinf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_asinf = double Function(
  double _X,
);

typedef _c_atan2f = ffi.Float Function(
  ffi.Float _Y,
  ffi.Float _X,
);

typedef _dart_atan2f = double Function(
  double _Y,
  double _X,
);

typedef _c_atanf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_atanf = double Function(
  double _X,
);

typedef _c_ceilf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_ceilf = double Function(
  double _X,
);

typedef _c_cosf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_cosf = double Function(
  double _X,
);

typedef _c_coshf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_coshf = double Function(
  double _X,
);

typedef _c_expf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_expf = double Function(
  double _X,
);

typedef _c_floorf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_floorf = double Function(
  double _X,
);

typedef _c_fmodf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_fmodf = double Function(
  double _X,
  double _Y,
);

typedef _c_log10f = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_log10f = double Function(
  double _X,
);

typedef _c_logf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_logf = double Function(
  double _X,
);

typedef _c_modff = ffi.Float Function(
  ffi.Float _X,
  ffi.Pointer<ffi.Float> _Y,
);

typedef _dart_modff = double Function(
  double _X,
  ffi.Pointer<ffi.Float> _Y,
);

typedef _c_powf = ffi.Float Function(
  ffi.Float _X,
  ffi.Float _Y,
);

typedef _dart_powf = double Function(
  double _X,
  double _Y,
);

typedef _c_sinf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_sinf = double Function(
  double _X,
);

typedef _c_sinhf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_sinhf = double Function(
  double _X,
);

typedef _c_sqrtf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_sqrtf = double Function(
  double _X,
);

typedef _c_tanf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_tanf = double Function(
  double _X,
);

typedef _c_tanhf = ffi.Float Function(
  ffi.Float _X,
);

typedef _dart_tanhf = double Function(
  double _X,
);

typedef _c_j0 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_j0 = double Function(
  double _X,
);

typedef _c_j1 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_j1 = double Function(
  double _X,
);

typedef _c_jn = ffi.Double Function(
  ffi.Int32 _X,
  ffi.Double _Y,
);

typedef _dart_jn = double Function(
  int _X,
  double _Y,
);

typedef _c_y0 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_y0 = double Function(
  double _X,
);

typedef _c_y1 = ffi.Double Function(
  ffi.Double _X,
);

typedef _dart_y1 = double Function(
  double _X,
);

typedef _c_yn = ffi.Double Function(
  ffi.Int32 _X,
  ffi.Double _Y,
);

typedef _dart_yn = double Function(
  int _X,
  double _Y,
);

typedef _c___vcrt_initialize = ffi.Uint8 Function();

typedef _dart___vcrt_initialize = int Function();

typedef _c___vcrt_uninitialize = ffi.Uint8 Function(
  ffi.Uint8 _Terminating,
);

typedef _dart___vcrt_uninitialize = int Function(
  int _Terminating,
);

typedef _c___vcrt_uninitialize_critical = ffi.Uint8 Function();

typedef _dart___vcrt_uninitialize_critical = int Function();

typedef _c___vcrt_thread_attach = ffi.Uint8 Function();

typedef _dart___vcrt_thread_attach = int Function();

typedef _c___vcrt_thread_detach = ffi.Uint8 Function();

typedef _dart___vcrt_thread_detach = int Function();

typedef _c___isa_available_init = ffi.Int32 Function();

typedef _dart___isa_available_init = int Function();

typedef _c__get_startup_argv_mode = ffi.Int32 Function();

typedef _dart__get_startup_argv_mode = int Function();

typedef _c__seh_filter_dll = ffi.Int32 Function(
  ffi.Uint64 _ExceptionNum,
  ffi.Pointer<_EXCEPTION_POINTERS> _ExceptionPtr,
);

typedef _dart__seh_filter_dll = int Function(
  int _ExceptionNum,
  ffi.Pointer<_EXCEPTION_POINTERS> _ExceptionPtr,
);

typedef _c__seh_filter_exe = ffi.Int32 Function(
  ffi.Uint64 _ExceptionNum,
  ffi.Pointer<_EXCEPTION_POINTERS> _ExceptionPtr,
);

typedef _dart__seh_filter_exe = int Function(
  int _ExceptionNum,
  ffi.Pointer<_EXCEPTION_POINTERS> _ExceptionPtr,
);

typedef _c__query_app_type = ffi.Int32 Function();

typedef _dart__query_app_type = int Function();

typedef _c__set_app_type = ffi.Void Function(
  ffi.Int32 _Type,
);

typedef _dart__set_app_type = void Function(
  int _Type,
);

typedef _UserMathErrorFunctionPointer = ffi.Int32 Function(
  ffi.Pointer<_exception>,
);

typedef _c___setusermatherr = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<_UserMathErrorFunctionPointer>>
      _UserMathErrorFunction,
);

typedef _dart___setusermatherr = void Function(
  ffi.Pointer<ffi.NativeFunction<_UserMathErrorFunctionPointer>>
      _UserMathErrorFunction,
);

typedef _c__is_c_termination_complete = ffi.Int32 Function();

typedef _dart__is_c_termination_complete = int Function();

typedef _c__configure_narrow_argv = ffi.Int32 Function(
  ffi.Int32 mode,
);

typedef _dart__configure_narrow_argv = int Function(
  int mode,
);

typedef _c__configure_wide_argv = ffi.Int32 Function(
  ffi.Int32 mode,
);

typedef _dart__configure_wide_argv = int Function(
  int mode,
);

typedef _c__initialize_narrow_environment = ffi.Int32 Function();

typedef _dart__initialize_narrow_environment = int Function();

typedef _c__initialize_wide_environment = ffi.Int32 Function();

typedef _dart__initialize_wide_environment = int Function();

typedef _c__get_initial_narrow_environment = ffi.Pointer<ffi.Pointer<ffi.Int8>>
    Function();

typedef _dart__get_initial_narrow_environment
    = ffi.Pointer<ffi.Pointer<ffi.Int8>> Function();

typedef _c__get_initial_wide_environment = ffi.Pointer<ffi.Pointer<ffi.Uint16>>
    Function();

typedef _dart__get_initial_wide_environment
    = ffi.Pointer<ffi.Pointer<ffi.Uint16>> Function();

typedef _c__get_narrow_winmain_command_line = ffi.Pointer<ffi.Int8> Function();

typedef _dart__get_narrow_winmain_command_line = ffi.Pointer<ffi.Int8>
    Function();

typedef _c__get_wide_winmain_command_line = ffi.Pointer<ffi.Uint16> Function();

typedef _dart__get_wide_winmain_command_line = ffi.Pointer<ffi.Uint16>
    Function();

typedef _c___p__acmdln = ffi.Pointer<ffi.Pointer<ffi.Int8>> Function();

typedef _dart___p__acmdln = ffi.Pointer<ffi.Pointer<ffi.Int8>> Function();

typedef _c___p__wcmdln = ffi.Pointer<ffi.Pointer<ffi.Uint16>> Function();

typedef _dart___p__wcmdln = ffi.Pointer<ffi.Pointer<ffi.Uint16>> Function();

typedef _PVFV = ffi.Void Function();

typedef _c__initterm = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _First,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _Last,
);

typedef _dart__initterm = void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _First,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PVFV>>> _Last,
);

typedef _PIFV = ffi.Int32 Function();

typedef _c__initterm_e = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PIFV>>> _First,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PIFV>>> _Last,
);

typedef _dart__initterm_e = int Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PIFV>>> _First,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_PIFV>>> _Last,
);

typedef _c__initialize_onexit_table = ffi.Int32 Function(
  ffi.Pointer<_onexit_table_t> _Table,
);

typedef _dart__initialize_onexit_table = int Function(
  ffi.Pointer<_onexit_table_t> _Table,
);

typedef _onexit_t = ffi.Int32 Function();

typedef _c__register_onexit_function = ffi.Int32 Function(
  ffi.Pointer<_onexit_table_t> _Table,
  ffi.Pointer<ffi.NativeFunction<_onexit_t>> _Function,
);

typedef _dart__register_onexit_function = int Function(
  ffi.Pointer<_onexit_table_t> _Table,
  ffi.Pointer<ffi.NativeFunction<_onexit_t>> _Function,
);

typedef _c__execute_onexit_table = ffi.Int32 Function(
  ffi.Pointer<_onexit_table_t> _Table,
);

typedef _dart__execute_onexit_table = int Function(
  ffi.Pointer<_onexit_table_t> _Table,
);

typedef _c__crt_atexit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_PVFV>> _Function,
);

typedef _dart__crt_atexit = int Function(
  ffi.Pointer<ffi.NativeFunction<_PVFV>> _Function,
);

typedef _c__crt_at_quick_exit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_PVFV>> _Function,
);

typedef _dart__crt_at_quick_exit = int Function(
  ffi.Pointer<ffi.NativeFunction<_PVFV>> _Function,
);

typedef _c___acrt_initialize = ffi.Uint8 Function();

typedef _dart___acrt_initialize = int Function();

typedef _c___acrt_uninitialize = ffi.Uint8 Function(
  ffi.Uint8 _Terminating,
);

typedef _dart___acrt_uninitialize = int Function(
  int _Terminating,
);

typedef _c___acrt_uninitialize_critical = ffi.Uint8 Function(
  ffi.Uint8 _Terminating,
);

typedef _dart___acrt_uninitialize_critical = int Function(
  int _Terminating,
);

typedef _c___acrt_thread_attach = ffi.Uint8 Function();

typedef _dart___acrt_thread_attach = int Function();

typedef _c___acrt_thread_detach = ffi.Uint8 Function();

typedef _dart___acrt_thread_detach = int Function();

typedef _c__wexecl = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wexecl = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wexecle = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wexecle = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wexeclp = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wexeclp = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wexeclpe = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wexeclpe = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wexecv = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _dart__wexecv = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _c__wexecve = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _dart__wexecve = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _c__wexecvp = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _dart__wexecvp = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _c__wexecvpe = ffi.IntPtr Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _dart__wexecvpe = int Function(
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _c__wspawnl = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wspawnl = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wspawnle = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wspawnle = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wspawnlp = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wspawnlp = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wspawnlpe = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _dart__wspawnlpe = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Uint16> _ArgList,
);

typedef _c__wspawnv = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _dart__wspawnv = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _c__wspawnve = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _dart__wspawnve = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _c__wspawnvp = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _dart__wspawnvp = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
);

typedef _c__wspawnvpe = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _dart__wspawnvpe = int Function(
  int _Mode,
  ffi.Pointer<ffi.Uint16> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _ArgList,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> _Env,
);

typedef _c__wsystem = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> _Command,
);

typedef _dart__wsystem = int Function(
  ffi.Pointer<ffi.Uint16> _Command,
);

typedef _c_exit1 = ffi.Void Function(
  ffi.Int32 _Code,
);

typedef _dart_exit = void Function(
  int _Code,
);

typedef _c__exit = ffi.Void Function(
  ffi.Int32 _Code,
);

typedef _dart__exit = void Function(
  int _Code,
);

typedef _c__Exit = ffi.Void Function(
  ffi.Int32 _Code,
);

typedef _dart__Exit = void Function(
  int _Code,
);

typedef _c_quick_exit = ffi.Void Function(
  ffi.Int32 _Code,
);

typedef _dart_quick_exit = void Function(
  int _Code,
);

typedef _c_abort = ffi.Void Function();

typedef _dart_abort = void Function();

typedef _c_system = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> _Command,
);

typedef _dart_system = int Function(
  ffi.Pointer<ffi.Int8> _Command,
);

typedef _c__cexit = ffi.Void Function();

typedef _dart__cexit = void Function();

typedef _c__c_exit = ffi.Void Function();

typedef _dart__c_exit = void Function();

typedef _tls_callback_type = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _c__register_thread_local_exe_atexit_callback = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<_tls_callback_type>> _Callback,
);

typedef _dart__register_thread_local_exe_atexit_callback = void Function(
  ffi.Pointer<ffi.NativeFunction<_tls_callback_type>> _Callback,
);

typedef _beginthread_proc_type = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c__beginthread = ffi.Uint64 Function(
  ffi.Pointer<ffi.NativeFunction<_beginthread_proc_type>> _StartAddress,
  ffi.Uint32 _StackSize,
  ffi.Pointer<ffi.Void> _ArgList,
);

typedef _dart__beginthread = int Function(
  ffi.Pointer<ffi.NativeFunction<_beginthread_proc_type>> _StartAddress,
  int _StackSize,
  ffi.Pointer<ffi.Void> _ArgList,
);

typedef _c__endthread = ffi.Void Function();

typedef _dart__endthread = void Function();

typedef _beginthreadex_proc_type = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c__beginthreadex = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> _Security,
  ffi.Uint32 _StackSize,
  ffi.Pointer<ffi.NativeFunction<_beginthreadex_proc_type>> _StartAddress,
  ffi.Pointer<ffi.Void> _ArgList,
  ffi.Uint32 _InitFlag,
  ffi.Pointer<ffi.Uint32> _ThrdAddr,
);

typedef _dart__beginthreadex = int Function(
  ffi.Pointer<ffi.Void> _Security,
  int _StackSize,
  ffi.Pointer<ffi.NativeFunction<_beginthreadex_proc_type>> _StartAddress,
  ffi.Pointer<ffi.Void> _ArgList,
  int _InitFlag,
  ffi.Pointer<ffi.Uint32> _ThrdAddr,
);

typedef _c__endthreadex = ffi.Void Function(
  ffi.Uint32 _ReturnCode,
);

typedef _dart__endthreadex = void Function(
  int _ReturnCode,
);

typedef _c__getpid = ffi.Int32 Function();

typedef _dart__getpid = int Function();

typedef _c__cwait = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int32> _TermStat,
  ffi.IntPtr _ProcHandle,
  ffi.Int32 _Action,
);

typedef _dart__cwait = int Function(
  ffi.Pointer<ffi.Int32> _TermStat,
  int _ProcHandle,
  int _Action,
);

typedef _c__execl = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__execl = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__execle = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__execle = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__execlp = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__execlp = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__execlpe = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__execlpe = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__execv = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart__execv = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c__execve = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart__execve = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c__execvp = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart__execvp = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c__execvpe = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart__execvpe = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c__spawnl = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__spawnl = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__spawnle = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__spawnle = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__spawnlp = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__spawnlp = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__spawnlpe = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart__spawnlpe = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c__spawnv = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart__spawnv = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c__spawnve = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart__spawnve = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c__spawnvp = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart__spawnvp = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c__spawnvpe = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart__spawnvpe = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c__loaddll = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
);

typedef _dart__loaddll = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
);

typedef _c__unloaddll = ffi.Int32 Function(
  ffi.IntPtr _Handle,
);

typedef _dart__unloaddll = int Function(
  int _Handle,
);

typedef _GetDllProcAddrProcType = ffi.Int32 Function();

typedef _c__getdllprocaddr
    = ffi.Pointer<ffi.NativeFunction<_GetDllProcAddrProcType>> Function(
  ffi.IntPtr _Handle,
  ffi.Pointer<ffi.Int8> _ProcedureName,
  ffi.IntPtr _Ordinal,
);

typedef _dart__getdllprocaddr
    = ffi.Pointer<ffi.NativeFunction<_GetDllProcAddrProcType>> Function(
  int _Handle,
  ffi.Pointer<ffi.Int8> _ProcedureName,
  int _Ordinal,
);

typedef _c_cwait = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int32> _TermStat,
  ffi.IntPtr _ProcHandle,
  ffi.Int32 _Action,
);

typedef _dart_cwait = int Function(
  ffi.Pointer<ffi.Int32> _TermStat,
  int _ProcHandle,
  int _Action,
);

typedef _c_execl = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_execl = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_execle = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_execle = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_execlp = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_execlp = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_execlpe = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_execlpe = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_execv = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart_execv = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c_execve = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart_execve = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c_execvp = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart_execvp = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c_execvpe = ffi.IntPtr Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart_execvpe = int Function(
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c_spawnl = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_spawnl = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_spawnle = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_spawnle = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_spawnlp = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_spawnlp = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_spawnlpe = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _dart_spawnlpe = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Int8> _Arguments,
);

typedef _c_spawnv = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart_spawnv = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c_spawnve = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart_spawnve = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c_spawnvp = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _dart_spawnvp = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
);

typedef _c_spawnvpe = ffi.IntPtr Function(
  ffi.Int32 _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _dart_spawnvpe = int Function(
  int _Mode,
  ffi.Pointer<ffi.Int8> _FileName,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Arguments,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> _Environment,
);

typedef _c_getpid = ffi.Int32 Function();

typedef _dart_getpid = int Function();

typedef SDL_ThreadFunction = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef pfnSDL_CurrentBeginThread = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Uint32,
  ffi.Pointer<ffi.NativeFunction<_typedefC_2>>,
  ffi.Pointer<ffi.Void>,
  ffi.Uint32,
  ffi.Pointer<ffi.Uint32>,
);

typedef pfnSDL_CurrentEndThread = ffi.Void Function(
  ffi.Uint32,
);

typedef _c_SDL_CreateThread = ffi.Pointer<SDL_Thread> Function(
  ffi.Pointer<ffi.NativeFunction<SDL_ThreadFunction>> fn,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Void> data,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentBeginThread>> pfnBeginThread,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentEndThread>> pfnEndThread,
);

typedef _dart_SDL_CreateThread = ffi.Pointer<SDL_Thread> Function(
  ffi.Pointer<ffi.NativeFunction<SDL_ThreadFunction>> fn,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Void> data,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentBeginThread>> pfnBeginThread,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentEndThread>> pfnEndThread,
);

typedef _typedefC_3 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_CreateThreadWithStackSize = ffi.Pointer<SDL_Thread> Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> fn,
  ffi.Pointer<ffi.Int8> name,
  ffi.Uint64 stacksize,
  ffi.Pointer<ffi.Void> data,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentBeginThread>> pfnBeginThread,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentEndThread>> pfnEndThread,
);

typedef _dart_SDL_CreateThreadWithStackSize = ffi.Pointer<SDL_Thread> Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> fn,
  ffi.Pointer<ffi.Int8> name,
  int stacksize,
  ffi.Pointer<ffi.Void> data,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentBeginThread>> pfnBeginThread,
  ffi.Pointer<ffi.NativeFunction<pfnSDL_CurrentEndThread>> pfnEndThread,
);

typedef _c_SDL_GetThreadName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<SDL_Thread> thread,
);

typedef _dart_SDL_GetThreadName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<SDL_Thread> thread,
);

typedef _c_SDL_ThreadID = ffi.Uint64 Function();

typedef _dart_SDL_ThreadID = int Function();

typedef _c_SDL_GetThreadID = ffi.Uint64 Function(
  ffi.Pointer<SDL_Thread> thread,
);

typedef _dart_SDL_GetThreadID = int Function(
  ffi.Pointer<SDL_Thread> thread,
);

typedef _c_SDL_SetThreadPriority = ffi.Int32 Function(
  ffi.Int32 priority,
);

typedef _dart_SDL_SetThreadPriority = int Function(
  int priority,
);

typedef _c_SDL_WaitThread = ffi.Void Function(
  ffi.Pointer<SDL_Thread> thread,
  ffi.Pointer<ffi.Int32> status,
);

typedef _dart_SDL_WaitThread = void Function(
  ffi.Pointer<SDL_Thread> thread,
  ffi.Pointer<ffi.Int32> status,
);

typedef _c_SDL_DetachThread = ffi.Void Function(
  ffi.Pointer<SDL_Thread> thread,
);

typedef _dart_SDL_DetachThread = void Function(
  ffi.Pointer<SDL_Thread> thread,
);

typedef _c_SDL_TLSCreate = ffi.Uint32 Function();

typedef _dart_SDL_TLSCreate = int Function();

typedef _c_SDL_TLSGet = ffi.Pointer<ffi.Void> Function(
  ffi.Uint32 id,
);

typedef _dart_SDL_TLSGet = ffi.Pointer<ffi.Void> Function(
  int id,
);

typedef _typedefC_5 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_TLSSet = ffi.Int32 Function(
  ffi.Uint32 id,
  ffi.Pointer<ffi.Void> value,
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> destructor,
);

typedef _dart_SDL_TLSSet = int Function(
  int id,
  ffi.Pointer<ffi.Void> value,
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> destructor,
);

typedef _c_SDL_RWFromFile = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Int8> file,
  ffi.Pointer<ffi.Int8> mode,
);

typedef _dart_SDL_RWFromFile = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Int8> file,
  ffi.Pointer<ffi.Int8> mode,
);

typedef _c_SDL_RWFromFP = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Void> fp,
  ffi.Int32 autoclose,
);

typedef _dart_SDL_RWFromFP = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Void> fp,
  int autoclose,
);

typedef _c_SDL_RWFromMem = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Void> mem,
  ffi.Int32 size,
);

typedef _dart_SDL_RWFromMem = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Void> mem,
  int size,
);

typedef _c_SDL_RWFromConstMem = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Void> mem,
  ffi.Int32 size,
);

typedef _dart_SDL_RWFromConstMem = ffi.Pointer<SDL_RWops> Function(
  ffi.Pointer<ffi.Void> mem,
  int size,
);

typedef _c_SDL_AllocRW = ffi.Pointer<SDL_RWops> Function();

typedef _dart_SDL_AllocRW = ffi.Pointer<SDL_RWops> Function();

typedef _c_SDL_FreeRW = ffi.Void Function(
  ffi.Pointer<SDL_RWops> area,
);

typedef _dart_SDL_FreeRW = void Function(
  ffi.Pointer<SDL_RWops> area,
);

typedef _c_SDL_RWsize = ffi.Int64 Function(
  ffi.Pointer<SDL_RWops> context,
);

typedef _dart_SDL_RWsize = int Function(
  ffi.Pointer<SDL_RWops> context,
);

typedef _c_SDL_RWseek = ffi.Int64 Function(
  ffi.Pointer<SDL_RWops> context,
  ffi.Int64 offset,
  ffi.Int32 whence,
);

typedef _dart_SDL_RWseek = int Function(
  ffi.Pointer<SDL_RWops> context,
  int offset,
  int whence,
);

typedef _c_SDL_RWtell = ffi.Int64 Function(
  ffi.Pointer<SDL_RWops> context,
);

typedef _dart_SDL_RWtell = int Function(
  ffi.Pointer<SDL_RWops> context,
);

typedef _c_SDL_RWread = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> context,
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 size,
  ffi.Uint64 maxnum,
);

typedef _dart_SDL_RWread = int Function(
  ffi.Pointer<SDL_RWops> context,
  ffi.Pointer<ffi.Void> ptr,
  int size,
  int maxnum,
);

typedef _c_SDL_RWwrite = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> context,
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 size,
  ffi.Uint64 num,
);

typedef _dart_SDL_RWwrite = int Function(
  ffi.Pointer<SDL_RWops> context,
  ffi.Pointer<ffi.Void> ptr,
  int size,
  int num,
);

typedef _c_SDL_RWclose = ffi.Int32 Function(
  ffi.Pointer<SDL_RWops> context,
);

typedef _dart_SDL_RWclose = int Function(
  ffi.Pointer<SDL_RWops> context,
);

typedef _c_SDL_LoadFile_RW = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_RWops> src,
  ffi.Pointer<ffi.Uint64> datasize,
  ffi.Int32 freesrc,
);

typedef _dart_SDL_LoadFile_RW = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_RWops> src,
  ffi.Pointer<ffi.Uint64> datasize,
  int freesrc,
);

typedef _c_SDL_LoadFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> file,
  ffi.Pointer<ffi.Uint64> datasize,
);

typedef _dart_SDL_LoadFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> file,
  ffi.Pointer<ffi.Uint64> datasize,
);

typedef _c_SDL_ReadU8 = ffi.Uint8 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadU8 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_ReadLE16 = ffi.Uint16 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadLE16 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_ReadBE16 = ffi.Uint16 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadBE16 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_ReadLE32 = ffi.Uint32 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadLE32 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_ReadBE32 = ffi.Uint32 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadBE32 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_ReadLE64 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadLE64 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_ReadBE64 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_ReadBE64 = int Function(
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_WriteU8 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint8 value,
);

typedef _dart_SDL_WriteU8 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_WriteLE16 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint16 value,
);

typedef _dart_SDL_WriteLE16 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_WriteBE16 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint16 value,
);

typedef _dart_SDL_WriteBE16 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_WriteLE32 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint32 value,
);

typedef _dart_SDL_WriteLE32 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_WriteBE32 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint32 value,
);

typedef _dart_SDL_WriteBE32 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_WriteLE64 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint64 value,
);

typedef _dart_SDL_WriteLE64 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_WriteBE64 = ffi.Uint64 Function(
  ffi.Pointer<SDL_RWops> dst,
  ffi.Uint64 value,
);

typedef _dart_SDL_WriteBE64 = int Function(
  ffi.Pointer<SDL_RWops> dst,
  int value,
);

typedef _c_SDL_GetNumAudioDrivers = ffi.Int32 Function();

typedef _dart_SDL_GetNumAudioDrivers = int Function();

typedef _c_SDL_GetAudioDriver = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 index,
);

typedef _dart_SDL_GetAudioDriver = ffi.Pointer<ffi.Int8> Function(
  int index,
);

typedef _c_SDL_AudioInit = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> driver_name,
);

typedef _dart_SDL_AudioInit = int Function(
  ffi.Pointer<ffi.Int8> driver_name,
);

typedef _c_SDL_AudioQuit = ffi.Void Function();

typedef _dart_SDL_AudioQuit = void Function();

typedef _c_SDL_GetCurrentAudioDriver = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetCurrentAudioDriver = ffi.Pointer<ffi.Int8> Function();

typedef _c_SDL_OpenAudio = ffi.Int32 Function(
  ffi.Pointer<SDL_AudioSpec> desired,
  ffi.Pointer<SDL_AudioSpec> obtained,
);

typedef _dart_SDL_OpenAudio = int Function(
  ffi.Pointer<SDL_AudioSpec> desired,
  ffi.Pointer<SDL_AudioSpec> obtained,
);

typedef _c_SDL_GetNumAudioDevices = ffi.Int32 Function(
  ffi.Int32 iscapture,
);

typedef _dart_SDL_GetNumAudioDevices = int Function(
  int iscapture,
);

typedef _c_SDL_GetAudioDeviceName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 index,
  ffi.Int32 iscapture,
);

typedef _dart_SDL_GetAudioDeviceName = ffi.Pointer<ffi.Int8> Function(
  int index,
  int iscapture,
);

typedef _c_SDL_OpenAudioDevice = ffi.Uint32 Function(
  ffi.Pointer<ffi.Int8> device,
  ffi.Int32 iscapture,
  ffi.Pointer<SDL_AudioSpec> desired,
  ffi.Pointer<SDL_AudioSpec> obtained,
  ffi.Int32 allowed_changes,
);

typedef _dart_SDL_OpenAudioDevice = int Function(
  ffi.Pointer<ffi.Int8> device,
  int iscapture,
  ffi.Pointer<SDL_AudioSpec> desired,
  ffi.Pointer<SDL_AudioSpec> obtained,
  int allowed_changes,
);

typedef _c_SDL_GetAudioStatus = ffi.Int32 Function();

typedef _dart_SDL_GetAudioStatus = int Function();

typedef _c_SDL_GetAudioDeviceStatus = ffi.Int32 Function(
  ffi.Uint32 dev,
);

typedef _dart_SDL_GetAudioDeviceStatus = int Function(
  int dev,
);

typedef _c_SDL_PauseAudio = ffi.Void Function(
  ffi.Int32 pause_on,
);

typedef _dart_SDL_PauseAudio = void Function(
  int pause_on,
);

typedef _c_SDL_PauseAudioDevice = ffi.Void Function(
  ffi.Uint32 dev,
  ffi.Int32 pause_on,
);

typedef _dart_SDL_PauseAudioDevice = void Function(
  int dev,
  int pause_on,
);

typedef _c_SDL_LoadWAV_RW = ffi.Pointer<SDL_AudioSpec> Function(
  ffi.Pointer<SDL_RWops> src,
  ffi.Int32 freesrc,
  ffi.Pointer<SDL_AudioSpec> spec,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_buf,
  ffi.Pointer<ffi.Uint32> audio_len,
);

typedef _dart_SDL_LoadWAV_RW = ffi.Pointer<SDL_AudioSpec> Function(
  ffi.Pointer<SDL_RWops> src,
  int freesrc,
  ffi.Pointer<SDL_AudioSpec> spec,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_buf,
  ffi.Pointer<ffi.Uint32> audio_len,
);

typedef _c_SDL_FreeWAV = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> audio_buf,
);

typedef _dart_SDL_FreeWAV = void Function(
  ffi.Pointer<ffi.Uint8> audio_buf,
);

typedef _c_SDL_BuildAudioCVT = ffi.Int32 Function(
  ffi.Pointer<SDL_AudioCVT> cvt,
  ffi.Uint16 src_format,
  ffi.Uint8 src_channels,
  ffi.Int32 src_rate,
  ffi.Uint16 dst_format,
  ffi.Uint8 dst_channels,
  ffi.Int32 dst_rate,
);

typedef _dart_SDL_BuildAudioCVT = int Function(
  ffi.Pointer<SDL_AudioCVT> cvt,
  int src_format,
  int src_channels,
  int src_rate,
  int dst_format,
  int dst_channels,
  int dst_rate,
);

typedef _c_SDL_ConvertAudio = ffi.Int32 Function(
  ffi.Pointer<SDL_AudioCVT> cvt,
);

typedef _dart_SDL_ConvertAudio = int Function(
  ffi.Pointer<SDL_AudioCVT> cvt,
);

typedef _c_SDL_NewAudioStream = ffi.Pointer<_SDL_AudioStream> Function(
  ffi.Uint16 src_format,
  ffi.Uint8 src_channels,
  ffi.Int32 src_rate,
  ffi.Uint16 dst_format,
  ffi.Uint8 dst_channels,
  ffi.Int32 dst_rate,
);

typedef _dart_SDL_NewAudioStream = ffi.Pointer<_SDL_AudioStream> Function(
  int src_format,
  int src_channels,
  int src_rate,
  int dst_format,
  int dst_channels,
  int dst_rate,
);

typedef _c_SDL_AudioStreamPut = ffi.Int32 Function(
  ffi.Pointer<_SDL_AudioStream> stream,
  ffi.Pointer<ffi.Void> buf,
  ffi.Int32 len,
);

typedef _dart_SDL_AudioStreamPut = int Function(
  ffi.Pointer<_SDL_AudioStream> stream,
  ffi.Pointer<ffi.Void> buf,
  int len,
);

typedef _c_SDL_AudioStreamGet = ffi.Int32 Function(
  ffi.Pointer<_SDL_AudioStream> stream,
  ffi.Pointer<ffi.Void> buf,
  ffi.Int32 len,
);

typedef _dart_SDL_AudioStreamGet = int Function(
  ffi.Pointer<_SDL_AudioStream> stream,
  ffi.Pointer<ffi.Void> buf,
  int len,
);

typedef _c_SDL_AudioStreamAvailable = ffi.Int32 Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _dart_SDL_AudioStreamAvailable = int Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _c_SDL_AudioStreamFlush = ffi.Int32 Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _dart_SDL_AudioStreamFlush = int Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _c_SDL_AudioStreamClear = ffi.Void Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _dart_SDL_AudioStreamClear = void Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _c_SDL_FreeAudioStream = ffi.Void Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _dart_SDL_FreeAudioStream = void Function(
  ffi.Pointer<_SDL_AudioStream> stream,
);

typedef _c_SDL_MixAudio = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Uint32 len,
  ffi.Int32 volume,
);

typedef _dart_SDL_MixAudio = void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int len,
  int volume,
);

typedef _c_SDL_MixAudioFormat = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Uint16 format,
  ffi.Uint32 len,
  ffi.Int32 volume,
);

typedef _dart_SDL_MixAudioFormat = void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int format,
  int len,
  int volume,
);

typedef _c_SDL_QueueAudio = ffi.Int32 Function(
  ffi.Uint32 dev,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint32 len,
);

typedef _dart_SDL_QueueAudio = int Function(
  int dev,
  ffi.Pointer<ffi.Void> data,
  int len,
);

typedef _c_SDL_DequeueAudio = ffi.Uint32 Function(
  ffi.Uint32 dev,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint32 len,
);

typedef _dart_SDL_DequeueAudio = int Function(
  int dev,
  ffi.Pointer<ffi.Void> data,
  int len,
);

typedef _c_SDL_GetQueuedAudioSize = ffi.Uint32 Function(
  ffi.Uint32 dev,
);

typedef _dart_SDL_GetQueuedAudioSize = int Function(
  int dev,
);

typedef _c_SDL_ClearQueuedAudio = ffi.Void Function(
  ffi.Uint32 dev,
);

typedef _dart_SDL_ClearQueuedAudio = void Function(
  int dev,
);

typedef _c_SDL_LockAudio = ffi.Void Function();

typedef _dart_SDL_LockAudio = void Function();

typedef _c_SDL_LockAudioDevice = ffi.Void Function(
  ffi.Uint32 dev,
);

typedef _dart_SDL_LockAudioDevice = void Function(
  int dev,
);

typedef _c_SDL_UnlockAudio = ffi.Void Function();

typedef _dart_SDL_UnlockAudio = void Function();

typedef _c_SDL_UnlockAudioDevice = ffi.Void Function(
  ffi.Uint32 dev,
);

typedef _dart_SDL_UnlockAudioDevice = void Function(
  int dev,
);

typedef _c_SDL_CloseAudio = ffi.Void Function();

typedef _dart_SDL_CloseAudio = void Function();

typedef _c_SDL_CloseAudioDevice = ffi.Void Function(
  ffi.Uint32 dev,
);

typedef _dart_SDL_CloseAudioDevice = void Function(
  int dev,
);

typedef _c_SDL_SetClipboardText = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> text,
);

typedef _dart_SDL_SetClipboardText = int Function(
  ffi.Pointer<ffi.Int8> text,
);

typedef _c_SDL_GetClipboardText = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetClipboardText = ffi.Pointer<ffi.Int8> Function();

typedef _c_SDL_HasClipboardText = ffi.Int32 Function();

typedef _dart_SDL_HasClipboardText = int Function();

typedef _c_SDL_GetCPUCount = ffi.Int32 Function();

typedef _dart_SDL_GetCPUCount = int Function();

typedef _c_SDL_GetCPUCacheLineSize = ffi.Int32 Function();

typedef _dart_SDL_GetCPUCacheLineSize = int Function();

typedef _c_SDL_HasRDTSC = ffi.Int32 Function();

typedef _dart_SDL_HasRDTSC = int Function();

typedef _c_SDL_HasAltiVec = ffi.Int32 Function();

typedef _dart_SDL_HasAltiVec = int Function();

typedef _c_SDL_HasMMX = ffi.Int32 Function();

typedef _dart_SDL_HasMMX = int Function();

typedef _c_SDL_Has3DNow = ffi.Int32 Function();

typedef _dart_SDL_Has3DNow = int Function();

typedef _c_SDL_HasSSE = ffi.Int32 Function();

typedef _dart_SDL_HasSSE = int Function();

typedef _c_SDL_HasSSE2 = ffi.Int32 Function();

typedef _dart_SDL_HasSSE2 = int Function();

typedef _c_SDL_HasSSE3 = ffi.Int32 Function();

typedef _dart_SDL_HasSSE3 = int Function();

typedef _c_SDL_HasSSE41 = ffi.Int32 Function();

typedef _dart_SDL_HasSSE41 = int Function();

typedef _c_SDL_HasSSE42 = ffi.Int32 Function();

typedef _dart_SDL_HasSSE42 = int Function();

typedef _c_SDL_HasAVX = ffi.Int32 Function();

typedef _dart_SDL_HasAVX = int Function();

typedef _c_SDL_HasAVX2 = ffi.Int32 Function();

typedef _dart_SDL_HasAVX2 = int Function();

typedef _c_SDL_HasAVX512F = ffi.Int32 Function();

typedef _dart_SDL_HasAVX512F = int Function();

typedef _c_SDL_HasARMSIMD = ffi.Int32 Function();

typedef _dart_SDL_HasARMSIMD = int Function();

typedef _c_SDL_HasNEON = ffi.Int32 Function();

typedef _dart_SDL_HasNEON = int Function();

typedef _c_SDL_GetSystemRAM = ffi.Int32 Function();

typedef _dart_SDL_GetSystemRAM = int Function();

typedef _c_SDL_SIMDGetAlignment = ffi.Uint64 Function();

typedef _dart_SDL_SIMDGetAlignment = int Function();

typedef _c_SDL_SIMDAlloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 len,
);

typedef _dart_SDL_SIMDAlloc = ffi.Pointer<ffi.Void> Function(
  int len,
);

typedef _c_SDL_SIMDRealloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> mem,
  ffi.Uint64 len,
);

typedef _dart_SDL_SIMDRealloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> mem,
  int len,
);

typedef _c_SDL_SIMDFree = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_SDL_SIMDFree = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_SDL_GetPixelFormatName = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint32 format,
);

typedef _dart_SDL_GetPixelFormatName = ffi.Pointer<ffi.Int8> Function(
  int format,
);

typedef _c_SDL_PixelFormatEnumToMasks = ffi.Int32 Function(
  ffi.Uint32 format,
  ffi.Pointer<ffi.Int32> bpp,
  ffi.Pointer<ffi.Uint32> Rmask,
  ffi.Pointer<ffi.Uint32> Gmask,
  ffi.Pointer<ffi.Uint32> Bmask,
  ffi.Pointer<ffi.Uint32> Amask,
);

typedef _dart_SDL_PixelFormatEnumToMasks = int Function(
  int format,
  ffi.Pointer<ffi.Int32> bpp,
  ffi.Pointer<ffi.Uint32> Rmask,
  ffi.Pointer<ffi.Uint32> Gmask,
  ffi.Pointer<ffi.Uint32> Bmask,
  ffi.Pointer<ffi.Uint32> Amask,
);

typedef _c_SDL_MasksToPixelFormatEnum = ffi.Uint32 Function(
  ffi.Int32 bpp,
  ffi.Uint32 Rmask,
  ffi.Uint32 Gmask,
  ffi.Uint32 Bmask,
  ffi.Uint32 Amask,
);

typedef _dart_SDL_MasksToPixelFormatEnum = int Function(
  int bpp,
  int Rmask,
  int Gmask,
  int Bmask,
  int Amask,
);

typedef _c_SDL_AllocFormat = ffi.Pointer<SDL_PixelFormat> Function(
  ffi.Uint32 pixel_format,
);

typedef _dart_SDL_AllocFormat = ffi.Pointer<SDL_PixelFormat> Function(
  int pixel_format,
);

typedef _c_SDL_FreeFormat = ffi.Void Function(
  ffi.Pointer<SDL_PixelFormat> format,
);

typedef _dart_SDL_FreeFormat = void Function(
  ffi.Pointer<SDL_PixelFormat> format,
);

typedef _c_SDL_AllocPalette = ffi.Pointer<SDL_Palette> Function(
  ffi.Int32 ncolors,
);

typedef _dart_SDL_AllocPalette = ffi.Pointer<SDL_Palette> Function(
  int ncolors,
);

typedef _c_SDL_SetPixelFormatPalette = ffi.Int32 Function(
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Pointer<SDL_Palette> palette,
);

typedef _dart_SDL_SetPixelFormatPalette = int Function(
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Pointer<SDL_Palette> palette,
);

typedef _c_SDL_SetPaletteColors = ffi.Int32 Function(
  ffi.Pointer<SDL_Palette> palette,
  ffi.Pointer<SDL_Color> colors,
  ffi.Int32 firstcolor,
  ffi.Int32 ncolors,
);

typedef _dart_SDL_SetPaletteColors = int Function(
  ffi.Pointer<SDL_Palette> palette,
  ffi.Pointer<SDL_Color> colors,
  int firstcolor,
  int ncolors,
);

typedef _c_SDL_FreePalette = ffi.Void Function(
  ffi.Pointer<SDL_Palette> palette,
);

typedef _dart_SDL_FreePalette = void Function(
  ffi.Pointer<SDL_Palette> palette,
);

typedef _c_SDL_MapRGB = ffi.Uint32 Function(
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Uint8 r,
  ffi.Uint8 g,
  ffi.Uint8 b,
);

typedef _dart_SDL_MapRGB = int Function(
  ffi.Pointer<SDL_PixelFormat> format,
  int r,
  int g,
  int b,
);

typedef _c_SDL_MapRGBA = ffi.Uint32 Function(
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Uint8 r,
  ffi.Uint8 g,
  ffi.Uint8 b,
  ffi.Uint8 a,
);

typedef _dart_SDL_MapRGBA = int Function(
  ffi.Pointer<SDL_PixelFormat> format,
  int r,
  int g,
  int b,
  int a,
);

typedef _c_SDL_GetRGB = ffi.Void Function(
  ffi.Uint32 pixel,
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

typedef _dart_SDL_GetRGB = void Function(
  int pixel,
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

typedef _c_SDL_GetRGBA = ffi.Void Function(
  ffi.Uint32 pixel,
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
  ffi.Pointer<ffi.Uint8> a,
);

typedef _dart_SDL_GetRGBA = void Function(
  int pixel,
  ffi.Pointer<SDL_PixelFormat> format,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
  ffi.Pointer<ffi.Uint8> a,
);

typedef _c_SDL_CalculateGammaRamp = ffi.Void Function(
  ffi.Float gamma,
  ffi.Pointer<ffi.Uint16> ramp,
);

typedef _dart_SDL_CalculateGammaRamp = void Function(
  double gamma,
  ffi.Pointer<ffi.Uint16> ramp,
);

typedef _c_SDL_HasIntersection = ffi.Int32 Function(
  ffi.Pointer<SDL_Rect> A,
  ffi.Pointer<SDL_Rect> B,
);

typedef _dart_SDL_HasIntersection = int Function(
  ffi.Pointer<SDL_Rect> A,
  ffi.Pointer<SDL_Rect> B,
);

typedef _c_SDL_IntersectRect = ffi.Int32 Function(
  ffi.Pointer<SDL_Rect> A,
  ffi.Pointer<SDL_Rect> B,
  ffi.Pointer<SDL_Rect> result,
);

typedef _dart_SDL_IntersectRect = int Function(
  ffi.Pointer<SDL_Rect> A,
  ffi.Pointer<SDL_Rect> B,
  ffi.Pointer<SDL_Rect> result,
);

typedef _c_SDL_UnionRect = ffi.Void Function(
  ffi.Pointer<SDL_Rect> A,
  ffi.Pointer<SDL_Rect> B,
  ffi.Pointer<SDL_Rect> result,
);

typedef _dart_SDL_UnionRect = void Function(
  ffi.Pointer<SDL_Rect> A,
  ffi.Pointer<SDL_Rect> B,
  ffi.Pointer<SDL_Rect> result,
);

typedef _c_SDL_EnclosePoints = ffi.Int32 Function(
  ffi.Pointer<SDL_Point> points,
  ffi.Int32 count,
  ffi.Pointer<SDL_Rect> clip,
  ffi.Pointer<SDL_Rect> result,
);

typedef _dart_SDL_EnclosePoints = int Function(
  ffi.Pointer<SDL_Point> points,
  int count,
  ffi.Pointer<SDL_Rect> clip,
  ffi.Pointer<SDL_Rect> result,
);

typedef _c_SDL_IntersectRectAndLine = ffi.Int32 Function(
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Int32> X1,
  ffi.Pointer<ffi.Int32> Y1,
  ffi.Pointer<ffi.Int32> X2,
  ffi.Pointer<ffi.Int32> Y2,
);

typedef _dart_SDL_IntersectRectAndLine = int Function(
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Int32> X1,
  ffi.Pointer<ffi.Int32> Y1,
  ffi.Pointer<ffi.Int32> X2,
  ffi.Pointer<ffi.Int32> Y2,
);

typedef _c_SDL_ComposeCustomBlendMode = ffi.Int32 Function(
  ffi.Int32 srcColorFactor,
  ffi.Int32 dstColorFactor,
  ffi.Int32 colorOperation,
  ffi.Int32 srcAlphaFactor,
  ffi.Int32 dstAlphaFactor,
  ffi.Int32 alphaOperation,
);

typedef _dart_SDL_ComposeCustomBlendMode = int Function(
  int srcColorFactor,
  int dstColorFactor,
  int colorOperation,
  int srcAlphaFactor,
  int dstAlphaFactor,
  int alphaOperation,
);

typedef _c_SDL_CreateRGBSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Uint32 flags,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 depth,
  ffi.Uint32 Rmask,
  ffi.Uint32 Gmask,
  ffi.Uint32 Bmask,
  ffi.Uint32 Amask,
);

typedef _dart_SDL_CreateRGBSurface = ffi.Pointer<SDL_Surface> Function(
  int flags,
  int width,
  int height,
  int depth,
  int Rmask,
  int Gmask,
  int Bmask,
  int Amask,
);

typedef _c_SDL_CreateRGBSurfaceWithFormat = ffi.Pointer<SDL_Surface> Function(
  ffi.Uint32 flags,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 depth,
  ffi.Uint32 format,
);

typedef _dart_SDL_CreateRGBSurfaceWithFormat = ffi.Pointer<SDL_Surface>
    Function(
  int flags,
  int width,
  int height,
  int depth,
  int format,
);

typedef _c_SDL_CreateRGBSurfaceFrom = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<ffi.Void> pixels,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 depth,
  ffi.Int32 pitch,
  ffi.Uint32 Rmask,
  ffi.Uint32 Gmask,
  ffi.Uint32 Bmask,
  ffi.Uint32 Amask,
);

typedef _dart_SDL_CreateRGBSurfaceFrom = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<ffi.Void> pixels,
  int width,
  int height,
  int depth,
  int pitch,
  int Rmask,
  int Gmask,
  int Bmask,
  int Amask,
);

typedef _c_SDL_CreateRGBSurfaceWithFormatFrom = ffi.Pointer<SDL_Surface>
    Function(
  ffi.Pointer<ffi.Void> pixels,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 depth,
  ffi.Int32 pitch,
  ffi.Uint32 format,
);

typedef _dart_SDL_CreateRGBSurfaceWithFormatFrom = ffi.Pointer<SDL_Surface>
    Function(
  ffi.Pointer<ffi.Void> pixels,
  int width,
  int height,
  int depth,
  int pitch,
  int format,
);

typedef _c_SDL_FreeSurface = ffi.Void Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_FreeSurface = void Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_SetSurfacePalette = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_Palette> palette,
);

typedef _dart_SDL_SetSurfacePalette = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_Palette> palette,
);

typedef _c_SDL_LockSurface = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_LockSurface = int Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_UnlockSurface = ffi.Void Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_UnlockSurface = void Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_LoadBMP_RW = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_RWops> src,
  ffi.Int32 freesrc,
);

typedef _dart_SDL_LoadBMP_RW = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_RWops> src,
  int freesrc,
);

typedef _c_SDL_SaveBMP_RW = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_RWops> dst,
  ffi.Int32 freedst,
);

typedef _dart_SDL_SaveBMP_RW = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_RWops> dst,
  int freedst,
);

typedef _c_SDL_SetSurfaceRLE = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Int32 flag,
);

typedef _dart_SDL_SetSurfaceRLE = int Function(
  ffi.Pointer<SDL_Surface> surface,
  int flag,
);

typedef _c_SDL_HasSurfaceRLE = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_HasSurfaceRLE = int Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_SetColorKey = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Int32 flag,
  ffi.Uint32 key,
);

typedef _dart_SDL_SetColorKey = int Function(
  ffi.Pointer<SDL_Surface> surface,
  int flag,
  int key,
);

typedef _c_SDL_HasColorKey = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_HasColorKey = int Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_GetColorKey = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Uint32> key,
);

typedef _dart_SDL_GetColorKey = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Uint32> key,
);

typedef _c_SDL_SetSurfaceColorMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Uint8 r,
  ffi.Uint8 g,
  ffi.Uint8 b,
);

typedef _dart_SDL_SetSurfaceColorMod = int Function(
  ffi.Pointer<SDL_Surface> surface,
  int r,
  int g,
  int b,
);

typedef _c_SDL_GetSurfaceColorMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

typedef _dart_SDL_GetSurfaceColorMod = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

typedef _c_SDL_SetSurfaceAlphaMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Uint8 alpha,
);

typedef _dart_SDL_SetSurfaceAlphaMod = int Function(
  ffi.Pointer<SDL_Surface> surface,
  int alpha,
);

typedef _c_SDL_GetSurfaceAlphaMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Uint8> alpha,
);

typedef _dart_SDL_GetSurfaceAlphaMod = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Uint8> alpha,
);

typedef _c_SDL_SetSurfaceBlendMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Int32 blendMode,
);

typedef _dart_SDL_SetSurfaceBlendMode = int Function(
  ffi.Pointer<SDL_Surface> surface,
  int blendMode,
);

typedef _c_SDL_GetSurfaceBlendMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Int32> blendMode,
);

typedef _dart_SDL_GetSurfaceBlendMode = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<ffi.Int32> blendMode,
);

typedef _c_SDL_SetClipRect = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_SetClipRect = int Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_GetClipRect = ffi.Void Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_GetClipRect = void Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_DuplicateSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_DuplicateSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_ConvertSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_PixelFormat> fmt,
  ffi.Uint32 flags,
);

typedef _dart_SDL_ConvertSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_PixelFormat> fmt,
  int flags,
);

typedef _c_SDL_ConvertSurfaceFormat = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Uint32 pixel_format,
  ffi.Uint32 flags,
);

typedef _dart_SDL_ConvertSurfaceFormat = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Surface> src,
  int pixel_format,
  int flags,
);

typedef _c_SDL_ConvertPixels = ffi.Int32 Function(
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Uint32 src_format,
  ffi.Pointer<ffi.Void> src,
  ffi.Int32 src_pitch,
  ffi.Uint32 dst_format,
  ffi.Pointer<ffi.Void> dst,
  ffi.Int32 dst_pitch,
);

typedef _dart_SDL_ConvertPixels = int Function(
  int width,
  int height,
  int src_format,
  ffi.Pointer<ffi.Void> src,
  int src_pitch,
  int dst_format,
  ffi.Pointer<ffi.Void> dst,
  int dst_pitch,
);

typedef _c_SDL_FillRect = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Uint32 color,
);

typedef _dart_SDL_FillRect = int Function(
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> rect,
  int color,
);

typedef _c_SDL_FillRects = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> rects,
  ffi.Int32 count,
  ffi.Uint32 color,
);

typedef _dart_SDL_FillRects = int Function(
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> rects,
  int count,
  int color,
);

typedef _c_SDL_UpperBlit = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _dart_SDL_UpperBlit = int Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _c_SDL_LowerBlit = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _dart_SDL_LowerBlit = int Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _c_SDL_SoftStretch = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _dart_SDL_SoftStretch = int Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _c_SDL_UpperBlitScaled = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _dart_SDL_UpperBlitScaled = int Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _c_SDL_LowerBlitScaled = ffi.Int32 Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _dart_SDL_LowerBlitScaled = int Function(
  ffi.Pointer<SDL_Surface> src,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Surface> dst,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _c_SDL_SetYUVConversionMode = ffi.Void Function(
  ffi.Int32 mode,
);

typedef _dart_SDL_SetYUVConversionMode = void Function(
  int mode,
);

typedef _c_SDL_GetYUVConversionMode = ffi.Int32 Function();

typedef _dart_SDL_GetYUVConversionMode = int Function();

typedef _c_SDL_GetYUVConversionModeForResolution = ffi.Int32 Function(
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_SDL_GetYUVConversionModeForResolution = int Function(
  int width,
  int height,
);

typedef _c_SDL_GetNumVideoDrivers = ffi.Int32 Function();

typedef _dart_SDL_GetNumVideoDrivers = int Function();

typedef _c_SDL_GetVideoDriver = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 index,
);

typedef _dart_SDL_GetVideoDriver = ffi.Pointer<ffi.Int8> Function(
  int index,
);

typedef _c_SDL_VideoInit = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> driver_name,
);

typedef _dart_SDL_VideoInit = int Function(
  ffi.Pointer<ffi.Int8> driver_name,
);

typedef _c_SDL_VideoQuit = ffi.Void Function();

typedef _dart_SDL_VideoQuit = void Function();

typedef _c_SDL_GetCurrentVideoDriver = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetCurrentVideoDriver = ffi.Pointer<ffi.Int8> Function();

typedef _c_SDL_GetNumVideoDisplays = ffi.Int32 Function();

typedef _dart_SDL_GetNumVideoDisplays = int Function();

typedef _c_SDL_GetDisplayName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 displayIndex,
);

typedef _dart_SDL_GetDisplayName = ffi.Pointer<ffi.Int8> Function(
  int displayIndex,
);

typedef _c_SDL_GetDisplayBounds = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_GetDisplayBounds = int Function(
  int displayIndex,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_GetDisplayUsableBounds = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_GetDisplayUsableBounds = int Function(
  int displayIndex,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_GetDisplayDPI = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<ffi.Float> ddpi,
  ffi.Pointer<ffi.Float> hdpi,
  ffi.Pointer<ffi.Float> vdpi,
);

typedef _dart_SDL_GetDisplayDPI = int Function(
  int displayIndex,
  ffi.Pointer<ffi.Float> ddpi,
  ffi.Pointer<ffi.Float> hdpi,
  ffi.Pointer<ffi.Float> vdpi,
);

typedef _c_SDL_GetDisplayOrientation = ffi.Int32 Function(
  ffi.Int32 displayIndex,
);

typedef _dart_SDL_GetDisplayOrientation = int Function(
  int displayIndex,
);

typedef _c_SDL_GetNumDisplayModes = ffi.Int32 Function(
  ffi.Int32 displayIndex,
);

typedef _dart_SDL_GetNumDisplayModes = int Function(
  int displayIndex,
);

typedef _c_SDL_GetDisplayMode = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Int32 modeIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _dart_SDL_GetDisplayMode = int Function(
  int displayIndex,
  int modeIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _c_SDL_GetDesktopDisplayMode = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _dart_SDL_GetDesktopDisplayMode = int Function(
  int displayIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _c_SDL_GetCurrentDisplayMode = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _dart_SDL_GetCurrentDisplayMode = int Function(
  int displayIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _c_SDL_GetClosestDisplayMode = ffi.Pointer<SDL_DisplayMode> Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
  ffi.Pointer<SDL_DisplayMode> closest,
);

typedef _dart_SDL_GetClosestDisplayMode = ffi.Pointer<SDL_DisplayMode> Function(
  int displayIndex,
  ffi.Pointer<SDL_DisplayMode> mode,
  ffi.Pointer<SDL_DisplayMode> closest,
);

typedef _c_SDL_GetWindowDisplayIndex = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowDisplayIndex = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowDisplayMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _dart_SDL_SetWindowDisplayMode = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _c_SDL_GetWindowDisplayMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _dart_SDL_GetWindowDisplayMode = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_DisplayMode> mode,
);

typedef _c_SDL_GetWindowPixelFormat = ffi.Uint32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowPixelFormat = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_CreateWindow = ffi.Pointer<SDL_Window> Function(
  ffi.Pointer<ffi.Int8> title,
  ffi.Int32 x,
  ffi.Int32 y,
  ffi.Int32 w,
  ffi.Int32 h,
  ffi.Uint32 flags,
);

typedef _dart_SDL_CreateWindow = ffi.Pointer<SDL_Window> Function(
  ffi.Pointer<ffi.Int8> title,
  int x,
  int y,
  int w,
  int h,
  int flags,
);

typedef _c_SDL_CreateWindowFrom = ffi.Pointer<SDL_Window> Function(
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_SDL_CreateWindowFrom = ffi.Pointer<SDL_Window> Function(
  ffi.Pointer<ffi.Void> data,
);

typedef _c_SDL_GetWindowID = ffi.Uint32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowID = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_GetWindowFromID = ffi.Pointer<SDL_Window> Function(
  ffi.Uint32 id,
);

typedef _dart_SDL_GetWindowFromID = ffi.Pointer<SDL_Window> Function(
  int id,
);

typedef _c_SDL_GetWindowFlags = ffi.Uint32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowFlags = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowTitle = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int8> title,
);

typedef _dart_SDL_SetWindowTitle = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int8> title,
);

typedef _c_SDL_GetWindowTitle = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowTitle = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowIcon = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_Surface> icon,
);

typedef _dart_SDL_SetWindowIcon = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_Surface> icon,
);

typedef _c_SDL_SetWindowData = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_SDL_SetWindowData = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_SDL_GetWindowData = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_SDL_GetWindowData = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_SDL_SetWindowPosition = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 x,
  ffi.Int32 y,
);

typedef _dart_SDL_SetWindowPosition = void Function(
  ffi.Pointer<SDL_Window> window,
  int x,
  int y,
);

typedef _c_SDL_GetWindowPosition = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _dart_SDL_GetWindowPosition = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _c_SDL_SetWindowSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 w,
  ffi.Int32 h,
);

typedef _dart_SDL_SetWindowSize = void Function(
  ffi.Pointer<SDL_Window> window,
  int w,
  int h,
);

typedef _c_SDL_GetWindowSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_GetWindowSize = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_GetWindowBordersSize = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> top,
  ffi.Pointer<ffi.Int32> left,
  ffi.Pointer<ffi.Int32> bottom,
  ffi.Pointer<ffi.Int32> right,
);

typedef _dart_SDL_GetWindowBordersSize = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> top,
  ffi.Pointer<ffi.Int32> left,
  ffi.Pointer<ffi.Int32> bottom,
  ffi.Pointer<ffi.Int32> right,
);

typedef _c_SDL_SetWindowMinimumSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 min_w,
  ffi.Int32 min_h,
);

typedef _dart_SDL_SetWindowMinimumSize = void Function(
  ffi.Pointer<SDL_Window> window,
  int min_w,
  int min_h,
);

typedef _c_SDL_GetWindowMinimumSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_GetWindowMinimumSize = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_SetWindowMaximumSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 max_w,
  ffi.Int32 max_h,
);

typedef _dart_SDL_SetWindowMaximumSize = void Function(
  ffi.Pointer<SDL_Window> window,
  int max_w,
  int max_h,
);

typedef _c_SDL_GetWindowMaximumSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_GetWindowMaximumSize = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_SetWindowBordered = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 bordered,
);

typedef _dart_SDL_SetWindowBordered = void Function(
  ffi.Pointer<SDL_Window> window,
  int bordered,
);

typedef _c_SDL_SetWindowResizable = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 resizable,
);

typedef _dart_SDL_SetWindowResizable = void Function(
  ffi.Pointer<SDL_Window> window,
  int resizable,
);

typedef _c_SDL_ShowWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_ShowWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_HideWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_HideWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_RaiseWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_RaiseWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_MaximizeWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_MaximizeWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_MinimizeWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_MinimizeWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_RestoreWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_RestoreWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowFullscreen = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Uint32 flags,
);

typedef _dart_SDL_SetWindowFullscreen = int Function(
  ffi.Pointer<SDL_Window> window,
  int flags,
);

typedef _c_SDL_GetWindowSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowSurface = ffi.Pointer<SDL_Surface> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_UpdateWindowSurface = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_UpdateWindowSurface = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_UpdateWindowSurfaceRects = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_Rect> rects,
  ffi.Int32 numrects,
);

typedef _dart_SDL_UpdateWindowSurfaceRects = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_Rect> rects,
  int numrects,
);

typedef _c_SDL_SetWindowGrab = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 grabbed,
);

typedef _dart_SDL_SetWindowGrab = void Function(
  ffi.Pointer<SDL_Window> window,
  int grabbed,
);

typedef _c_SDL_GetWindowGrab = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowGrab = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_GetGrabbedWindow = ffi.Pointer<SDL_Window> Function();

typedef _dart_SDL_GetGrabbedWindow = ffi.Pointer<SDL_Window> Function();

typedef _c_SDL_SetWindowBrightness = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Float brightness,
);

typedef _dart_SDL_SetWindowBrightness = int Function(
  ffi.Pointer<SDL_Window> window,
  double brightness,
);

typedef _c_SDL_GetWindowBrightness = ffi.Float Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetWindowBrightness = double Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowOpacity = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Float opacity,
);

typedef _dart_SDL_SetWindowOpacity = int Function(
  ffi.Pointer<SDL_Window> window,
  double opacity,
);

typedef _c_SDL_GetWindowOpacity = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Float> out_opacity,
);

typedef _dart_SDL_GetWindowOpacity = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Float> out_opacity,
);

typedef _c_SDL_SetWindowModalFor = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> modal_window,
  ffi.Pointer<SDL_Window> parent_window,
);

typedef _dart_SDL_SetWindowModalFor = int Function(
  ffi.Pointer<SDL_Window> modal_window,
  ffi.Pointer<SDL_Window> parent_window,
);

typedef _c_SDL_SetWindowInputFocus = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_SetWindowInputFocus = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowGammaRamp = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Uint16> red,
  ffi.Pointer<ffi.Uint16> green,
  ffi.Pointer<ffi.Uint16> blue,
);

typedef _dart_SDL_SetWindowGammaRamp = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Uint16> red,
  ffi.Pointer<ffi.Uint16> green,
  ffi.Pointer<ffi.Uint16> blue,
);

typedef _c_SDL_GetWindowGammaRamp = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Uint16> red,
  ffi.Pointer<ffi.Uint16> green,
  ffi.Pointer<ffi.Uint16> blue,
);

typedef _dart_SDL_GetWindowGammaRamp = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Uint16> red,
  ffi.Pointer<ffi.Uint16> green,
  ffi.Pointer<ffi.Uint16> blue,
);

typedef SDL_HitTest = ffi.Int32 Function(
  ffi.Pointer<SDL_Window>,
  ffi.Pointer<SDL_Point>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_SetWindowHitTest = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.NativeFunction<SDL_HitTest>> callback,
  ffi.Pointer<ffi.Void> callback_data,
);

typedef _dart_SDL_SetWindowHitTest = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.NativeFunction<SDL_HitTest>> callback,
  ffi.Pointer<ffi.Void> callback_data,
);

typedef _c_SDL_DestroyWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_DestroyWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_IsScreenSaverEnabled = ffi.Int32 Function();

typedef _dart_SDL_IsScreenSaverEnabled = int Function();

typedef _c_SDL_EnableScreenSaver = ffi.Void Function();

typedef _dart_SDL_EnableScreenSaver = void Function();

typedef _c_SDL_DisableScreenSaver = ffi.Void Function();

typedef _dart_SDL_DisableScreenSaver = void Function();

typedef _c_SDL_GL_LoadLibrary = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_SDL_GL_LoadLibrary = int Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_SDL_GL_GetProcAddress = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> proc,
);

typedef _dart_SDL_GL_GetProcAddress = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> proc,
);

typedef _c_SDL_GL_UnloadLibrary = ffi.Void Function();

typedef _dart_SDL_GL_UnloadLibrary = void Function();

typedef _c_SDL_GL_ExtensionSupported = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> extension_1,
);

typedef _dart_SDL_GL_ExtensionSupported = int Function(
  ffi.Pointer<ffi.Int8> extension_1,
);

typedef _c_SDL_GL_ResetAttributes = ffi.Void Function();

typedef _dart_SDL_GL_ResetAttributes = void Function();

typedef _c_SDL_GL_SetAttribute = ffi.Int32 Function(
  ffi.Int32 attr,
  ffi.Int32 value,
);

typedef _dart_SDL_GL_SetAttribute = int Function(
  int attr,
  int value,
);

typedef _c_SDL_GL_GetAttribute = ffi.Int32 Function(
  ffi.Int32 attr,
  ffi.Pointer<ffi.Int32> value,
);

typedef _dart_SDL_GL_GetAttribute = int Function(
  int attr,
  ffi.Pointer<ffi.Int32> value,
);

typedef _c_SDL_GL_CreateContext = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GL_CreateContext = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_GL_MakeCurrent = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_SDL_GL_MakeCurrent = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_SDL_GL_GetCurrentWindow = ffi.Pointer<SDL_Window> Function();

typedef _dart_SDL_GL_GetCurrentWindow = ffi.Pointer<SDL_Window> Function();

typedef _c_SDL_GL_GetCurrentContext = ffi.Pointer<ffi.Void> Function();

typedef _dart_SDL_GL_GetCurrentContext = ffi.Pointer<ffi.Void> Function();

typedef _c_SDL_GL_GetDrawableSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_GL_GetDrawableSize = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_GL_SetSwapInterval = ffi.Int32 Function(
  ffi.Int32 interval,
);

typedef _dart_SDL_GL_SetSwapInterval = int Function(
  int interval,
);

typedef _c_SDL_GL_GetSwapInterval = ffi.Int32 Function();

typedef _dart_SDL_GL_GetSwapInterval = int Function();

typedef _c_SDL_GL_SwapWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GL_SwapWindow = void Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_GL_DeleteContext = ffi.Void Function(
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_SDL_GL_DeleteContext = void Function(
  ffi.Pointer<ffi.Void> context,
);

typedef _c_SDL_GetKeyboardFocus = ffi.Pointer<SDL_Window> Function();

typedef _dart_SDL_GetKeyboardFocus = ffi.Pointer<SDL_Window> Function();

typedef _c_SDL_GetKeyboardState = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<ffi.Int32> numkeys,
);

typedef _dart_SDL_GetKeyboardState = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<ffi.Int32> numkeys,
);

typedef _c_SDL_GetModState = ffi.Int32 Function();

typedef _dart_SDL_GetModState = int Function();

typedef _c_SDL_SetModState = ffi.Void Function(
  ffi.Int32 modstate,
);

typedef _dart_SDL_SetModState = void Function(
  int modstate,
);

typedef _c_SDL_GetKeyFromScancode = ffi.Int32 Function(
  ffi.Int32 scancode,
);

typedef _dart_SDL_GetKeyFromScancode = int Function(
  int scancode,
);

typedef _c_SDL_GetScancodeFromKey = ffi.Int32 Function(
  ffi.Int32 key,
);

typedef _dart_SDL_GetScancodeFromKey = int Function(
  int key,
);

typedef _c_SDL_GetScancodeName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 scancode,
);

typedef _dart_SDL_GetScancodeName = ffi.Pointer<ffi.Int8> Function(
  int scancode,
);

typedef _c_SDL_GetScancodeFromName = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_SDL_GetScancodeFromName = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_SDL_GetKeyName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 key,
);

typedef _dart_SDL_GetKeyName = ffi.Pointer<ffi.Int8> Function(
  int key,
);

typedef _c_SDL_GetKeyFromName = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_SDL_GetKeyFromName = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_SDL_StartTextInput = ffi.Void Function();

typedef _dart_SDL_StartTextInput = void Function();

typedef _c_SDL_IsTextInputActive = ffi.Int32 Function();

typedef _dart_SDL_IsTextInputActive = int Function();

typedef _c_SDL_StopTextInput = ffi.Void Function();

typedef _dart_SDL_StopTextInput = void Function();

typedef _c_SDL_SetTextInputRect = ffi.Void Function(
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_SetTextInputRect = void Function(
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_HasScreenKeyboardSupport = ffi.Int32 Function();

typedef _dart_SDL_HasScreenKeyboardSupport = int Function();

typedef _c_SDL_IsScreenKeyboardShown = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_IsScreenKeyboardShown = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_GetMouseFocus = ffi.Pointer<SDL_Window> Function();

typedef _dart_SDL_GetMouseFocus = ffi.Pointer<SDL_Window> Function();

typedef _c_SDL_GetMouseState = ffi.Uint32 Function(
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _dart_SDL_GetMouseState = int Function(
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _c_SDL_GetGlobalMouseState = ffi.Uint32 Function(
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _dart_SDL_GetGlobalMouseState = int Function(
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _c_SDL_GetRelativeMouseState = ffi.Uint32 Function(
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _dart_SDL_GetRelativeMouseState = int Function(
  ffi.Pointer<ffi.Int32> x,
  ffi.Pointer<ffi.Int32> y,
);

typedef _c_SDL_WarpMouseInWindow = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 x,
  ffi.Int32 y,
);

typedef _dart_SDL_WarpMouseInWindow = void Function(
  ffi.Pointer<SDL_Window> window,
  int x,
  int y,
);

typedef _c_SDL_WarpMouseGlobal = ffi.Int32 Function(
  ffi.Int32 x,
  ffi.Int32 y,
);

typedef _dart_SDL_WarpMouseGlobal = int Function(
  int x,
  int y,
);

typedef _c_SDL_SetRelativeMouseMode = ffi.Int32 Function(
  ffi.Int32 enabled,
);

typedef _dart_SDL_SetRelativeMouseMode = int Function(
  int enabled,
);

typedef _c_SDL_CaptureMouse = ffi.Int32 Function(
  ffi.Int32 enabled,
);

typedef _dart_SDL_CaptureMouse = int Function(
  int enabled,
);

typedef _c_SDL_GetRelativeMouseMode = ffi.Int32 Function();

typedef _dart_SDL_GetRelativeMouseMode = int Function();

typedef _c_SDL_CreateCursor = ffi.Pointer<SDL_Cursor> Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Pointer<ffi.Uint8> mask,
  ffi.Int32 w,
  ffi.Int32 h,
  ffi.Int32 hot_x,
  ffi.Int32 hot_y,
);

typedef _dart_SDL_CreateCursor = ffi.Pointer<SDL_Cursor> Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Pointer<ffi.Uint8> mask,
  int w,
  int h,
  int hot_x,
  int hot_y,
);

typedef _c_SDL_CreateColorCursor = ffi.Pointer<SDL_Cursor> Function(
  ffi.Pointer<SDL_Surface> surface,
  ffi.Int32 hot_x,
  ffi.Int32 hot_y,
);

typedef _dart_SDL_CreateColorCursor = ffi.Pointer<SDL_Cursor> Function(
  ffi.Pointer<SDL_Surface> surface,
  int hot_x,
  int hot_y,
);

typedef _c_SDL_CreateSystemCursor = ffi.Pointer<SDL_Cursor> Function(
  ffi.Int32 id,
);

typedef _dart_SDL_CreateSystemCursor = ffi.Pointer<SDL_Cursor> Function(
  int id,
);

typedef _c_SDL_SetCursor = ffi.Void Function(
  ffi.Pointer<SDL_Cursor> cursor,
);

typedef _dart_SDL_SetCursor = void Function(
  ffi.Pointer<SDL_Cursor> cursor,
);

typedef _c_SDL_GetCursor = ffi.Pointer<SDL_Cursor> Function();

typedef _dart_SDL_GetCursor = ffi.Pointer<SDL_Cursor> Function();

typedef _c_SDL_GetDefaultCursor = ffi.Pointer<SDL_Cursor> Function();

typedef _dart_SDL_GetDefaultCursor = ffi.Pointer<SDL_Cursor> Function();

typedef _c_SDL_FreeCursor = ffi.Void Function(
  ffi.Pointer<SDL_Cursor> cursor,
);

typedef _dart_SDL_FreeCursor = void Function(
  ffi.Pointer<SDL_Cursor> cursor,
);

typedef _c_SDL_ShowCursor = ffi.Int32 Function(
  ffi.Int32 toggle,
);

typedef _dart_SDL_ShowCursor = int Function(
  int toggle,
);

typedef _c_SDL_LockJoysticks = ffi.Void Function();

typedef _dart_SDL_LockJoysticks = void Function();

typedef _c_SDL_UnlockJoysticks = ffi.Void Function();

typedef _dart_SDL_UnlockJoysticks = void Function();

typedef _c_SDL_NumJoysticks = ffi.Int32 Function();

typedef _dart_SDL_NumJoysticks = int Function();

typedef _c_SDL_JoystickNameForIndex = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickNameForIndex = ffi.Pointer<ffi.Int8> Function(
  int device_index,
);

typedef _c_SDL_JoystickGetDevicePlayerIndex = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickGetDevicePlayerIndex = int Function(
  int device_index,
);

typedef _c_SDL_JoystickGetDeviceVendor = ffi.Uint16 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickGetDeviceVendor = int Function(
  int device_index,
);

typedef _c_SDL_JoystickGetDeviceProduct = ffi.Uint16 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickGetDeviceProduct = int Function(
  int device_index,
);

typedef _c_SDL_JoystickGetDeviceProductVersion = ffi.Uint16 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickGetDeviceProductVersion = int Function(
  int device_index,
);

typedef _c_SDL_JoystickGetDeviceType = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickGetDeviceType = int Function(
  int device_index,
);

typedef _c_SDL_JoystickGetDeviceInstanceID = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickGetDeviceInstanceID = int Function(
  int device_index,
);

typedef _c_SDL_JoystickOpen = ffi.Pointer<_SDL_Joystick> Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickOpen = ffi.Pointer<_SDL_Joystick> Function(
  int device_index,
);

typedef _c_SDL_JoystickFromInstanceID = ffi.Pointer<_SDL_Joystick> Function(
  ffi.Int32 instance_id,
);

typedef _dart_SDL_JoystickFromInstanceID = ffi.Pointer<_SDL_Joystick> Function(
  int instance_id,
);

typedef _c_SDL_JoystickFromPlayerIndex = ffi.Pointer<_SDL_Joystick> Function(
  ffi.Int32 player_index,
);

typedef _dart_SDL_JoystickFromPlayerIndex = ffi.Pointer<_SDL_Joystick> Function(
  int player_index,
);

typedef _c_SDL_JoystickAttachVirtual = ffi.Int32 Function(
  ffi.Int32 type,
  ffi.Int32 naxes,
  ffi.Int32 nbuttons,
  ffi.Int32 nhats,
);

typedef _dart_SDL_JoystickAttachVirtual = int Function(
  int type,
  int naxes,
  int nbuttons,
  int nhats,
);

typedef _c_SDL_JoystickDetachVirtual = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickDetachVirtual = int Function(
  int device_index,
);

typedef _c_SDL_JoystickIsVirtual = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_JoystickIsVirtual = int Function(
  int device_index,
);

typedef _c_SDL_JoystickSetVirtualAxis = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 axis,
  ffi.Int16 value,
);

typedef _dart_SDL_JoystickSetVirtualAxis = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int axis,
  int value,
);

typedef _c_SDL_JoystickSetVirtualButton = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 button,
  ffi.Uint8 value,
);

typedef _dart_SDL_JoystickSetVirtualButton = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int button,
  int value,
);

typedef _c_SDL_JoystickSetVirtualHat = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 hat,
  ffi.Uint8 value,
);

typedef _dart_SDL_JoystickSetVirtualHat = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int hat,
  int value,
);

typedef _c_SDL_JoystickName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickGetPlayerIndex = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetPlayerIndex = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickSetPlayerIndex = ffi.Void Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 player_index,
);

typedef _dart_SDL_JoystickSetPlayerIndex = void Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int player_index,
);

typedef _c_SDL_JoystickGetVendor = ffi.Uint16 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetVendor = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickGetProduct = ffi.Uint16 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetProduct = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickGetProductVersion = ffi.Uint16 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetProductVersion = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickGetSerial = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetSerial = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickGetType = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetType = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickGetAttached = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickGetAttached = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickInstanceID = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickInstanceID = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickNumAxes = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickNumAxes = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickNumBalls = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickNumBalls = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickNumHats = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickNumHats = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickNumButtons = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickNumButtons = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickUpdate = ffi.Void Function();

typedef _dart_SDL_JoystickUpdate = void Function();

typedef _c_SDL_JoystickEventState = ffi.Int32 Function(
  ffi.Int32 state,
);

typedef _dart_SDL_JoystickEventState = int Function(
  int state,
);

typedef _c_SDL_JoystickGetAxis = ffi.Int16 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 axis,
);

typedef _dart_SDL_JoystickGetAxis = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int axis,
);

typedef _c_SDL_JoystickGetAxisInitialState = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 axis,
  ffi.Pointer<ffi.Int16> state,
);

typedef _dart_SDL_JoystickGetAxisInitialState = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int axis,
  ffi.Pointer<ffi.Int16> state,
);

typedef _c_SDL_JoystickGetHat = ffi.Uint8 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 hat,
);

typedef _dart_SDL_JoystickGetHat = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int hat,
);

typedef _c_SDL_JoystickGetBall = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 ball,
  ffi.Pointer<ffi.Int32> dx,
  ffi.Pointer<ffi.Int32> dy,
);

typedef _dart_SDL_JoystickGetBall = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int ball,
  ffi.Pointer<ffi.Int32> dx,
  ffi.Pointer<ffi.Int32> dy,
);

typedef _c_SDL_JoystickGetButton = ffi.Uint8 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Int32 button,
);

typedef _dart_SDL_JoystickGetButton = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int button,
);

typedef _c_SDL_JoystickRumble = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Uint16 low_frequency_rumble,
  ffi.Uint16 high_frequency_rumble,
  ffi.Uint32 duration_ms,
);

typedef _dart_SDL_JoystickRumble = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int low_frequency_rumble,
  int high_frequency_rumble,
  int duration_ms,
);

typedef _c_SDL_JoystickRumbleTriggers = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Uint16 left_rumble,
  ffi.Uint16 right_rumble,
  ffi.Uint32 duration_ms,
);

typedef _dart_SDL_JoystickRumbleTriggers = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int left_rumble,
  int right_rumble,
  int duration_ms,
);

typedef _c_SDL_JoystickHasLED = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickHasLED = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickSetLED = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  ffi.Uint8 red,
  ffi.Uint8 green,
  ffi.Uint8 blue,
);

typedef _dart_SDL_JoystickSetLED = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
  int red,
  int green,
  int blue,
);

typedef _c_SDL_JoystickClose = ffi.Void Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickClose = void Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_JoystickCurrentPowerLevel = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickCurrentPowerLevel = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_LockSensors = ffi.Void Function();

typedef _dart_SDL_LockSensors = void Function();

typedef _c_SDL_UnlockSensors = ffi.Void Function();

typedef _dart_SDL_UnlockSensors = void Function();

typedef _c_SDL_NumSensors = ffi.Int32 Function();

typedef _dart_SDL_NumSensors = int Function();

typedef _c_SDL_SensorGetDeviceName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_SensorGetDeviceName = ffi.Pointer<ffi.Int8> Function(
  int device_index,
);

typedef _c_SDL_SensorGetDeviceType = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_SensorGetDeviceType = int Function(
  int device_index,
);

typedef _c_SDL_SensorGetDeviceNonPortableType = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_SensorGetDeviceNonPortableType = int Function(
  int device_index,
);

typedef _c_SDL_SensorGetDeviceInstanceID = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_SensorGetDeviceInstanceID = int Function(
  int device_index,
);

typedef _c_SDL_SensorOpen = ffi.Pointer<_SDL_Sensor> Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_SensorOpen = ffi.Pointer<_SDL_Sensor> Function(
  int device_index,
);

typedef _c_SDL_SensorFromInstanceID = ffi.Pointer<_SDL_Sensor> Function(
  ffi.Int32 instance_id,
);

typedef _dart_SDL_SensorFromInstanceID = ffi.Pointer<_SDL_Sensor> Function(
  int instance_id,
);

typedef _c_SDL_SensorGetName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _dart_SDL_SensorGetName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _c_SDL_SensorGetType = ffi.Int32 Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _dart_SDL_SensorGetType = int Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _c_SDL_SensorGetNonPortableType = ffi.Int32 Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _dart_SDL_SensorGetNonPortableType = int Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _c_SDL_SensorGetInstanceID = ffi.Int32 Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _dart_SDL_SensorGetInstanceID = int Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _c_SDL_SensorGetData = ffi.Int32 Function(
  ffi.Pointer<_SDL_Sensor> sensor,
  ffi.Pointer<ffi.Float> data,
  ffi.Int32 num_values,
);

typedef _dart_SDL_SensorGetData = int Function(
  ffi.Pointer<_SDL_Sensor> sensor,
  ffi.Pointer<ffi.Float> data,
  int num_values,
);

typedef _c_SDL_SensorClose = ffi.Void Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _dart_SDL_SensorClose = void Function(
  ffi.Pointer<_SDL_Sensor> sensor,
);

typedef _c_SDL_SensorUpdate = ffi.Void Function();

typedef _dart_SDL_SensorUpdate = void Function();

typedef _c_SDL_GameControllerAddMappingsFromRW = ffi.Int32 Function(
  ffi.Pointer<SDL_RWops> rw,
  ffi.Int32 freerw,
);

typedef _dart_SDL_GameControllerAddMappingsFromRW = int Function(
  ffi.Pointer<SDL_RWops> rw,
  int freerw,
);

typedef _c_SDL_GameControllerAddMapping = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> mappingString,
);

typedef _dart_SDL_GameControllerAddMapping = int Function(
  ffi.Pointer<ffi.Int8> mappingString,
);

typedef _c_SDL_GameControllerNumMappings = ffi.Int32 Function();

typedef _dart_SDL_GameControllerNumMappings = int Function();

typedef _c_SDL_GameControllerMappingForIndex = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 mapping_index,
);

typedef _dart_SDL_GameControllerMappingForIndex = ffi.Pointer<ffi.Int8>
    Function(
  int mapping_index,
);

typedef _c_SDL_GameControllerMapping = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerMapping = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_IsGameController = ffi.Int32 Function(
  ffi.Int32 joystick_index,
);

typedef _dart_SDL_IsGameController = int Function(
  int joystick_index,
);

typedef _c_SDL_GameControllerNameForIndex = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 joystick_index,
);

typedef _dart_SDL_GameControllerNameForIndex = ffi.Pointer<ffi.Int8> Function(
  int joystick_index,
);

typedef _c_SDL_GameControllerTypeForIndex = ffi.Int32 Function(
  ffi.Int32 joystick_index,
);

typedef _dart_SDL_GameControllerTypeForIndex = int Function(
  int joystick_index,
);

typedef _c_SDL_GameControllerMappingForDeviceIndex = ffi.Pointer<ffi.Int8>
    Function(
  ffi.Int32 joystick_index,
);

typedef _dart_SDL_GameControllerMappingForDeviceIndex = ffi.Pointer<ffi.Int8>
    Function(
  int joystick_index,
);

typedef _c_SDL_GameControllerOpen = ffi.Pointer<_SDL_GameController> Function(
  ffi.Int32 joystick_index,
);

typedef _dart_SDL_GameControllerOpen = ffi.Pointer<_SDL_GameController>
    Function(
  int joystick_index,
);

typedef _c_SDL_GameControllerFromInstanceID = ffi.Pointer<_SDL_GameController>
    Function(
  ffi.Int32 joyid,
);

typedef _dart_SDL_GameControllerFromInstanceID
    = ffi.Pointer<_SDL_GameController> Function(
  int joyid,
);

typedef _c_SDL_GameControllerFromPlayerIndex = ffi.Pointer<_SDL_GameController>
    Function(
  ffi.Int32 player_index,
);

typedef _dart_SDL_GameControllerFromPlayerIndex
    = ffi.Pointer<_SDL_GameController> Function(
  int player_index,
);

typedef _c_SDL_GameControllerName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerName = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetType = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetType = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetPlayerIndex = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetPlayerIndex = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerSetPlayerIndex = ffi.Void Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 player_index,
);

typedef _dart_SDL_GameControllerSetPlayerIndex = void Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int player_index,
);

typedef _c_SDL_GameControllerGetVendor = ffi.Uint16 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetVendor = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetProduct = ffi.Uint16 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetProduct = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetProductVersion = ffi.Uint16 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetProductVersion = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetSerial = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetSerial = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetAttached = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetAttached = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetJoystick = ffi.Pointer<_SDL_Joystick> Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetJoystick = ffi.Pointer<_SDL_Joystick>
    Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerEventState = ffi.Int32 Function(
  ffi.Int32 state,
);

typedef _dart_SDL_GameControllerEventState = int Function(
  int state,
);

typedef _c_SDL_GameControllerUpdate = ffi.Void Function();

typedef _dart_SDL_GameControllerUpdate = void Function();

typedef _c_SDL_GameControllerGetAxisFromString = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> pchString,
);

typedef _dart_SDL_GameControllerGetAxisFromString = int Function(
  ffi.Pointer<ffi.Int8> pchString,
);

typedef _c_SDL_GameControllerGetStringForAxis = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 axis,
);

typedef _dart_SDL_GameControllerGetStringForAxis = ffi.Pointer<ffi.Int8>
    Function(
  int axis,
);

typedef _c_SDL_GameControllerHasAxis = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 axis,
);

typedef _dart_SDL_GameControllerHasAxis = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int axis,
);

typedef _c_SDL_GameControllerGetAxis = ffi.Int16 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 axis,
);

typedef _dart_SDL_GameControllerGetAxis = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int axis,
);

typedef _c_SDL_GameControllerGetButtonFromString = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> pchString,
);

typedef _dart_SDL_GameControllerGetButtonFromString = int Function(
  ffi.Pointer<ffi.Int8> pchString,
);

typedef _c_SDL_GameControllerGetStringForButton = ffi.Pointer<ffi.Int8>
    Function(
  ffi.Int32 button,
);

typedef _dart_SDL_GameControllerGetStringForButton = ffi.Pointer<ffi.Int8>
    Function(
  int button,
);

typedef _c_SDL_GameControllerHasButton = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 button,
);

typedef _dart_SDL_GameControllerHasButton = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int button,
);

typedef _c_SDL_GameControllerGetButton = ffi.Uint8 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 button,
);

typedef _dart_SDL_GameControllerGetButton = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int button,
);

typedef _c_SDL_GameControllerGetNumTouchpads = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerGetNumTouchpads = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerGetNumTouchpadFingers = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 touchpad,
);

typedef _dart_SDL_GameControllerGetNumTouchpadFingers = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int touchpad,
);

typedef _c_SDL_GameControllerGetTouchpadFinger = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 touchpad,
  ffi.Int32 finger,
  ffi.Pointer<ffi.Uint8> state,
  ffi.Pointer<ffi.Float> x,
  ffi.Pointer<ffi.Float> y,
  ffi.Pointer<ffi.Float> pressure,
);

typedef _dart_SDL_GameControllerGetTouchpadFinger = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int touchpad,
  int finger,
  ffi.Pointer<ffi.Uint8> state,
  ffi.Pointer<ffi.Float> x,
  ffi.Pointer<ffi.Float> y,
  ffi.Pointer<ffi.Float> pressure,
);

typedef _c_SDL_GameControllerHasSensor = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 type,
);

typedef _dart_SDL_GameControllerHasSensor = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int type,
);

typedef _c_SDL_GameControllerSetSensorEnabled = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 type,
  ffi.Int32 enabled,
);

typedef _dart_SDL_GameControllerSetSensorEnabled = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int type,
  int enabled,
);

typedef _c_SDL_GameControllerIsSensorEnabled = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 type,
);

typedef _dart_SDL_GameControllerIsSensorEnabled = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int type,
);

typedef _c_SDL_GameControllerGetSensorData = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Int32 type,
  ffi.Pointer<ffi.Float> data,
  ffi.Int32 num_values,
);

typedef _dart_SDL_GameControllerGetSensorData = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int type,
  ffi.Pointer<ffi.Float> data,
  int num_values,
);

typedef _c_SDL_GameControllerRumble = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Uint16 low_frequency_rumble,
  ffi.Uint16 high_frequency_rumble,
  ffi.Uint32 duration_ms,
);

typedef _dart_SDL_GameControllerRumble = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int low_frequency_rumble,
  int high_frequency_rumble,
  int duration_ms,
);

typedef _c_SDL_GameControllerRumbleTriggers = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Uint16 left_rumble,
  ffi.Uint16 right_rumble,
  ffi.Uint32 duration_ms,
);

typedef _dart_SDL_GameControllerRumbleTriggers = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int left_rumble,
  int right_rumble,
  int duration_ms,
);

typedef _c_SDL_GameControllerHasLED = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerHasLED = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GameControllerSetLED = ffi.Int32 Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  ffi.Uint8 red,
  ffi.Uint8 green,
  ffi.Uint8 blue,
);

typedef _dart_SDL_GameControllerSetLED = int Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
  int red,
  int green,
  int blue,
);

typedef _c_SDL_GameControllerClose = ffi.Void Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _dart_SDL_GameControllerClose = void Function(
  ffi.Pointer<_SDL_GameController> gamecontroller,
);

typedef _c_SDL_GetNumTouchDevices = ffi.Int32 Function();

typedef _dart_SDL_GetNumTouchDevices = int Function();

typedef _c_SDL_GetTouchDevice = ffi.Int64 Function(
  ffi.Int32 index,
);

typedef _dart_SDL_GetTouchDevice = int Function(
  int index,
);

typedef _c_SDL_GetTouchDeviceType = ffi.Int32 Function(
  ffi.Int64 touchID,
);

typedef _dart_SDL_GetTouchDeviceType = int Function(
  int touchID,
);

typedef _c_SDL_GetNumTouchFingers = ffi.Int32 Function(
  ffi.Int64 touchID,
);

typedef _dart_SDL_GetNumTouchFingers = int Function(
  int touchID,
);

typedef _c_SDL_GetTouchFinger = ffi.Pointer<SDL_Finger> Function(
  ffi.Int64 touchID,
  ffi.Int32 index,
);

typedef _dart_SDL_GetTouchFinger = ffi.Pointer<SDL_Finger> Function(
  int touchID,
  int index,
);

typedef _c_SDL_RecordGesture = ffi.Int32 Function(
  ffi.Int64 touchId,
);

typedef _dart_SDL_RecordGesture = int Function(
  int touchId,
);

typedef _c_SDL_SaveAllDollarTemplates = ffi.Int32 Function(
  ffi.Pointer<SDL_RWops> dst,
);

typedef _dart_SDL_SaveAllDollarTemplates = int Function(
  ffi.Pointer<SDL_RWops> dst,
);

typedef _c_SDL_SaveDollarTemplate = ffi.Int32 Function(
  ffi.Int64 gestureId,
  ffi.Pointer<SDL_RWops> dst,
);

typedef _dart_SDL_SaveDollarTemplate = int Function(
  int gestureId,
  ffi.Pointer<SDL_RWops> dst,
);

typedef _c_SDL_LoadDollarTemplates = ffi.Int32 Function(
  ffi.Int64 touchId,
  ffi.Pointer<SDL_RWops> src,
);

typedef _dart_SDL_LoadDollarTemplates = int Function(
  int touchId,
  ffi.Pointer<SDL_RWops> src,
);

typedef _c_SDL_PumpEvents = ffi.Void Function();

typedef _dart_SDL_PumpEvents = void Function();

typedef _c_SDL_HasEvent = ffi.Int32 Function(
  ffi.Uint32 type,
);

typedef _dart_SDL_HasEvent = int Function(
  int type,
);

typedef _c_SDL_HasEvents = ffi.Int32 Function(
  ffi.Uint32 minType,
  ffi.Uint32 maxType,
);

typedef _dart_SDL_HasEvents = int Function(
  int minType,
  int maxType,
);

typedef _c_SDL_FlushEvent = ffi.Void Function(
  ffi.Uint32 type,
);

typedef _dart_SDL_FlushEvent = void Function(
  int type,
);

typedef _c_SDL_FlushEvents = ffi.Void Function(
  ffi.Uint32 minType,
  ffi.Uint32 maxType,
);

typedef _dart_SDL_FlushEvents = void Function(
  int minType,
  int maxType,
);

typedef _c_SDL_EventState = ffi.Uint8 Function(
  ffi.Uint32 type,
  ffi.Int32 state,
);

typedef _dart_SDL_EventState = int Function(
  int type,
  int state,
);

typedef _c_SDL_RegisterEvents = ffi.Uint32 Function(
  ffi.Int32 numevents,
);

typedef _dart_SDL_RegisterEvents = int Function(
  int numevents,
);

typedef _c_SDL_GetBasePath = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetBasePath = ffi.Pointer<ffi.Int8> Function();

typedef _c_SDL_GetPrefPath = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> org,
  ffi.Pointer<ffi.Int8> app,
);

typedef _dart_SDL_GetPrefPath = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> org,
  ffi.Pointer<ffi.Int8> app,
);

typedef _c_SDL_NumHaptics = ffi.Int32 Function();

typedef _dart_SDL_NumHaptics = int Function();

typedef _c_SDL_HapticName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_HapticName = ffi.Pointer<ffi.Int8> Function(
  int device_index,
);

typedef _c_SDL_HapticOpen = ffi.Pointer<_SDL_Haptic> Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_HapticOpen = ffi.Pointer<_SDL_Haptic> Function(
  int device_index,
);

typedef _c_SDL_HapticOpened = ffi.Int32 Function(
  ffi.Int32 device_index,
);

typedef _dart_SDL_HapticOpened = int Function(
  int device_index,
);

typedef _c_SDL_HapticIndex = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticIndex = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_MouseIsHaptic = ffi.Int32 Function();

typedef _dart_SDL_MouseIsHaptic = int Function();

typedef _c_SDL_HapticOpenFromMouse = ffi.Pointer<_SDL_Haptic> Function();

typedef _dart_SDL_HapticOpenFromMouse = ffi.Pointer<_SDL_Haptic> Function();

typedef _c_SDL_JoystickIsHaptic = ffi.Int32 Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_JoystickIsHaptic = int Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_HapticOpenFromJoystick = ffi.Pointer<_SDL_Haptic> Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _dart_SDL_HapticOpenFromJoystick = ffi.Pointer<_SDL_Haptic> Function(
  ffi.Pointer<_SDL_Joystick> joystick,
);

typedef _c_SDL_HapticClose = ffi.Void Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticClose = void Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticNumEffects = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticNumEffects = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticNumEffectsPlaying = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticNumEffectsPlaying = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticQuery = ffi.Uint32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticQuery = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticNumAxes = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticNumAxes = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticRunEffect = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Int32 effect,
  ffi.Uint32 iterations,
);

typedef _dart_SDL_HapticRunEffect = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  int effect,
  int iterations,
);

typedef _c_SDL_HapticStopEffect = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Int32 effect,
);

typedef _dart_SDL_HapticStopEffect = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  int effect,
);

typedef _c_SDL_HapticDestroyEffect = ffi.Void Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Int32 effect,
);

typedef _dart_SDL_HapticDestroyEffect = void Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  int effect,
);

typedef _c_SDL_HapticGetEffectStatus = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Int32 effect,
);

typedef _dart_SDL_HapticGetEffectStatus = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  int effect,
);

typedef _c_SDL_HapticSetGain = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Int32 gain,
);

typedef _dart_SDL_HapticSetGain = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  int gain,
);

typedef _c_SDL_HapticSetAutocenter = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Int32 autocenter,
);

typedef _dart_SDL_HapticSetAutocenter = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  int autocenter,
);

typedef _c_SDL_HapticPause = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticPause = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticUnpause = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticUnpause = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticStopAll = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticStopAll = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticRumbleSupported = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticRumbleSupported = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticRumbleInit = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticRumbleInit = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_HapticRumblePlay = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  ffi.Float strength,
  ffi.Uint32 length,
);

typedef _dart_SDL_HapticRumblePlay = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
  double strength,
  int length,
);

typedef _c_SDL_HapticRumbleStop = ffi.Int32 Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _dart_SDL_HapticRumbleStop = int Function(
  ffi.Pointer<_SDL_Haptic> haptic,
);

typedef _c_SDL_SetHintWithPriority = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  ffi.Int32 priority,
);

typedef _dart_SDL_SetHintWithPriority = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  int priority,
);

typedef _c_SDL_SetHint = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_SDL_SetHint = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_SDL_GetHint = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_SDL_GetHint = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_SDL_GetHintBoolean = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 default_value,
);

typedef _dart_SDL_GetHintBoolean = int Function(
  ffi.Pointer<ffi.Int8> name,
  int default_value,
);

typedef SDL_HintCallback = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
);

typedef _c_SDL_AddHintCallback = ffi.Void Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.NativeFunction<SDL_HintCallback>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_SDL_AddHintCallback = void Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.NativeFunction<SDL_HintCallback>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_SDL_DelHintCallback = ffi.Void Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.NativeFunction<SDL_HintCallback>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_SDL_DelHintCallback = void Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.NativeFunction<SDL_HintCallback>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_SDL_ClearHints = ffi.Void Function();

typedef _dart_SDL_ClearHints = void Function();

typedef _c_SDL_LoadObject = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> sofile,
);

typedef _dart_SDL_LoadObject = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> sofile,
);

typedef _c_SDL_LoadFunction = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> handle,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_SDL_LoadFunction = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> handle,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_SDL_UnloadObject = ffi.Void Function(
  ffi.Pointer<ffi.Void> handle,
);

typedef _dart_SDL_UnloadObject = void Function(
  ffi.Pointer<ffi.Void> handle,
);

typedef _c_SDL_LogSetAllPriority = ffi.Void Function(
  ffi.Int32 priority,
);

typedef _dart_SDL_LogSetAllPriority = void Function(
  int priority,
);

typedef _c_SDL_LogSetPriority = ffi.Void Function(
  ffi.Int32 category,
  ffi.Int32 priority,
);

typedef _dart_SDL_LogSetPriority = void Function(
  int category,
  int priority,
);

typedef _c_SDL_LogGetPriority = ffi.Int32 Function(
  ffi.Int32 category,
);

typedef _dart_SDL_LogGetPriority = int Function(
  int category,
);

typedef _c_SDL_LogResetPriorities = ffi.Void Function();

typedef _dart_SDL_LogResetPriorities = void Function();

typedef _c_SDL_Log = ffi.Void Function(
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_Log = void Function(
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogVerbose = ffi.Void Function(
  ffi.Int32 category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogVerbose = void Function(
  int category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogDebug = ffi.Void Function(
  ffi.Int32 category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogDebug = void Function(
  int category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogInfo = ffi.Void Function(
  ffi.Int32 category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogInfo = void Function(
  int category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogWarn = ffi.Void Function(
  ffi.Int32 category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogWarn = void Function(
  int category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogError = ffi.Void Function(
  ffi.Int32 category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogError = void Function(
  int category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogCritical = ffi.Void Function(
  ffi.Int32 category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogCritical = void Function(
  int category,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogMessage = ffi.Void Function(
  ffi.Int32 category,
  ffi.Int32 priority,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_SDL_LogMessage = void Function(
  int category,
  int priority,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_SDL_LogMessageV = ffi.Void Function(
  ffi.Int32 category,
  ffi.Int32 priority,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<ffi.Int8> ap,
);

typedef _dart_SDL_LogMessageV = void Function(
  int category,
  int priority,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<ffi.Int8> ap,
);

typedef SDL_LogOutputFunction = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
);

typedef _c_SDL_LogGetOutputFunction = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_LogOutputFunction>>> callback,
  ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
);

typedef _dart_SDL_LogGetOutputFunction = void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<SDL_LogOutputFunction>>> callback,
  ffi.Pointer<ffi.Pointer<ffi.Void>> userdata,
);

typedef _c_SDL_LogSetOutputFunction = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<SDL_LogOutputFunction>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_SDL_LogSetOutputFunction = void Function(
  ffi.Pointer<ffi.NativeFunction<SDL_LogOutputFunction>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_SDL_ShowMessageBox = ffi.Int32 Function(
  ffi.Pointer<SDL_MessageBoxData> messageboxdata,
  ffi.Pointer<ffi.Int32> buttonid,
);

typedef _dart_SDL_ShowMessageBox = int Function(
  ffi.Pointer<SDL_MessageBoxData> messageboxdata,
  ffi.Pointer<ffi.Int32> buttonid,
);

typedef _c_SDL_ShowSimpleMessageBox = ffi.Int32 Function(
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Int8> title,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_ShowSimpleMessageBox = int Function(
  int flags,
  ffi.Pointer<ffi.Int8> title,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_Metal_CreateView = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_Metal_CreateView = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_Metal_DestroyView = ffi.Void Function(
  ffi.Pointer<ffi.Void> view,
);

typedef _dart_SDL_Metal_DestroyView = void Function(
  ffi.Pointer<ffi.Void> view,
);

typedef _c_SDL_Metal_GetLayer = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> view,
);

typedef _dart_SDL_Metal_GetLayer = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> view,
);

typedef _c_SDL_Metal_GetDrawableSize = ffi.Void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_Metal_GetDrawableSize = void Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_GetPowerInfo = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> secs,
  ffi.Pointer<ffi.Int32> pct,
);

typedef _dart_SDL_GetPowerInfo = int Function(
  ffi.Pointer<ffi.Int32> secs,
  ffi.Pointer<ffi.Int32> pct,
);

typedef _c_SDL_GetNumRenderDrivers = ffi.Int32 Function();

typedef _dart_SDL_GetNumRenderDrivers = int Function();

typedef _c_SDL_GetRenderDriverInfo = ffi.Int32 Function(
  ffi.Int32 index,
  ffi.Pointer<SDL_RendererInfo> info,
);

typedef _dart_SDL_GetRenderDriverInfo = int Function(
  int index,
  ffi.Pointer<SDL_RendererInfo> info,
);

typedef _c_SDL_CreateWindowAndRenderer = ffi.Int32 Function(
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Uint32 window_flags,
  ffi.Pointer<ffi.Pointer<SDL_Window>> window,
  ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
);

typedef _dart_SDL_CreateWindowAndRenderer = int Function(
  int width,
  int height,
  int window_flags,
  ffi.Pointer<ffi.Pointer<SDL_Window>> window,
  ffi.Pointer<ffi.Pointer<SDL_Renderer>> renderer,
);

typedef _c_SDL_CreateRenderer = ffi.Pointer<SDL_Renderer> Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Int32 index,
  ffi.Uint32 flags,
);

typedef _dart_SDL_CreateRenderer = ffi.Pointer<SDL_Renderer> Function(
  ffi.Pointer<SDL_Window> window,
  int index,
  int flags,
);

typedef _c_SDL_CreateSoftwareRenderer = ffi.Pointer<SDL_Renderer> Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_CreateSoftwareRenderer = ffi.Pointer<SDL_Renderer> Function(
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_GetRenderer = ffi.Pointer<SDL_Renderer> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_GetRenderer = ffi.Pointer<SDL_Renderer> Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_GetRendererInfo = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_RendererInfo> info,
);

typedef _dart_SDL_GetRendererInfo = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_RendererInfo> info,
);

typedef _c_SDL_GetRendererOutputSize = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_GetRendererOutputSize = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_CreateTexture = ffi.Pointer<SDL_Texture> Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Uint32 format,
  ffi.Int32 access,
  ffi.Int32 w,
  ffi.Int32 h,
);

typedef _dart_SDL_CreateTexture = ffi.Pointer<SDL_Texture> Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int format,
  int access,
  int w,
  int h,
);

typedef _c_SDL_CreateTextureFromSurface = ffi.Pointer<SDL_Texture> Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Surface> surface,
);

typedef _dart_SDL_CreateTextureFromSurface = ffi.Pointer<SDL_Texture> Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Surface> surface,
);

typedef _c_SDL_QueryTexture = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Uint32> format,
  ffi.Pointer<ffi.Int32> access,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_QueryTexture = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Uint32> format,
  ffi.Pointer<ffi.Int32> access,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_SetTextureColorMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Uint8 r,
  ffi.Uint8 g,
  ffi.Uint8 b,
);

typedef _dart_SDL_SetTextureColorMod = int Function(
  ffi.Pointer<SDL_Texture> texture,
  int r,
  int g,
  int b,
);

typedef _c_SDL_GetTextureColorMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

typedef _dart_SDL_GetTextureColorMod = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

typedef _c_SDL_SetTextureAlphaMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Uint8 alpha,
);

typedef _dart_SDL_SetTextureAlphaMod = int Function(
  ffi.Pointer<SDL_Texture> texture,
  int alpha,
);

typedef _c_SDL_GetTextureAlphaMod = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Uint8> alpha,
);

typedef _dart_SDL_GetTextureAlphaMod = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Uint8> alpha,
);

typedef _c_SDL_SetTextureBlendMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Int32 blendMode,
);

typedef _dart_SDL_SetTextureBlendMode = int Function(
  ffi.Pointer<SDL_Texture> texture,
  int blendMode,
);

typedef _c_SDL_GetTextureBlendMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Int32> blendMode,
);

typedef _dart_SDL_GetTextureBlendMode = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Int32> blendMode,
);

typedef _c_SDL_SetTextureScaleMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Int32 scaleMode,
);

typedef _dart_SDL_SetTextureScaleMode = int Function(
  ffi.Pointer<SDL_Texture> texture,
  int scaleMode,
);

typedef _c_SDL_GetTextureScaleMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Int32> scaleMode,
);

typedef _dart_SDL_GetTextureScaleMode = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Int32> scaleMode,
);

typedef _c_SDL_UpdateTexture = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Void> pixels,
  ffi.Int32 pitch,
);

typedef _dart_SDL_UpdateTexture = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Void> pixels,
  int pitch,
);

typedef _c_SDL_UpdateYUVTexture = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Uint8> Yplane,
  ffi.Int32 Ypitch,
  ffi.Pointer<ffi.Uint8> Uplane,
  ffi.Int32 Upitch,
  ffi.Pointer<ffi.Uint8> Vplane,
  ffi.Int32 Vpitch,
);

typedef _dart_SDL_UpdateYUVTexture = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Uint8> Yplane,
  int Ypitch,
  ffi.Pointer<ffi.Uint8> Uplane,
  int Upitch,
  ffi.Pointer<ffi.Uint8> Vplane,
  int Vpitch,
);

typedef _c_SDL_LockTexture = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
  ffi.Pointer<ffi.Int32> pitch,
);

typedef _dart_SDL_LockTexture = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Pointer<ffi.Void>> pixels,
  ffi.Pointer<ffi.Int32> pitch,
);

typedef _c_SDL_LockTextureToSurface = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
);

typedef _dart_SDL_LockTextureToSurface = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Pointer<ffi.Pointer<SDL_Surface>> surface,
);

typedef _c_SDL_UnlockTexture = ffi.Void Function(
  ffi.Pointer<SDL_Texture> texture,
);

typedef _dart_SDL_UnlockTexture = void Function(
  ffi.Pointer<SDL_Texture> texture,
);

typedef _c_SDL_RenderTargetSupported = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderTargetSupported = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_SetRenderTarget = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
);

typedef _dart_SDL_SetRenderTarget = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
);

typedef _c_SDL_GetRenderTarget = ffi.Pointer<SDL_Texture> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_GetRenderTarget = ffi.Pointer<SDL_Texture> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_RenderSetLogicalSize = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Int32 w,
  ffi.Int32 h,
);

typedef _dart_SDL_RenderSetLogicalSize = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int w,
  int h,
);

typedef _c_SDL_RenderGetLogicalSize = ffi.Void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _dart_SDL_RenderGetLogicalSize = void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Int32> w,
  ffi.Pointer<ffi.Int32> h,
);

typedef _c_SDL_RenderSetIntegerScale = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Int32 enable,
);

typedef _dart_SDL_RenderSetIntegerScale = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int enable,
);

typedef _c_SDL_RenderGetIntegerScale = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderGetIntegerScale = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_RenderSetViewport = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_RenderSetViewport = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_RenderGetViewport = ffi.Void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_RenderGetViewport = void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_RenderSetClipRect = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_RenderSetClipRect = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_RenderGetClipRect = ffi.Void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_RenderGetClipRect = void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_RenderIsClipEnabled = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderIsClipEnabled = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_RenderSetScale = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Float scaleX,
  ffi.Float scaleY,
);

typedef _dart_SDL_RenderSetScale = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  double scaleX,
  double scaleY,
);

typedef _c_SDL_RenderGetScale = ffi.Void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Float> scaleX,
  ffi.Pointer<ffi.Float> scaleY,
);

typedef _dart_SDL_RenderGetScale = void Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Float> scaleX,
  ffi.Pointer<ffi.Float> scaleY,
);

typedef _c_SDL_SetRenderDrawColor = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Uint8 r,
  ffi.Uint8 g,
  ffi.Uint8 b,
  ffi.Uint8 a,
);

typedef _dart_SDL_SetRenderDrawColor = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int r,
  int g,
  int b,
  int a,
);

typedef _c_SDL_GetRenderDrawColor = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
  ffi.Pointer<ffi.Uint8> a,
);

typedef _dart_SDL_GetRenderDrawColor = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
  ffi.Pointer<ffi.Uint8> a,
);

typedef _c_SDL_SetRenderDrawBlendMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Int32 blendMode,
);

typedef _dart_SDL_SetRenderDrawBlendMode = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int blendMode,
);

typedef _c_SDL_GetRenderDrawBlendMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Int32> blendMode,
);

typedef _dart_SDL_GetRenderDrawBlendMode = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<ffi.Int32> blendMode,
);

typedef _c_SDL_RenderClear = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderClear = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_RenderDrawPoint = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Int32 x,
  ffi.Int32 y,
);

typedef _dart_SDL_RenderDrawPoint = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int x,
  int y,
);

typedef _c_SDL_RenderDrawPoints = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Point> points,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderDrawPoints = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Point> points,
  int count,
);

typedef _c_SDL_RenderDrawLine = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Int32 x1,
  ffi.Int32 y1,
  ffi.Int32 x2,
  ffi.Int32 y2,
);

typedef _dart_SDL_RenderDrawLine = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  int x1,
  int y1,
  int x2,
  int y2,
);

typedef _c_SDL_RenderDrawLines = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Point> points,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderDrawLines = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Point> points,
  int count,
);

typedef _c_SDL_RenderDrawRect = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_RenderDrawRect = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_RenderDrawRects = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rects,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderDrawRects = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rects,
  int count,
);

typedef _c_SDL_RenderFillRect = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _dart_SDL_RenderFillRect = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
);

typedef _c_SDL_RenderFillRects = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rects,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderFillRects = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rects,
  int count,
);

typedef _c_SDL_RenderCopy = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _dart_SDL_RenderCopy = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Rect> dstrect,
);

typedef _c_SDL_RenderCopyEx = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Rect> dstrect,
  ffi.Double angle,
  ffi.Pointer<SDL_Point> center,
  ffi.Int32 flip,
);

typedef _dart_SDL_RenderCopyEx = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_Rect> dstrect,
  double angle,
  ffi.Pointer<SDL_Point> center,
  int flip,
);

typedef _c_SDL_RenderDrawPointF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Float x,
  ffi.Float y,
);

typedef _dart_SDL_RenderDrawPointF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  double x,
  double y,
);

typedef _c_SDL_RenderDrawPointsF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FPoint> points,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderDrawPointsF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FPoint> points,
  int count,
);

typedef _c_SDL_RenderDrawLineF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Float x1,
  ffi.Float y1,
  ffi.Float x2,
  ffi.Float y2,
);

typedef _dart_SDL_RenderDrawLineF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  double x1,
  double y1,
  double x2,
  double y2,
);

typedef _c_SDL_RenderDrawLinesF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FPoint> points,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderDrawLinesF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FPoint> points,
  int count,
);

typedef _c_SDL_RenderDrawRectF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rect,
);

typedef _dart_SDL_RenderDrawRectF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rect,
);

typedef _c_SDL_RenderDrawRectsF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rects,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderDrawRectsF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rects,
  int count,
);

typedef _c_SDL_RenderFillRectF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rect,
);

typedef _dart_SDL_RenderFillRectF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rect,
);

typedef _c_SDL_RenderFillRectsF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rects,
  ffi.Int32 count,
);

typedef _dart_SDL_RenderFillRectsF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_FRect> rects,
  int count,
);

typedef _c_SDL_RenderCopyF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_FRect> dstrect,
);

typedef _dart_SDL_RenderCopyF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_FRect> dstrect,
);

typedef _c_SDL_RenderCopyExF = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_FRect> dstrect,
  ffi.Double angle,
  ffi.Pointer<SDL_FPoint> center,
  ffi.Int32 flip,
);

typedef _dart_SDL_RenderCopyExF = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<SDL_Rect> srcrect,
  ffi.Pointer<SDL_FRect> dstrect,
  double angle,
  ffi.Pointer<SDL_FPoint> center,
  int flip,
);

typedef _c_SDL_RenderReadPixels = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
  ffi.Uint32 format,
  ffi.Pointer<ffi.Void> pixels,
  ffi.Int32 pitch,
);

typedef _dart_SDL_RenderReadPixels = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
  ffi.Pointer<SDL_Rect> rect,
  int format,
  ffi.Pointer<ffi.Void> pixels,
  int pitch,
);

typedef _c_SDL_RenderPresent = ffi.Void Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderPresent = void Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_DestroyTexture = ffi.Void Function(
  ffi.Pointer<SDL_Texture> texture,
);

typedef _dart_SDL_DestroyTexture = void Function(
  ffi.Pointer<SDL_Texture> texture,
);

typedef _c_SDL_DestroyRenderer = ffi.Void Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_DestroyRenderer = void Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_RenderFlush = ffi.Int32 Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderFlush = int Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_GL_BindTexture = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Float> texw,
  ffi.Pointer<ffi.Float> texh,
);

typedef _dart_SDL_GL_BindTexture = int Function(
  ffi.Pointer<SDL_Texture> texture,
  ffi.Pointer<ffi.Float> texw,
  ffi.Pointer<ffi.Float> texh,
);

typedef _c_SDL_GL_UnbindTexture = ffi.Int32 Function(
  ffi.Pointer<SDL_Texture> texture,
);

typedef _dart_SDL_GL_UnbindTexture = int Function(
  ffi.Pointer<SDL_Texture> texture,
);

typedef _c_SDL_RenderGetMetalLayer = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderGetMetalLayer = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_RenderGetMetalCommandEncoder = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderGetMetalCommandEncoder = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_CreateShapedWindow = ffi.Pointer<SDL_Window> Function(
  ffi.Pointer<ffi.Int8> title,
  ffi.Uint32 x,
  ffi.Uint32 y,
  ffi.Uint32 w,
  ffi.Uint32 h,
  ffi.Uint32 flags,
);

typedef _dart_SDL_CreateShapedWindow = ffi.Pointer<SDL_Window> Function(
  ffi.Pointer<ffi.Int8> title,
  int x,
  int y,
  int w,
  int h,
  int flags,
);

typedef _c_SDL_IsShapedWindow = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _dart_SDL_IsShapedWindow = int Function(
  ffi.Pointer<SDL_Window> window,
);

typedef _c_SDL_SetWindowShape = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_Surface> shape,
  ffi.Pointer<SDL_WindowShapeMode> shape_mode,
);

typedef _dart_SDL_SetWindowShape = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_Surface> shape,
  ffi.Pointer<SDL_WindowShapeMode> shape_mode,
);

typedef _c_SDL_GetShapedWindowMode = ffi.Int32 Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_WindowShapeMode> shape_mode,
);

typedef _dart_SDL_GetShapedWindowMode = int Function(
  ffi.Pointer<SDL_Window> window,
  ffi.Pointer<SDL_WindowShapeMode> shape_mode,
);

typedef SDL_WindowsMessageHook = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Uint32,
  ffi.Uint64,
  ffi.Int64,
);

typedef _c_SDL_SetWindowsMessageHook = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<SDL_WindowsMessageHook>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_SDL_SetWindowsMessageHook = void Function(
  ffi.Pointer<ffi.NativeFunction<SDL_WindowsMessageHook>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_SDL_Direct3D9GetAdapterIndex = ffi.Int32 Function(
  ffi.Int32 displayIndex,
);

typedef _dart_SDL_Direct3D9GetAdapterIndex = int Function(
  int displayIndex,
);

typedef _c_SDL_RenderGetD3D9Device = ffi.Pointer<IDirect3DDevice9> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _dart_SDL_RenderGetD3D9Device = ffi.Pointer<IDirect3DDevice9> Function(
  ffi.Pointer<SDL_Renderer> renderer,
);

typedef _c_SDL_DXGIGetOutputInfo = ffi.Int32 Function(
  ffi.Int32 displayIndex,
  ffi.Pointer<ffi.Int32> adapterIndex,
  ffi.Pointer<ffi.Int32> outputIndex,
);

typedef _dart_SDL_DXGIGetOutputInfo = int Function(
  int displayIndex,
  ffi.Pointer<ffi.Int32> adapterIndex,
  ffi.Pointer<ffi.Int32> outputIndex,
);

typedef _c_SDL_IsTablet = ffi.Int32 Function();

typedef _dart_SDL_IsTablet = int Function();

typedef _c_SDL_OnApplicationWillTerminate = ffi.Void Function();

typedef _dart_SDL_OnApplicationWillTerminate = void Function();

typedef _c_SDL_OnApplicationDidReceiveMemoryWarning = ffi.Void Function();

typedef _dart_SDL_OnApplicationDidReceiveMemoryWarning = void Function();

typedef _c_SDL_OnApplicationWillResignActive = ffi.Void Function();

typedef _dart_SDL_OnApplicationWillResignActive = void Function();

typedef _c_SDL_OnApplicationDidEnterBackground = ffi.Void Function();

typedef _dart_SDL_OnApplicationDidEnterBackground = void Function();

typedef _c_SDL_OnApplicationWillEnterForeground = ffi.Void Function();

typedef _dart_SDL_OnApplicationWillEnterForeground = void Function();

typedef _c_SDL_OnApplicationDidBecomeActive = ffi.Void Function();

typedef _dart_SDL_OnApplicationDidBecomeActive = void Function();

typedef _c_SDL_GetTicks = ffi.Uint32 Function();

typedef _dart_SDL_GetTicks = int Function();

typedef _c_SDL_GetPerformanceCounter = ffi.Uint64 Function();

typedef _dart_SDL_GetPerformanceCounter = int Function();

typedef _c_SDL_GetPerformanceFrequency = ffi.Uint64 Function();

typedef _dart_SDL_GetPerformanceFrequency = int Function();

typedef _c_SDL_Delay = ffi.Void Function(
  ffi.Uint32 ms,
);

typedef _dart_SDL_Delay = void Function(
  int ms,
);

typedef SDL_TimerCallback = ffi.Uint32 Function(
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_SDL_AddTimer = ffi.Int32 Function(
  ffi.Uint32 interval,
  ffi.Pointer<ffi.NativeFunction<SDL_TimerCallback>> callback,
  ffi.Pointer<ffi.Void> param,
);

typedef _dart_SDL_AddTimer = int Function(
  int interval,
  ffi.Pointer<ffi.NativeFunction<SDL_TimerCallback>> callback,
  ffi.Pointer<ffi.Void> param,
);

typedef _c_SDL_RemoveTimer = ffi.Int32 Function(
  ffi.Int32 id,
);

typedef _dart_SDL_RemoveTimer = int Function(
  int id,
);

typedef _c_SDL_GetVersion = ffi.Void Function(
  ffi.Pointer<SDL_version> ver,
);

typedef _dart_SDL_GetVersion = void Function(
  ffi.Pointer<SDL_version> ver,
);

typedef _c_SDL_GetRevision = ffi.Pointer<ffi.Int8> Function();

typedef _dart_SDL_GetRevision = ffi.Pointer<ffi.Int8> Function();

typedef _c_SDL_GetRevisionNumber = ffi.Int32 Function();

typedef _dart_SDL_GetRevisionNumber = int Function();

typedef _c_SDL_GetPreferredLocales = ffi.Pointer<SDL_Locale> Function();

typedef _dart_SDL_GetPreferredLocales = ffi.Pointer<SDL_Locale> Function();

typedef _c_SDL_OpenURL = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_SDL_OpenURL = int Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_SDL_Init = ffi.Int32 Function(
  ffi.Uint32 flags,
);

typedef _dart_SDL_Init = int Function(
  int flags,
);

typedef _c_SDL_InitSubSystem = ffi.Int32 Function(
  ffi.Uint32 flags,
);

typedef _dart_SDL_InitSubSystem = int Function(
  int flags,
);

typedef _c_SDL_QuitSubSystem = ffi.Void Function(
  ffi.Uint32 flags,
);

typedef _dart_SDL_QuitSubSystem = void Function(
  int flags,
);

typedef _c_SDL_WasInit = ffi.Uint32 Function(
  ffi.Uint32 flags,
);

typedef _dart_SDL_WasInit = int Function(
  int flags,
);

typedef _c_SDL_Quit = ffi.Void Function();

typedef _dart_SDL_Quit = void Function();

typedef SDL_AudioCallback = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);
